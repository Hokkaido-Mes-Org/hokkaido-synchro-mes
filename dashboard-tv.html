<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="refresh" content="300"> <!-- Auto-refresh a cada 5 min -->
    <title>Hokkaido Plastics | Painel Industrial</title>
    <link rel="icon" href="https://i.postimg.cc/5jdHwhF9/hokkaido-logo-110.png" type="image/png">
    
    <!-- Google Fonts - Roboto (padrão industrial) -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700;900&family=Roboto+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    
    <style>
        /* ==================== INDUSTRIAL 4.0 DESIGN SYSTEM ==================== */
        /* Inspirado em: GE Predix, Siemens MindSphere, PTC ThingWorx */
        
        :root {
            /* Core Industrial Palette - MindSphere/Predix Style */
            --industrial-black: #0a0e14;
            --industrial-dark: #0d1117;
            --industrial-panel: #151b23;
            --industrial-card: #1c2431;
            --industrial-border: #2d3748;
            --industrial-hover: #252d3a;
            
            /* Accent Colors - Siemens Teal/Cyan */
            --accent-primary: #00b4d8;
            --accent-secondary: #0096c7;
            --accent-tertiary: #48cae4;
            --accent-glow: rgba(0, 180, 216, 0.4);
            
            /* Status Colors - Industrial Standard */
            --status-running: #00e676;
            --status-warning: #ffab00;
            --status-critical: #ff1744;
            --status-idle: #78909c;
            --status-maintenance: #7c4dff;
            
            /* OEE Component Colors */
            --oee-availability: #00b4d8;
            --oee-performance: #00e676;
            --oee-quality: #7c4dff;
            
            /* Text Hierarchy */
            --text-primary: #ffffff;
            --text-secondary: #b0bec5;
            --text-tertiary: #78909c;
            --text-data: #00e5ff;
            
            /* Gradients */
            --gradient-header: linear-gradient(180deg, #151b23 0%, #0d1117 100%);
            --gradient-card: linear-gradient(145deg, #1c2431 0%, #151b23 100%);
            --gradient-accent: linear-gradient(135deg, #00b4d8 0%, #0077b6 100%);
            --gradient-success: linear-gradient(135deg, #00e676 0%, #00c853 100%);
            --gradient-danger: linear-gradient(135deg, #ff1744 0%, #d50000 100%);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--industrial-black);
            color: var(--text-primary);
            line-height: 1.4;
        }

        /* ==================== HEADER - MINDSPHERE STYLE ==================== */
        .industrial-header {
            background: var(--gradient-header);
            border-bottom: 1px solid var(--industrial-border);
            height: 80px;
            display: grid;
            grid-template-columns: 320px 1fr auto;
            align-items: center;
            padding: 0 24px;
            position: relative;
        }

        .industrial-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
            opacity: 0.5;
        }

        .brand-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .brand-logo {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px;
        }

        .brand-logo img {
            height: 42px;
            width: auto;
            object-fit: contain;
        }

        .brand-info {
            display: flex;
            flex-direction: column;
        }

        .brand-name {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--text-primary);
        }

        .brand-type {
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 1.5px;
            color: var(--accent-primary);
            text-transform: uppercase;
        }

        .system-status {
            display: flex;
            align-items: center;
            gap: 32px;
            justify-self: center;
        }

        .status-module {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 180, 216, 0.08);
            border: 1px solid rgba(0, 180, 216, 0.2);
            border-radius: 4px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--status-running);
            box-shadow: 0 0 8px var(--status-running);
            animation: pulse-glow 2s infinite;
        }

        @keyframes pulse-glow {
            0%, 100% { opacity: 1; box-shadow: 0 0 8px var(--status-running); }
            50% { opacity: 0.6; box-shadow: 0 0 16px var(--status-running); }
        }

        @keyframes pulse-alert {
            0%, 100% { opacity: 1; box-shadow: 0 0 12px #ff1744; transform: scale(1); }
            50% { opacity: 0.6; box-shadow: 0 0 24px #ff1744; transform: scale(1.2); }
        }

        .status-label {
            font-size: 11px;
            font-weight: 500;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        .shift-module {
            background: var(--industrial-card);
            border: 1px solid var(--industrial-border);
            padding: 6px 20px;
            border-radius: 4px;
        }

        .shift-label {
            font-size: 10px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .shift-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-primary);
            font-family: 'Roboto Mono', monospace;
        }

        .datetime-section {
            display: flex;
            align-items: center;
            gap: 24px;
            position: relative;
        }

        .datetime-display {
            text-align: right;
        }

        .time-value {
            font-size: 28px;
            font-weight: 300;
            font-family: 'Roboto Mono', monospace;
            color: var(--text-primary);
            letter-spacing: 2px;
        }

        .date-value {
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* ==================== BOTÃO TELA CHEIA ==================== */
        .fullscreen-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .fullscreen-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.5);
            transform: scale(1.05);
        }

        .fullscreen-btn:active {
            transform: scale(0.95);
        }

        /* Estado fullscreen ativo */
        .fullscreen-btn.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        /* ==================== FILTERED DATE BADGE ==================== */
        .filtered-date-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 171, 0, 0.15);
            border: 1px solid rgba(255, 171, 0, 0.4);
            border-radius: 20px;
            padding: 6px 14px;
            color: #ffab00;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            animation: pulse-filter 2s infinite;
        }

        @keyframes pulse-filter {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* ==================== DATE FILTER BUTTON ==================== */
        .date-filter-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: rgba(0, 180, 216, 0.1);
            border: 1px solid rgba(0, 180, 216, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-right: 8px;
            position: relative;
        }

        .date-filter-btn:hover {
            background: rgba(0, 180, 216, 0.2);
            border-color: rgba(0, 180, 216, 0.5);
            transform: scale(1.05);
        }

        .date-filter-btn:active {
            transform: scale(0.95);
        }

        .date-filter-btn.active {
            background: rgba(0, 180, 216, 0.3);
            border-color: var(--accent-primary);
            color: var(--accent-tertiary);
        }

        /* Panel de filtro de data */
        .date-filter-panel {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: var(--industrial-card);
            border: 1px solid var(--industrial-border);
            border-radius: 8px;
            padding: 16px;
            min-width: 280px;
            box-shadow: 0 10px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        .date-filter-header {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .date-filter-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--industrial-panel);
            border: 1px solid var(--industrial-border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Roboto', sans-serif;
            font-size: 14px;
            margin-bottom: 12px;
            transition: all 0.2s ease;
        }

        .date-filter-input:hover {
            border-color: var(--accent-primary);
        }

        .date-filter-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            background: var(--industrial-card);
            box-shadow: 0 0 0 3px rgba(0, 180, 216, 0.1);
        }

        .date-filter-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .date-filter-apply,
        .date-filter-reset {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.5px;
        }

        .date-filter-apply {
            background: var(--accent-primary);
            color: var(--industrial-black);
        }

        .date-filter-apply:hover {
            background: var(--accent-tertiary);
            transform: translateY(-2px);
        }

        .date-filter-reset {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .date-filter-reset:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        /* Ocultar filtro de data em fullscreen */
        :fullscreen .date-filter-btn,
        :-webkit-full-screen .date-filter-btn,
        :-moz-full-screen .date-filter-btn {
            display: none !important;
        }

        .live-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 23, 68, 0.15);
            border: 1px solid rgba(255, 23, 68, 0.3);
            padding: 6px 12px;
            border-radius: 4px;
        }

        .live-dot {
            width: 6px;
            height: 6px;
            background: var(--status-critical);
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .live-text {
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--status-critical);
        }

        /* ==================== MAIN DASHBOARD GRID ==================== */
        .dashboard-container {
            display: grid;
            grid-template-columns: 1fr 1fr 320px;
            grid-template-rows: auto auto 1fr auto;
            gap: 12px;
            padding: 12px 24px;
            height: calc(100vh - 64px);
            background: 
                radial-gradient(ellipse at top left, rgba(0, 180, 216, 0.03) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(124, 77, 255, 0.03) 0%, transparent 50%),
                var(--industrial-black);
        }

        /* ==================== KPI STRIP - TOP ROW ==================== */
        .kpi-strip {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .kpi-module {
            background: var(--gradient-card);
            border: 1px solid var(--industrial-border);
            border-radius: 4px;
            padding: 16px 20px;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .kpi-module:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px rgba(0, 180, 216, 0.1);
        }

        .kpi-module::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
        }

        .kpi-module.oee::before { background: var(--gradient-accent); }
        .kpi-module.availability::before { background: var(--oee-availability); }
        .kpi-module.performance::before { background: var(--oee-performance); }
        .kpi-module.quality::before { background: var(--oee-quality); }
        .kpi-module.production::before { background: var(--status-running); }
        .kpi-module.downtime::before { background: var(--status-critical); }

        .kpi-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }

        .kpi-title {
            font-size: 10px;
            font-weight: 500;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: var(--text-tertiary);
        }

        .kpi-trend {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 2px;
        }

        .kpi-trend.positive {
            background: rgba(0, 230, 118, 0.15);
            color: var(--status-running);
        }

        .kpi-trend.negative {
            background: rgba(255, 23, 68, 0.15);
            color: var(--status-critical);
        }

        .kpi-trend.neutral {
            background: rgba(255, 171, 0, 0.15);
            color: var(--status-warning);
        }

        .kpi-value-container {
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .kpi-value {
            font-size: 32px;
            font-weight: 300;
            font-family: 'Roboto Mono', monospace;
            letter-spacing: -1px;
        }

        .kpi-module.oee .kpi-value { color: var(--accent-primary); }
        .kpi-module.availability .kpi-value { color: var(--oee-availability); }
        .kpi-module.performance .kpi-value { color: var(--oee-performance); }
        .kpi-module.quality .kpi-value { color: var(--oee-quality); }
        .kpi-module.production .kpi-value { color: var(--status-running); }
        .kpi-module.downtime .kpi-value { color: var(--status-critical); }

        .kpi-unit {
            font-size: 14px;
            color: var(--text-tertiary);
            font-weight: 400;
        }

        .kpi-target {
            font-size: 10px;
            color: var(--text-tertiary);
            margin-top: 4px;
        }

        .kpi-target span {
            color: var(--text-secondary);
        }

        /* ==================== DATA PANELS ==================== */
        .data-panel {
            background: var(--gradient-card);
            border: 1px solid var(--industrial-border);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--industrial-border);
        }

        .panel-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        .panel-title i {
            color: var(--accent-primary);
            opacity: 0.8;
        }

        .panel-actions {
            display: flex;
            gap: 8px;
        }

        .panel-tag {
            font-size: 9px;
            font-weight: 600;
            padding: 3px 8px;
            border-radius: 2px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .panel-tag.live {
            background: rgba(0, 230, 118, 0.15);
            color: var(--status-running);
            border: 1px solid rgba(0, 230, 118, 0.3);
        }

        .panel-body {
            flex: 1;
            padding: 16px;
            position: relative;
            min-height: 0;
        }

        .panel-body canvas {
            width: 100% !important;
            height: 100% !important;
        }

        /* ==================== MACHINE GRID - PREDIX STYLE ==================== */
        .machines-panel {
            /* Agora não precisa span 2 rows */
        }

        .machines-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            height: 100%;
            overflow-y: auto;
            padding-right: 4px;
        }

        .machines-grid::-webkit-scrollbar {
            width: 4px;
        }

        .machines-grid::-webkit-scrollbar-track {
            background: var(--industrial-dark);
        }

        .machines-grid::-webkit-scrollbar-thumb {
            background: var(--industrial-border);
            border-radius: 2px;
        }

        .machine-row {
            display: grid;
            grid-template-columns: 80px 1fr 80px 60px;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--industrial-panel);
            border: 1px solid var(--industrial-border);
            border-radius: 4px;
            position: relative;
            transition: all 0.2s ease;
        }

        .machine-row:hover {
            background: var(--industrial-hover);
        }

        .machine-row::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            border-radius: 4px 0 0 4px;
        }

        .machine-row.running::before { background: var(--status-running); }
        .machine-row.stopped::before { background: var(--status-critical); }
        .machine-row.setup::before { background: var(--status-warning); }
        .machine-row.maintenance::before { background: var(--status-maintenance); }
        .machine-row.idle::before { background: var(--status-idle); }

        .machine-row.stopped {
            animation: alert-pulse 2s infinite;
        }

        @keyframes alert-pulse {
            0%, 100% { background: var(--industrial-panel); }
            50% { background: rgba(255, 23, 68, 0.1); }
        }

        .machine-id {
            display: flex;
            flex-direction: column;
        }

        .machine-name {
            font-size: 14px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            color: var(--text-primary);
        }

        .machine-type {
            font-size: 9px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .machine-info {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .machine-product {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .machine-order {
            font-size: 9px;
            color: var(--text-tertiary);
        }

        .machine-oee {
            text-align: right;
        }

        .machine-oee-value {
            font-size: 18px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
        }

        .machine-row.running .machine-oee-value { color: var(--status-running); }
        .machine-row.stopped .machine-oee-value { color: var(--status-critical); }
        .machine-row.setup .machine-oee-value { color: var(--status-warning); }
        .machine-row.maintenance .machine-oee-value { color: var(--status-maintenance); }
        .machine-row.idle .machine-oee-value { color: var(--status-idle); }

        .machine-oee-label {
            font-size: 8px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .machine-status {
            text-align: center;
        }

        .status-badge {
            font-size: 8px;
            font-weight: 700;
            padding: 4px 8px;
            border-radius: 2px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .machine-row.running .status-badge {
            background: rgba(0, 230, 118, 0.15);
            color: var(--status-running);
            border: 1px solid rgba(0, 230, 118, 0.3);
        }

        .machine-row.stopped .status-badge {
            background: rgba(255, 23, 68, 0.15);
            color: var(--status-critical);
            border: 1px solid rgba(255, 23, 68, 0.3);
        }

        .machine-row.setup .status-badge {
            background: rgba(255, 171, 0, 0.15);
            color: var(--status-warning);
            border: 1px solid rgba(255, 171, 0, 0.3);
        }

        .machine-row.maintenance .status-badge {
            background: rgba(124, 77, 255, 0.15);
            color: var(--status-maintenance);
            border: 1px solid rgba(124, 77, 255, 0.3);
        }

        /* ==================== OEE GAUGE - MINDSPHERE STYLE ==================== */
        .oee-panel-highlight {
            border: 1px solid var(--accent-primary) !important;
            box-shadow: 0 0 15px rgba(0, 180, 216, 0.15) !important;
        }

        .oee-gauge-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: space-around;
            height: 100%;
            padding: 12px 16px;
            gap: 16px;
        }

        .gauge-wrapper {
            position: relative;
            width: 140px;
            height: 140px;
            flex-shrink: 0;
        }

        .gauge-svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
            overflow: visible;
        }

        .gauge-bg {
            fill: none;
            stroke: var(--industrial-border);
            stroke-width: 8;
        }

        .gauge-fill {
            fill: none;
            stroke-width: 8;
            stroke-linecap: round;
            transition: stroke-dashoffset 1s ease;
        }

        .gauge-fill.availability { stroke: var(--oee-availability); }
        .gauge-fill.performance { stroke: var(--oee-performance); }
        .gauge-fill.quality { stroke: var(--oee-quality); }

        .gauge-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .gauge-value {
            font-size: 28px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            color: var(--accent-primary);
            line-height: 1;
            text-shadow: 0 0 15px rgba(0, 180, 216, 0.4);
        }

        .gauge-label {
            font-size: 9px;
            font-weight: 500;
            letter-spacing: 1px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            margin-top: 2px;
        }

        .oee-breakdown {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 8px;
        }

        .oee-factor {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            border-left: 3px solid var(--industrial-border);
            min-width: 130px;
        }

        .oee-factor.availability { border-left-color: var(--oee-availability); }
        .oee-factor.performance { border-left-color: var(--oee-performance); }
        .oee-factor.quality { border-left-color: var(--oee-quality); }

        .oee-factor-value {
            font-size: 18px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            min-width: 55px;
        }

        .oee-factor.availability .oee-factor-value { color: var(--oee-availability); }
        .oee-factor.performance .oee-factor-value { color: var(--oee-performance); }
        .oee-factor.quality .oee-factor-value { color: var(--oee-quality); }

        .oee-factor-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* ==================== STOPPED MACHINES LIST ==================== */
        .stopped-machines-list {
            width: 100%;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 8px;
            height: 100%;
            overflow: hidden;
            align-content: start;
        }

        .stopped-machine-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 8px;
            background: rgba(255, 23, 68, 0.12);
            border-radius: 6px;
            border: 2px solid var(--status-critical);
            animation: stopped-card-pulse 2s infinite;
            text-align: center;
            min-height: 70px;
        }

        @keyframes stopped-card-pulse {
            0%, 100% { background: rgba(255, 23, 68, 0.12); border-color: var(--status-critical); }
            50% { background: rgba(255, 23, 68, 0.22); border-color: #ff5252; }
        }

        .stopped-machine-card .machine-id {
            font-size: 18px;
            font-weight: 900;
            font-family: 'Roboto Mono', monospace;
            color: var(--status-critical);
            line-height: 1;
        }

        .stopped-machine-card .machine-reason {
            font-size: 9px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .stopped-machine-card .machine-time {
            font-size: 11px;
            font-weight: 700;
            font-family: 'Roboto Mono', monospace;
            color: var(--status-warning);
            margin-top: 4px;
            padding: 2px 6px;
            background: rgba(255, 171, 0, 0.2);
            border-radius: 3px;
        }

        .no-stopped-machines {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 30px;
            color: var(--status-running);
            text-align: center;
            height: 100%;
            grid-column: 1 / -1;
        }

        .no-stopped-machines i {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
        }

        .no-stopped-machines p {
            font-size: 14px;
            font-weight: 500;
        }

        /* Destaque para o painel de máquinas paradas */
        .stopped-machines-highlight {
            animation: panel-alert 3s infinite;
        }

        @keyframes panel-alert {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 23, 68, 0.3), inset 0 0 20px rgba(255, 23, 68, 0.06); }
            50% { box-shadow: 0 0 50px rgba(255, 23, 68, 0.45), inset 0 0 30px rgba(255, 23, 68, 0.1); }
        }

        /* ==================== FOOTER - STATUS MÁQUINAS GRID ==================== */
        .industrial-footer {
            grid-column: 1 / -1;
            background: var(--industrial-panel);
            border: 2px solid var(--accent-primary);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            min-height: 200px;
            flex: 1;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 180, 216, 0.25), inset 0 0 20px rgba(0, 180, 216, 0.05);
        }

        .footer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(90deg, rgba(0, 180, 216, 0.2), rgba(0, 180, 216, 0.08));
            border-bottom: 2px solid var(--accent-primary);
            flex-shrink: 0;
        }

        .footer-label {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .footer-label i {
            width: 18px;
            height: 18px;
            color: var(--accent-primary);
        }

        .footer-label span {
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            color: var(--accent-primary);
        }

        .footer-legend {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 9px;
            color: var(--text-tertiary);
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
        }

        .footer-timestamp-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 16px;
            background: rgba(0, 180, 216, 0.1);
            border-top: 1px solid var(--industrial-border);
            font-size: 11px;
            color: var(--text-tertiary);
            flex-shrink: 0;
        }

        .footer-timestamp-bar span:first-child {
            font-family: 'Roboto Mono', monospace;
            color: var(--accent-primary);
            font-weight: 600;
            font-size: 12px;
        }

        .machine-status-grid {
            display: grid;
            grid-template-columns: repeat(14, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 8px;
            padding: 12px 16px;
            flex: 1;
            overflow: hidden;
            align-content: center;
        }

        .machine-status-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 70px;
            padding: 8px 6px;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-weight: 700;
            font-size: 14px;
            text-transform: uppercase;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .machine-status-card:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .machine-status-card .machine-number {
            font-size: 16px;
            font-weight: 900;
            line-height: 1.1;
        }

        .machine-status-card .machine-label {
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 0.3px;
            margin-top: 3px;
            opacity: 0.95;
            white-space: nowrap;
            text-align: center;
        }

        /* Status colors */
        /* Produzindo = Verde Forte */
        .machine-status-card.produzindo {
            background: rgba(34, 197, 94, 0.25);
            border-color: #22C55E;
            color: #16A34A;
        }

        /* Manutenção = Amarelo */
        .machine-status-card.manutencao {
            background: rgba(255, 235, 59, 0.2);
            border-color: #FFEB3B;
            color: #FFEB3B;
        }

        /* Ferramentaria = Laranja */
        .machine-status-card.ferramentaria {
            background: rgba(255, 152, 0, 0.2);
            border-color: #FF9800;
            color: #FF9800;
        }

        /* Compras = Marrom */
        .machine-status-card.compras {
            background: rgba(121, 85, 72, 0.2);
            border-color: #795548;
            color: #795548;
        }

        /* Processo = Roxo */
        .machine-status-card.processo {
            background: rgba(156, 39, 176, 0.2);
            border-color: #9C27B0;
            color: #9C27B0;
        }

        /* Qualidade = Vermelho */
        .machine-status-card.qualidade {
            background: rgba(244, 67, 54, 0.2);
            border-color: #F44336;
            color: #F44336;
        }

        /* Produção = Verde Claro */
        .machine-status-card.producao {
            background: rgba(187, 247, 208, 0.4);
            border-color: #86EFAC;
            color: #4ADE80;
        }

        /* Preparação = Rosa */
        .machine-status-card.preparacao {
            background: rgba(233, 30, 99, 0.2);
            border-color: #E91E63;
            color: #E91E63;
        }

        /* PMP = Rosa */
        .machine-status-card.pmp {
            background: rgba(233, 30, 99, 0.2);
            border-color: #E91E63;
            color: #E91E63;
        }

        /* PCP = Preto */
        .machine-status-card.pcp {
            background: rgba(33, 33, 33, 0.8);
            border-color: #212121;
            color: #BDBDBD;
        }

        /* Comercial = Cinza Escuro */
        .machine-status-card.comercial {
            background: rgba(97, 97, 97, 0.3);
            border-color: #616161;
            color: #BDBDBD;
        }

        /* Setup = Azul Claro */
        .machine-status-card.setup {
            background: rgba(3, 169, 244, 0.2);
            border-color: #03A9F4;
            color: #03A9F4;
        }

        /* Administrativo = Branco */
        .machine-status-card.administrativo {
            background: rgba(255, 255, 255, 0.9);
            border-color: #FFFFFF;
            color: #424242;
        }

        /* Outros/Sem status */
        .machine-status-card.outros {
            background: rgba(120, 144, 156, 0.2);
            border-color: var(--status-idle);
            color: var(--status-idle);
        }

        @keyframes card-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Ticker legacy styles (kept for compatibility) */
        .ticker-item .highlight-good {
            color: var(--status-running);
        }

        .ticker-item .highlight-warning {
            color: var(--status-warning);
        }

        .ticker-item .highlight-critical {
            color: var(--status-critical);
        }

        /* ==================== SHIFT KPIs GRID ==================== */
        .shift-kpis-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            height: 100%;
        }

        .shift-kpi-card {
            background: linear-gradient(135deg, rgba(30, 40, 55, 0.9), rgba(20, 30, 45, 0.95));
            border: 1px solid var(--industrial-border);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
        }

        .shift-kpi-card.total {
            background: linear-gradient(135deg, rgba(0, 180, 216, 0.15), rgba(0, 230, 118, 0.1));
            border-color: var(--industrial-cyan);
            border-width: 2px;
        }

        .shift-kpi-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 14px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--industrial-border);
        }

        .shift-badge {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }

        .shift-badge.t1 { background: rgba(0, 180, 216, 0.2); color: var(--industrial-cyan); }
        .shift-badge.t2 { background: rgba(255, 171, 0, 0.2); color: var(--status-warning); }
        .shift-badge.t3 { background: rgba(156, 39, 176, 0.2); color: #ce93d8; }
        .shift-badge.total { background: rgba(0, 230, 118, 0.2); color: var(--status-success); }

        .shift-time {
            font-size: 12px;
            color: var(--text-secondary);
            font-family: 'Roboto Mono', monospace;
        }

        .shift-kpi-body {
            display: flex;
            flex-direction: column;
            gap: 12px;
            flex: 1;
        }

        .shift-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255,255,255,0.05);
        }

        .shift-metric:last-child {
            border-bottom: none;
        }

        .shift-metric .metric-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            font-family: 'Roboto Mono', monospace;
        }

        .shift-metric .metric-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .shift-kpi-card.total .metric-value {
            color: var(--industrial-cyan);
            font-size: 20px;
        }

        .shift-kpi-card.total .metric-label {
            color: rgba(0, 230, 118, 0.8);
        }

        /* ==================== ACCESS CONTROL ==================== */
        .access-block {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at 20% 20%, rgba(0,180,216,0.08), transparent 45%), #0a0e14;
            color: #e0e0e0;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 12px;
            z-index: 9999;
        }
        .access-block h2 {
            font-size: 20px;
            letter-spacing: 0.5px;
            color: #90caf9;
            text-align: center;
        }
        .access-block p {
            color: #9eabb3;
            font-size: 14px;
            text-align: center;
        }
        .access-block .badge {
            padding: 6px 12px;
            border-radius: 12px;
            background: rgba(255,23,68,0.15);
            border: 1px solid rgba(255,23,68,0.4);
            color: #ff8a80;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        @keyframes ticker-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .footer-timestamp {
            padding: 0 16px;
            font-size: 10px;
            font-family: 'Roboto Mono', monospace;
            color: var(--text-tertiary);
            border-left: 1px solid var(--industrial-border);
            height: 100%;
            display: flex;
            align-items: center;
        }

        /* ==================== RESPONSIVE ADJUSTMENTS ==================== */
        
        /* Tablets Landscape e Desktops pequenos */
        @media (max-width: 1600px) {
            .kpi-strip {
                grid-template-columns: repeat(2, 1fr);
            }
            .kpi-value {
                font-size: 28px;
            }
            .gauge-wrapper {
                width: 150px;
                height: 150px;
            }
        }

        @media (max-width: 1400px) {
            .dashboard-container {
                grid-template-columns: 1fr 1fr 320px;
            }
            .machine-status-grid {
                grid-template-columns: repeat(9, 1fr);
                grid-template-rows: repeat(3, 1fr);
                gap: 6px;
            }
            .machine-status-card {
                min-width: 55px;
                padding: 6px 4px;
            }
            .machine-status-card .machine-number {
                font-size: 14px;
            }
            .machine-status-card .machine-label {
                font-size: 8px;
            }
        }
        
        /* Tablets Portrait */
        @media (max-width: 1024px) {
            html, body {
                overflow: auto;
            }
            
            .industrial-header {
                grid-template-columns: 1fr;
                height: auto;
                padding: 12px 16px;
                gap: 12px;
            }
            
            .brand-section {
                justify-content: center;
            }
            
            .system-status {
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }
            
            .status-module {
                padding: 6px 12px;
            }
            
            .datetime-section {
                justify-content: center;
                gap: 16px;
            }
            
            .time-value {
                font-size: 22px;
            }
            
            .dashboard-container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto auto;
                height: auto;
                min-height: calc(100vh - 120px);
                padding: 12px;
                gap: 10px;
            }
            
            .kpi-strip {
                grid-column: 1 / -1;
                grid-template-columns: repeat(2, 1fr);
            }
            
            .kpi-value {
                font-size: 24px;
            }
            
            .kpi-module {
                padding: 12px 14px;
            }
            
            .machines-panel {
                grid-column: 1 / -1;
                grid-row: auto;
            }
            
            .machines-grid {
                max-height: 300px;
            }
            
            .data-panel {
                grid-column: span 1;
            }
            
            .shift-kpis-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .oee-gauge-container {
                flex-direction: column;
                gap: 16px;
            }
            
            .gauge-wrapper {
                width: 140px;
                height: 140px;
            }
            
            .machine-status-grid {
                grid-template-columns: repeat(7, 1fr);
                grid-template-rows: repeat(4, 1fr);
                gap: 6px;
                justify-content: center;
            }
            
            .machine-status-card {
                min-width: 50px;
                padding: 6px 4px;
                font-size: 12px;
            }
            
            .machine-status-card .machine-number {
                font-size: 13px;
            }

            .machine-status-card .machine-label {
                font-size: 7px;
            }
            
            .stopped-machines-list {
                max-height: 200px;
                overflow-y: auto;
            }
            
            .oee-breakdown {
                flex-direction: row;
                gap: 12px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .oee-factor {
                min-width: auto;
                padding: 6px 10px;
            }
            
            .industrial-footer {
                flex-direction: column;
                height: auto;
                padding: 8px;
            }
            
            .footer-label {
                width: 100%;
                justify-content: center;
                padding: 8px;
            }
            
            .footer-ticker {
                padding: 8px 12px;
            }
            
            .ticker-item {
                font-size: 12px;
                padding: 0 20px;
            }
        }
        
        /* Smartphones Landscape */
        @media (max-width: 768px) {
            .industrial-header {
                padding: 10px 12px;
            }
            
            .brand-logo img {
                height: 32px;
            }
            
            .brand-name {
                font-size: 14px;
            }
            
            .brand-type {
                font-size: 8px;
            }
            
            .status-module {
                padding: 4px 8px;
            }
            
            .status-label {
                font-size: 9px;
            }
            
            .shift-module {
                padding: 4px 12px;
            }
            
            .shift-value {
                font-size: 12px;
            }
            
            .time-value {
                font-size: 18px;
            }
            
            .date-value {
                font-size: 9px;
            }
            
            .live-badge {
                padding: 4px 8px;
            }
            
            .live-text {
                font-size: 8px;
            }
            
            .dashboard-container {
                grid-template-columns: 1fr;
                padding: 8px;
                gap: 8px;
            }
            
            .kpi-strip {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .kpi-value {
                font-size: 22px;
            }
            
            .kpi-title {
                font-size: 9px;
            }
            
            .kpi-module {
                padding: 10px 12px;
            }
            
            .kpi-target {
                font-size: 9px;
            }
            
            .machines-grid {
                max-height: 250px;
            }
            
            .machine-row {
                grid-template-columns: 60px 1fr 60px 50px;
                padding: 8px 10px;
                gap: 8px;
            }
            
            .machine-name {
                font-size: 12px;
            }
            
            .machine-type {
                font-size: 8px;
            }
            
            .machine-product {
                font-size: 10px;
            }
            
            .machine-oee-value {
                font-size: 14px;
            }
            
            .status-badge {
                font-size: 7px;
                padding: 3px 6px;
            }
            
            .panel-header {
                padding: 10px 12px;
            }
            
            .panel-title {
                font-size: 10px;
            }
            
            .panel-body {
                padding: 12px;
            }
            
            .shift-kpis-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }
            
            .shift-kpi-card {
                padding: 10px;
            }
            
            .shift-badge {
                font-size: 9px;
                padding: 3px 8px;
            }
            
            .shift-time {
                font-size: 8px;
            }
            
            .shift-metric .metric-value {
                font-size: 14px;
            }
            
            .shift-metric .metric-label {
                font-size: 8px;
            }
            
            .gauge-wrapper {
                width: 100px;
                height: 100px;
            }
            
            .gauge-value {
                font-size: 22px;
            }
            
            .gauge-label {
                font-size: 8px;
            }
            
            .oee-factor {
                padding: 6px 8px;
            }
            
            .oee-factor-value {
                font-size: 14px;
                min-width: 45px;
            }
            
            .oee-factor-label {
                font-size: 8px;
            }
            
            /* Machine Status Grid - 768px */
            .machine-status-grid {
                grid-template-columns: repeat(5, 1fr);
                grid-template-rows: auto;
                gap: 5px;
                padding: 8px;
            }
            
            .machine-status-card {
                padding: 5px 3px;
            }
            
            .machine-status-card .machine-number {
                font-size: 11px;
            }
            
            .machine-status-card .machine-label {
                font-size: 6px;
            }
            
            /* Stopped Machines List - 768px */
            .stopped-machines-list {
                max-height: 200px;
            }
            
            .stopped-machine-item {
                padding: 8px 10px;
            }
            
            .stopped-machine-item .machine-name {
                font-size: 11px;
            }
            
            .stopped-machine-item .stop-reason {
                font-size: 9px;
            }
            
            .stopped-machine-item .stop-duration {
                font-size: 10px;
            }
            
            .footer-timestamp {
                font-size: 9px;
                padding: 0 10px;
            }
        }
        
        /* Smartphones Portrait */
        @media (max-width: 480px) {
            .industrial-header {
                padding: 8px 10px;
            }
            
            .brand-section {
                gap: 8px;
            }
            
            .brand-logo img {
                height: 28px;
            }
            
            .brand-name {
                font-size: 12px;
                letter-spacing: 1px;
            }
            
            .system-status {
                gap: 6px;
            }
            
            .status-module {
                padding: 3px 6px;
            }
            
            .status-label {
                font-size: 8px;
                letter-spacing: 0.5px;
            }
            
            .status-indicator {
                width: 6px;
                height: 6px;
            }
            
            .shift-module {
                padding: 3px 8px;
            }
            
            .shift-label {
                font-size: 8px;
            }
            
            .shift-value {
                font-size: 10px;
            }
            
            .datetime-section {
                gap: 10px;
            }
            
            .time-value {
                font-size: 16px;
            }
            
            .date-value {
                font-size: 8px;
            }
            
            .live-badge {
                padding: 3px 6px;
            }
            
            .live-dot {
                width: 5px;
                height: 5px;
            }
            
            .live-text {
                font-size: 7px;
            }
            
            .dashboard-container {
                padding: 6px;
                gap: 6px;
            }
            
            .kpi-strip {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            
            .kpi-module {
                padding: 8px 10px;
            }
            
            .kpi-title {
                font-size: 8px;
                letter-spacing: 1px;
            }
            
            .kpi-value {
                font-size: 20px;
            }
            
            .kpi-unit {
                font-size: 12px;
            }
            
            .kpi-target {
                font-size: 8px;
            }
            
            .kpi-trend {
                font-size: 8px;
                padding: 1px 4px;
            }
            
            .machines-grid {
                max-height: 200px;
            }
            
            .machine-row {
                grid-template-columns: 50px 1fr 50px;
                padding: 6px 8px;
                gap: 6px;
            }
            
            .machine-status {
                display: none;
            }
            
            .machine-name {
                font-size: 11px;
            }
            
            .machine-type {
                font-size: 7px;
            }
            
            .machine-product {
                font-size: 9px;
            }
            
            .machine-order {
                font-size: 8px;
            }
            
            .machine-oee-value {
                font-size: 13px;
            }
            
            .machine-oee-label {
                font-size: 7px;
            }
            
            .panel-header {
                padding: 8px 10px;
            }
            
            .panel-title {
                font-size: 9px;
                gap: 6px;
            }
            
            .panel-tag {
                font-size: 8px;
                padding: 2px 6px;
            }
            
            .panel-body {
                padding: 10px;
            }
            
            .shift-kpis-grid {
                grid-template-columns: 1fr 1fr;
                gap: 6px;
            }
            
            .shift-kpi-card {
                padding: 8px;
            }
            
            .shift-kpi-header {
                margin-bottom: 8px;
                padding-bottom: 6px;
            }
            
            .shift-badge {
                font-size: 8px;
                padding: 2px 6px;
            }
            
            .shift-time {
                font-size: 7px;
            }
            
            .shift-metric {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
            }
            
            .shift-metric .metric-value {
                font-size: 13px;
            }
            
            .shift-metric .metric-label {
                font-size: 7px;
            }
            
            .oee-gauge-container {
                padding: 8px;
            }
            
            .gauge-wrapper {
                width: 90px;
                height: 90px;
            }
            
            .gauge-value {
                font-size: 18px;
            }
            
            .gauge-label {
                font-size: 7px;
            }
            
            .gauge-bg, .gauge-fill {
                stroke-width: 6;
            }
            
            .oee-breakdown {
                gap: 8px;
            }
            
            .oee-factor {
                padding: 5px 7px;
                gap: 6px;
            }
            
            .oee-factor-value {
                font-size: 12px;
                min-width: 40px;
            }
            
            .oee-factor-label {
                font-size: 7px;
            }
            
            /* Machine Status Grid - 480px */
            .machine-status-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 4px;
                padding: 8px;
            }
            
            .machine-status-card {
                padding: 6px;
            }
            
            .machine-status-card .machine-name {
                font-size: 9px;
            }
            
            .machine-status-card .machine-status-label {
                font-size: 6px;
            }
            
            /* Stopped Machines List - 480px */
            .stopped-machines-list {
                max-height: 160px;
            }
            
            .stopped-machine-item {
                padding: 6px 8px;
            }
            
            .stopped-machine-item .machine-name {
                font-size: 10px;
            }
            
            .stopped-machine-item .stop-reason {
                font-size: 8px;
            }
            
            .stopped-machine-item .stop-duration {
                font-size: 9px;
            }
            
            .industrial-footer {
                gap: 0;
            }
            
            .footer-timestamp {
                font-size: 8px;
                padding: 6px 8px;
            }
            
            /* Access block mobile */
            .access-block h2 {
                font-size: 16px;
                padding: 0 20px;
            }
            
            .access-block p {
                font-size: 12px;
            }
            
            .access-block .badge {
                font-size: 10px;
                padding: 4px 10px;
            }
        }
        
        /* Smartphones muito pequenos */
        @media (max-width: 360px) {
            .brand-name {
                display: none;
            }
            
            .brand-type {
                display: none;
            }
            
            .kpi-strip {
                grid-template-columns: 1fr;
            }
            
            .kpi-module {
                display: grid;
                grid-template-columns: 1fr auto;
                align-items: center;
                gap: 8px;
            }
            
            .kpi-header {
                margin-bottom: 0;
            }
            
            .kpi-value-container {
                justify-self: end;
            }
            
            .kpi-target {
                grid-column: 1 / -1;
                margin-top: 4px;
            }
            
            .shift-kpis-grid {
                grid-template-columns: 1fr;
            }
            
            /* Machine Status Grid - 360px */
            .machine-status-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 3px;
                padding: 6px;
            }
            
            .machine-status-card {
                padding: 5px;
            }
            
            .machine-status-card .machine-name {
                font-size: 8px;
            }
            
            .machine-status-card .machine-status-label {
                font-size: 6px;
            }
            
            /* Stopped Machines List - 360px */
            .stopped-machines-list {
                max-height: 140px;
            }
            
            .stopped-machine-item {
                padding: 5px 6px;
            }
            
            .stopped-machine-item .machine-name {
                font-size: 9px;
            }
            
            .stopped-machine-item .stop-reason {
                font-size: 7px;
            }
            
            .stopped-machine-item .stop-duration {
                font-size: 8px;
            }
        }
    </style>
</head>
<body>
    <div id="accessDenied" class="access-block">
        <div class="badge">Acesso Restrito</div>
        <h2>Somente Leandro Camargo pode visualizar este painel.</h2>
        <p>Entre com o usuário autorizado para continuar.</p>
    </div>
    <!-- ==================== INDUSTRIAL HEADER ==================== -->
    <header class="industrial-header">
        <div class="brand-section">
            <div class="brand-logo" style="display: flex; align-items: center; gap: 15px;">
                <img src="https://i.postimg.cc/5jdHwhF9/hokkaido-logo-110.png" alt="Hokkaido" style="height: 45px; width: auto;">
                <img src="https://i.postimg.cc/bNrChs97/Gemini-Generated-Image-hli5dqhli5dqhli5-removebg-preview.png" alt="Lean" style="height: 45px; width: auto;">
            </div>
        </div>

        <div class="system-status">
            <div class="status-module">
                <div class="status-indicator"></div>
                <span class="status-label">Sistema Online</span>
            </div>
            <div class="shift-module">
                <div class="shift-label">Turno Atual</div>
                <div class="shift-value" id="currentShift">1º TURNO</div>
            </div>
            <div class="status-module" id="activeDowntimeAlert" style="display: none; background: rgba(255, 23, 68, 0.15); border-color: rgba(255, 23, 68, 0.5);">
                <div class="status-indicator" style="background: #ff1744; animation: pulse-alert 1s infinite;"></div>
                <span class="status-label" style="color: #ff1744;" id="activeDowntimeText">0 Paradas Ativas</span>
            </div>
            <div class="status-module">
                <span class="status-label" id="headerMachineCount">-- Máquinas Conectadas</span>
            </div>
        </div>

        <div class="datetime-section">
            <div class="live-badge" id="liveBadge">
                <div class="live-dot"></div>
                <span class="live-text">AO VIVO</span>
            </div>
            <div class="filtered-date-badge" id="filteredDateBadge" style="display: none;">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                <span id="filteredDateText">--/--/----</span>
            </div>
            <div class="datetime-display">
                <div class="time-value" id="currentTime">00:00:00</div>
                <div class="date-value" id="currentDate">Carregando...</div>
            </div>
            <button id="dateFilterBtn" class="date-filter-btn" title="Filtrar por Data">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                    <line x1="16" y1="2" x2="16" y2="6"></line>
                    <line x1="8" y1="2" x2="8" y2="6"></line>
                    <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
            </button>
            <div id="dateFilterPanel" class="date-filter-panel" style="display: none;">
                <div class="date-filter-header">Filtro de Data</div>
                <input type="date" id="filterDate" class="date-filter-input">
                <div class="date-filter-buttons">
                    <button id="dateFilterApply" class="date-filter-apply">Aplicar</button>
                    <button id="dateFilterReset" class="date-filter-reset">Hoje</button>
                </div>
            </div>
            <button id="fullscreenBtn" class="fullscreen-btn" title="Tela Cheia (F11)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
            </button>
        </div>
    </header>

    <!-- ==================== MAIN DASHBOARD ==================== -->
    <main class="dashboard-container">
        <!-- KPI STRIP - PRODUÇÃO DO DIA -->
        <div class="kpi-strip">
            <!-- 1. PLANEJAMENTO DO DIA -->
            <div class="kpi-module production" style="grid-column: span 1;">
                <div class="kpi-header">
                    <span class="kpi-title">Planejamento do Dia</span>
                    <span class="kpi-trend" id="kpiProductionTrend">
                        <i data-lucide="calendar" style="width:12px;height:12px"></i>
                        Meta
                    </span>
                </div>
                <div class="kpi-value-container">
                    <span class="kpi-value" id="kpiPlanning">0</span>
                    <span class="kpi-unit">pçs</span>
                </div>
                <div class="kpi-target">Soma dos produtos planejados</div>
            </div>

            <!-- 2. EXECUTADO -->
            <div class="kpi-module oee" style="grid-column: span 1;">
                <div class="kpi-header">
                    <span class="kpi-title">Executado</span>
                    <span class="kpi-trend" id="kpiCompletionTrend">
                        <i data-lucide="minus" style="width:12px;height:12px"></i>
                        --
                    </span>
                </div>
                <div class="kpi-value-container">
                    <span class="kpi-value" id="kpiExecuted">0</span>
                    <span class="kpi-unit">pçs</span>
                </div>
                <div class="kpi-target">Progresso: <span id="kpiProgress">0%</span></div>
            </div>
        </div>

        <!-- KPIs ADICIONAIS -->
        <div class="data-panel" style="grid-column: span 2;">
            <div class="panel-header">
                <div class="panel-title">
                    <i data-lucide="bar-chart-3" style="width:14px;height:14px"></i>
                    Indicadores por Turno
                </div>
                <div class="panel-actions">
                    <span class="panel-tag live">Tempo Real</span>
                </div>
            </div>
            <div class="panel-body">
                <div class="shift-kpis-grid" id="shiftKpisGrid">
                    <!-- T1 -->
                    <div class="shift-kpi-card">
                        <div class="shift-kpi-header">
                            <span class="shift-badge t1">T1</span>
                            <span class="shift-time">07:00 - 15:00</span>
                        </div>
                        <div class="shift-kpi-body">
                            <div class="shift-metric">
                                <span class="metric-value" id="t1Planned">0</span>
                                <span class="metric-label">Planejado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t1Production">0</span>
                                <span class="metric-label">Executado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t1Efficiency">0%</span>
                                <span class="metric-label">% Meta</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t1Downtime">0min</span>
                                <span class="metric-label">Paradas</span>
                            </div>
                        </div>
                    </div>
                    <!-- T2 -->
                    <div class="shift-kpi-card">
                        <div class="shift-kpi-header">
                            <span class="shift-badge t2">T2</span>
                            <span class="shift-time">15:00 - 23:20</span>
                        </div>
                        <div class="shift-kpi-body">
                            <div class="shift-metric">
                                <span class="metric-value" id="t2Planned">0</span>
                                <span class="metric-label">Planejado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t2Production">0</span>
                                <span class="metric-label">Executado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t2Efficiency">0%</span>
                                <span class="metric-label">% Meta</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t2Downtime">0min</span>
                                <span class="metric-label">Paradas</span>
                            </div>
                        </div>
                    </div>
                    <!-- T3 -->
                    <div class="shift-kpi-card">
                        <div class="shift-kpi-header">
                            <span class="shift-badge t3">T3</span>
                            <span class="shift-time">23:20 - 07:00</span>
                        </div>
                        <div class="shift-kpi-body">
                            <div class="shift-metric">
                                <span class="metric-value" id="t3Planned">0</span>
                                <span class="metric-label">Planejado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t3Production">0</span>
                                <span class="metric-label">Executado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t3Efficiency">0%</span>
                                <span class="metric-label">% Meta</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="t3Downtime">0min</span>
                                <span class="metric-label">Paradas</span>
                            </div>
                        </div>
                    </div>
                    <!-- TOTAIS -->
                    <div class="shift-kpi-card total">
                        <div class="shift-kpi-header">
                            <span class="shift-badge total">TOTAL</span>
                            <span class="shift-time">Dia Completo</span>
                        </div>
                        <div class="shift-kpi-body">
                            <div class="shift-metric">
                                <span class="metric-value" id="totalDayPlanned">0</span>
                                <span class="metric-label">Planejado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="totalDayProduction">0</span>
                                <span class="metric-label">Executado</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="totalDayEfficiency">0%</span>
                                <span class="metric-label">% Meta</span>
                            </div>
                            <div class="shift-metric">
                                <span class="metric-value" id="totalDayDowntime">0min</span>
                                <span class="metric-label">Paradas</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- OEE GAUGE - COMPACTO -->
        <div class="data-panel oee-panel-highlight">
            <div class="panel-header" style="background: rgba(0, 180, 216, 0.08);">
                <div class="panel-title" style="color: var(--accent-primary);">
                    <i data-lucide="gauge" style="width:14px;height:14px"></i>
                    OEE
                </div>
            </div>
            <div class="panel-body">
                <div class="oee-gauge-container">
                    <div class="gauge-wrapper">
                        <svg class="gauge-svg" viewBox="0 0 200 200">
                            <!-- Background circles -->
                            <circle class="gauge-bg" cx="100" cy="100" r="90"/>
                            <circle class="gauge-bg" cx="100" cy="100" r="75"/>
                            <circle class="gauge-bg" cx="100" cy="100" r="60"/>
                            
                            <!-- Availability (outer) - circumference = 2 * PI * 90 = 565.49 -->
                            <circle class="gauge-fill availability" cx="100" cy="100" r="90"
                                stroke-dasharray="565.49" stroke-dashoffset="565.49" id="gaugeAvailability"/>
                            
                            <!-- Performance (middle) - circumference = 2 * PI * 75 = 471.24 -->
                            <circle class="gauge-fill performance" cx="100" cy="100" r="75"
                                stroke-dasharray="471.24" stroke-dashoffset="471.24" id="gaugePerformance"/>
                            
                            <!-- Quality (inner) - circumference = 2 * PI * 60 = 376.99 -->
                            <circle class="gauge-fill quality" cx="100" cy="100" r="60"
                                stroke-dasharray="376.99" stroke-dashoffset="376.99" id="gaugeQuality"/>
                        </svg>
                        <div class="gauge-center">
                            <div class="gauge-value" id="gaugeOEE">--</div>
                            <div class="gauge-label">OEE %</div>
                        </div>
                    </div>
                    <div class="oee-breakdown">
                        <div class="oee-factor availability">
                            <div class="oee-factor-value" id="oeeAvailValue">--%</div>
                            <div class="oee-factor-label">Disp.</div>
                        </div>
                        <div class="oee-factor performance">
                            <div class="oee-factor-value" id="oeePerformValue">--%</div>
                            <div class="oee-factor-label">Perf.</div>
                        </div>
                        <div class="oee-factor quality">
                            <div class="oee-factor-value" id="oeeQualValue">--%</div>
                            <div class="oee-factor-label">Qual.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Elemento oculto para compatibilidade -->
        <div id="machinesGrid" style="display: none;\"></div>

        <!-- FOOTER - STATUS GRID DE TODAS AS MÁQUINAS (Estilo Lançamento) -->
        <footer class="industrial-footer">
            <div class="footer-header">
                <div class="footer-label">
                    <i data-lucide="cpu"></i>
                    <span>Status das Máquinas</span>
                </div>
                <div class="footer-legend">
                    <span class="legend-item"><span class="legend-color" style="background: #00e676;"></span>OK</span>
                    <span class="legend-item"><span class="legend-color" style="background: #03A9F4;"></span>Setup</span>
                    <span class="legend-item"><span class="legend-color" style="background: #795548;"></span>Compras</span>
                    <span class="legend-item"><span class="legend-color" style="background: #FF9800;"></span>Ferram.</span>
                    <span class="legend-item"><span class="legend-color" style="background: #9C27B0;"></span>Processo</span>
                    <span class="legend-item"><span class="legend-color" style="background: #FFEB3B;"></span>Manut.</span>
                    <span class="legend-item"><span class="legend-color" style="background: #F44336;"></span>Qualid.</span>
                    <span class="legend-item"><span class="legend-color" style="background: #E91E63;"></span>PMP</span>
                    <span class="legend-item"><span class="legend-color" style="background: #616161;"></span>Comerc.</span>
                    <span class="legend-item"><span class="legend-color" style="background: #212121;"></span>PCP</span>
                </div>
            </div>
            <div class="machine-status-grid" id="machineStatusGrid">
                <!-- Populated by JS - Cards com número da máquina e cor do status -->
            </div>
            <div class="footer-timestamp-bar">
                <span id="lastUpdate">--:--:--</span>
                <span>Atualização automática a cada 1 minuto</span>
            </div>
        </footer>
    </main>

    <!-- ==================== SCRIPTS ==================== -->
    <script>
        // ==================== FIREBASE CONFIG ====================
        const firebaseConfig = {
            apiKey: "AIzaSyB1YrMK07_7QROsCJQqE0MFsmJncfjphmI",
            authDomain: "hokkaido-synchro.firebaseapp.com",
            projectId: "hokkaido-synchro",
            storageBucket: "hokkaido-synchro.firebasestorage.app",
            messagingSenderId: "635645564631",
            appId: "1:635645564631:web:1e19be7957e39d1adc8292"
        };

        let db;
        let paretoChartInstance = null;
        
        // Cache de dados
        let cachedMachines = [];
        let cachedProductions = [];
        let cachedPlanning = [];
        let cachedDowntimes = [];
        let selectedDate = null; // Data filtrada (null = hoje/workDay)

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('[Dashboard TV] Iniciando...');
            
            // ==================== CONTROLE DE TELA CHEIA ====================
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', toggleFullscreen);
                
                // Detectar mudança de fullscreen
                document.addEventListener('fullscreenchange', () => {
                    if (document.fullscreenElement) {
                        fullscreenBtn.classList.add('active');
                        console.log('[Dashboard TV] Entrando em tela cheia');
                    } else {
                        fullscreenBtn.classList.remove('active');
                        console.log('[Dashboard TV] Saindo de tela cheia');
                    }
                });
            }
            
            // Atalho de teclado: F11 para tela cheia
            document.addEventListener('keydown', (e) => {
                if (e.key === 'F11') {
                    e.preventDefault();
                    toggleFullscreen();
                }
            });
            
            function toggleFullscreen() {
                if (!document.fullscreenElement) {
                    // Entrar em fullscreen
                    document.documentElement.requestFullscreen().catch(err => {
                        console.error(`[Dashboard TV] Erro ao ativar fullscreen: ${err.message}`);
                        // Fallback para navegadores que suportam webkit
                        if (document.documentElement.webkitRequestFullscreen) {
                            document.documentElement.webkitRequestFullscreen();
                        } else if (document.documentElement.mozRequestFullScreen) {
                            document.documentElement.mozRequestFullScreen();
                        } else if (document.documentElement.msRequestFullscreen) {
                            document.documentElement.msRequestFullscreen();
                        }
                    });
                } else {
                    // Sair de fullscreen
                    document.exitFullscreen().catch(err => {
                        console.error(`[Dashboard TV] Erro ao sair de fullscreen: ${err.message}`);
                    });
                }
            }
            
            // ==================== CONTROLE DE FILTRO DE DATA ====================
            const dateFilterBtn = document.getElementById('dateFilterBtn');
            const dateFilterPanel = document.getElementById('dateFilterPanel');
            const filterDateInput = document.getElementById('filterDate');
            const dateFilterApply = document.getElementById('dateFilterApply');
            const dateFilterReset = document.getElementById('dateFilterReset');
            const liveBadge = document.getElementById('liveBadge');
            const filteredDateBadge = document.getElementById('filteredDateBadge');
            const filteredDateText = document.getElementById('filteredDateText');
            
            // Função para atualizar indicadores visuais de data
            function updateDateIndicators() {
                if (selectedDate) {
                    // Modo histórico - mostrar badge de data filtrada
                    if (liveBadge) liveBadge.style.display = 'none';
                    if (filteredDateBadge) filteredDateBadge.style.display = 'flex';
                    if (filteredDateText) {
                        const d = selectedDate;
                        filteredDateText.textContent = `${d.getDate().toString().padStart(2,'0')}/${(d.getMonth()+1).toString().padStart(2,'0')}/${d.getFullYear()}`;
                    }
                } else {
                    // Modo ao vivo
                    if (liveBadge) liveBadge.style.display = 'flex';
                    if (filteredDateBadge) filteredDateBadge.style.display = 'none';
                }
            }
            
            if (dateFilterBtn && dateFilterPanel) {
                console.log('[Dashboard TV] Filtro de data inicializado');
                
                // Toggle do painel de filtro
                dateFilterBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const isVisible = dateFilterPanel.style.display !== 'none';
                    dateFilterPanel.style.display = isVisible ? 'none' : 'block';
                    
                    // Atualizar input com data selecionada ou hoje
                    const todayDate = new Date();
                    const dateToShow = selectedDate || todayDate;
                    filterDateInput.value = dateToShow.toISOString().split('T')[0];
                    console.log('[Dashboard TV] Painel de filtro:', isVisible ? 'fechado' : 'aberto');
                });
                
                // Fechar painel ao clicar fora
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.datetime-section')) {
                        dateFilterPanel.style.display = 'none';
                    }
                });
                
                // Aplicar filtro
                if (dateFilterApply) {
                    dateFilterApply.addEventListener('click', async () => {
                        const dateStr = filterDateInput.value;
                        if (dateStr) {
                            // Atualizar a variável global selectedDate
                            selectedDate = new Date(dateStr + 'T12:00:00');
                            dateFilterBtn.classList.add('active');
                            updateDateIndicators();
                            console.log('[Dashboard TV] ✅ Filtro de data aplicado:', dateStr);
                            console.log('[Dashboard TV] selectedDate agora é:', selectedDate);
                            dateFilterPanel.style.display = 'none';
                            
                            // Recarregar dados com a data filtrada
                            try {
                                await loadRealTimeData();
                                console.log('[Dashboard TV] ✅ Dados recarregados para:', dateStr);
                            } catch (err) {
                                console.error('[Dashboard TV] ❌ Erro ao recarregar:', err);
                            }
                        }
                    });
                }
                
                // Resetar para hoje
                if (dateFilterReset) {
                    dateFilterReset.addEventListener('click', async () => {
                        selectedDate = null;
                        filterDateInput.value = new Date().toISOString().split('T')[0];
                        dateFilterBtn.classList.remove('active');
                        updateDateIndicators();
                        console.log('[Dashboard TV] 🔄 Filtro de data resetado para hoje');
                        dateFilterPanel.style.display = 'none';
                        
                        // Recarregar dados para hoje
                        try {
                            await loadRealTimeData();
                            console.log('[Dashboard TV] ✅ Dados recarregados para hoje');
                        } catch (err) {
                            console.error('[Dashboard TV] ❌ Erro ao recarregar:', err);
                        }
                    });
                }
            } else {
                console.error('[Dashboard TV] ❌ Elementos do filtro de data não encontrados!');
            }
            
            // Criar ícones Lucide com verificação
            if (typeof lucide !== 'undefined' && lucide.createIcons) {
                lucide.createIcons();
                console.log('[Dashboard TV] Lucide icons criados');
            } else {
                console.warn('[Dashboard TV] Lucide não encontrado');
            }
            
            initDateTime();
            console.log('[Dashboard TV] DateTime inicializado');
            
            // Verificar acesso - comentado para debug, descomentar para produção
            // if (!checkAccess()) return;
            
            // Inicializar Firebase
            try {
                console.log('[Dashboard TV] Verificando Firebase...');
                if (typeof firebase === 'undefined') {
                    throw new Error('Firebase SDK não carregado');
                }
                
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                    console.log('[Dashboard TV] Firebase app inicializado');
                }
                db = firebase.firestore();
                console.log('[Dashboard TV] Firestore conectado');
                
                // Carregar dados reais
                console.log('[Dashboard TV] Carregando dados...');
                await loadRealTimeData();
                console.log('[Dashboard TV] Dados carregados com sucesso');
                
            } catch (error) {
                console.error('[Dashboard TV] Erro ao carregar dados:', error);
                // Mostrar mensagem de erro na interface
                showNoDataMessage('Erro ao conectar com o banco de dados');
            }
            
            // Auto-update intervals
            setInterval(updateDateTime, 1000);
            setInterval(loadRealTimeData, 60000); // Atualiza a cada 1 minuto
            
            // ✅ NOVO: Listener em tempo real para paradas ativas (active_downtimes)
            // Isso garante que mudanças em paradas ativas sejam refletidas quase instantaneamente
            db.collection('active_downtimes').onSnapshot(snapshot => {
                try {
                    console.log('[Dashboard TV] Snapshot em tempo real de active_downtimes:', snapshot.size);
                    // Atualizar paradas ativas em tempo real
                    updateRealTimeActiveDowntimes();
                } catch (error) {
                    console.error('[Dashboard TV] Erro ao processar snapshot de active_downtimes:', error);
                }
            }, error => {
                console.warn('[Dashboard TV] Erro ao ouvir active_downtimes:', error.message);
                // Falha silenciosa - o polling de 10 segundos ainda funcionará
            });
            
            console.log('[Dashboard TV] Inicialização completa!');
        });

        function checkAccess() {
            const overlay = document.getElementById('accessDenied');
            const allowedEmails = [
                'leandro.camargo@hokkaido.com', 
                'leandro.camargo@synchro.com',
                'tiago.oliveira@hokkaido.com',
                'tiago.oliveira@synchro.com',
                'michelle.benjamin@hokkaido.com',
                'michelle.benjamin@synchro.com'
            ];
            const allowedNames = [
                'leandro camargo', 
                'leandro c.',
                'tiago oliveira',
                'tiago o.',
                'michelle benjamin',
                'michelle b.'
            ];

            let userEmail = null;
            let userName = null;

            if (window.authSystem && typeof window.authSystem.getCurrentUser === 'function') {
                const u = window.authSystem.getCurrentUser();
                userEmail = (u?.email || '').toLowerCase();
                userName = (u?.displayName || u?.name || '').toLowerCase();
            }

            if (!userEmail && window.localStorage) {
                try {
                    const raw = localStorage.getItem('synchroCurrentUser');
                    if (raw) {
                        const parsed = JSON.parse(raw);
                        userEmail = (parsed?.email || '').toLowerCase();
                        userName = (parsed?.displayName || parsed?.name || '').toLowerCase();
                    }
                } catch (e) {
                    console.warn('Não foi possível ler usuário do storage:', e);
                }
            }

            const emailAllowed = userEmail && allowedEmails.includes(userEmail);
            const nameAllowed = userName && allowedNames.some(n => userName.includes(n));

            if (emailAllowed || nameAllowed) {
                return true;
            }

            if (overlay) {
                overlay.style.display = 'flex';
            }
            console.warn('[Dashboard TV] Acesso negado para usuário não autorizado');
            return false;
        }

        // ==================== DATE & TIME ====================
        function initDateTime() {
            updateDateTime();
        }

        function updateDateTime() {
            const now = new Date();
            
            // Time
            const time = now.toLocaleTimeString('pt-BR', { 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            document.getElementById('currentTime').textContent = time;
            document.getElementById('lastUpdate').textContent = time;
            
            // Date
            const options = { weekday: 'short', day: '2-digit', month: 'short', year: 'numeric' };
            const date = now.toLocaleDateString('pt-BR', options).toUpperCase();
            document.getElementById('currentDate').textContent = date;
            
            // Shift
            const hour = now.getHours();
            let shift = '1º TURNO';
            const minute = now.getMinutes();
            if (hour >= 7 && hour < 15) shift = '1º TURNO (07:00-15:00)';
            else if (hour >= 15 && (hour < 23 || (hour === 23 && minute < 20))) shift = '2º TURNO (15:00-23:20)';
            else shift = '3º TURNO (23:20-07:00)';
            document.getElementById('currentShift').textContent = shift;
        }

        // ==================== FUNÇÕES DE NORMALIZAÇÃO (IDÊNTICO AO SYNCHRO) ====================
        
        // Normalizar ID de máquina (ex: "H-01", "h01", "H01" -> "H01")
        function normalizeMachineId(id) {
            if (!id) return null;
            const s = String(id).toUpperCase().replace(/\s+/g, '');
            // Aceita H-01, H01, h01 etc.; mantém dois dígitos
            const match = s.match(/^H[-_]?(\d{1,2})$/);
            if (match) {
                return `H${match[1].padStart(2, '0')}`;
            }
            // Se vier apenas dígitos (ex.: 1, 01), prefixa H
            const n = s.match(/^(\d{1,2})$/);
            if (n) {
                return `H${n[1].padStart(2, '0')}`;
            }
            // Fallback: remove hífens e tenta novamente
            const cleaned = s.replace(/-/g, '');
            const m2 = cleaned.match(/^H(\d{1,2})$/);
            if (m2) return `H${m2[1].padStart(2, '0')}`;
            return s; // devolve como veio se não reconhecer
        }
        
        // Calcular o dia de trabalho baseado no turno (turno 3 -> dia anterior)
        function getWorkDay(dateStr, timeHint) {
            if (!dateStr) return null;
            const baseDate = new Date(dateStr + 'T12:00:00');
            if (Number.isNaN(baseDate.getTime())) return dateStr;
            
            // Se houver timeHint, verificar se é turno 3 (antes das 7h)
            if (timeHint) {
                const [hours] = timeHint.split(':').map(Number);
                if (!Number.isNaN(hours) && hours < 7) {
                    // Turno 3 após meia-noite - pertence ao dia anterior
                    baseDate.setDate(baseDate.getDate() - 1);
                }
            }
            // Usar mesma lógica de getTodayString para evitar problemas de timezone
            return new Date(baseDate.getTime() - (baseDate.getTimezoneOffset() * 60000))
                .toISOString()
                .split('T')[0];
        }
        
        // Obter workDay a partir de timestamp - CORRIGIDO para usar hora local
        function getWorkDayFromTimestamp(timestamp) {
            if (!timestamp) return null;
            let date;
            if (timestamp?.toDate) {
                date = timestamp.toDate();
            } else if (timestamp instanceof Date) {
                date = timestamp;
            } else {
                date = new Date(timestamp);
            }
            if (Number.isNaN(date.getTime())) return null;
            
            const hours = date.getHours();
            // Se antes das 7h, pertence ao dia anterior
            if (hours < 7) {
                date.setDate(date.getDate() - 1);
            }
            // Usar mesma lógica de getTodayString para evitar problemas de timezone
            return new Date(date.getTime() - (date.getTimezoneOffset() * 60000))
                .toISOString()
                .split('T')[0];
        }
        
        // Resolver datetime de produção
        function resolveProductionDateTime(raw) {
            if (!raw) return null;
            
            // Tentar timestamp direto
            if (raw.timestamp?.toDate) return raw.timestamp.toDate();
            if (raw.createdAt?.toDate) return raw.createdAt.toDate();
            
            // Tentar combinar data + hora
            const dateStr = raw.data || raw.date;
            const timeStr = raw.horaInformada || raw.hora || raw.hour || raw.time;
            
            if (dateStr && timeStr) {
                const combined = new Date(`${dateStr}T${timeStr}:00`);
                if (!Number.isNaN(combined.getTime())) return combined;
            }
            
            return null;
        }
        
        // Normalizar turno
        function normalizeShift(value) {
            if (value === undefined || value === null) return null;
            if (typeof value === 'number' && Number.isFinite(value)) return value;
            const match = String(value).match(/(\d+)/);
            return match ? Number(match[1]) : null;
        }
        
        // ==================== getFilteredData - IDÊNTICO AO SYNCHRO ====================
        async function getFilteredData(collection, startDate, endDate, machine = 'all', shift = 'all') {
            try {
                console.log('[Dashboard TV][getFilteredData] called', { collection, startDate, endDate, machine, shift });
                
                const collectionConfig = {
                    production: {
                        collection: 'production_entries',
                        dateField: 'data',
                        mapper: (id, raw) => {
                            const mappedDate = raw.data || raw.date || '';
                            const resolvedDateTime = resolveProductionDateTime(raw);
                            const timeHint = raw.horaInformada || raw.hora || raw.hour || raw.time || null;
                            const workDay = getWorkDayFromTimestamp(resolvedDateTime) || getWorkDay(mappedDate, timeHint);
                            const product = raw.product || raw.produto || raw.product_cod || raw.cod_produto || raw.productName || raw.mp || '';
                            
                            // Garantir que quantity seja sempre inteiro (sem decimais)
                            const rawQty = Number(raw.produzido ?? raw.pecasBoas ?? raw.quantity ?? raw.produced ?? 0) || 0;
                            
                            return {
                                id,
                                date: mappedDate,
                                machine: normalizeMachineId(raw.machine || raw.machineRef || raw.machine_id || null),
                                quantity: Math.round(rawQty), // Sempre inteiro
                                shift: normalizeShift(raw.turno ?? raw.shift),
                                mp: raw.mp || '',
                                product: product,
                                workDay: workDay || mappedDate,
                                raw
                            };
                        }
                    },
                    losses: {
                        collection: 'production_entries',
                        dateField: 'data',
                        mapper: (id, raw) => {
                            const dateValue = raw.data || raw.date || '';
                            const resolvedDateTime = resolveProductionDateTime(raw);
                            const timeHint = raw.horaInformada || raw.hora || raw.hour || raw.time || null;
                            const workDay = getWorkDayFromTimestamp(resolvedDateTime) || getWorkDay(dateValue, timeHint);
                            
                            // Extrair refugo de múltiplos campos
                            const rawRefugoKg = Number(raw.refugo_kg ?? raw.refugoKg ?? raw.scrap_kg ?? raw.scrapKg ?? 0) || 0;
                            const rawRefugoPcs = Number(raw.refugo_qty ?? raw.refugo_qtd ?? raw.scrap_qty ?? raw.scrap_qtd ?? raw.pecasRuins ?? raw.refugo_pcs ?? 0) || 0;
                            const pieceWeight = Number(raw.piece_weight ?? raw.peso_unitario ?? raw.pesoUnitario ?? raw.peso ?? 0) || 0;
                            
                            const resolvedPcs = rawRefugoPcs > 0
                                ? rawRefugoPcs
                                : (rawRefugoKg > 0 && pieceWeight > 0 ? Math.round((rawRefugoKg * 1000) / pieceWeight) : 0);
                            const resolvedKg = rawRefugoKg > 0
                                ? rawRefugoKg
                                : (pieceWeight > 0 && resolvedPcs > 0 ? (resolvedPcs * pieceWeight) / 1000 : 0);
                            
                            const product = raw.product || raw.produto || raw.product_cod || raw.cod_produto || raw.productName || '';
                            
                            return {
                                id,
                                date: dateValue,
                                machine: normalizeMachineId(raw.machine || raw.machineRef || raw.machine_id || null),
                                quantity: resolvedPcs,
                                shift: normalizeShift(raw.turno ?? raw.shift),
                                reason: raw.perdas || raw.reason || '',
                                mp: raw.mp || '',
                                product: product,
                                workDay: workDay || dateValue,
                                scrapPcs: resolvedPcs,
                                scrapKg: resolvedKg,
                                pieceWeight,
                                raw
                            };
                        }
                    },
                    downtime: {
                        collection: 'downtime_entries',
                        dateField: 'date',
                        mapper: (id, raw) => {
                            let duration = Number(raw.duration ?? raw.duration_min ?? raw.duracao_min ?? 0) || 0;
                            if (!duration && raw.startTime && raw.endTime) {
                                const s = new Date(`1970-01-01T${raw.startTime}:00`);
                                const e = new Date(`1970-01-01T${raw.endTime}:00`);
                                duration = Math.max(0, Math.round((e - s) / 60000));
                            }
                            
                            const timeHint = raw.startTime || raw.endTime || null;
                            const workDay = getWorkDay(raw.date || '', timeHint);
                            
                            // Inferir turno se não informado
                            let mappedShift = normalizeShift(raw.shift ?? raw.turno);
                            if (!mappedShift && raw.startTime) {
                                const [hours] = raw.startTime.split(':').map(Number);
                                if (!Number.isNaN(hours)) {
                                    if (hours >= 7 && hours < 15) mappedShift = 1;
                                    else if (hours >= 15 && hours < 23) mappedShift = 2;
                                    else mappedShift = 3;
                                }
                            }
                            
                            return {
                                id,
                                date: raw.date || '',
                                machine: normalizeMachineId(raw.machine || null),
                                duration,
                                reason: raw.reason || '',
                                shift: mappedShift,
                                startTime: raw.startTime || '',
                                endTime: raw.endTime || '',
                                workDay: workDay || raw.date || '',
                                raw
                            };
                        }
                    },
                    plan: {
                        collection: 'planning',
                        dateField: 'date',
                        mapper: (id, raw) => ({
                            id,
                            date: raw.date || '',
                            machine: normalizeMachineId(raw.machine || null),
                            quantity: Number(raw.planned_quantity ?? raw.quantity ?? 0) || 0,
                            shift: normalizeShift(raw.shift ?? raw.turno),
                            product: raw.product || '',
                            mp: raw.mp || '',
                            workDay: raw.date || '',
                            raw
                        })
                    }
                };
                
                const config = collectionConfig[collection];
                if (!config) {
                    console.warn(`[Dashboard TV] Coleção desconhecida: ${collection}`);
                    return [];
                }
                
                if (!startDate || !endDate) {
                    console.warn('[Dashboard TV][getFilteredData] datas inválidas', { startDate, endDate });
                    return [];
                }
                
                // Expandir período para capturar dados do turno 3
                const startObj = new Date(startDate);
                startObj.setDate(startObj.getDate() - 1);
                const queryStartDate = startObj.toISOString().split('T')[0];
                
                const endObj = new Date(endDate);
                endObj.setDate(endObj.getDate() + 1);
                const queryEndDate = endObj.toISOString().split('T')[0];
                
                let query = db.collection(config.collection);
                query = query.where(config.dateField, '>=', queryStartDate).where(config.dateField, '<=', queryEndDate);
                
                let snapshot = await query.get();
                console.log('[Dashboard TV][getFilteredData] raw snapshot', { collection: config.collection, size: snapshot.size });
                
                let data = snapshot.docs.map(doc => config.mapper(doc.id, doc.data()));
                
                // Filtrar por workDay
                data = data.filter(item => {
                    const workDay = item.workDay || item.date;
                    if (!workDay) return false;
                    return workDay >= startDate && workDay <= endDate;
                });
                
                // Filtrar perdas com quantidade > 0 (verificar todos os campos possíveis)
                if (collection === 'losses') {
                    data = data.filter(item => {
                        const hasQty = (item.quantity || 0) > 0;
                        const hasScrapPcs = (item.scrapPcs || 0) > 0;
                        const hasScrapKg = (item.scrapKg || 0) > 0;
                        // Também verificar campos raw diretamente
                        const hasRawQty = Number(item.raw?.refugo_qty || item.raw?.refugo_pcs || item.raw?.pecasRuins || 0) > 0;
                        const hasRawKg = Number(item.raw?.refugo_kg || 0) > 0;
                        return hasQty || hasScrapPcs || hasScrapKg || hasRawQty || hasRawKg;
                    });
                    console.log('[Dashboard TV][getFilteredData] Perdas após filtro:', data.length, 
                                'Amostra:', data.length > 0 ? data[0] : 'nenhum');
                }
                
                // Filtrar por máquina
                if (machine !== 'all' && machine) {
                    const target = normalizeMachineId(machine);
                    data = data.filter(item => normalizeMachineId(item.machine) === target);
                }
                
                // Filtrar por turno
                if (shift !== 'all' && shift) {
                    data = data.filter(item => Number(item.shift || 0) === Number(shift));
                }
                
                console.log('[Dashboard TV][getFilteredData] returning', { collection, count: data.length });
                return data;
            } catch (error) {
                console.error('[Dashboard TV] Erro em getFilteredData:', error);
                return [];
            }
        }
        
        // ==================== REAL-TIME DATA LOADING ====================
        async function loadRealTimeData() {
            try {
                console.log('[Dashboard TV] Carregando dados reais...');
                // Usar data filtrada se selecionada, senão usar hoje (workDay)
                const dataToLoad = getFilteredDateForData();
                const today = dataToLoad; // Alias para compatibilidade
                console.log('[Dashboard TV] Data carregando:', dataToLoad, '(Filtrado:', selectedDate ? 'Sim' : 'Não', ')');
                
                // Usar getFilteredData - IDÊNTICO ao Synchro
                const [productionData, lossesData, downtimeData, planData] = await Promise.all([
                    getFilteredData('production', dataToLoad, dataToLoad, 'all', 'all'),
                    getFilteredData('losses', dataToLoad, dataToLoad, 'all', 'all'),
                    getFilteredData('downtime', dataToLoad, dataToLoad, 'all', 'all'),
                    getFilteredData('plan', dataToLoad, dataToLoad, 'all', 'all')
                ]);
                
                console.log('[Dashboard TV] Dados carregados via getFilteredData:', {
                    production: productionData.length,
                    losses: lossesData.length,
                    downtime: downtimeData.length,
                    plan: planData.length
                });
                
                // Lista de máquinas válidas do sistema (27 máquinas conforme machineDatabase)
                const validMachineIdsForData = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                                         'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                                         'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
                
                // Converter para formato do cache (compatível com funções existentes)
                // IMPORTANTE: Filtrar apenas máquinas válidas do machineDatabase
                cachedProductions = productionData.map(p => ({ ...p.raw, id: p.id, _normalized: p }));
                cachedPlanning = planData
                    .filter(p => isPlanActive(p.raw))
                    .filter(p => {
                        const machineId = normalizeMachineId(p.raw?.machine || p.raw?.machineId || p.raw?.maquina);
                        if (!validMachineIdsForData.has(machineId)) {
                            console.warn(`[Dashboard TV] Máquina "${machineId}" do planejamento não existe no sistema (ignorada)`);
                            return false;
                        }
                        return true;
                    })
                    .map(p => ({ ...p.raw, id: p.id, _normalized: p }));
                
                // IMPORTANTE: Filtrar paradas apenas de máquinas válidas do machineDatabase
                cachedDowntimes = downtimeData
                    .filter(d => {
                        const machineId = normalizeMachineId(d.raw?.machine || d.raw?.machineId || d.raw?.maquina);
                        if (!validMachineIdsForData.has(machineId)) {
                            console.warn(`[Dashboard TV] Máquina "${machineId}" em downtime_entries não existe no sistema (ignorada)`);
                            return false;
                        }
                        return true;
                    })
                    .map(d => ({ ...d.raw, id: d.id, _normalized: d }));
                
                // Guardar dados normalizados para cálculos OEE
                window._tvNormalizedData = {
                    production: productionData,
                    losses: lossesData,
                    downtime: downtimeData,
                    plan: planData.filter(p => isPlanActive(p.raw))
                };
                
                // Lista de máquinas válidas do sistema (27 máquinas conforme machineDatabase)
                const validMachineIdsForDowntimes = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                                             'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                                             'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
                
                // Buscar paradas longas ativas (extended_downtime_logs) - FILTRAR APENAS MÁQUINAS VÁLIDAS
                const extendedSnapshot = await db.collection('extended_downtime_logs').get();
                const extendedDowntimes = extendedSnapshot.docs
                    .map(doc => ({ id: doc.id, source: 'extended', ...doc.data() }))
                    .filter(dt => {
                        // VALIDAÇÃO: Verificar se a máquina existe no sistema
                        const machineId = normalizeMachineId(dt.machine_id || dt.machine);
                        if (!validMachineIdsForDowntimes.has(machineId)) {
                            console.warn(`[Dashboard TV] Máquina "${dt.machine_id || dt.machine}" em extended_downtime_logs não existe no sistema (ignorada)`);
                            return false;
                        }
                        
                        const dtDate = dt.start_date || dt.date || '';
                        const isActive = dt.status === 'active';
                        const isToday = dtDate === today;
                        return isActive || isToday;
                    })
                    .map(dt => {
                        let duration = dt.duration_minutes || dt.duration || 0;
                        if (dt.status === 'active' && dt.start_datetime) {
                            const startTime = dt.start_datetime?.toDate?.() || new Date(dt.start_date + 'T' + (dt.start_time || '00:00'));
                            duration = Math.floor((new Date() - startTime) / (1000 * 60));
                        }
                        return {
                            ...dt,
                            date: dt.start_date || dt.date,
                            machine: normalizeMachineId(dt.machine_id || dt.machine),
                            reason: dt.reason || dt.type || 'Parada Longa',
                            duration: duration
                        };
                    });
                
                // NOVO: Buscar paradas ativas em tempo real (active_downtimes) - PRIORIDADE MÁXIMA
                // FILTRAR APENAS MÁQUINAS VÁLIDAS DO MACHINEDB
                const activeDowntimesSnapshot = await db.collection('active_downtimes').get();
                const liveActiveDowntimes = activeDowntimesSnapshot.docs
                    .filter(doc => {
                        const data = doc.data();
                        const machineId = normalizeMachineId(doc.id);
                        // VALIDAÇÃO: Verificar se a máquina existe no machineDatabase
                        if (!validMachineIdsForDowntimes.has(machineId)) {
                            console.warn(`[Dashboard TV] Máquina "${doc.id}" em active_downtimes não existe no sistema (ignorada)`);
                            return false;
                        }
                        return data && data.isActive === true;
                    })
                    .map(doc => {
                        const data = doc.data();
                        const machineId = normalizeMachineId(doc.id); // O ID do documento é o ID da máquina
                        let duration = data.durationMinutes || 0;
                        
                        // Calcular duração se tiver startDate
                        if (data.startDate) {
                            const startTime = data.startDate?.toDate?.() || new Date(data.startDate);
                            duration = Math.floor((new Date() - startTime) / (1000 * 60));
                        }
                        
                        return {
                            id: machineId,
                            source: 'active_live',
                            status: 'active',
                            isActive: true,
                            date: today,
                            machine: machineId,
                            machine_id: machineId,
                            reason: data.reason || 'Parada ativa',
                            type: data.type || 'parada',
                            duration: duration,
                            startDate: data.startDate
                        };
                    });
                
                console.log('[Dashboard TV] Paradas LIVE (active_downtimes):', liveActiveDowntimes.length, liveActiveDowntimes.map(d => d.machine));
                
                // DEBUG: Log das paradas ATIVAS antes de juntar ao cache
                console.log('[Dashboard TV] 🔴 PARADAS ATIVAS para contagem no header:');
                console.log('  - Extended (status=active):', extendedDowntimes.filter(d => d.status === 'active').map(d => normalizeMachineId(d.machine || d.machine_id)));
                console.log('  - Active Live:', liveActiveDowntimes.map(d => d.machine));
                
                // Adicionar paradas longas e paradas live ao cache
                // IMPORTANTE: Manter TODAS as paradas sem deduplicar para permitir análise completa
                // A deduplicação será feita nas funções específicas (updateMachinesGrid, updateStoppedMachinesList)
                cachedDowntimes = [...cachedDowntimes, ...extendedDowntimes, ...liveActiveDowntimes];
                
                console.log('[Dashboard TV] Total de paradas (todas as fontes):', cachedDowntimes.length);
                console.log('[Dashboard TV] Paradas por fonte:', {
                    downtime_entries: cachedDowntimes.filter(d => !d.source).length,
                    extended: cachedDowntimes.filter(d => d.source === 'extended').length,
                    active_live: cachedDowntimes.filter(d => d.source === 'active_live').length
                });
                
                // DEBUG: Log específico para H03
                const h03Downtimes = cachedDowntimes.filter(d => 
                    (d.machine || d.machine_id || d.maquina || '').toUpperCase() === 'H03'
                );
                if (h03Downtimes.length > 0) {
                    console.log('[Dashboard TV] 🔍 H03 - Paradas encontradas:', h03Downtimes.length);
                    h03Downtimes.forEach((dt, idx) => {
                        console.log(`[Dashboard TV] H03 Parada #${idx + 1}:`, {
                            source: dt.source || 'downtime_entries',
                            status: dt.status,
                            isActive: dt.isActive,
                            reason: dt.reason || dt.motivo,
                            startTime: dt.startTime || dt.start_time,
                            endTime: dt.endTime || dt.end_time,
                            date: dt.date || dt.start_date
                        });
                    });
                } else {
                    console.log('[Dashboard TV] 🔍 H03 - NENHUMA parada encontrada no cache');
                }
                
                // Debug: amostras
                if (cachedProductions.length > 0) {
                    console.log('[Dashboard TV] Amostra produção:', JSON.stringify(cachedProductions[0], null, 2));
                    // Debug detalhado de campos de refugo
                    const sampleProd = cachedProductions[0];
                    console.log('[Dashboard TV] Campos de refugo na produção:', {
                        pecasRuins: sampleProd.pecasRuins,
                        refugo_pcs: sampleProd.refugo_pcs,
                        refugo: sampleProd.refugo,
                        refugo_kg: sampleProd.refugo_kg,
                        refugo_qty: sampleProd.refugo_qty
                    });
                }
                if (window._tvNormalizedData.losses.length > 0) {
                    console.log('[Dashboard TV] Amostra perda normalizada:', JSON.stringify(window._tvNormalizedData.losses[0], null, 2));
                    console.log('[Dashboard TV] Total de perdas normalizadas:', window._tvNormalizedData.losses.length);
                    console.log('[Dashboard TV] Soma total de refugo (scrapPcs):', 
                        window._tvNormalizedData.losses.reduce((sum, l) => sum + (l.scrapPcs || 0), 0));
                } else {
                    console.warn('[Dashboard TV] NENHUMA PERDA NORMALIZADA ENCONTRADA!');
                }

                // Atualizar interface
                console.log('[Dashboard TV] Atualizando interface...');
                updateMachinesGrid();
                updateKPIs();
                updateShiftKPIs();
                updateStoppedMachinesList();
                updateMachineStatusGrid();
                updateActiveDowntimeAlert();
                
                if (cachedPlanning.length === 0) {
                    console.log('[Dashboard TV] Sem planejamentos ativos');
                    showNoDataMessage('Nenhum planejamento ativo no momento');
                }
                
                console.log('[Dashboard TV] Dados carregados com sucesso!');

            } catch (error) {
                console.error('[Dashboard TV] Erro ao carregar dados:', error);
                showNoDataMessage('Erro ao carregar dados: ' + error.message);
            }
        }

        // Alinha com a lógica do app principal: dia de produção vira "ontem" antes das 07:00
        function getTodayString(date = new Date()) {
            const localDate = new Date(date);
            if (localDate.getHours() < 7) {
                localDate.setDate(localDate.getDate() - 1);
            }
            return new Date(localDate.getTime() - (localDate.getTimezoneOffset() * 60000))
                .toISOString()
                .split('T')[0];
        }

        // Função para obter data atual ou filtrada (escopo global)
        function getFilteredDateForData() {
            if (selectedDate) {
                // Retornar data filtrada no formato YYYY-MM-DD
                return selectedDate.toISOString().split('T')[0];
            }
            return getTodayString(); // Usar workDay de hoje
        }

        function getYesterdayString() {
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            return getTodayString(yesterday);
        }

        function isPlanActive(plan) {
            const status = (plan.status || '').toLowerCase();
            return !['concluida', 'finalizada', 'finalizado', 'cancelada', 'cancelado'].includes(status);
        }

        // Mostrar mensagem quando não houver dados
        function showNoDataMessage(message) {
            const grid = document.getElementById('machinesGrid');
            if (grid) {
                grid.innerHTML = `
                    <div style="grid-column: span 2; text-align: center; padding: 40px; color: #78909c;">
                        <i data-lucide="alert-circle" style="width: 48px; height: 48px; margin-bottom: 12px; opacity: 0.5;"></i>
                        <p style="font-size: 14px;">${message}</p>
                        <p style="font-size: 11px; margin-top: 8px;">Aguardando dados do Firebase...</p>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        }

        // Atualizar alerta de paradas ativas no header
        function updateActiveDowntimeAlert() {
            const alertEl = document.getElementById('activeDowntimeAlert');
            const alertText = document.getElementById('activeDowntimeText');
            
            if (!alertEl || !alertText) return;
            
            // Lista de máquinas válidas do sistema (27 máquinas conforme machineDatabase)
            const validMachineIds = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                             'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                             'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
            
            // Contar paradas ativas (extended downtimes com status = 'active' OU active_downtimes live)
            // IMPORTANTE: Filtrar apenas máquinas válidas E DEDUPLICAR por máquina
            const seenMachines = new Set();
            const activeDowntimes = cachedDowntimes.filter(dt => {
                // Verificar se a máquina existe no sistema
                const machineId = normalizeMachineId(dt.machine || dt.machine_id || dt.maquina);
                if (!validMachineIds.has(machineId)) {
                    return false; // Ignorar máquinas que não existem
                }
                
                // Verificar se é parada ativa
                const isActive = (dt.source === 'extended' && dt.status === 'active') ||
                                 (dt.source === 'active_live' && dt.isActive === true);
                
                if (!isActive) return false;
                
                // DEDUPLICAR: Cada máquina conta apenas uma vez
                if (seenMachines.has(machineId)) {
                    return false; // Já contamos essa máquina
                }
                seenMachines.add(machineId);
                return true;
            });
            
            // DEBUG: Log para identificar máquinas contadas
            console.log('[Dashboard TV] Paradas ativas contadas:', activeDowntimes.length, 'máquinas:', [...seenMachines]);
            
            if (activeDowntimes.length > 0) {
                alertEl.style.display = 'flex';
                alertText.textContent = activeDowntimes.length === 1 
                    ? '1 Parada Ativa' 
                    : `${activeDowntimes.length} Paradas Ativas`;
                
                // Listar máquinas paradas
                const machines = activeDowntimes.map(dt => dt.machine || dt.machine_id).join(', ');
                alertText.title = `Máquinas: ${machines}`;
            } else {
                alertEl.style.display = 'none';
            }
        }

        // ✅ NOVO: Função para atualizar paradas ativas em tempo real (listener)
        async function updateRealTimeActiveDowntimes() {
            try {
                console.log('[Dashboard TV] Atualizando paradas ativas em tempo real...');
                const today = getFilteredDateForData();
                
                // Lista de máquinas válidas do sistema (27 máquinas conforme machineDatabase)
                const validMachineIds = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                                 'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                                 'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
                
                // Buscar paradas LIVE ativas (active_downtimes)
                const activeDowntimesSnapshot = await db.collection('active_downtimes').get();
                const liveActiveDowntimes = activeDowntimesSnapshot.docs
                    .filter(doc => {
                        const data = doc.data();
                        const machineId = normalizeMachineId(doc.id);
                        // VALIDAÇÃO: Verificar se a máquina existe no machineDatabase
                        if (!validMachineIds.has(machineId)) {
                            console.warn(`[Dashboard TV] Máquina "${doc.id}" em active_downtimes não existe no sistema (ignorada)`);
                            return false;
                        }
                        return data && data.isActive === true;
                    })
                    .map(doc => {
                        const data = doc.data();
                        const machineId = normalizeMachineId(doc.id);
                        let duration = data.durationMinutes || 0;
                        
                        if (data.startDate) {
                            const startTime = data.startDate?.toDate?.() || new Date(data.startDate);
                            duration = Math.floor((new Date() - startTime) / (1000 * 60));
                        }
                        
                        return {
                            id: machineId,
                            source: 'active_live',
                            status: 'active',
                            isActive: true,
                            date: today,
                            machine: machineId,
                            machine_id: machineId,
                            reason: data.reason || 'Parada ativa',
                            type: data.type || 'parada',
                            duration: duration,
                            startDate: data.startDate
                        };
                    });
                
                console.log('[Dashboard TV] Paradas LIVE atualizadas:', liveActiveDowntimes.length);
                
                // DEBUG: Verificar se H03 está nas paradas LIVE
                const h03Live = liveActiveDowntimes.find(d => d.machine === 'H03');
                if (h03Live) {
                    console.log('[Dashboard TV] 🔍 H03 encontrada em active_downtimes:', h03Live);
                }
                
                // Atualizar apenas as paradas LIVE no cachedDowntimes (remover antigas, adicionar novas)
                // Manter as outras paradas (extended e normal) intactas
                cachedDowntimes = cachedDowntimes.filter(dt => dt.source !== 'active_live');
                cachedDowntimes.push(...liveActiveDowntimes);
                
                // Atualizar TODAS as funções que dependem de paradas
                updateActiveDowntimeAlert();
                updateMachinesGrid();
                updateStoppedMachinesList();
                updateMachineStatusGrid();
                
            } catch (error) {
                console.error('[Dashboard TV] Erro ao atualizar paradas em tempo real:', error);
            }
        }

        // ==================== MACHINES GRID - REAL DATA ====================
        function updateMachinesGrid() {
            const grid = document.getElementById('machinesGrid');
            if (!grid) {
                console.error('[Dashboard TV] Elemento machinesGrid não encontrado!');
                return;
            }
            
            const statusLabels = {
                running: 'RODANDO',
                stopped: 'PARADA',
                setup: 'SETUP',
                maintenance: 'MANUT.',
                idle: 'OCIOSA'
            };
            
            // Obter hora atual para comparação
            const now = new Date();
            const currentTime = now.toTimeString().slice(0, 5); // HH:MM
            const today = getFilteredDateForData(); // Usa data filtrada se selecionada
            
            // Primeiro: Obter TODAS as paradas ativas
            // Inclui: extended_downtime_logs com status = 'active' E downtime_entries sem endTime ou em andamento
            const activeDowntimesMap = {};
            
            cachedDowntimes.forEach(dt => {
                const dtMachine = normalizeMachineId(dt.machine || dt.machine_id || dt.maquina);
                if (!dtMachine) return;
                
                // PRIORIDADE 1: Parada LIVE (active_downtimes) - maior prioridade
                const isLiveActive = dt.source === 'active_live' && dt.isActive === true;
                
                // PRIORIDADE 2: Parada ativa de extended_downtime_logs
                const isExtendedActive = dt.source === 'extended' && dt.status === 'active';
                
                // PRIORIDADE 3: Parada normal (downtime_entries) em andamento
                const dtDate = dt.date || dt.workDay || '';
                const isToday = dtDate === today;
                const hasNoEndTime = !dt.endTime || dt.endTime === '';
                const endTimeNotPassed = dt.endTime && currentTime < dt.endTime;
                const isNormalActive = !dt.source && isToday && (hasNoEndTime || endTimeNotPassed);
                
                // Se qualquer condição de parada ativa for verdadeira
                if ((isLiveActive || isExtendedActive || isNormalActive) && !activeDowntimesMap[dtMachine]) {
                    const reason = (dt.reason || dt.type || '').toLowerCase();
                    let sourceType = 'normal';
                    if (isLiveActive) sourceType = 'live';
                    else if (isExtendedActive) sourceType = 'extended';
                    
                    activeDowntimesMap[dtMachine] = {
                        reason: reason,
                        rawReason: dt.reason || dt.type || 'Parada',
                        startTime: dt.startTime || dt.start_time || '',
                        endTime: dt.endTime || dt.end_time || '',
                        duration: dt.duration || 0,
                        source: dt.source || 'normal',
                        isActive: sourceType
                    };
                    console.log(`[Dashboard TV] Parada detectada: Máquina ${dtMachine}, Fonte: ${sourceType.toUpperCase()}, Motivo: "${dt.reason || dt.type || 'N/A'}"`);
                }
            });
            
            console.log('[Dashboard TV] Hora atual:', currentTime);
            console.log('[Dashboard TV] Paradas ativas encontradas:', Object.keys(activeDowntimesMap));
            console.log('[Dashboard TV] Detalhes das paradas:', activeDowntimesMap);
            
            // Lista de máquinas VÁLIDAS do sistema (27 máquinas conforme machineDatabase)
            const validMachineIds = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                             'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                             'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
            
            // Agrupar produção por máquina (do planejamento) - APENAS máquinas válidas
            const machineData = {};
            
            cachedPlanning.forEach(plan => {
                const rawMachineId = plan.machine || plan.machineId || plan.maquina || 'N/A';
                const machineId = normalizeMachineId(rawMachineId) || rawMachineId;
                // VALIDAÇÃO: Só adicionar se a máquina existir no machineDatabase
                if (!validMachineIds.has(machineId)) {
                    console.warn(`[Dashboard TV] Máquina "${machineId}" do planejamento não existe no sistema (ignorada)`);
                    return;
                }
                if (!machineData[machineId]) {
                    machineData[machineId] = {
                        id: machineId,
                        type: 'Injetora',
                        product: plan.product || plan.product_cod || plan.produto || plan.descricao || 'Sem produto',
                        order: plan.order_number || plan.id || 'N/A',
                        produced: 0,
                        target: getPlanTarget(plan),
                        cycleTime: plan.budgeted_cycle || plan.tempoCiclo || 0,
                        status: 'running'
                    };
                }
            });
            
            // IMPORTANTE: Adicionar máquinas com paradas ativas que NÃO estão no planejamento
            // SOMENTE se a máquina existir no machineDatabase
            Object.keys(activeDowntimesMap).forEach(machineId => {
                // VALIDAÇÃO: Só adicionar se a máquina existir no machineDatabase
                if (!validMachineIds.has(machineId)) {
                    console.warn(`[Dashboard TV] Máquina "${machineId}" com parada ativa não existe no sistema (ignorada)`);
                    return;
                }
                if (!machineData[machineId]) {
                    machineData[machineId] = {
                        id: machineId,
                        type: 'Injetora',
                        product: activeDowntimesMap[machineId].rawReason,
                        order: 'Parada Ativa',
                        produced: 0,
                        target: 0,
                        cycleTime: 0,
                        status: 'stopped'
                    };
                    console.log(`[Dashboard TV] Máquina ${machineId} adicionada (parada ativa sem planejamento)`);
                }
            });
            
            console.log('[Dashboard TV] IDs de máquinas (planejamento + paradas):', Object.keys(machineData));
            
            // Somar produções por máquina (via planId ou diretamente pela máquina)
            cachedProductions.forEach(prod => {
                const planId = prod.planId;
                const prodMachine = normalizeMachineId(prod.machine || prod.machineId || prod.maquina);
                
                // Tentar encontrar plano pelo planId
                let plan = cachedPlanning.find(p => p.id === planId);
                
                // Se não encontrou pelo planId, tentar pela máquina normalizada
                if (!plan && prodMachine) {
                    plan = cachedPlanning.find(p => 
                        normalizeMachineId(p.machine || p.machineId || p.maquina) === prodMachine
                    );
                }
                
                if (plan) {
                    const machineId = normalizeMachineId(plan.machine || plan.machineId || plan.maquina);
                    if (machineData[machineId]) {
                        machineData[machineId].produced += getProducedQty(prod);
                    }
                } else if (prodMachine && machineData[prodMachine]) {
                    // Associar diretamente à máquina se existir
                    machineData[prodMachine].produced += getProducedQty(prod);
                }
            });
            
            // Calcular OEE por máquina e APLICAR STATUS DAS PARADAS ATIVAS
            const machines = Object.values(machineData).map(m => {
                let oee = 0;
                if (m.target > 0) {
                    oee = Math.min((m.produced / m.target) * 100, 100);
                }
                
                // Determinar status baseado em paradas ativas - PRIORIDADE MÁXIMA
                let status = 'running';
                const normalizedId = normalizeMachineId(m.id);
                const activeDowntime = activeDowntimesMap[normalizedId];
                
                if (activeDowntime) {
                    // Máquina tem parada ativa - determinar tipo de parada
                    const reason = activeDowntime.reason;
                    if (reason.includes('setup') || reason.includes('troca') || reason.includes('ajuste')) {
                        status = 'setup';
                    } else if (reason.includes('manut') || reason.includes('quebra') || reason.includes('mecânic') || reason.includes('elétric')) {
                        status = 'maintenance';
                    } else {
                        status = 'stopped';
                    }
                    console.log(`[Dashboard TV] Máquina ${m.id} - PARADA ATIVA: "${activeDowntime.rawReason}" -> Status: ${status}`);
                } else if (oee === 0 && m.produced === 0) {
                    status = 'idle';
                }
                
                return {
                    ...m,
                    oee: oee,
                    status: status
                };
            });
            
            // Se não houver máquinas reais, mostrar mensagem
            if (machines.length === 0) {
                grid.innerHTML = `
                    <div style="grid-column: span 2; text-align: center; padding: 40px; color: #78909c;">
                        <i data-lucide="inbox" style="width: 48px; height: 48px; margin-bottom: 12px; opacity: 0.5;"></i>
                        <p style="font-size: 14px;">Nenhuma máquina com planejamento ativo</p>
                        <p style="font-size: 11px; margin-top: 8px;">Os dados serão exibidos quando houver ordens de produção</p>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Ordenar: paradas primeiro, depois por ID
            machines.sort((a, b) => {
                const statusOrder = { stopped: 0, maintenance: 1, setup: 2, idle: 3, running: 4 };
                const orderA = statusOrder[a.status] ?? 5;
                const orderB = statusOrder[b.status] ?? 5;
                if (orderA !== orderB) return orderA - orderB;
                return (a.id || '').localeCompare(b.id || '');
            });
            
            // Filtrar apenas máquinas que estão produzindo (sem paradas ativas)
            // Inclui status 'running' (produzindo) e 'idle' (planejamento sem produção ainda)
            // Exclui máquinas com paradas ativas (stopped, maintenance, setup)
            const producingMachines = machines.filter(m => m.status === 'running' || m.status === 'idle');
            
            grid.innerHTML = producingMachines.slice(0, 8).map(m => `
                <div class="machine-row ${m.status}">
                    <div class="machine-id">
                        <span class="machine-name">${m.id}</span>
                        <span class="machine-type">${m.type}</span>
                    </div>
                    <div class="machine-info">
                        <span class="machine-product">${m.product}</span>
                        <span class="machine-order">${m.order.substring(0, 15)}</span>
                    </div>
                    <div class="machine-oee">
                        <span class="machine-oee-value">${m.oee.toFixed(1)}%</span>
                        <span class="machine-oee-label">OEE</span>
                    </div>
                    <div class="machine-status">
                        <span class="status-badge">${statusLabels[m.status]}</span>
                    </div>
                </div>
            `).join('');
            
            // Atualizar contadores de máquinas - apenas as que estão realmente produzindo
            const machineCount = producingMachines.length;
            const headerStatus = document.getElementById('headerMachineCount');
            const machinesTag = document.getElementById('machinesTag');
            
            if (headerStatus) headerStatus.textContent = `${machineCount} Máquina${machineCount !== 1 ? 's' : ''} Produzindo`;
            if (machinesTag) machinesTag.textContent = `${machineCount} Produzindo`;
        }

        // ==================== KPIs UPDATE - DADOS REAIS ====================
        async function updateKPIs() {
            // ========== CÁLCULOS DE PRODUÇÃO ==========
            let totalProduced = 0;      // Total de peças boas
            let totalRefugo = 0;        // Total de refugo
            let totalTarget = 0;        // Meta total do dia
            let totalDowntimeMinutes = 0; // Tempo total de paradas
            let lastHourProduced = 0;
            
            // Usar dados normalizados quando disponíveis
            const normalizedData = window._tvNormalizedData;
            
            // IMPORTANTE: Usar a data filtrada ou workDay atual
            const workDay = getFilteredDateForData(); // Usa data filtrada se selecionada
            
            console.log('[Dashboard TV] updateKPIs - cachedProductions:', cachedProductions.length);
            console.log('[Dashboard TV] updateKPIs - cachedPlanning:', cachedPlanning.length);
            console.log('[Dashboard TV] updateKPIs - normalizedData:', normalizedData ? 'disponível' : 'não disponível');
            console.log('[Dashboard TV] updateKPIs - workDay:', workDay);
            
            // DEBUG: Listar workDays únicos nos dados
            if (normalizedData?.production) {
                const uniqueWorkDays = [...new Set(normalizedData.production.map(p => p.workDay))];
                console.log('[Dashboard TV] updateKPIs - WorkDays únicos nos dados:', uniqueWorkDays);
                console.log('[Dashboard TV] updateKPIs - Total registros produção:', normalizedData.production.length);
                const matchingRecords = normalizedData.production.filter(p => p.workDay === workDay);
                console.log('[Dashboard TV] updateKPIs - Registros do workDay atual:', matchingRecords.length);
                const totalMatchingQty = matchingRecords.reduce((sum, p) => sum + (p.quantity || 0), 0);
                console.log('[Dashboard TV] updateKPIs - Soma produção do workDay atual:', totalMatchingQty);
            }
            
            // Somar produção do dia (usando dados normalizados)
            if (normalizedData?.production) {
                normalizedData.production.forEach(item => {
                    // Só contar produções do workDay atual (dia de produção) - CONSISTENTE com updateShiftKPIs
                    if (item.workDay !== workDay) return;
                    
                    totalProduced += Math.round(item.quantity || 0);
                    
                    // Produção da última hora
                    const now = new Date();
                    const hourStr = item.raw?.hora || item.raw?.hour || item.raw?.horaInformada;
                    if (hourStr && hourStr.length >= 2) {
                        const h = parseInt(hourStr.slice(0, 2));
                        if (!Number.isNaN(h)) {
                            const currentHour = now.getHours();
                            if (h === currentHour || h === (currentHour - 1)) {
                                lastHourProduced += Math.round(item.quantity || 0);
                            }
                        }
                    }
                });
            } else {
                // Fallback para cachedProductions
                cachedProductions.forEach(prod => {
                    const good = getProducedQty(prod);
                    totalProduced += good;

                    const now = new Date();
                    const hourStr = prod.hora || prod.hour || prod.horaInformada;
                    if (hourStr && hourStr.length >= 2) {
                        const h = parseInt(hourStr.slice(0, 2));
                        if (!Number.isNaN(h)) {
                            const currentHour = now.getHours();
                            if (h === currentHour || h === (currentHour - 1)) {
                                lastHourProduced += good;
                            }
                        }
                    }
                });
            }
            
            // Somar refugo (usando dados normalizados de losses - CONSISTENTE com updateShiftKPIs)
            if (normalizedData?.losses) {
                totalRefugo = Math.round(normalizedData.losses
                    .filter(item => item.workDay === workDay)
                    .reduce((sum, item) => sum + (item.scrapPcs || item.quantity || 0), 0));
                console.log('[Dashboard TV] Refugo normalizado (workDay=' + workDay + '):', totalRefugo, 'pçs');
            } else {
                cachedProductions.forEach(prod => {
                    const bad = Math.round(prod.pecasRuins || prod.refugo_pcs || prod.refugo || prod.scrap || 0);
                    totalRefugo += bad;
                });
            }
            
            // Somar metas do planejamento ativo
            if (normalizedData?.plan) {
                normalizedData.plan.forEach(item => {
                    totalTarget += Math.round(item.quantity || 0);
                });
            } else {
                cachedPlanning.forEach(plan => {
                    totalTarget += Math.round(getPlanTarget(plan));
                });
            }
            
            console.log('[Dashboard TV] KPIs calculados - Produção:', totalProduced, 'Refugo:', totalRefugo, 'Meta:', totalTarget);
            
            // Somar tempo de paradas do dia (usando dados normalizados)
            const today = getFilteredDateForData(); // Usa data filtrada se selecionada
            if (normalizedData?.downtime) {
                totalDowntimeMinutes = normalizedData.downtime.reduce((sum, item) => sum + (item.duration || 0), 0);
            } else {
                cachedDowntimes.filter(dt => (dt.date || dt.data) === today).forEach(dt => {
                    let minutes = dt.duration || dt.duration_minutes || 0;
                    if (!minutes && dt.startTime && dt.endTime) {
                        const s = new Date(`1970-01-01T${dt.startTime}:00`);
                        const e = new Date(`1970-01-01T${dt.endTime}:00`);
                        minutes = Math.max(0, Math.round((e - s) / 60000));
                    }
                    totalDowntimeMinutes += minutes;
                });
            }
            
            console.log('[Dashboard TV] Paradas do dia:', today, 'Total minutos:', totalDowntimeMinutes);
            
            // ========== 1. PLANEJAMENTO DO DIA (soma do planejado) ==========
            const planningEl = document.getElementById('kpiPlanning');
            const prodTrendEl = document.getElementById('kpiProductionTrend');
            
            if (planningEl) planningEl.textContent = formatNumber(totalTarget);
            if (prodTrendEl) {
                prodTrendEl.className = 'kpi-trend neutral';
                prodTrendEl.innerHTML = `<i data-lucide="calendar" style="width:12px;height:12px"></i>Meta`;
            }
            
            // ========== 2. EXECUTADO (soma do produzido) ==========
            const executedEl = document.getElementById('kpiExecuted');
            const progressEl = document.getElementById('kpiProgress');
            const completionTrendEl = document.getElementById('kpiCompletionTrend');
            const safeTarget = totalTarget || totalProduced || 1;
            const completionPercent = Math.min((totalProduced / safeTarget) * 100, 150);
            
            if (executedEl) executedEl.textContent = formatNumber(totalProduced);
            if (progressEl) progressEl.textContent = completionPercent.toFixed(1) + '%';
            if (completionTrendEl) {
                if (completionPercent >= 100) {
                    completionTrendEl.className = 'kpi-trend positive';
                    completionTrendEl.innerHTML = `<i data-lucide="check-circle" style="width:12px;height:12px"></i>Meta batida!`;
                } else if (completionPercent >= 70) {
                    completionTrendEl.className = 'kpi-trend positive';
                    completionTrendEl.innerHTML = `<i data-lucide="trending-up" style="width:12px;height:12px"></i>Em dia`;
                } else if (completionPercent >= 40) {
                    completionTrendEl.className = 'kpi-trend neutral';
                    completionTrendEl.innerHTML = `<i data-lucide="clock" style="width:12px;height:12px"></i>Atenção`;
                } else {
                    completionTrendEl.className = 'kpi-trend negative';
                    completionTrendEl.innerHTML = `<i data-lucide="alert-triangle" style="width:12px;height:12px"></i>Atrasado`;
                }
            }
            
            // ========== 3. ORDENS ATIVAS ==========
            const ordersEl = document.getElementById('kpiOrders');
            const machinesActiveEl = document.getElementById('kpiMachinesActive');
            
            // Contar máquinas únicas
            const uniqueMachines = new Set();
            cachedPlanning.forEach(plan => {
                const machineId = plan.machine || plan.machineId || plan.maquina;
                if (machineId) uniqueMachines.add(machineId);
            });
            
            if (ordersEl) ordersEl.textContent = cachedPlanning.length;
            if (machinesActiveEl) machinesActiveEl.textContent = uniqueMachines.size;
            
            // ========== 4. QUALIDADE ==========
            const qualityEl = document.getElementById('kpiQuality');
            const refugoEl = document.getElementById('kpiRefugo');
            const qualityTrendEl = document.getElementById('kpiQualityTrend');
            
            const totalPcs = totalProduced + totalRefugo;
            const qualityPercent = totalPcs > 0 ? (totalProduced / totalPcs) * 100 : 100;
            
            if (qualityEl) qualityEl.textContent = qualityPercent.toFixed(1);
            if (refugoEl) refugoEl.textContent = formatNumber(totalRefugo) + ' pçs';
            if (qualityTrendEl) {
                if (qualityPercent >= 99) {
                    qualityTrendEl.className = 'kpi-trend positive';
                    qualityTrendEl.innerHTML = `<i data-lucide="shield-check" style="width:12px;height:12px"></i>Excelente`;
                } else if (qualityPercent >= 95) {
                    qualityTrendEl.className = 'kpi-trend positive';
                    qualityTrendEl.innerHTML = `<i data-lucide="trending-up" style="width:12px;height:12px"></i>Bom`;
                } else if (qualityPercent >= 90) {
                    qualityTrendEl.className = 'kpi-trend neutral';
                    qualityTrendEl.innerHTML = `<i data-lucide="minus" style="width:12px;height:12px"></i>Regular`;
                } else {
                    qualityTrendEl.className = 'kpi-trend negative';
                    qualityTrendEl.innerHTML = `<i data-lucide="trending-down" style="width:12px;height:12px"></i>Crítico`;
                }
            }
            
            // ========== 5. PARADAS HOJE ==========
            const downtimeEl = document.getElementById('kpiDowntime');
            const downtimeEventsEl = document.getElementById('kpiDowntimeEvents');
            const downtimeTrendEl = document.getElementById('kpiDowntimeTrend');
            
            const todayDowntimes = cachedDowntimes.filter(dt => (dt.date || dt.data) === today);
            
            if (downtimeEl) {
                if (totalDowntimeMinutes >= 60) {
                    const hours = Math.floor(totalDowntimeMinutes / 60);
                    const mins = totalDowntimeMinutes % 60;
                    downtimeEl.textContent = `${hours}h${mins > 0 ? mins : ''}`;
                } else {
                    downtimeEl.textContent = totalDowntimeMinutes;
                }
            }
            if (downtimeEventsEl) downtimeEventsEl.textContent = todayDowntimes.length;
            if (downtimeTrendEl) {
                if (totalDowntimeMinutes <= 30) {
                    downtimeTrendEl.className = 'kpi-trend positive';
                    downtimeTrendEl.innerHTML = `<i data-lucide="thumbs-up" style="width:12px;height:12px"></i>Baixo`;
                } else if (totalDowntimeMinutes <= 90) {
                    downtimeTrendEl.className = 'kpi-trend neutral';
                    downtimeTrendEl.innerHTML = `<i data-lucide="minus" style="width:12px;height:12px"></i>Normal`;
                } else {
                    downtimeTrendEl.className = 'kpi-trend negative';
                    downtimeTrendEl.innerHTML = `<i data-lucide="alert-circle" style="width:12px;height:12px"></i>Alto`;
                }
            }
            
            // ========== 6. LANÇAMENTOS HOJE ==========
            const entriesEl = document.getElementById('kpiEntries');
            const lastEntryEl = document.getElementById('kpiLastEntry');
            
            if (entriesEl) entriesEl.textContent = cachedProductions.length;
            
            // Encontrar última entrada
            if (lastEntryEl) {
                let lastTime = '--:--';
                if (cachedProductions.length > 0) {
                    // Tentar encontrar o horário mais recente
                    const sorted = [...cachedProductions].sort((a, b) => {
                        // Converter para string de forma segura
                        const getTimeStr = (val) => {
                            if (!val) return '';
                            if (typeof val === 'string') return val;
                            if (val.toDate) return val.toDate().toISOString(); // Firebase Timestamp
                            if (val instanceof Date) return val.toISOString();
                            return String(val);
                        };
                        const timeA = getTimeStr(a.hora || a.hour || a.createdAt);
                        const timeB = getTimeStr(b.hora || b.hour || b.createdAt);
                        return timeB.localeCompare(timeA);
                    });
                    const lastProd = sorted[0];
                    let lastTimeVal = lastProd.hora || lastProd.hour;
                    if (typeof lastTimeVal === 'string' && lastTimeVal.length >= 5) {
                        lastTime = lastTimeVal.substring(0, 5);
                    } else {
                        lastTime = '--:--';
                    }
                }
                lastEntryEl.textContent = lastTime;
            }
            
            // ========== CÁLCULO DO OEE - MESMA LÓGICA DO SISTEMA PRINCIPAL ==========
            // Usar a mesma fórmula do script.js: calculateShiftOEE
            await calculateAndUpdateOEE(today);
            
            // Recriar ícones Lucide
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // ========== FUNÇÃO DE CÁLCULO OEE - REPLICANDO aggregateOeeMetrics DO SYNCHRO ==========
        async function calculateAndUpdateOEE(dateStr) {
            try {
                console.log('[Dashboard TV OEE] Calculando para data:', dateStr);
                
                // Usar dados normalizados (idêntico ao Synchro)
                const normalizedData = window._tvNormalizedData;
                if (!normalizedData) {
                    console.warn('[Dashboard TV OEE] Dados normalizados não disponíveis');
                    updateOEERing(0, 0, 100);
                    return;
                }
                
                const { production: productionData, losses: lossesData, downtime: downtimeData, plan: planData } = normalizedData;
                
                console.log('[Dashboard TV OEE] Dados normalizados:', {
                    production: productionData.length,
                    losses: lossesData.length,
                    downtime: downtimeData.length,
                    plan: planData.length
                });
                
                // aggregateOeeMetrics - IDÊNTICA à função do script.js
                const toShiftNumber = (value) => {
                    if (value === null || value === undefined) return null;
                    const num = Number(value);
                    return Number.isFinite(num) && num > 0 ? num : null;
                };
                
                const determineShiftFromTime = (timeStr) => {
                    if (!timeStr || typeof timeStr !== 'string') return null;
                    const [hoursStr] = timeStr.split(':');
                    const hours = Number(hoursStr);
                    if (!Number.isFinite(hours)) return null;
                    if (hours >= 7 && hours < 15) return 1;
                    if (hours >= 15 && hours < 23) return 2;
                    return 3;
                };
                
                const inferShift = (item) => {
                    // Tentar de múltiplas fontes
                    const candidates = [item.shift, item?.raw?.shift, item?.raw?.turno];
                    for (const value of candidates) {
                        const shiftNum = toShiftNumber(value);
                        if (shiftNum) return shiftNum;
                    }
                    
                    // Tentar pelo horário
                    const timeCandidates = [item.startTime, item.endTime, item?.raw?.hora, item?.raw?.horaInformada];
                    for (const time of timeCandidates) {
                        const shiftNum = determineShiftFromTime(time);
                        if (shiftNum) return shiftNum;
                    }
                    
                    // Padrão: turno 1
                    return 1;
                };
                
                const inferMachine = (item) => item.machine || item?.raw?.machine || item?.raw?.machineRef || item?.raw?.machine_id || null;
                
                const groupKey = (machine, shift, workDay) => `${machine || 'unknown'}_${shift ?? 'none'}_${workDay || 'nodate'}`;
                const grouped = {};
                
                const getOrCreateGroup = (item) => {
                    const machine = inferMachine(item);
                    const shiftNum = inferShift(item);
                    const workDay = item.workDay || item.date || 'nodate';
                    
                    if (!machine) return null;
                    
                    const key = groupKey(machine, shiftNum, workDay);
                    if (!grouped[key]) {
                        grouped[key] = {
                            machine,
                            shift: shiftNum,
                            workDay,
                            production: 0,
                            scrapPcs: 0,
                            scrapKg: 0,
                            downtimeMin: 0
                        };
                    }
                    return grouped[key];
                };
                
                // Agrupar produção
                productionData.forEach(item => {
                    const group = getOrCreateGroup(item);
                    if (group) group.production += item.quantity || 0;
                });
                
                // Agrupar perdas
                lossesData.forEach(item => {
                    const group = getOrCreateGroup(item);
                    if (group) {
                        group.scrapPcs += Number(item.scrapPcs ?? item.quantity ?? 0) || 0;
                        group.scrapKg += Number(item.scrapKg ?? 0) || 0;
                    }
                });
                
                // Agrupar paradas
                downtimeData.forEach(item => {
                    const group = getOrCreateGroup(item);
                    if (group) group.downtimeMin += item.duration || 0;
                });
                
                console.log('[Dashboard TV OEE] Grupos criados:', Object.keys(grouped).length);
                
                // Calcular métricas por grupo
                const groupsWithMetrics = [];
                const clamp01 = (value) => Math.max(0, Math.min(1, value));
                
                Object.values(grouped).forEach(group => {
                    // Buscar plano para essa máquina
                    const planCandidates = planData.filter(p => p && p.machine === group.machine);
                    
                    let cicloReal = 30;
                    let cavAtivas = 2;
                    let pieceWeight = 0.1;
                    
                    if (planCandidates.length > 0) {
                        const plan = planCandidates.find(p => Number(p.shift || 0) === group.shift) || planCandidates[0];
                        if (plan?.raw) {
                            const shiftKey = `t${group.shift}`;
                            cicloReal = plan.raw[`real_cycle_${shiftKey}`] || plan.raw.budgeted_cycle || 30;
                            cavAtivas = plan.raw[`active_cavities_${shiftKey}`] || plan.raw.mold_cavities || 2;
                            pieceWeight = plan.raw.piece_weight || 0.1;
                        }
                    }
                    
                    // Resolver refugo em peças
                    let refugoPcs = Math.round(Math.max(0, group.scrapPcs || 0));
                    if (!refugoPcs && group.scrapKg > 0 && pieceWeight > 0) {
                        refugoPcs = Math.round((group.scrapKg * 1000) / pieceWeight);
                    }
                    
                    const metrics = calculateShiftOEE(
                        group.production,
                        group.downtimeMin,
                        refugoPcs,
                        cicloReal,
                        cavAtivas
                    );
                    
                    console.log('[Dashboard TV OEE] Grupo:', group.machine, 'T' + group.shift, 
                                'Prod:', group.production, 'Refugo:', refugoPcs, 'Paradas:', group.downtimeMin + 'min',
                                'Ciclo:', cicloReal, 'Cav:', cavAtivas,
                                '-> Disp:', (metrics.disponibilidade * 100).toFixed(1) + '%',
                                'Perf:', (metrics.performance * 100).toFixed(1) + '%',
                                'Qual:', (metrics.qualidade * 100).toFixed(1) + '%');
                    
                    groupsWithMetrics.push({
                        machine: group.machine,
                        shift: group.shift,
                        workDay: group.workDay,
                        disponibilidade: clamp01(metrics.disponibilidade),
                        performance: clamp01(metrics.performance),
                        qualidade: clamp01(metrics.qualidade),
                        oee: clamp01(metrics.oee)
                    });
                });
                
                // Calcular média dos grupos (igual aggregateOeeMetrics)
                const averageMetric = (items, selector) => {
                    if (!items.length) return 0;
                    return items.reduce((sum, item) => sum + selector(item), 0) / items.length;
                };
                
                let availability = 0, performanceVal = 0, quality = 0;
                
                if (groupsWithMetrics.length > 0) {
                    availability = averageMetric(groupsWithMetrics, item => item.disponibilidade) * 100;
                    performanceVal = averageMetric(groupsWithMetrics, item => item.performance) * 100;
                    quality = averageMetric(groupsWithMetrics, item => item.qualidade) * 100;
                } else {
                    availability = 100;
                    performanceVal = 0;
                    quality = 100;
                }
                
                console.log('[Dashboard TV OEE] RESULTADO FINAL - Disponibilidade:', availability.toFixed(1) + '%', 
                            'Performance:', performanceVal.toFixed(1) + '%', 
                            'Qualidade:', quality.toFixed(1) + '%',
                            'OEE:', ((availability * performanceVal * quality) / 10000).toFixed(1) + '%');
                
                updateOEERing(availability, performanceVal, quality);
                
            } catch (error) {
                console.error('[Dashboard TV] Erro ao calcular OEE:', error);
                updateOEERing(0, 0, 100);
            }
        }
        
        // Função calculateShiftOEE - CÓPIA EXATA do script.js linha 22173
        function calculateShiftOEE(produzido, tempoParadaMin, refugoPcs, cicloReal, cavAtivas) {
            const tempoTurnoMin = 480; // 8 horas por turno
            
            const tempoProgramado = tempoTurnoMin;
            const tempoProduzindo = Math.max(0, tempoProgramado - Math.max(0, tempoParadaMin));
            const disponibilidade = tempoProgramado > 0 ? (tempoProduzindo / tempoProgramado) : 0;

            const producaoTeorica = cicloReal > 0 && cavAtivas > 0 ? (tempoProduzindo * 60 / cicloReal) * cavAtivas : 0;
            const performance = producaoTeorica > 0 ? Math.min(1, produzido / producaoTeorica) : (produzido > 0 ? 1 : 0);
            
            const totalProduzido = Math.max(0, produzido) + Math.max(0, refugoPcs);
            const qualidade = totalProduzido > 0 ? (Math.max(0, produzido) / totalProduzido) : (produzido > 0 ? 1 : 0);
            
            const oee = disponibilidade * performance * qualidade;

            return {
                disponibilidade: isNaN(disponibilidade) || !isFinite(disponibilidade) ? 0 : Math.max(0, Math.min(1, disponibilidade)),
                performance: isNaN(performance) || !isFinite(performance) ? 0 : Math.max(0, Math.min(1, performance)),
                qualidade: isNaN(qualidade) || !isFinite(qualidade) ? 0 : Math.max(0, Math.min(1, qualidade)),
                oee: isNaN(oee) || !isFinite(oee) ? 0 : Math.max(0, Math.min(1, oee))
            };
        }

        function formatNumber(num) {
            // Retornar número inteiro formatado (sem K, M)
            return Math.round(num).toLocaleString('pt-BR');
        }

        function updateOEERing(availability, performance, quality) {
            // Garantir valores válidos
            const safeAvail = Number.isFinite(availability) ? Math.max(0, Math.min(availability, 100)) : 0;
            const safePerf = Number.isFinite(performance) ? Math.max(0, Math.min(performance, 100)) : 0;
            const safeQual = Number.isFinite(quality) ? Math.max(0, Math.min(quality, 100)) : 100;
            
            // Calcular OEE (A x P x Q / 10000)
            const oee = (safeAvail * safePerf * safeQual) / 10000;
            
            // Atualizar valor central
            const oeeEl = document.getElementById('gaugeOEE');
            if (oeeEl) oeeEl.textContent = oee.toFixed(1);
            
            // Atualizar valores breakdown
            const availEl = document.getElementById('oeeAvailValue');
            const perfEl = document.getElementById('oeePerformValue');
            const qualEl = document.getElementById('oeeQualValue');
            
            if (availEl) availEl.textContent = safeAvail.toFixed(1) + '%';
            if (perfEl) perfEl.textContent = safePerf.toFixed(1) + '%';
            if (qualEl) qualEl.textContent = safeQual.toFixed(1) + '%';
            
            // Atualizar arcos do gauge SVG - raios conforme definido no HTML
            // Availability (outer) - radius 90, circunferência = 2 * PI * 90 = 565.49
            const availCircle = document.getElementById('gaugeAvailability');
            if (availCircle) {
                const circumference = 2 * Math.PI * 90;
                const offset = circumference * (1 - safeAvail / 100);
                availCircle.setAttribute('stroke-dasharray', circumference.toFixed(2));
                availCircle.setAttribute('stroke-dashoffset', offset.toFixed(2));
            }
            
            // Performance (middle) - radius 75, circunferência = 2 * PI * 75 = 471.24
            const perfCircle = document.getElementById('gaugePerformance');
            if (perfCircle) {
                const circumference = 2 * Math.PI * 75;
                const offset = circumference * (1 - safePerf / 100);
                perfCircle.setAttribute('stroke-dasharray', circumference.toFixed(2));
                perfCircle.setAttribute('stroke-dashoffset', offset.toFixed(2));
            }
            
            // Quality (inner) - radius 60, circunferência = 2 * PI * 60 = 376.99
            const qualCircle = document.getElementById('gaugeQuality');
            if (qualCircle) {
                const circumference = 2 * Math.PI * 60;
                const offset = circumference * (1 - safeQual / 100);
                qualCircle.setAttribute('stroke-dasharray', circumference.toFixed(2));
                qualCircle.setAttribute('stroke-dashoffset', offset.toFixed(2));
            }
        }

        // ==================== SHIFT KPIs UPDATE ====================
        function updateShiftKPIs() {
            // Inicializar contadores por turno
            const shifts = {
                T1: { production: 0, target: 0, downtime: 0 },
                T2: { production: 0, target: 0, downtime: 0 },
                T3: { production: 0, target: 0, downtime: 0 }
            };
            
            // Usar dados normalizados que já têm workDay correto
            const normalizedData = window._tvNormalizedData;
            
            // IMPORTANTE: Usar a data filtrada ou workDay atual
            // O workDay só muda às 07:00, então T1, T2 e T3 permanecem do mesmo dia até o fim do T3
            const workDay = getFilteredDateForData(); // Usa data filtrada se selecionada
            
            // Verificar se estamos visualizando dados históricos (data passada)
            const todayWorkDay = getTodayString();
            const isHistoricalView = selectedDate !== null && workDay !== todayWorkDay;
            
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            
            // Calcular minutos desde o início do dia de trabalho (07:00)
            // Se estamos entre 00:00-06:59, o dia de trabalho começou ontem às 07:00
            // Se estamos entre 07:00-23:59, o dia de trabalho começou hoje às 07:00
            let minutesSinceWorkDayStart;
            if (currentHour < 7) {
                // Madrugada: já passaram (24 - 7 + currentHour) * 60 + currentMinute minutos
                minutesSinceWorkDayStart = (17 + currentHour) * 60 + currentMinute; // 17 = 24 - 7
            } else {
                // Dia normal: passaram (currentHour - 7) * 60 + currentMinute minutos
                minutesSinceWorkDayStart = (currentHour - 7) * 60 + currentMinute;
            }
            
            // Determinar quais turnos já ocorreram/estão em andamento
            // Se é visualização histórica, todos os turnos são considerados ativos (dia completo)
            // T1: 07:00-15:00 (minutos 0-479 do workday)
            // T2: 15:00-23:20 (minutos 480-979 do workday)
            // T3: 23:20-07:00 (minutos 980-1439 do workday)
            const isT1Active = isHistoricalView || minutesSinceWorkDayStart >= 0;    // T1 sempre ativo após 07:00
            const isT2Active = isHistoricalView || minutesSinceWorkDayStart >= 480;  // T2 ativo após 15:00 (8h * 60min)
            const isT3Active = isHistoricalView || minutesSinceWorkDayStart >= 980;  // T3 ativo após 23:20 (16h20 * 60min = 980min)
            
            console.log('[Dashboard TV] WorkDay:', workDay, '| Histórico:', isHistoricalView, '| Minutos desde início:', minutesSinceWorkDayStart);
            console.log('[Dashboard TV] Turnos ativos - T1:', isT1Active, 'T2:', isT2Active, 'T3:', isT3Active, '| Hora atual:', currentHour + ':' + currentMinute);
            
            // Contar produção por turno usando dados normalizados
            if (normalizedData?.production) {
                normalizedData.production.forEach(item => {
                    // Só contar produções do workDay atual (dia de produção)
                    if (item.workDay !== workDay) return;
                    
                    const turnoNum = item.shift || 1;
                    const turnoKey = 'T' + turnoNum;
                    const qty = Math.round(item.quantity || 0);
                    
                    if (shifts[turnoKey]) {
                        shifts[turnoKey].production += qty;
                    }
                });
            } else {
                // Fallback: usar cachedProductions
                cachedProductions.forEach(prod => {
                    const turnoRaw = prod.turno || prod.shift;
                    let turno = '';
                    if (typeof turnoRaw === 'string') {
                        turno = turnoRaw.toUpperCase();
                    } else if (typeof turnoRaw === 'number') {
                        turno = 'T' + turnoRaw;
                    } else if (turnoRaw) {
                        turno = String(turnoRaw).toUpperCase();
                    }
                    
                    const qty = getProducedQty(prod);
                    if (shifts[turno]) {
                        shifts[turno].production += qty;
                    }
                });
            }
            
            // Calcular meta por turno (dividir meta total por 3)
            // Usar normalizedData?.plan se disponível (igual ao updateKPIs)
            let totalTarget = 0;
            if (normalizedData?.plan) {
                totalTarget = normalizedData.plan.reduce((sum, item) => sum + (item.quantity || 0), 0);
            } else {
                totalTarget = cachedPlanning.reduce((sum, p) => sum + getPlanTarget(p), 0);
            }
            const targetPerShift = Math.round(totalTarget / 3);
            shifts.T1.target = targetPerShift;
            shifts.T2.target = targetPerShift;
            shifts.T3.target = targetPerShift;
            
            // Contar paradas por turno usando dados normalizados
            if (normalizedData?.downtime) {
                normalizedData.downtime.forEach(item => {
                    // Só contar paradas do workDay atual (dia de produção)
                    if (item.workDay !== workDay) return;
                    
                    const turnoNum = item.shift || 1;
                    const turnoKey = 'T' + turnoNum;
                    const minutes = item.duration || 0;
                    
                    if (shifts[turnoKey]) {
                        shifts[turnoKey].downtime += minutes;
                    }
                });
            } else {
                // Fallback: usar cachedDowntimes
                cachedDowntimes.filter(dt => (dt.date || dt.data) === workDay).forEach(dt => {
                    const turnoRaw = dt.turno || dt.shift;
                    let turno = '';
                    if (typeof turnoRaw === 'string') {
                        turno = turnoRaw.toUpperCase();
                    } else if (typeof turnoRaw === 'number') {
                        turno = 'T' + turnoRaw;
                    } else if (turnoRaw) {
                        turno = String(turnoRaw).toUpperCase();
                    }
                    
                    let minutes = dt.duration || dt.duration_minutes || 0;
                    if (!minutes && dt.startTime && dt.endTime) {
                        const s = new Date(`1970-01-01T${dt.startTime}:00`);
                        const e = new Date(`1970-01-01T${dt.endTime}:00`);
                        minutes = Math.max(0, Math.round((e - s) / 60000));
                    }
                    if (shifts[turno]) {
                        shifts[turno].downtime += minutes;
                    }
                });
            }
            
            // Zerar turnos que ainda não começaram (para não mostrar dados incorretos)
            if (!isT1Active) {
                shifts.T1 = { production: 0, target: 0, downtime: 0 };
            }
            if (!isT2Active) {
                shifts.T2 = { production: 0, target: 0, downtime: 0 };
            }
            if (!isT3Active) {
                shifts.T3 = { production: 0, target: 0, downtime: 0 };
            }
            
            console.log('[Dashboard TV] Dados por turno após filtro:', shifts);
            
            // Atualizar elementos do DOM
            const formatQty = (n) => Math.round(n).toLocaleString('pt-BR');
            const calcEfficiency = (prod, target) => target > 0 ? Math.min((prod / target) * 100, 150).toFixed(0) : 0;
            
            // T1 - sempre ativo após 7h
            const t1Planned = document.getElementById('t1Planned');
            const t1Prod = document.getElementById('t1Production');
            const t1Eff = document.getElementById('t1Efficiency');
            const t1Down = document.getElementById('t1Downtime');
            if (isT1Active) {
                if (t1Planned) t1Planned.textContent = formatQty(shifts.T1.target);
                if (t1Prod) t1Prod.textContent = formatQty(shifts.T1.production);
                if (t1Eff) t1Eff.textContent = calcEfficiency(shifts.T1.production, shifts.T1.target) + '%';
                if (t1Down) t1Down.textContent = shifts.T1.downtime + 'min';
            } else {
                if (t1Planned) t1Planned.textContent = '--';
                if (t1Prod) t1Prod.textContent = '--';
                if (t1Eff) t1Eff.textContent = '--';
                if (t1Down) t1Down.textContent = '--';
            }
            
            // T2 - ativo após 15h
            const t2Planned = document.getElementById('t2Planned');
            const t2Prod = document.getElementById('t2Production');
            const t2Eff = document.getElementById('t2Efficiency');
            const t2Down = document.getElementById('t2Downtime');
            if (isT2Active) {
                if (t2Planned) t2Planned.textContent = formatQty(shifts.T2.target);
                if (t2Prod) t2Prod.textContent = formatQty(shifts.T2.production);
                if (t2Eff) t2Eff.textContent = calcEfficiency(shifts.T2.production, shifts.T2.target) + '%';
                if (t2Down) t2Down.textContent = shifts.T2.downtime + 'min';
            } else {
                if (t2Planned) t2Planned.textContent = '--';
                if (t2Prod) t2Prod.textContent = '--';
                if (t2Eff) t2Eff.textContent = '--';
                if (t2Down) t2Down.textContent = '--';
            }
            
            // T3 - ativo após 23h ou antes das 7h (madrugada)
            const t3Planned = document.getElementById('t3Planned');
            const t3Prod = document.getElementById('t3Production');
            const t3Eff = document.getElementById('t3Efficiency');
            const t3Down = document.getElementById('t3Downtime');
            if (isT3Active) {
                if (t3Planned) t3Planned.textContent = formatQty(shifts.T3.target);
                if (t3Prod) t3Prod.textContent = formatQty(shifts.T3.production);
                if (t3Eff) t3Eff.textContent = calcEfficiency(shifts.T3.production, shifts.T3.target) + '%';
                if (t3Down) t3Down.textContent = shifts.T3.downtime + 'min';
            } else {
                if (t3Planned) t3Planned.textContent = '--';
                if (t3Prod) t3Prod.textContent = '--';
                if (t3Eff) t3Eff.textContent = '--';
                if (t3Down) t3Down.textContent = 'Não iniciado';
            }
            
            // Totais
            const totalPlanned = totalTarget; // Usar o totalTarget original, não a soma dos turnos
            const totalProd = shifts.T1.production + shifts.T2.production + shifts.T3.production;
            const totalDown = shifts.T1.downtime + shifts.T2.downtime + shifts.T3.downtime;
            
            const totalDayPlanned = document.getElementById('totalDayPlanned');
            const totalDayProd = document.getElementById('totalDayProduction');
            const totalDayEff = document.getElementById('totalDayEfficiency');
            const totalDayDown = document.getElementById('totalDayDowntime');
            if (totalDayPlanned) totalDayPlanned.textContent = formatQty(totalPlanned);
            if (totalDayProd) totalDayProd.textContent = formatQty(totalProd);
            if (totalDayEff) totalDayEff.textContent = calcEfficiency(totalProd, totalTarget) + '%';
            if (totalDayDown) totalDayDown.textContent = totalDown >= 60 ? Math.floor(totalDown/60) + 'h' + (totalDown%60) + 'm' : totalDown + 'min';
        }

        // ==================== PRODUCTION CHART - REAL DATA ====================
        function updateProductionChart() {
            // Removido - substituído por KPIs por turno
            return;
        }

        // ==================== PARETO CHART - REAL DATA ====================
        function updateParetoChart() {
            const canvas = document.getElementById('paretoChart');
            if (!canvas) {
                console.error('[Dashboard TV] Elemento paretoChart não encontrado!');
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Agrupar perdas por motivo
            const lossData = {};
            
            cachedDowntimes.forEach(dt => {
                const motivo = dt.reason || dt.tipo || dt.motivo || 'Outros';
                const start = dt.startTime;
                const end = dt.endTime;
                let minutes = dt.duration || dt.duration_minutes || 0;
                if (!minutes && start && end) {
                    const s = new Date(`1970-01-01T${start}:00`);
                    const e = new Date(`1970-01-01T${end}:00`);
                    minutes = Math.max(0, Math.round((e - s) / 60000));
                }
                if (!lossData[motivo]) lossData[motivo] = 0;
                lossData[motivo] += minutes;
            });
            
            // Se não houver dados de perdas, mostrar mensagem
            if (Object.keys(lossData).length === 0) {
                const canvas = document.getElementById('paretoChart');
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#78909c';
                    ctx.font = '14px Roboto';
                    ctx.textAlign = 'center';
                    ctx.fillText('Sem paradas registradas hoje', canvas.width / 2, canvas.height / 2);
                }
                return;
            }
            
            // Ordenar por valor
            const sorted = Object.entries(lossData).sort((a, b) => b[1] - a[1]);
            const categories = sorted.map(s => s[0]);
            const times = sorted.map(s => s[1]);
            
            // Calcular acumulado
            const total = times.reduce((a, b) => a + b, 0);
            const cumulative = [];
            let sum = 0;
            times.forEach(t => {
                sum += t;
                cumulative.push((sum / total) * 100);
            });
            
            // Destruir gráfico anterior se existir
            if (paretoChartInstance) {
                paretoChartInstance.destroy();
            }
            
            paretoChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: categories.slice(0, 7),
                    datasets: [
                        {
                            label: 'Tempo Parado (min)',
                            data: times.slice(0, 7),
                            backgroundColor: (context) => {
                                const index = context.dataIndex;
                                if (index === 0) return 'rgba(255, 23, 68, 0.8)';
                                if (index === 1) return 'rgba(255, 23, 68, 0.65)';
                                if (index === 2) return 'rgba(255, 23, 68, 0.5)';
                                return 'rgba(255, 23, 68, 0.35)';
                            },
                            borderColor: 'rgba(255, 23, 68, 1)',
                            borderWidth: 0,
                            borderRadius: 2,
                            barPercentage: 0.7,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Acumulado %',
                            data: cumulative.slice(0, 7),
                            type: 'line',
                            borderColor: 'rgba(0, 180, 216, 1)',
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            pointRadius: 4,
                            pointBackgroundColor: 'rgba(0, 180, 216, 1)',
                            pointBorderColor: '#0d1117',
                            pointBorderWidth: 2,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: getParetoChartOptions()
            });
        }

        function getParetoChartOptions() {
            return {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'top',
                        align: 'end',
                        labels: {
                            color: '#78909c',
                            font: { size: 10, family: 'Roboto' },
                            usePointStyle: true,
                            padding: 16
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { display: false },
                        ticks: { color: '#78909c', font: { size: 9, family: 'Roboto' }, maxRotation: 0 }
                    },
                    y: {
                        position: 'left',
                        grid: { color: 'rgba(45, 55, 72, 0.5)', drawBorder: false },
                        ticks: { 
                            color: '#78909c', 
                            font: { size: 10, family: 'Roboto Mono' },
                            callback: v => v + ' min'
                        },
                        title: { display: true, text: 'Duração (min)', color: '#78909c', font: { size: 10 } }
                    },
                    y1: {
                        position: 'right',
                        min: 0,
                        max: 100,
                        grid: { display: false },
                        ticks: { 
                            color: '#00b4d8', 
                            font: { size: 10, family: 'Roboto Mono' },
                            callback: v => v + '%'
                        },
                        title: { display: true, text: 'Acumulado %', color: '#00b4d8', font: { size: 10 } }
                    }
                }
            };
        }

        // ==================== STOPPED MACHINES LIST ====================
        function updateStoppedMachinesList() {
            const listEl = document.getElementById('stoppedMachinesList');
            const tagEl = document.getElementById('stoppedMachinesTag');
            if (!listEl) return;
            
            // Lista de máquinas válidas do sistema (27 máquinas conforme machineDatabase)
            const validMachineIds = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                             'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                             'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
            
            // Buscar paradas ativas do cache (já deduplicado) - FILTRAR APENAS MÁQUINAS VÁLIDAS
            const activeDowntimes = cachedDowntimes.filter(dt => {
                // VALIDAÇÃO: Verificar se a máquina existe no machineDatabase
                const machineId = normalizeMachineId(dt.machine || dt.machine_id || dt.maquina);
                if (!validMachineIds.has(machineId)) {
                    return false; // Ignorar máquinas que não existem no sistema
                }
                
                // Paradas LIVE (active_downtimes) - sempre ativas
                if (dt.source === 'active_live' && dt.isActive === true) return true;
                
                // Extended downtimes ativos
                if (dt.source === 'extended' && dt.status === 'active') return true;
                
                // Paradas do dia que não foram finalizadas (sem endTime)
                if (!dt.endTime || dt.endTime === '' || dt.endTime === '--:--') {
                    const reason = (dt.reason || dt.motivo || '').toLowerCase();
                    const isLongStop = reason.includes('parada') || reason.includes('manutencao') || 
                                       reason.includes('manutenção') || reason.includes('ferramentaria') ||
                                       reason.includes('setup') || reason.includes('comercial');
                    return isLongStop;
                }
                
                return false;
            });
            
            if (tagEl) {
                const count = activeDowntimes.length;
                tagEl.textContent = count + ' Parada' + (count !== 1 ? 's' : '');
            }
            
            if (activeDowntimes.length === 0) {
                listEl.innerHTML = `
                    <div class="no-stopped-machines" style="height: 100%;">
                        <i data-lucide="check-circle-2" style="width: 60px; height: 60px; color: var(--status-running);"></i>
                        <p style="font-size: 18px; margin-top: 16px;">Todas as máquinas em operação!</p>
                        <p style="font-size: 12px; color: var(--text-tertiary); margin-top: 8px;">Nenhuma parada registrada no momento</p>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Ordenar por duração (maior primeiro)
            activeDowntimes.sort((a, b) => (b.duration || 0) - (a.duration || 0));
            
            // Renderizar cards de máquinas paradas
            listEl.innerHTML = activeDowntimes.map(dt => {
                const machineId = dt.machine || dt.machine_id || dt.maquina || 'N/A';
                const reason = dt.reason || dt.motivo || dt.type || 'Sem motivo';
                
                // Abreviar motivo para caber no card
                const shortReason = reason.length > 18 ? reason.substring(0, 16) + '...' : reason;
                
                // Calcular tempo parada
                let duration = dt.duration || 0;
                let durationStr = '';
                
                if (dt.status === 'active' && (dt.start_datetime || dt.startTime)) {
                    // Calcular tempo em tempo real
                    const startTime = dt.start_datetime?.toDate?.() || new Date(dt.start_date + 'T' + (dt.start_time || dt.startTime || '00:00'));
                    duration = Math.floor((new Date() - startTime) / (1000 * 60));
                }
                
                if (duration >= 60) {
                    const hours = Math.floor(duration / 60);
                    const mins = duration % 60;
                    durationStr = `${hours}h${mins > 0 ? mins + 'm' : ''}`;
                } else {
                    durationStr = `${duration}min`;
                }
                
                // Determinar cor baseada na categoria
                let borderColor = 'var(--status-critical)';
                const reasonLower = reason.toLowerCase();
                if (reasonLower.includes('setup') || reasonLower.includes('troca')) {
                    borderColor = '#3B82F6';
                } else if (reasonLower.includes('manutencao') || reasonLower.includes('manutenção')) {
                    borderColor = 'var(--status-warning)';
                } else if (reasonLower.includes('ferramentaria') || reasonLower.includes('molde')) {
                    borderColor = 'var(--status-warning)';
                } else if (reasonLower.includes('comercial') || reasonLower.includes('pcp') || reasonLower.includes('sem pedido')) {
                    borderColor = 'var(--status-idle)';
                }
                
                return `
                    <div class="stopped-machine-card" style="border-color: ${borderColor};" title="${reason}">
                        <span class="machine-id" style="color: ${borderColor};">${machineId}</span>
                        <span class="machine-reason">${shortReason}</span>
                        <span class="machine-time">${durationStr || '--'}</span>
                    </div>
                `;
            }).join('');
        }

        // ==================== MACHINE STATUS GRID ====================
        function updateMachineStatusGrid() {
            const gridEl = document.getElementById('machineStatusGrid');
            if (!gridEl) return;
            
            // Definir todas as máquinas do sistema (conforme database.js)
            const allMachineIds = ['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                   'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                   'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32'];
            
            // Criar mapa de paradas ativas para cada máquina
            const machineDowntimeMap = new Map();
            cachedDowntimes.forEach(dt => {
                const machineId = (dt.machine || dt.maquina || dt.machine_id || '').toUpperCase();
                if (machineId) {
                    if (!machineDowntimeMap.has(machineId)) {
                        machineDowntimeMap.set(machineId, []);
                    }
                    machineDowntimeMap.get(machineId).push(dt);
                }
            });
            
            // Criar mapa de máquinas em produção (planejamento ativo)
            const machineProductionMap = new Map();
            cachedPlanning.forEach(plan => {
                const machineId = (plan.machine || plan.machineId || plan.maquina || '').toUpperCase();
                if (machineId) {
                    machineProductionMap.set(machineId, plan);
                }
            });
            
            // Função para determinar a classe CSS baseada no status da máquina
            function getStatusClass(machineId) {
                // Se tem parada ativa, verificar tipo
                const downtimes = machineDowntimeMap.get(machineId);
                if (downtimes && downtimes.length > 0) {
                    // Filtrar apenas paradas ativas (não finalizadas)
                    const activeDowntimes = downtimes.filter(dt => {
                        // PRIORIDADE 1: Parada LIVE (active_downtimes) - SEMPRE ativa
                        if (dt.source === 'active_live' && dt.isActive === true) {
                            return true;
                        }
                        
                        // PRIORIDADE 2: Extended downtimes com status = 'active'
                        if (dt.source === 'extended' && dt.status === 'active') {
                            return true;
                        }
                        
                        // PRIORIDADE 3: Paradas normais (downtime_entries)
                        // Se tem status, verificar se é ativo
                        if (dt.status && dt.status !== 'active' && dt.status !== 'registered') {
                            return false;
                        }
                        // Se tem endTime, a parada já foi finalizada
                        if (dt.endTime && dt.endTime !== '' && dt.endTime !== '--:--') {
                            return false;
                        }
                        return true;
                    });
                    
                    // Se não há paradas ativas, verificar se está produzindo
                    if (activeDowntimes.length === 0) {
                        if (machineProductionMap.has(machineId)) {
                            return 'produzindo';
                        }
                        return 'outros';
                    }
                    
                    const lastDowntime = activeDowntimes[activeDowntimes.length - 1];
                    const reason = (lastDowntime.reason || lastDowntime.motivo || lastDowntime.downtime_reason || '').toLowerCase();
                    
                    // Preparação de Material = Rosa
                    // Inclui: "AGUARDANDO PREPARAÇÃO DE MATERIAL", "AGUARDANDO ESTUFAGEM DE M.P", "FORA DE COR", "TESTE DE COR"
                    if (reason.includes('preparação') || reason.includes('preparacao') || 
                        reason.includes('estufagem') || reason.includes('fora de cor') || reason.includes('teste de cor')) {
                        return 'preparacao';
                    }
                    
                    // Setup = Azul Claro
                    // Inclui: "INSTALAÇÃO DE MOLDE", "RETIRADA DE MOLDE", "INSTALAÇÃO DE PERÍFÉRICOS"
                    if (reason.includes('setup') || reason.includes('instalação') || reason.includes('instalacao') ||
                        reason.includes('retirada de molde')) {
                        return 'setup';
                    }
                    
                    // Compras = Marrom
                    // Inclui: "FALTA DE MATÉRIA PRIMA", "FALTA DE SACO PLÁSTICO", "FALTA DE CAIXA DE PAPELÃO", "FALTA DE MASTER"
                    if (reason.includes('compra') || 
                        (reason.includes('falta') && (reason.includes('matéria') || reason.includes('materia') || 
                        reason.includes('prima') || reason.includes('saco') || reason.includes('caixa') || reason.includes('master')))) {
                        return 'compras';
                    }
                    
                    // Ferramentaria = Laranja
                    // Inclui: "CORRETIVA DE MOLDE", "PREVENTIVA DE MOLDE", "TROCA DE VERSÃO"
                    if (reason.includes('ferramentaria') || reason.includes('corretiva de molde') || 
                        reason.includes('preventiva de molde') || reason.includes('troca de versão') || reason.includes('versão')) {
                        return 'ferramentaria';
                    }
                    
                    // Processo = Roxo
                    // Inclui: "ABERTURA DE CAVIDADE", "AJUSTE DE PROCESSO", "FECHAMENTO DE CAVIDADE", "TRY OUT", "PRENDENDO GALHO", "PRENDENDO PEÇAS"
                    if (reason.includes('processo') || reason.includes('ajuste') || reason.includes('cavidade') || 
                        reason.includes('try out') || reason.includes('prendendo')) {
                        return 'processo';
                    }
                    
                    // Manutenção = Amarelo
                    // Inclui: "MANUTENÇÃO CORRETIVA", "MANUTENÇÃO PREVENTIVA"
                    if (reason.includes('manutenção') || reason.includes('manutencao') || reason.includes('maintenance')) {
                        return 'manutencao';
                    }
                    
                    // Qualidade = Vermelho
                    // Inclui: "AGUARDANDO CLIENTE/FORNECEDOR", "LIBERAÇÃO INÍCIAL", "AGUARDANDO DISPOSIÇÃO DA QUALIDADE"
                    if (reason.includes('qualidade') || reason.includes('liberação') || reason.includes('aguardando cliente') || 
                        reason.includes('aguardando fornecedor') || reason.includes('disposição')) {
                        return 'qualidade';
                    }
                    
                    // Produção = Rosa
                    // Inclui: "FALTA DE OPERADOR", "TROCA DE COR", "F.O REVEZAMENTO ALMOÇO", "F.O REVEZAMENTO JANTA", "INICIO/REINICIO"
                    if (reason.includes('operador') || reason.includes('troca de cor') || 
                        reason.includes('revezamento') || reason.includes('almoço') || reason.includes('janta') ||
                        reason.includes('inicio') || reason.includes('reinicio')) {
                        return 'producao';
                    }
                    
                    // Comercial = Cinza
                    // Inclui: "SEM PEDIDO"
                    if (reason.includes('comercial') || reason.includes('sem pedido')) {
                        return 'comercial';
                    }
                    
                    // PCP = Preto
                    // Inclui: "SEM PROGRAMAÇÃO", "SEM PROGRAMAÇÃO-FIM DE SEMANA", "ESTRATÉGIA PCP"
                    if (reason.includes('pcp') || reason.includes('estratégia') || reason.includes('estrategia') || 
                        reason.includes('sem programação') || reason.includes('sem programacao')) {
                        return 'pcp';
                    }
                    
                    // Administrativo = Branco
                    // Inclui: "FALTA DE ENERGIA", "FALTA DE ÁGUA", "QUEDA DE ENERGIA"
                    if (reason.includes('energia') || reason.includes('falta de água') || reason.includes('queda')) {
                        return 'administrativo';
                    }
                    
                    // Outros
                    // Inclui: "VAZAMENTO DO BICO", "QUEIMA DE RESISTÊNCIA"
                    if (reason.includes('vazamento') || reason.includes('queima de resist')) {
                        return 'outros';
                    }
                    
                    // Default para paradas não mapeadas = Outros
                    return 'outros';
                }
                
                // Se não tem parada mas tem planejamento, está produzindo
                if (machineProductionMap.has(machineId)) {
                    return 'produzindo';
                }
                
                // Default
                return 'outros';
            }
            
            // Função para obter label do status - nomes completos
            function getStatusLabel(statusClass) {
                const labels = {
                    'produzindo': 'Produzindo',
                    'manutencao': 'Manutenção',
                    'ferramentaria': 'Ferrament.',
                    'compras': 'Compras',
                    'processo': 'Processo',
                    'qualidade': 'Qualidade',
                    'preparacao': 'Preparação',
                    'producao': 'Produção',
                    'pmp': 'PMP',
                    'pcp': 'PCP',
                    'comercial': 'Comercial',
                    'setup': 'Setup',
                    'administrativo': 'Energia',
                    'outros': 'Outros'
                };
                return labels[statusClass] || 'Outros';
            }
            
            // Renderizar grid
            gridEl.innerHTML = allMachineIds.map(machineId => {
                const statusClass = getStatusClass(machineId);
                const statusLabel = getStatusLabel(statusClass);
                
                // Buscar motivo da parada se houver
                let title = 'Máquina sem status';
                const downtimes = machineDowntimeMap.get(machineId);
                if (downtimes && downtimes.length > 0) {
                    const lastDowntime = downtimes[downtimes.length - 1];
                    title = lastDowntime.reason || lastDowntime.motivo || 'Parada ativa';
                } else if (machineProductionMap.has(machineId)) {
                    title = 'Em produção';
                }
                
                return `
                    <div class="machine-status-card ${statusClass}" title="${title}">
                        <span class="machine-number">${machineId}</span>
                        <span class="machine-label">${statusLabel}</span>
                    </div>
                `;
            }).join('');
            
            console.log('[Dashboard TV] Machine Status Grid renderizado com', allMachineIds.length, 'máquinas');
        }

        // ==================== LOSSES TABLE - REAL DATA ====================
        function updateLossesTable() {
            const table = document.getElementById('lossesTable');
            if (!table) {
                console.error('[Dashboard TV] Elemento lossesTable não encontrado!');
                return;
            }
            
            // Agrupar perdas
            const lossData = {};
            
            cachedDowntimes.forEach(dt => {
                const motivo = dt.reason || dt.tipo || dt.motivo || 'Outros';
                const machine = dt.machine || dt.maquina || 'N/A';
                const start = dt.startTime;
                const end = dt.endTime;
                let minutes = dt.duration || dt.duration_minutes || 0;
                if (!minutes && start && end) {
                    const s = new Date(`1970-01-01T${start}:00`);
                    const e = new Date(`1970-01-01T${end}:00`);
                    minutes = Math.max(0, Math.round((e - s) / 60000));
                }
                if (!lossData[motivo]) {
                    lossData[motivo] = { time: 0, machine: machine };
                }
                lossData[motivo].time += minutes;
            });
            
            // Se não houver dados, mostrar mensagem
            if (Object.keys(lossData).length === 0) {
                table.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: #78909c;">
                        <i data-lucide="check-circle" style="width: 32px; height: 32px; margin-bottom: 8px; color: #00e676;"></i>
                        <p style="font-size: 12px;">Sem paradas registradas hoje</p>
                    </div>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Ordenar e calcular percentuais
            const sorted = Object.entries(lossData).sort((a, b) => b[1].time - a[1].time);
            const total = sorted.reduce((sum, s) => sum + s[1].time, 0);
            
            const losses = sorted.slice(0, 5).map((s, i) => ({
                rank: i + 1,
                reason: s[0],
                machine: s[1].machine,
                time: s[1].time,
                percent: total > 0 ? Math.round((s[1].time / total) * 100) : 0
            }));
            
            table.innerHTML = losses.map(l => `
                <div class="loss-row">
                    <span class="loss-rank">#${l.rank}</span>
                    <div class="loss-info">
                        <span class="loss-reason">${l.reason}</span>
                        <span class="loss-machine">${l.machine}</span>
                    </div>
                    <span class="loss-time">${l.time}min</span>
                    <span class="loss-percent">${l.percent}%</span>
                </div>
            `).join('');
        }

        // ==================== TICKER UPDATE ====================
        function updateTicker() {
            const ticker = document.querySelector('.ticker-track');
            if (!ticker) return;
            
            console.log('[Dashboard TV Ticker] Atualizando ticker com dados reais...');
            console.log('[Dashboard TV Ticker] Planning:', cachedPlanning.length, '| Productions:', cachedProductions.length, '| Downtimes:', cachedDowntimes.length);
            
            // Usar dados normalizados quando disponíveis
            const normalizedData = window._tvNormalizedData;
            
            // Calcular estatísticas de produção
            let totalProduced = 0;
            let totalRefugo = 0;
            
            if (normalizedData?.production) {
                totalProduced = normalizedData.production.reduce((sum, p) => sum + (p.quantity || 0), 0);
            } else {
                totalProduced = cachedProductions.reduce((sum, p) => sum + getProducedQty(p), 0);
            }
            
            // Refugo vem da coleção losses (dados normalizados) - IGUAL AO SYNCHRO
            if (normalizedData?.losses) {
                totalRefugo = normalizedData.losses.reduce((sum, p) => sum + (p.scrapPcs || p.quantity || 0), 0);
                console.log('[Dashboard TV Ticker] Refugo dos dados normalizados:', totalRefugo);
            } else {
                // Fallback: tentar dos cachedProductions
                totalRefugo = cachedProductions.reduce((sum, p) => sum + (p.pecasRuins || p.refugo_pcs || p.refugo || 0), 0);
            }
            
            const totalTarget = cachedPlanning.reduce((sum, p) => sum + getPlanTarget(p), 0);
            const completion = totalTarget > 0 ? ((totalProduced / totalTarget) * 100).toFixed(1) : 0;
            
            // Calcular paradas do dia
            const today = getFilteredDateForData(); // Usa data filtrada se selecionada
            const todayDowntimes = cachedDowntimes.filter(dt => (dt.date || dt.data) === today);
            let totalDowntimeMinutes = 0;
            todayDowntimes.forEach(dt => {
                let minutes = dt.duration || dt.duration_minutes || 0;
                if (!minutes && dt.startTime && dt.endTime) {
                    const s = new Date(`1970-01-01T${dt.startTime}:00`);
                    const e = new Date(`1970-01-01T${dt.endTime}:00`);
                    minutes = Math.max(0, Math.round((e - s) / 60000));
                }
                totalDowntimeMinutes += minutes;
            });
            
            // Encontrar melhor máquina (baseado em performance)
            const machinePerf = {};
            cachedProductions.forEach(prod => {
                const plan = cachedPlanning.find(p => p.id === prod.planId);
                if (plan) {
                    const machineId = plan.machine || plan.machineId || plan.maquina;
                    if (!machinePerf[machineId]) machinePerf[machineId] = { produced: 0, target: getPlanTarget(plan) };
                    machinePerf[machineId].produced += getProducedQty(prod);
                }
            });
            
            let bestMachine = null;
            let bestPerf = 0;
            Object.entries(machinePerf).forEach(([id, data]) => {
                const perf = data.target > 0 ? (data.produced / data.target) * 100 : 0;
                if (perf > bestPerf) {
                    bestPerf = perf;
                    bestMachine = id;
                }
            });
            
            // Encontrar máquinas paradas AGORA
            // Lista de máquinas válidas para contagem (27 máquinas do sistema)
            const validMachineIdsSet = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                                 'H11', 'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                                 'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
            
            // Filtrar cachedMachines para apenas máquinas válidas
            const validMachines = cachedMachines.filter(m => validMachineIdsSet.has(normalizeMachineId(m.id || m.name)));
            const activeMachines = validMachines.filter(m => m.status === 'running' || m.status === 'producao');
            const stoppedMachines = validMachines.filter(m => m.status === 'parada' || m.status === 'stopped' || m.status === 'setup');
            
            // Classes de destaque
            const completionClass = completion >= 80 ? 'highlight-good' : (completion >= 50 ? 'highlight-warning' : 'highlight-critical');
            const qualityClass = totalRefugo === 0 ? 'highlight-good' : (totalRefugo < 100 ? 'highlight-warning' : 'highlight-critical');
            const downtimeClass = totalDowntimeMinutes <= 30 ? 'highlight-good' : (totalDowntimeMinutes <= 90 ? 'highlight-warning' : 'highlight-critical');
            
            // Construir itens do ticker
            const tickerItems = [];
            
            // Item 1: Produção
            tickerItems.push(`<span class="ticker-item"><strong>📊 PRODUÇÃO:</strong> Meta diária em <span class="${completionClass}">${completion}%</span> de conclusão (${formatNumber(totalProduced)} / ${formatNumber(totalTarget)} pçs)</span>`);
            
            // Item 2: Qualidade
            tickerItems.push(`<span class="ticker-item"><strong>✅ QUALIDADE:</strong> <span class="${qualityClass}">${totalRefugo === 0 ? 'Zero refugo hoje' : formatNumber(totalRefugo) + ' pçs refugo'}</span></span>`);
            
            // Item 3: Paradas
            tickerItems.push(`<span class="ticker-item"><strong>⏱️ PARADAS:</strong> <span class="${downtimeClass}">${totalDowntimeMinutes}min</span> em ${todayDowntimes.length} evento(s) hoje</span>`);
            
            // Item 4: Status das máquinas
            if (cachedMachines.length > 0) {
                const runningCount = activeMachines.length;
                const stoppedCount = stoppedMachines.length;
                const statusClass = stoppedCount === 0 ? 'highlight-good' : (stoppedCount <= 2 ? 'highlight-warning' : 'highlight-critical');
                tickerItems.push(`<span class="ticker-item"><strong>🏭 MÁQUINAS:</strong> <span class="${statusClass}">${runningCount} produzindo | ${stoppedCount} parada(s)</span></span>`);
            }
            
            // Item 5: Destaque (melhor máquina)
            if (bestMachine && bestPerf > 0) {
                tickerItems.push(`<span class="ticker-item"><strong>⭐ DESTAQUE:</strong> ${bestMachine} com <span class="highlight-good">${bestPerf.toFixed(1)}%</span> da meta</span>`);
            }
            
            // Item 6: Ordens
            tickerItems.push(`<span class="ticker-item"><strong>📋 ORDENS:</strong> ${cachedPlanning.length} ordens ativas | ${cachedProductions.length} lançamentos hoje</span>`);
            
            // Item 7: Alerta de máquinas paradas (se houver)
            if (stoppedMachines.length > 0) {
                const stoppedNames = stoppedMachines.slice(0, 3).map(m => m.name || m.id).join(', ');
                tickerItems.push(`<span class="ticker-item"><strong>🔴 ATENÇÃO:</strong> <span class="highlight-critical">${stoppedNames}</span> ${stoppedMachines.length > 3 ? '(+' + (stoppedMachines.length - 3) + ')' : ''} parada(s)</span>`);
            }
            
            // Atualizar ticker - duplicar itens para animação contínua
            const allItems = [...tickerItems, ...tickerItems];
            ticker.innerHTML = allItems.join('');
            
            console.log('[Dashboard TV Ticker] Ticker atualizado com', tickerItems.length, 'itens');
        }

        // ==================== HELPERS ====================
        // Função centralizada para extrair quantidade planejada (consistente com script.js)
        function getPlanTarget(plan) {
            if (!plan) return 0;
            // Prioridade: lot_size > order_lot_size > planned_quantity > planned_qty > quantidade > meta > target > qtdPlanejada
            const qty = plan.lot_size || 
                        plan.order_lot_size || 
                        plan.planned_quantity || 
                        plan.planned_qty || 
                        plan.quantidade || 
                        plan.meta || 
                        plan.target || 
                        plan.qtdPlanejada || 
                        0;
            return Math.round(Number(qty) || 0);
        }

        function getProducedQty(prod) {
            const qty = prod.produzido || prod.pecasBoas || prod.quantity || prod.produced || prod.qtd || prod.quantidade || prod.total_produzido || 0;
            return Math.round(Number(qty) || 0); // Sempre retornar inteiro
        }
    </script>
</body>

</html>
