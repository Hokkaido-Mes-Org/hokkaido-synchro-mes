// Função global para fechar modais (disponível imediatamente)
// ============ CONFIGURAÇÃO DE MÁQUINAS ============
// Máquinas desativadas/retiradas de uso - não aparecem nos dashboards
const DISABLED_MACHINES = ['H11'];
// ====================================================

window.closeModal = function(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.warn('[closeModal] Modal não encontrado:', modalId);
        return;
    }
    modal.classList.add('hidden');
    modal.setAttribute('aria-hidden', 'true');
    modal.removeAttribute('data-modal-open');
    
    // Limpar estilos aplicados pelo modalManager se existir
    if (window.__modalManager) {
        window.__modalManager.clearStyles(modal);
        const modalContent = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
        if (modalContent) {
            window.__modalManager.clearContentStyles(modalContent);
        }
    }
    
    // Limpar formulários associados ao modal fechado
    const form = modal.querySelector('form');
    if (form) form.reset();
    console.log('[closeModal] Modal fechado:', modalId);
};

// Popular o select de MP no cadastro de ordem de produção
document.addEventListener('DOMContentLoaded', async function() {
    // Aguardar database estar carregado (máximo 3 segundos)
    let attempts = 0;
    while (attempts < 30 && (typeof productDatabase === 'undefined' || !productDatabase || productDatabase.length === 0)) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
    }
    
    if (typeof productDatabase === 'undefined' || !productDatabase || productDatabase.length === 0) {
        console.error('[CRÍTICO] Database não carregado após 3 segundos!');
    } else {
        console.log(`[OK] Database carregado: ${productDatabase.length} produtos, productByCode size: ${productByCode?.size || 0}`);
    }
    
    // Ocultar subaba Analytics IA para todos, exceto usuários autorizados (Leandro Camargo, Davi Batista ou role 'suporte')
    setTimeout(() => {
        try {
            const user = window.authSystem?.getCurrentUser?.();
            const analyticsBtn = document.querySelector('.analysis-tab-btn[data-view="predictive"]');
            const isAuthorizedUser = user && (
                user.name === 'Leandro Camargo' || user.username === 'leandro.camargo' ||
                user.name === 'Davi Batista' || user.username === 'davi.batista' ||
                user.role === 'suporte'
            );
            if (analyticsBtn && !isAuthorizedUser) {
                analyticsBtn.style.display = 'none';
            }
            
            // Mostrar filtro de data no lançamento para Leandro Camargo, Davi Batista ou perfis de suporte
            const lancamentoDateFilter = document.getElementById('lancamento-date-filter');
            const isLeandro = user && (
                user.name === 'Leandro Camargo' || user.username === 'leandro.camargo' ||
                user.email === 'leandro@hokkaido.com.br'
            );
            const isDavi = user && (
                user.name === 'Davi Batista' || user.username === 'davi.batista' ||
                user.email === 'davi@hokkaido.com.br'
            );
            const isSuporte = user?.role === 'suporte';
            if (lancamentoDateFilter && (isLeandro || isDavi || isSuporte)) {
                lancamentoDateFilter.classList.remove('hidden');
                setupLancamentoDateFilter();
            }
            
            // Mostrar botão de Novo Produto apenas para usuários autorizados (gestores, suporte, Leandro ou Davi)
            const btnNewProduct = document.getElementById('btn-new-product');
            const isGestorOrAdmin = user && (
                user.name === 'Leandro Camargo' || user.username === 'leandro.camargo' ||
                user.email === 'leandro@hokkaido.com.br' ||
                user.name === 'Davi Batista' || user.username === 'davi.batista' ||
                user.email === 'davi@hokkaido.com.br' ||
                user.role === 'suporte' || user.role === 'gestor'
            );
            if (btnNewProduct && !isGestorOrAdmin) {
                btnNewProduct.style.display = 'none';
            }
            
            // Mostrar/ocultar aba PMP para usuários autorizados
            const pmpNavBtn = document.querySelector('[data-page="pmp"]');
            const allowedPMPUsers = ['leandro camargo', 'manaus silva', 'daniel rocha'];
            const userNameLower = (user?.name || '').toLowerCase().trim();
            const isAllowedForPMP = user && allowedPMPUsers.includes(userNameLower);
            
            // DEBUG: Log detalhado
            console.log('[PMP-DEBUG] Verificando acesso PMP:', {
                userName: user?.name,
                userNameLower: userNameLower,
                allowedPMPUsers: allowedPMPUsers,
                isAllowedForPMP: isAllowedForPMP
            });
            
            if (pmpNavBtn) {
                if (isAllowedForPMP) {
                    pmpNavBtn.style.display = '';  // Mostrar
                    console.log('✅ Aba PMP visível para ' + user.name);
                } else {
                    pmpNavBtn.style.display = 'none';  // Ocultar
                    console.log('🔒 Aba PMP oculta para usuário: ' + (user?.name || 'desconhecido'));
                }
            } else {
                console.warn('⚠️ Botão da aba PMP não encontrado no DOM');
            }
            
            // Mostrar/ocultar aba Dashboard TV para usuários autorizados
            const dashboardTVNavBtn = document.querySelector('[data-page="dashboard-tv"]');
            const allowedDashboardTVUsers = ['daniel rocha', 'linaldo', 'luciano'];
            const isAllowedForDashboardTV = user && (allowedDashboardTVUsers.includes(userNameLower) || 
               user.name === 'Leandro Camargo' || 
               user.email === 'leandro@hokkaido.com.br' ||
               user.name === 'Davi Batista' || 
               user.email === 'davi@hokkaido.com.br' ||
               user.role === 'lider');
            
            console.log('[DASHBOARD-TV-DEBUG] Verificando acesso Dashboard TV:', {
                userName: user?.name,
                userNameLower: userNameLower,
                allowedDashboardTVUsers: allowedDashboardTVUsers,
                isAllowedForDashboardTV: isAllowedForDashboardTV
            });
            
            if (dashboardTVNavBtn) {
                if (isAllowedForDashboardTV) {
                    dashboardTVNavBtn.style.display = '';  // Mostrar
                    console.log('✅ Aba Dashboard TV visível para ' + user.name);
                } else {
                    dashboardTVNavBtn.style.display = 'none';  // Ocultar
                    console.log('🔒 Aba Dashboard TV oculta para usuário: ' + (user?.name || 'desconhecido'));
                }
            } else {
                console.warn('⚠️ Botão da aba Dashboard TV não encontrado no DOM');
            }
        } catch (e) {
            console.warn('Erro ao aplicar restrição da aba PMP:', e);
        }
    }, 300);
    
    // Configurar filtro de data do lançamento
    function setupLancamentoDateFilter() {
        const dateInput = document.getElementById('lancamento-date-input');
        const applyBtn = document.getElementById('lancamento-date-apply');
        const resetBtn = document.getElementById('lancamento-date-reset');
        const indicator = document.getElementById('lancamento-date-indicator');
        const dateLabel = document.getElementById('lancamento-date-label');
        
        if (!dateInput) return;
        
        // Definir data atual como padrão
        const today = new Date();
        const hour = today.getHours();
        const minute = today.getMinutes();
        if (hour < 6 || (hour === 6 && minute < 30)) today.setDate(today.getDate() - 1);
        const todayStr = today.toISOString().split('T')[0];
        dateInput.value = todayStr;
        
        // Variável global para data selecionada no lançamento
        window.lancamentoFilterDate = null;
        
        applyBtn?.addEventListener('click', () => {
            const selectedDate = dateInput.value;
            if (!selectedDate) return;
            
            window.lancamentoFilterDate = selectedDate;
            
            // Mostrar indicador
            if (indicator) indicator.classList.remove('hidden');
            if (dateLabel) {
                const dateObj = new Date(selectedDate + 'T12:00:00');
                const formatted = dateObj.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: '2-digit' });
                dateLabel.textContent = `Visualizando: ${formatted}`;
            }
            
            // Recarregar dados com a nova data
            if (typeof populateMachineSelector === 'function') {
                populateMachineSelector(selectedDate);
            }
            if (typeof loadTodayStats === 'function') {
                loadTodayStats(selectedDate);
            }
            if (typeof loadRecentEntries === 'function') {
                loadRecentEntries(false, selectedDate);
            }
            
            console.log('[FILTRO DATA] Aplicado:', selectedDate);
        });
        
        resetBtn?.addEventListener('click', () => {
            window.lancamentoFilterDate = null;
            dateInput.value = todayStr;
            
            // Ocultar indicador
            if (indicator) indicator.classList.add('hidden');
            
            // Recarregar dados do dia atual
            if (typeof populateMachineSelector === 'function') {
                populateMachineSelector();
            }
            if (typeof loadTodayStats === 'function') {
                loadTodayStats();
            }
            if (typeof loadRecentEntries === 'function') {
                loadRecentEntries(false);
            }
            
            console.log('[FILTRO DATA] Resetado para hoje');
        });
        
        // Renderizar ícones
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
    
    function popularSelectMPOrdem() {
        const select = document.getElementById('order-raw-material');
        if (!select) return;
        select.innerHTML = '<option value="">Selecione a matéria-prima...</option>';
        materiaPrimaDatabase.forEach(mp => {
            const opt = document.createElement('option');
            opt.value = mp.codigo;
            opt.textContent = `${mp.codigo} - ${mp.descricao}`;
            select.appendChild(opt);
        });
    }
    carregarBancoMateriaPrima(popularSelectMPOrdem);
});
// Utilitário para obter descrição da MP pelo código
function getDescricaoMP(codigo) {
    const cod = Number(codigo);
    const mp = materiaPrimaDatabase.find(mp => Number(mp.codigo) === cod);
    return mp ? mp.descricao : String(codigo);
}

// Exemplo de uso em análises de perda:
// Em qualquer local que exibe ou processa MP de perda, use getDescricaoMP(codigo) para mostrar a descrição padronizada.

// Exemplo para gráficos e relatórios:
// const descricao = getDescricaoMP(loss.mp_codigo);
// Popular o select de MP na tela de planejamento
document.addEventListener('DOMContentLoaded', function() {
    function popularSelectMPPlanejamento() {
        const select = document.getElementById('planning-mp');
        if (!select) return;
        select.innerHTML = '<option value="">Selecione a matéria-prima...</option>';
        materiaPrimaDatabase.forEach(mp => {
            const opt = document.createElement('option');
            opt.value = mp.codigo;
            opt.textContent = `${mp.codigo} - ${mp.descricao}`;
            select.appendChild(opt);
        });
    }
    carregarBancoMateriaPrima(popularSelectMPPlanejamento);
});
// --- Integração do banco de Matéria-prima no modal de edição de ordem ---
// Carregar banco de matéria-prima
function carregarBancoMateriaPrima(callback) {
    if (window.materiaPrimaDatabase && Array.isArray(window.materiaPrimaDatabase)) {
          if (callback) callback(); // Callback to populate the select
    }
}

function popularSelectMP() {
    const select = document.getElementById('edit-order-mp');
    if (!select) return;
    select.innerHTML = '<option value="">Selecione a matéria-prima...</option>';
    materiaPrimaDatabase.forEach(mp => {
          const opt = document.createElement('option');
          opt.value = mp.codigo;
          opt.textContent = `${mp.codigo} - ${mp.descricao}`;
          select.appendChild(opt); // Append option to select
    });
}

// Popular o select de MP ao abrir o modal de edição
document.addEventListener('DOMContentLoaded', function() {
    const editOrderModal = document.getElementById('edit-order-modal');
    // Sempre popular o select de MP ao exibir o modal
    if (editOrderModal) {
        // Usar MutationObserver para detectar exibição do modal
        const observer = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                if (mutation.attributeName === 'class') {
                    const isVisible = !editOrderModal.classList.contains('hidden');
                    if (isVisible) {
                        carregarBancoMateriaPrima(popularSelectMP);
                    }
                }
            });
        });
        observer.observe(editOrderModal, { attributes: true });
    }
    // Fallback: popular ao abrir o modal manualmente
    const btns = document.querySelectorAll('[data-edit-order]');
    btns.forEach(btn => {
        btn.addEventListener('click', function() {
            carregarBancoMateriaPrima(popularSelectMP);
        });
    });
});
// This file contains the full and correct JavaScript code for the Hokkaido Mes application.
// All functionalities, including the new database with product codes, are implemented here.

document.addEventListener('DOMContentLoaded', function() {
    console.log('📍 [DEBUG] script.js DOMContentLoaded iniciado');
    console.log('📍 [DEBUG] window.authSystem disponível?', window.authSystem);
    if (window.authSystem) {
        console.log('📍 [DEBUG] currentUser:', window.authSystem.getCurrentUser?.());
    }
    
    // Firebase Configuration
    if (typeof firebase === 'undefined' || typeof firebase.firestore === 'undefined') {
        alert("Erro Crítico: A biblioteca da base de dados não conseguiu ser carregada.");
        return;
    }

    const firebaseConfig = {
        apiKey: "AIzaSyB1YrMK07_7QROsCJQqE0MFsmJncfjphmI",
        authDomain: "hokkaido-synchro.firebaseapp.com",
        projectId: "hokkaido-synchro",
        storageBucket: "hokkaido-synchro.firebasestorage.app",
        messagingSenderId: "635645564631",
        appId: "1:635645564631:web:1e19be7957e39d1adc8292"
    };

    let db;
    let storage = null;
    
    // Sistema de gerenciamento de listeners Firestore
    const listenerManager = {
        listeners: new Map(),
        
        subscribe(name, query, onSnapshot, onError) {
            // Desinscrever anterior se existir
            this.unsubscribe(name);
            
            try {
                const unsubscribe = query.onSnapshot(
                    snapshot => {
                        try {
                            onSnapshot(snapshot);
                        } catch (error) {
                            console.error(`Erro ao processar snapshot ${name}:`, error);
                        }
                    },
                    error => {
                        console.error(`Erro no listener ${name}:`, error);
                        if (onError) onError(error);
                    }
                );
                
                this.listeners.set(name, unsubscribe);
                console.log(`✅ Listener "${name}" inscrito`);
            } catch (error) {
                console.error(`Erro ao criar listener ${name}:`, error);
                if (onError) onError(error);
            }
        },
        
        unsubscribe(name) {
            const unsubscribe = this.listeners.get(name);
            if (unsubscribe) {
                try {
                    unsubscribe();
                    this.listeners.delete(name);
                    console.log(`✅ Listener "${name}" desinscritos`);
                } catch (error) {
                    console.error(`Erro ao desinscrever listener ${name}:`, error);
                }
            }
        },
        
        unsubscribeAll() {
            for (const name of this.listeners.keys()) {
                this.unsubscribe(name);
            }
        },
        
        // AÇÃO 3: Visibility API - pausar/retomar listeners
        pauseAll() {
            if (this._paused) return;
            this._paused = true;
            this._pausedListeners = new Map(this.listeners);
            for (const [name, unsubscribe] of this.listeners) {
                try {
                    unsubscribe();
                    console.log(`⏸️ Listener "${name}" pausado`);
                } catch (e) {
                    console.warn(`Erro ao pausar listener ${name}:`, e);
                }
            }
            this.listeners.clear();
        },
        
        resumeAll() {
            if (!this._paused) return;
            this._paused = false;
            console.log('▶️ Retomando listeners...');
            // Re-registrar listeners será feito ao recarregar a view atual
            if (typeof window._currentListenerSetup === 'function') {
                window._currentListenerSetup();
            }
        }
    };
    
    // AÇÃO 3: Visibility API - pausar listeners quando aba não visível
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            console.log('👁️ Aba oculta - pausando listeners para economizar');
            listenerManager.pauseAll();
            // Pausar polling de downtimes ativos
            if (window._activeDowntimesPolling) {
                clearInterval(window._activeDowntimesPolling);
                window._activeDowntimesPolling = null;
            }
        } else {
            console.log('👁️ Aba visível - retomando listeners');
            listenerManager.resumeAll();
            // Retomar polling de downtimes ativos
            if (typeof window._startActiveDowntimesPolling === 'function') {
                window._startActiveDowntimesPolling();
            }
        }
    });
    
    // Limpar listeners quando a página está se descarregando
    window.addEventListener('beforeunload', () => {
        listenerManager.unsubscribeAll();
        if (window._activeDowntimesPolling) {
            clearInterval(window._activeDowntimesPolling);
        }
    });
    
    // AÇÃO 5: CacheManager para relatórios - evita consultas repetidas
    const CacheManager = {
        _cache: new Map(),
        _ttl: 60000, // 60 segundos de TTL padrão
        
        // Gera chave única para o cache
        _generateKey(collection, filters) {
            return `${collection}:${JSON.stringify(filters)}`;
        },
        
        // Verifica se cache é válido
        isValid(key) {
            const entry = this._cache.get(key);
            if (!entry) return false;
            return Date.now() - entry.timestamp < this._ttl;
        },
        
        // Obtém dados do cache
        get(key) {
            const entry = this._cache.get(key);
            if (!entry) return null;
            if (Date.now() - entry.timestamp >= this._ttl) {
                this._cache.delete(key);
                return null;
            }
            console.log(`📦 Cache hit: ${key}`);
            return entry.data;
        },
        
        // Armazena dados no cache
        set(key, data) {
            this._cache.set(key, {
                data: data,
                timestamp: Date.now()
            });
            console.log(`💾 Cache set: ${key}`);
        },
        
        // Consulta com cache automático
        async fetchWithCache(collection, filters = {}, ttl = null) {
            const key = this._generateKey(collection, filters);
            
            // Verificar cache
            const cached = this.get(key);
            if (cached !== null) {
                return cached;
            }
            
            // Buscar do Firestore
            let query = db.collection(collection);
            
            // Aplicar filtros
            if (filters.where) {
                for (const [field, op, value] of filters.where) {
                    query = query.where(field, op, value);
                }
            }
            if (filters.orderBy) {
                query = query.orderBy(filters.orderBy.field, filters.orderBy.direction || 'asc');
            }
            if (filters.limit) {
                query = query.limit(filters.limit);
            }
            
            const snapshot = await query.get();
            const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // Armazenar no cache
            const effectiveTtl = ttl || this._ttl;
            this._cache.set(key, {
                data: data,
                timestamp: Date.now(),
                ttl: effectiveTtl
            });
            
            console.log(`🔥 Firestore fetch: ${collection} (${data.length} docs)`);
            return data;
        },
        
        // Invalida cache de uma collection
        invalidate(collection) {
            for (const key of this._cache.keys()) {
                if (key.startsWith(`${collection}:`)) {
                    this._cache.delete(key);
                    console.log(`🗑️ Cache invalidado: ${key}`);
                }
            }
        },
        
        // Limpa todo o cache
        clear() {
            this._cache.clear();
            console.log('🗑️ Cache completamente limpo');
        }
    };
    
    // Expor CacheManager globalmente
    window.CacheManager = CacheManager;

    // ========== DATASTORE CENTRALIZADO ==========
    // Armazena dados de listeners em memória para evitar leituras repetidas
    const DataStore = {
        _data: {
            planning: null,
            productionOrders: null,
            productionEntries: null,
            activeDowntimes: null,
            extendedDowntimeLogs: null,
            downtimeEntries: null
        },
        _timestamps: {},
        _subscribers: new Map(),
        _readCounts: {
            total: 0,
            byCollection: {}
        },
        
        // Obter dados (sempre retorna do store, nunca do Firebase diretamente)
        get(collection) {
            return this._data[collection] || null;
        },
        
        // Atualizar dados (chamado pelos listeners)
        set(collection, data) {
            this._data[collection] = data;
            this._timestamps[collection] = Date.now();
            
            // Notificar subscribers
            const subs = this._subscribers.get(collection);
            if (subs) {
                subs.forEach(callback => {
                    try {
                        callback(data);
                    } catch (e) {
                        console.warn(`Erro no subscriber de ${collection}:`, e);
                    }
                });
            }
        },
        
        // Verificar se dados estão "frescos" (recentes)
        // TTL aumentado de 30s para 120s para reduzir leituras Firebase
        isFresh(collection, maxAgeMs = 120000) {
            const ts = this._timestamps[collection];
            if (!ts) return false;
            return Date.now() - ts < maxAgeMs;
        },
        
        // Obter timestamp da última atualização
        getTimestamp(collection) {
            return this._timestamps[collection] || 0;
        },
        
        // Registrar subscriber para atualizações
        subscribe(collection, callback) {
            if (!this._subscribers.has(collection)) {
                this._subscribers.set(collection, new Set());
            }
            this._subscribers.get(collection).add(callback);
            
            // Retorna função de unsubscribe
            return () => {
                const subs = this._subscribers.get(collection);
                if (subs) subs.delete(callback);
            };
        },
        
        // Contar leitura para monitoramento
        trackRead(collection, source = 'unknown') {
            this._readCounts.total++;
            this._readCounts.byCollection[collection] = (this._readCounts.byCollection[collection] || 0) + 1;
        },
        
        // Obter estatísticas de leitura
        getStats() {
            return {
                ...this._readCounts,
                lastUpdates: { ...this._timestamps }
            };
        },
        
        // Resetar contadores
        resetStats() {
            this._readCounts = { total: 0, byCollection: {} };
        },
        
        // Buscar do Firebase com cache inteligente
        async fetchIfNeeded(collection, queryBuilder = null, forceRefresh = false) {
            // Se dados existem e são frescos, usar do cache
            if (!forceRefresh && this.isFresh(collection, 60000) && this._data[collection]) {
                console.log(`📦 DataStore: usando cache de ${collection}`);
                return this._data[collection];
            }
            
            // Buscar do Firebase
            this.trackRead(collection, 'fetchIfNeeded');
            console.log(`🔥 DataStore: buscando ${collection} do Firebase`);
            
            let query = db.collection(collection);
            if (queryBuilder) {
                query = queryBuilder(query);
            }
            
            const snapshot = await query.get();
            const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            this.set(collection, data);
            return data;
        },
        
        // Encontrar item por ID (busca no store primeiro)
        findById(collection, id) {
            const data = this._data[collection];
            if (!data) return null;
            return data.find(item => item.id === id) || null;
        },
        
        // Filtrar dados do store (sem buscar do Firebase)
        filter(collection, predicate) {
            const data = this._data[collection];
            if (!data) return [];
            return data.filter(predicate);
        }
    };
    
    // Expor DataStore globalmente
    window.DataStore = DataStore;

    // ========== BATCH QUERY MANAGER ==========
    // Agrupa queries para reduzir número de leituras
    const BatchQueryManager = {
        _pendingQueries: new Map(),
        _batchDelay: 50, // ms para agrupar queries
        
        // Adiciona query ao batch
        async query(collection, docId) {
            return new Promise((resolve, reject) => {
                if (!this._pendingQueries.has(collection)) {
                    this._pendingQueries.set(collection, {
                        docIds: new Set(),
                        resolvers: []
                    });
                    
                    // Executar batch após delay
                    setTimeout(() => this._executeBatch(collection), this._batchDelay);
                }
                
                const batch = this._pendingQueries.get(collection);
                batch.docIds.add(docId);
                batch.resolvers.push({ docId, resolve, reject });
            });
        },
        
        // Executar batch de queries
        async _executeBatch(collection) {
            const batch = this._pendingQueries.get(collection);
            if (!batch) return;
            
            this._pendingQueries.delete(collection);
            
            const docIds = Array.from(batch.docIds);
            console.log(`📦 Batch query: ${collection} (${docIds.length} docs)`);
            
            // Firebase limita a 10 itens por 'in' query
            const chunks = [];
            for (let i = 0; i < docIds.length; i += 10) {
                chunks.push(docIds.slice(i, i + 10));
            }
            
            const allDocs = new Map();
            
            for (const chunk of chunks) {
                try {
                    const snapshot = await db.collection(collection)
                        .where(firebase.firestore.FieldPath.documentId(), 'in', chunk)
                        .get();
                    
                    snapshot.docs.forEach(doc => {
                        allDocs.set(doc.id, { id: doc.id, ...doc.data() });
                    });
                } catch (error) {
                    console.error(`Erro no batch query ${collection}:`, error);
                }
            }
            
            // Resolver todas as promises
            batch.resolvers.forEach(({ docId, resolve }) => {
                resolve(allDocs.get(docId) || null);
            });
        }
    };
    
    window.BatchQueryManager = BatchQueryManager;

    // ========== FIREBASE USAGE MONITOR ==========
    // Monitor de uso do Firebase para acompanhar economia de leituras
    const FirebaseMonitor = {
        _startTime: Date.now(),
        _reads: 0,
        _writes: 0,
        _cacheHits: 0,
        _estimatedSavings: 0,
        
        trackRead(collection, wasFromCache = false) {
            if (wasFromCache) {
                this._cacheHits++;
                this._estimatedSavings++;
            } else {
                this._reads++;
            }
        },
        
        trackWrite(collection) {
            this._writes++;
        },
        
        getStats() {
            const runtime = Math.round((Date.now() - this._startTime) / 60000);
            const totalRequests = this._reads + this._cacheHits;
            const hitRate = totalRequests > 0 ? Math.round((this._cacheHits / totalRequests) * 100) : 0;
            
            return {
                runtime: `${runtime} min`,
                reads: this._reads,
                writes: this._writes,
                cacheHits: this._cacheHits,
                estimatedSavings: this._estimatedSavings,
                hitRate: `${hitRate}%`
            };
        },
        
        printStats() {
            const stats = this.getStats();
            console.log('%c📊 FIREBASE USAGE STATS', 'color: #00b4d8; font-weight: bold; font-size: 14px');
            console.log(`   ⏱️ Tempo de execução: ${stats.runtime}`);
            console.log(`   🔥 Leituras Firebase: ${stats.reads}`);
            console.log(`   📦 Hits de cache: ${stats.cacheHits}`);
            console.log(`   💰 Leituras economizadas: ${stats.estimatedSavings}`);
            console.log(`   📈 Taxa de cache: ${stats.hitRate}`);
            console.log(`   ✏️ Escritas: ${stats.writes}`);
            return stats;
        },
        
        reset() {
            this._startTime = Date.now();
            this._reads = 0;
            this._writes = 0;
            this._cacheHits = 0;
            this._estimatedSavings = 0;
        }
    };
    
    window.FirebaseMonitor = FirebaseMonitor;
    
    // Comando rápido no console: digite fbstats() para ver estatísticas
    window.fbstats = () => FirebaseMonitor.printStats();

    // ========== HELPER FUNCTIONS - LEITURAS OTIMIZADAS ==========
    // Funções para buscar dados de collections com cache/DataStore

    /**
     * Busca production_orders do DataStore/Cache antes de ir ao Firebase
     * @param {boolean} forceRefresh - Forçar atualização do Firebase
     * @returns {Promise<Array>} - Lista de production_orders
     */
    async function getProductionOrdersCached(forceRefresh = false) {
        // Primeiro, verificar se temos no productionOrdersCache (variável local)
        if (!forceRefresh && typeof productionOrdersCache !== 'undefined' && productionOrdersCache && productionOrdersCache.length > 0) {
            console.log('📦 Usando productionOrdersCache local');
            return productionOrdersCache;
        }
        
        // Segundo, verificar DataStore
        if (!forceRefresh && window.DataStore) {
            const cached = window.DataStore.get('productionOrders');
            if (cached && cached.length > 0) {
                console.log('📦 Usando DataStore.productionOrders');
                if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('production_orders', true);
                return cached;
            }
        }
        
        // Terceiro, verificar CacheManager
        const cacheKey = 'production_orders:all';
        if (!forceRefresh && window.CacheManager) {
            const cached = window.CacheManager.get(cacheKey);
            if (cached) {
                console.log('📦 Usando CacheManager.production_orders');
                if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('production_orders', true);
                return cached;
            }
        }
        
        // Se não encontrou em nenhum cache, buscar do Firebase
        console.log('🔥 Buscando production_orders do Firebase');
        if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('production_orders', false);
        const snapshot = await db.collection('production_orders').get();
        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Armazenar em todos os caches
        if (window.DataStore) {
            window.DataStore.set('productionOrders', data);
        }
        if (window.CacheManager) {
            window.CacheManager.set(cacheKey, data);
        }
        
        return data;
    }
    
    /**
     * Busca planning do DataStore/Cache antes de ir ao Firebase
     * @param {string} date - Data opcional para filtrar
     * @param {boolean} forceRefresh - Forçar atualização do Firebase
     * @returns {Promise<Array>} - Lista de plannings
     */
    async function getPlanningCached(date = null, forceRefresh = false) {
        // Se não precisa filtrar por data e temos no DataStore
        if (!forceRefresh && window.DataStore) {
            const cached = window.DataStore.get('planning');
            if (cached && cached.length > 0) {
                if (!date) {
                    console.log('📦 Usando DataStore.planning');
                    if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('planning', true);
                    return cached;
                }
                // Filtrar por data localmente
                const filtered = cached.filter(p => p.date === date);
                if (filtered.length > 0) {
                    console.log('📦 Usando DataStore.planning (filtrado por data)');
                    if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('planning', true);
                    return filtered;
                }
            }
        }
        
        // Buscar do Firebase
        console.log('🔥 Buscando planning do Firebase');
        if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('planning', false);
        let query = db.collection('planning');
        if (date) {
            query = query.where('date', '==', date);
        }
        const snapshot = await query.get();
        return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    }
    
    /**
     * Encontra uma production_order por ID usando cache
     * @param {string} orderId - ID do documento ou número da OP
     * @returns {Promise<Object|null>}
     */
    async function findProductionOrderCached(orderId) {
        const allOrders = await getProductionOrdersCached();
        
        // Buscar por ID do documento
        let order = allOrders.find(o => o.id === orderId);
        if (order) return order;
        
        // Buscar por número da ordem
        const normalized = String(orderId).toUpperCase().trim();
        order = allOrders.find(o => 
            String(o.order_number || '').toUpperCase().trim() === normalized ||
            String(o.orderNumber || '').toUpperCase().trim() === normalized
        );
        
        return order || null;
    }
    
    /**
     * Busca production_entries do DataStore/Cache antes de ir ao Firebase
     * @param {string} date - Data para filtrar (workDay)
     * @param {boolean} forceRefresh - Forçar atualização do Firebase
     * @returns {Promise<Array>} - Lista de production_entries
     */
    async function getProductionEntriesCached(date = null, forceRefresh = false) {
        // Verificar DataStore primeiro
        if (!forceRefresh && window.DataStore) {
            const cached = window.DataStore.get('productionEntries');
            if (cached && cached.length > 0) {
                if (!date) {
                    console.log('📦 Usando DataStore.productionEntries');
                    if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('production_entries', true);
                    return cached;
                }
                // Filtrar por data localmente
                const filtered = cached.filter(e => e.workDay === date || e.data === date);
                if (filtered.length >= 0) { // Retorna mesmo se vazio (pode não ter dados nessa data)
                    console.log('📦 Usando DataStore.productionEntries (filtrado por data)');
                    if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('production_entries', true);
                    return filtered;
                }
            }
        }
        
        // Buscar do Firebase
        console.log('🔥 Buscando production_entries do Firebase');
        if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('production_entries', false);
        let query = db.collection('production_entries');
        if (date) {
            query = query.where('workDay', '==', date);
        }
        const snapshot = await query.get();
        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Armazenar no DataStore se buscou todos
        if (!date && window.DataStore) {
            window.DataStore.set('productionEntries', data);
        }
        
        return data;
    }
    
    /**
     * Busca extended_downtime_logs do DataStore/Cache antes de ir ao Firebase
     * @param {boolean} forceRefresh - Forçar atualização do Firebase
     * @param {boolean} activeOnly - Filtrar apenas ativos
     * @returns {Promise<Array>} - Lista de extended_downtime_logs
     */
    async function getExtendedDowntimesCached(forceRefresh = false, activeOnly = false) {
        // Verificar DataStore primeiro
        if (!forceRefresh && window.DataStore) {
            const cached = window.DataStore.get('extendedDowntimeLogs');
            if (cached && cached.length >= 0) {
                if (activeOnly) {
                    const filtered = cached.filter(d => d.status === 'active');
                    console.log('📦 Usando DataStore.extendedDowntimeLogs (ativos)');
                    if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('extended_downtime_logs', true);
                    return filtered;
                }
                console.log('📦 Usando DataStore.extendedDowntimeLogs');
                if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('extended_downtime_logs', true);
                return cached;
            }
        }
        
        // Buscar do Firebase
        console.log('🔥 Buscando extended_downtime_logs do Firebase');
        if (window.FirebaseMonitor) window.FirebaseMonitor.trackRead('extended_downtime_logs', false);
        const snapshot = await db.collection('extended_downtime_logs').get();
        const data = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Armazenar no DataStore
        if (window.DataStore) {
            window.DataStore.set('extendedDowntimeLogs', data);
        }
        
        if (activeOnly) {
            return data.filter(d => d.status === 'active');
        }
        return data;
    }
    
    // Expor globalmente
    window.getProductionOrdersCached = getProductionOrdersCached;
    window.getPlanningCached = getPlanningCached;
    window.findProductionOrderCached = findProductionOrderCached;
    window.getProductionEntriesCached = getProductionEntriesCached;
    window.getExtendedDowntimesCached = getExtendedDowntimesCached;
    
    
    try {
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        
        // Configurações de Firestore para melhorar estabilidade
    db = firebase.firestore();
    window.db = db;
        
        // Tentar desabilitar QUIC se disponível (evita ERR_QUIC_PROTOCOL_ERROR)
        if (db.settings) {
            try {
                db.settings({
                    experimentalForceLongPolling: true
                });
                console.log('✅ Firestore: Long polling forçado (QUIC desabilitado)');
            } catch (e) {
                console.warn('⚠️ Não foi possível configurar long polling:', e.message);
            }
        }
        
        if (typeof firebase.storage === 'function') {
            // Nota: Fotos foram removidas do sistema; Storage não é utilizado.
            console.log('Firebase Storage detectado (não utilizado: fotos removidas)');
        } else {
            console.log('Firebase Storage indisponível (irrelevante: fotos removidas).');
        }
        
        // Firebase inicializado (teste de conexão removido para otimização)
        console.log('Firebase inicializado com sucesso');
        console.log('Firestore instance:', db);
        
    } catch (error) {
        console.error("Erro ao inicializar Firebase: ", error);
        alert("Erro fatal: Não foi possível conectar à base de dados.");
        return;
    }

    // Monitor global para erros de rede (inclui QUIC)
    window.addEventListener('error', (event) => {
        if (event.message && event.message.includes('QUIC')) {
            console.warn('⚠️ QUIC Protocol Error detectado - tentando reconectar...');
            console.warn('Detalhes:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        }
    });

    // Monitor para erros não capturados de Promise
    window.addEventListener('unhandledrejection', (event) => {
        if (event.reason && (event.reason.message?.includes('QUIC') || event.reason.code?.includes('QUIC'))) {
            console.warn('⚠️ QUIC Promise Rejection detectada');
            console.warn('Reason:', event.reason);
            // Não preventar o erro - deixar prosseguir normalmente
        }
    });

    // --- Configuration Lists ---
    
    // Função centralizada para extrair quantidade planejada de um plano
    // Usada para garantir consistência entre Dashboard TV e Aba Análise
    // CORREÇÃO: Priorizar planned_quantity (meta diária calculada) sobre lot_size (tamanho total OP)
    function getPlanQuantity(raw) {
        if (!raw) return 0;
        // Prioridade: planned_quantity (meta diária) > planned_qty > quantidade > meta > target > qtdPlanejada
        // NÃO USAR lot_size/order_lot_size aqui - esses são o tamanho total da OP, não a meta diária!
        const qty = raw.planned_quantity || 
                    raw.planned_qty || 
                    raw.quantidade || 
                    raw.meta || 
                    raw.target || 
                    raw.qtdPlanejada || 
                    0;
        return Math.round(Number(qty) || 0);
    }
    
    // Normalização de IDs de máquina: H01, H02, ...
    function normalizeMachineId(id) {
        if (!id) return null;
        const s = String(id).toUpperCase().replace(/\s+/g, '');
        // Aceita H-01, H01, h01 etc.; mantém dois dígitos
        const match = s.match(/^H[-_]?(\d{1,2})$/);
        if (match) {
            return `H${match[1].padStart(2, '0')}`;
        }
        // Se vier apenas dígitos (ex.: 1, 01), prefixa H
        const n = s.match(/^(\d{1,2})$/);
        if (n) {
            return `H${n[1].padStart(2, '0')}`;
        }
        // Fallback: remove hífens e tenta novamente
        const cleaned = s.replace(/-/g, '');
        const m2 = cleaned.match(/^H(\d{1,2})$/);
        if (m2) return `H${m2[1].padStart(2, '0')}`;
        return s; // devolve como veio se não reconhecer
    }

    // ================================
    // FUNÇÕES DE TARA E PESOS - TUDO EM GRAMAS
    // ================================
    
    // Obter peso da tara para uma máquina específica (retorna em GRAMAS)
    function getTareWeightForMachine(machine) {
        if (!machine) return 0;
        
        const normalizedMachine = normalizeMachineId(machine);
        const tareWeightKg = window.databaseModule?.tareByMachine?.get(normalizedMachine);
        
        if (!tareWeightKg) return 0;
        
        // Converter kg para gramas - sempre retornar em gramas!
        return Math.round(tareWeightKg * 1000);
    }
    
    // Converter kg para gramas com validação
    function kgToGrams(kg) {
        const num = parseFloat(kg);
        if (!Number.isFinite(num) || num < 0) return 0;
        return Math.round(num * 1000);
    }
    
    // Converter gramas para kg com precisão
    function gramsToKg(grams) {
        const num = parseFloat(grams);
        if (!Number.isFinite(num) || num < 0) return 0;
        return num / 1000;
    }
    
    // Calcular quantidade de peças baseado em peso em gramas
    // Retorna { quantity: número, remainder: gramas restantes, error: null | string }
    function calculateQuantityFromGrams(weightGrams, pieceWeightGrams) {
        const weight = parseFloat(weightGrams) || 0;
        const pieceWeight = parseFloat(pieceWeightGrams) || 0;
        
        if (weight <= 0 || pieceWeight <= 0) {
            return { quantity: 0, remainder: weight, error: 'Peso da peça ou peso total inválido' };
        }
        
        const quantity = Math.floor(weight / pieceWeight);
        const remainder = weight % pieceWeight;
        
        return { 
            quantity: Math.max(0, quantity), 
            remainder: Math.max(0, remainder),
            error: null 
        };
    }
    
    // Calcular peso total esperado para quantidade de peças em gramas
    function calculateExpectedWeightGrams(quantity, pieceWeightGrams) {
        const qty = parseInt(quantity) || 0;
        const pieceWeight = parseFloat(pieceWeightGrams) || 0;
        
        if (qty < 0 || pieceWeight <= 0) return 0;
        
        return qty * pieceWeight;
    }
    
    // Validar consistência: se tem quantidade E peso, verificar se são coerentes
    // Retorna { valid: boolean, message: string, suggestedQty: number }
    function validateWeightQuantityConsistency(weightGrams, quantity, pieceWeightGrams, tolerancePercent = 5) {
        const weight = parseFloat(weightGrams) || 0;
        const qty = parseInt(quantity) || 0;
        const pieceWeight = parseFloat(pieceWeightGrams) || 0;
        
        if (weight <= 0 || qty <= 0 || pieceWeight <= 0) {
            return { valid: true, message: '', suggestedQty: qty };
        }
        
        const expectedWeight = qty * pieceWeight;
        const tolerance = (expectedWeight * tolerancePercent) / 100;
        const difference = Math.abs(weight - expectedWeight);
        
        const suggestedQty = Math.round(weight / pieceWeight);
        
        if (difference > tolerance) {
            return {
                valid: false,
                message: `⚠️ Inconsistência detectada! Peso: ${(weight/1000).toFixed(3)}kg | Peças: ${qty} | Peso esperado: ${(expectedWeight/1000).toFixed(3)}kg | Sugestão: ${suggestedQty} peças`,
                suggestedQty: suggestedQty
            };
        }
        
        return { valid: true, message: '', suggestedQty: qty };
    }
    
    // Configurar campos de tara nos formulários
    function setupTareControls() {
        // Limpar estados antigos na inicialização
        cleanOldTareStates();
        
        // Formulário de produção rápida
        const quickUseTareCheckbox = document.getElementById('quick-production-use-tare');
        const quickTareInfo = document.getElementById('quick-production-tare-info');
        const quickTareWeight = document.getElementById('quick-production-tare-weight');
        
        if (quickUseTareCheckbox) {
            quickUseTareCheckbox.addEventListener('change', function() {
                updateTareDisplay('quick', this.checked);
                // Salvar estado quando mudado
                if (selectedMachineData?.machine) {
                    saveTareState(selectedMachineData.machine, this.checked);
                }
            });
        }
        
        // Formulário de produção manual
        const manualUseTareCheckbox = document.getElementById('manual-production-use-tare');
        const manualTareInfo = document.getElementById('manual-production-tare-info');
        const manualTareWeight = document.getElementById('manual-production-tare-weight');
        
        if (manualUseTareCheckbox) {
            manualUseTareCheckbox.addEventListener('change', function() {
                updateTareDisplay('manual', this.checked);
                // Salvar estado quando mudado
                if (selectedMachineData?.machine) {
                    saveTareState(selectedMachineData.machine, this.checked);
                }
            });
        }
        
        // Formulário de perdas
        const lossesUseTareCheckbox = document.getElementById('quick-losses-use-tare');
        const lossesTareInfo = document.getElementById('quick-losses-tare-info');
        const lossesTareWeight = document.getElementById('quick-losses-tare-weight');
        
        if (lossesUseTareCheckbox) {
            lossesUseTareCheckbox.addEventListener('change', function() {
                updateTareDisplay('losses', this.checked);
                // Salvar estado quando mudado
                if (selectedMachineData?.machine) {
                    saveTareState(selectedMachineData.machine, this.checked);
                }
            });
        }
    }
    
    // Verificar se a máquina tem tara cadastrada
    function machineHasTare(machine) {
        return getTareWeightForMachine(machine) > 0;
    }
    
    // ================================
    // SISTEMA DE PERSISTÊNCIA DA TARA
    // ================================
    
    // Obter data atual no formato YYYY-MM-DD
    function getCurrentDateString() {
        const today = new Date();
        return today.getFullYear() + '-' + 
               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
               String(today.getDate()).padStart(2, '0');
    }
    
    // Salvar estado da tara para uma máquina específica
    function saveTareState(machine, useTare) {
        if (!machine) return;
        
        const dateKey = getCurrentDateString();
        const storageKey = `tare_state_${dateKey}`;
        
        try {
            let tareStates = JSON.parse(localStorage.getItem(storageKey) || '{}');
            tareStates[machine] = {
                useTare: useTare,
                timestamp: Date.now()
            };
            localStorage.setItem(storageKey, JSON.stringify(tareStates));
            
            console.log(`[TARE] Estado salvo para ${machine}: ${useTare}`);
        } catch (error) {
            console.error('[TARE] Erro ao salvar estado:', error);
        }
    }
    
    // Recuperar estado da tara para uma máquina específica
    function loadTareState(machine) {
        if (!machine) return false;
        
        const dateKey = getCurrentDateString();
        const storageKey = `tare_state_${dateKey}`;
        
        try {
            const tareStates = JSON.parse(localStorage.getItem(storageKey) || '{}');
            const machineState = tareStates[machine];
            
            if (machineState && machineState.useTare !== undefined) {
                console.log(`[TARE] Estado recuperado para ${machine}: ${machineState.useTare}`);
                return machineState.useTare;
            }
        } catch (error) {
            console.error('[TARE] Erro ao carregar estado:', error);
        }
        
        return false;
    }
    
    // Limpar estados de tara de dias anteriores (limpeza automática)
    function cleanOldTareStates() {
        try {
            const currentDate = getCurrentDateString();
            const keysToRemove = [];
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('tare_state_') && !key.includes(currentDate)) {
                    keysToRemove.push(key);
                }
            }
            
            keysToRemove.forEach(key => {
                localStorage.removeItem(key);
                console.log(`[TARE] Estado antigo removido: ${key}`);
            });
        } catch (error) {
            console.error('[TARE] Erro na limpeza de estados antigos:', error);
        }
    }
    
    // ================================
    // FUNÇÕES DE USUÁRIOS
    // ================================
    
    // Popular select de usuários ordenados por código (COD)
    // Configura o campo de código do operador com validação em tempo real
    function setupUserCodeInput(inputId) {
        const input = document.getElementById(inputId);
        if (!input) return;
        
        // Verificar se já foi configurado para evitar duplicação de listeners
        if (input.dataset.userCodeSetup === 'true') {
            return;
        }
        input.dataset.userCodeSetup = 'true';
        
        // Adicionar event listener para mostrar o nome enquanto digita
        input.addEventListener('input', function() {
            updateUserNameDisplay(inputId, this.value);
        });
        
        // Também atualizar ao perder o foco (blur)
        input.addEventListener('blur', function() {
            updateUserNameDisplay(inputId, this.value);
        });
        
        console.log(`[USER] Input ${inputId} configurado para validação`);
    }
    
    // Atualiza a exibição do nome do usuário baseado no código digitado
    function updateUserNameDisplay(inputId, userCod) {
        // Mapear o inputId para o elemento de exibição do nome
        const displayIdMap = {
            'quick-production-user': 'quick-production-user-name',
            'quick-losses-user': 'quick-losses-user-name',
            'quick-downtime-user': 'quick-downtime-user-name',
            'manual-production-user': 'manual-production-user-name',
            'manual-losses-user': 'manual-losses-user-name',
            'manual-downtime-user': 'manual-downtime-user-name'
        };
        
        const displayElement = document.getElementById(displayIdMap[inputId]);
        if (!displayElement) return;
        
        if (!userCod || userCod === '') {
            displayElement.textContent = 'Digite o código para ver o nome';
            displayElement.className = 'text-xs text-gray-400 mt-1';
            return;
        }
        
        const user = window.getUserByCode ? window.getUserByCode(parseInt(userCod)) : null;
        if (user) {
            displayElement.textContent = `✅ ${user.nomeUsuario} - ${user.nomeCompleto}`;
            displayElement.className = 'text-xs text-green-600 font-medium mt-1';
        } else {
            displayElement.textContent = '❌ Código não encontrado';
            displayElement.className = 'text-xs text-red-500 mt-1';
        }
    }
    
    // Configura todos os campos de código de usuário nos modais
    function setupAllUserCodeInputs() {
        const userInputIds = [
            'quick-production-user',
            'quick-losses-user',
            'quick-downtime-user',
            'manual-production-user',
            'manual-losses-user',
            'manual-downtime-user'
        ];
        
        userInputIds.forEach(inputId => {
            setupUserCodeInput(inputId);
        });
        
        console.log('[USER] Todos os inputs de código de usuário configurados');
    }
    
    // Mantém compatibilidade - função antiga redirecionada
    function populateUserSelect(selectId) {
        setupUserCodeInput(selectId);
    }
    
    function populateAllUserSelects() {
        setupAllUserCodeInputs();
    }
    
    // ================================
    // SISTEMA DE AUTO-PREENCHIMENTO DE OPERADOR POR ESCALA
    // ================================
    
    /**
     * Busca o operador escalado para uma máquina/turno/data específica
     * @param {string} maquina - Identificador da máquina (ex: "H31", "H15")
     * @param {number} turno - Número do turno (1, 2 ou 3)
     * @param {string} data - Data no formato "YYYY-MM-DD"
     * @returns {Promise<{cod: number, nome: string, user: string}|null>} - Dados do operador ou null
     */
    async function getOperadorEscalado(maquina, turno, data) {
        if (!maquina || !turno || !data) {
            console.log('[ESCALA] Parâmetros inválidos:', { maquina, turno, data });
            return null;
        }
        
        try {
            const db = firebase.firestore();
            
            // Buscar escalas para a data e turno especificados
            const snapshot = await db.collection('escalas_operadores')
                .where('data', '==', data)
                .where('turno', '==', parseInt(turno))
                .get();
            
            if (snapshot.empty) {
                console.log('[ESCALA] Nenhuma escala encontrada para:', { data, turno });
                return null;
            }
            
            // Procurar qual escala contém a máquina especificada
            for (const doc of snapshot.docs) {
                const escala = doc.data();
                const maquinas = escala.maquinas || [];
                
                // Verificar se a máquina está na lista (case-insensitive)
                const maquinaEncontrada = maquinas.some(m => 
                    m.toLowerCase() === maquina.toLowerCase()
                );
                
                if (maquinaEncontrada) {
                    console.log('[ESCALA] Operador encontrado:', {
                        maquina,
                        turno,
                        data,
                        operador: escala.operadorNome,
                        cod: escala.operadorCod
                    });
                    
                    return {
                        cod: escala.operadorCod,
                        nome: escala.operadorNome || escala.operadorUser,
                        user: escala.operadorUser
                    };
                }
            }
            
            console.log('[ESCALA] Máquina não encontrada em nenhuma escala:', maquina);
            return null;
            
        } catch (error) {
            console.error('[ESCALA] Erro ao buscar operador escalado:', error);
            return null;
        }
    }
    
    /**
     * Obtém o turno atual baseado na hora
     * @returns {number} - Número do turno (1, 2 ou 3)
     */
    function getTurnoAtual() {
        const now = new Date();
        const hour = now.getHours();
        const min = now.getMinutes();
        
        // Turno 1: 06:30 - 14:59
        if ((hour === 6 && min >= 30) || (hour >= 7 && hour < 15)) return 1;
        // Turno 2: 15:00 - 23:19
        if (hour >= 15 && (hour < 23 || (hour === 23 && min < 20))) return 2;
        // Turno 3: 23:20 - 06:29
        return 3;
    }
    
    /**
     * Obtém a data de produção atual (considera que antes das 7h é do dia anterior)
     * @returns {string} - Data no formato "YYYY-MM-DD"
     */
    function getDataProducaoAtual() {
        const now = new Date();
        const hour = now.getHours();
        const minute = now.getMinutes();
        
        // Se for antes das 6h30, pertence ao dia de trabalho anterior
        if (hour < 6 || (hour === 6 && minute < 30)) {
            const prevDay = new Date(now);
            prevDay.setDate(prevDay.getDate() - 1);
            return new Date(prevDay.getTime() - (prevDay.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
        }
        
        return new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
    }
    
    /**
     * Auto-preenche o campo de código de operador baseado na escala da máquina selecionada
     * @param {string} inputId - ID do campo de input do código do operador
     * @param {string} maquina - Identificador da máquina (ex: "H31")
     * @param {number} turno - Turno (opcional, usa atual se não informado)
     * @param {string} data - Data (opcional, usa atual se não informado)
     */
    async function autoPreencherOperadorPorEscala(inputId, maquina, turno = null, data = null) {
        const input = document.getElementById(inputId);
        if (!input) {
            console.log('[ESCALA] Input não encontrado:', inputId);
            return;
        }
        
        // Usar turno e data atuais se não informados
        const turnoEfetivo = turno || getTurnoAtual();
        const dataEfetiva = data || getDataProducaoAtual();
        
        console.log('[ESCALA] Buscando operador para:', { maquina, turno: turnoEfetivo, data: dataEfetiva });
        
        // Mostrar estado de carregamento
        updateUserNameDisplay(inputId, '');
        const displayMap = {
            'quick-production-user': 'quick-production-user-name',
            'quick-losses-user': 'quick-losses-user-name',
            'quick-downtime-user': 'quick-downtime-user-name',
            'manual-production-user': 'manual-production-user-name',
            'manual-losses-user': 'manual-losses-user-name',
            'manual-downtime-user': 'manual-downtime-user-name'
        };
        const displayEl = document.getElementById(displayMap[inputId]);
        if (displayEl) {
            displayEl.textContent = '🔍 Buscando operador na escala...';
            displayEl.className = 'text-xs text-blue-500 mt-1';
        }
        
        try {
            const operador = await getOperadorEscalado(maquina, turnoEfetivo, dataEfetiva);
            
            if (operador && operador.cod) {
                // Preencher automaticamente o código
                input.value = operador.cod;
                
                // Atualizar exibição do nome
                if (displayEl) {
                    displayEl.textContent = `✅ ${operador.user || operador.nome} (Escala: ${maquina} - T${turnoEfetivo})`;
                    displayEl.className = 'text-xs text-green-600 font-medium mt-1';
                }
                
                // Marcar que foi preenchido automaticamente
                input.dataset.autoPreenchido = 'true';
                input.dataset.escalaMaquina = maquina;
                input.dataset.escalaTurno = turnoEfetivo;
                
                console.log('[ESCALA] Operador auto-preenchido:', operador);
            } else {
                // Nenhum operador escalado - limpar e permitir digitação manual
                input.value = '';
                input.dataset.autoPreenchido = 'false';
                
                if (displayEl) {
                    displayEl.textContent = '⚠️ Nenhum operador escalado - digite o código manualmente';
                    displayEl.className = 'text-xs text-amber-600 mt-1';
                }
                
                console.log('[ESCALA] Nenhum operador encontrado na escala');
            }
        } catch (error) {
            console.error('[ESCALA] Erro ao auto-preencher operador:', error);
            
            if (displayEl) {
                displayEl.textContent = '❌ Erro ao buscar escala - digite o código manualmente';
                displayEl.className = 'text-xs text-red-500 mt-1';
            }
        }
    }
    
    // Expor funções para uso global
    window.getOperadorEscalado = getOperadorEscalado;
    window.autoPreencherOperadorPorEscala = autoPreencherOperadorPorEscala;
    window.getTurnoAtual = getTurnoAtual;
    window.getDataProducaoAtual = getDataProducaoAtual;
    
    // Carregar estado persistente da tara para todos os formulários
    function loadTareStateForAllForms(machine) {
        if (!machine) return;
        
        const savedState = loadTareState(machine);
        const hasTare = machineHasTare(machine);
        
        // Aplicar estado salvo apenas se a máquina tem tara cadastrada
        if (hasTare && savedState) {
            const formTypes = ['quick-production', 'manual-production', 'quick-losses'];
            
            formTypes.forEach(formType => {
                const checkbox = document.getElementById(`${formType}-use-tare`);
                if (checkbox) {
                    checkbox.checked = savedState;
                    console.log(`[TARE] Estado restaurado para ${formType}: ${savedState}`);
                }
            });
        }
    }
    
    // Atualizar exibição das informações de tara
    function updateTareDisplay(formType, useTare) {
        // Determinar IDs corretos baseado no tipo de formulário
        const isLosses = formType === 'losses';
        const prefix = isLosses ? 'quick-losses' : `${formType}-production`;
        
        const tareCheckbox = document.getElementById(`${prefix}-use-tare`);
        const tareInfo = document.getElementById(`${prefix}-tare-info`);
        const tareWeightSpan = document.getElementById(`${prefix}-tare-weight`);
        
        if (!tareInfo || !tareWeightSpan || !tareCheckbox) return;
        
        // Mostrar/esconder checkbox baseado na disponibilidade de tara
        const hasTare = selectedMachineData?.machine && machineHasTare(selectedMachineData.machine);
        const tareContainer = tareCheckbox.closest('div');
        
        if (tareContainer) {
            if (hasTare) {
                tareContainer.style.display = 'block';
            } else {
                tareContainer.style.display = 'none';
                tareCheckbox.checked = false;
                useTare = false;
            }
        }
        
        if (useTare && hasTare) {
            const tareWeightGrams = getTareWeightForMachine(selectedMachineData.machine);
            // Exibir em gramas (getTareWeightForMachine retorna gramas)
            tareWeightSpan.textContent = `${tareWeightGrams}`;
            tareInfo.classList.remove('hidden');
        } else {
            tareInfo.classList.add('hidden');
        }
    }

    // Lista de máquinas padronizada via database.js quando disponível
    const machineList = (window.databaseModule && window.databaseModule.machineDatabase)
        ? window.databaseModule.machineDatabase.map(m => normalizeMachineId(m.id))
        : [
            "H01", "H02", "H03", "H04", "H05", "H06", "H07", "H08", "H09", "H10",
            "H12", "H13", "H14", "H15", "H16", "H17", "H18", "H19", "H20",
            "H26", "H27", "H28", "H29", "H30", "H31", "H32"
        ];

    // Base de dados de máquinas com seus modelos (usa database.js se disponível)
    const machineDatabase = (window.databaseModule && window.databaseModule.machineDatabase) ? window.databaseModule.machineDatabase : [
        { id: "H-01", model: "SANDRETTO OTTO" },
        { id: "H-02", model: "SANDRETTO SERIE 200" },
        { id: "H-03", model: "LS LTE280" },
        { id: "H-04", model: "LS LTE 330" },
        { id: "H-05", model: "LS LTE 170" },
        { id: "H-06", model: "HAITIAN MA2000" },
        { id: "H-07", model: "CHEN HSONG JM 178 A" },
        { id: "H-08", model: "REED 200 TG II" },
        { id: "H-09", model: "REED 200 TG II" },
        { id: "H-10", model: "HAITIAN MA 3200" },
        { id: "H-11", model: "ROMI 300 TGR" },
        { id: "H-12", model: "BORCHE BH 120" },
        { id: "H-13", model: "HAITIAN MA 2000 770G" },
        { id: "H-14", model: "SANDRETTO SB UNO" },
        { id: "H-15", model: "ROMI EN 260 CM 10" },
        { id: "H-16", model: "HAITIAN MA 2000 III" },
        { id: "H-17", model: "ROMI EN 260 CM 10" },
        { id: "H-18", model: "HAITIAN MA 2000 III" },
        { id: "H-19", model: "HAITIAN MA 2000 III" },
        { id: "H-20", model: "HAITIAN PL 200J" },
        { id: "H-26", model: "ROMI PRIMAX CM9" },
        { id: "H-27", model: "ROMI PRIMAX CM8" },
        { id: "H-28", model: "ROMI PRIMAX CM8" },
        { id: "H-29", model: "ROMI PRIMAX CM8" },
        { id: "H-30", model: "ROMI PRIMAX CM8" },
        { id: "H-31", model: "ROMI PRÁTICA CM8" },
        { id: "H-32", model: "ROMI PRÁTICA CM8" }
    ];

    // Motivos de Refugo e Parada: preferir database.js se disponível (senão usa fallback agrupado)
    // Observação: o app usa funções getGrouped* abaixo para popular selects/relatórios

    const preparadores = ['Daniel', 'João', 'Luis', 'Manaus', 'Rafael', 'Stanley', 'Wagner', 'Yohan'].sort();

    /**
     * Função helper para buscar produto por código com fallback seguro
     * Evita erros de "Cannot read properties of undefined"
     * @param {string|number} code - Código do produto
     * @returns {object|null} - Produto encontrado ou null
     */
    function getProductByCode(code) {
        if (!code && code !== 0) return null;
        
        const numericCode = Number(code);
        const stringCode = String(code).trim();
        let product = null;

        // 1. Tentar via window.productByCode (exposto diretamente pelo database.js)
        if (window.productByCode instanceof Map && window.productByCode.size > 0) {
            product = window.productByCode.get(numericCode) || window.productByCode.get(stringCode);
            if (product) return product;
        }

        // 2. Tentar via window.databaseModule.productByCode
        const moduleIndex = window.databaseModule?.productByCode;
        if (moduleIndex instanceof Map && moduleIndex.size > 0) {
            product = moduleIndex.get(numericCode) || moduleIndex.get(stringCode);
            if (product) return product;
        }

        // 3. Fallback: window.productDatabase (exposto diretamente pelo database.js)
        if (Array.isArray(window.productDatabase) && window.productDatabase.length > 0) {
            product = window.productDatabase.find(p => Number(p.cod) === numericCode || String(p.cod) === stringCode);
            if (product) return product;
        }

        // 4. Fallback: buscar no array do databaseModule
        const dbArray = window.databaseModule?.productDatabase;
        if (Array.isArray(dbArray) && dbArray.length > 0) {
            product = dbArray.find(p => Number(p.cod) === numericCode || String(p.cod) === stringCode);
            if (product) return product;
        }

        // Debug: logar se não encontrou
        console.warn(`[getProductByCode] Produto ${code} não encontrado. Status:`, {
            windowProductByCodeSize: window.productByCode?.size || 0,
            windowProductDatabaseLength: window.productDatabase?.length || 0,
            databaseModuleExists: !!window.databaseModule
        });

        return null;
    }
    
    // Global Variables
    let currentAnalysisView = 'resumo';
    let docIdToDelete = null;
    let collectionToDelete = null;
    let fullDashboardData = { perdas: [] };
    let paretoChartInstance, productionTimelineChartInstance, oeeByShiftChartInstance, oeeTrendChartInstance;
    const gaugeChartInstances = {};
    const gaugeChartStyles = {
        'availability-gauge': {
            color: '#10B981',
            warningColor: '#F59E0B',
            dangerColor: '#EF4444'
        },
        'performance-gauge': {
            color: '#3B82F6',
            warningColor: '#8B5CF6',
            dangerColor: '#EF4444'
        },
        'quality-gauge': {
            color: '#F59E0B',
            warningColor: '#F97316',
            dangerColor: '#EF4444'
        }
    };
    const DEFAULT_DONUT_COLORS = ['#10B981', '#3B82F6', '#F97316', '#8B5CF6', '#F59E0B', '#EC4899', '#14B8A6', '#EF4444'];
    let currentReportData = [];
    
    // Variáveis do novo painel de lançamento
    let selectedMachineData = null;
    let hourlyChartInstance = null;
    let opChartInstance = null;
    // Evitar concorrência/reentrncia na atualização dos gráficos de Lançamento
    let isRefreshingLaunchCharts = false;
    let analysisHourlyChartInstance = null;
    let machineProductionTimelineInstance = null;
    let productionTimer = null;
    let productionTimerBaseSeconds = 0;
    let productionTimerResumeTimestamp = null;
    let currentDowntimeStart = null;
    let downtimeTimer = null;
    let downtimeNotificationSent = false;
    let machineStatus = 'running'; // 'running' ou 'stopped'
    let recentEntriesCache = new Map();
    let allRecentEntries = []; // Armazenar todas as entradas para filtro
    let currentEntryFilter = 'all'; // Filtro atual: 'all', 'production', 'downtime', 'loss'
    let currentEditContext = null;
    let machineCardData = {};
    const machineCardCharts = {};
    let activeMachineCard = null;
    let ajustesPageInitialized = false;
    let pilotTabInitialized = false;
    let isSubmittingPilotReport = false;

    // Timer para atualização automática de paradas longas (a cada 30 minutos)
    let extendedDowntimeUpdateTimer = null;
    const EXTENDED_DOWNTIME_UPDATE_INTERVAL = 30 * 60 * 1000; // 30 minutos em ms

    // Flags de configuração
    const QUALITY_AUTOFILL_ENABLED = false;
    const PIECE_WEIGHT_TOLERANCE_PERCENT = 1;

    // Estados auxiliares
    let quickProductionUpdateFeedback = null;

    function parseWeightInputToGrams(value) {
        if (value === undefined || value === null || value === '') return 0;
        let numValue = parseFloat(String(value).replace(',', '.'));
        if (!Number.isFinite(numValue) || numValue <= 0) return 0;
        // Entrada é sempre em GRAMAS - não faz mais conversão automática
        return Math.round(numValue);
    }

    function parsePieceWeightInput(value) {
        // Parser específico para peso da peça no planejamento
        // Admite que o usuário pode digitar em gramas (como 0,194 ou 194)
        // NÃO converte valores para evitar ambiguidade
        if (value === undefined || value === null || value === '') return 0;
        const normalized = typeof normalizeNumericString === 'function' 
            ? normalizeNumericString(value)
            : String(value).replace(',', '.');
        const parsed = parseFloat(normalized);
        if (!Number.isFinite(parsed) || parsed <= 0) return 0;
        // Retornar como-está (assumir que já está em gramas)
        return parsed;
    }

    function parsePieceWeightGrams(value) {
        if (value === undefined || value === null || value === '') return 0;
        const parsed = parseFloat(value);
        if (!Number.isFinite(parsed) || parsed <= 0) return 0;
        // Retornar diretamente - espera-se que o valor já esteja em GRAMAS
        return parsed;
    }

    function resolvePieceWeightGrams(...sources) {
        for (const source of sources) {
            const grams = parsePieceWeightGrams(source);
            if (grams > 0) {
                return grams;
            }
        }
        return 0;
    }

    function getPlanPieceWeightInfo(machineData = selectedMachineData) {
        const latestMeasured = parsePieceWeightGrams(machineData?.latest_piece_weight_grams);
        if (latestMeasured > 0) {
            return {
                grams: latestMeasured,
                source: 'quality_release',
                label: 'Última liberação da qualidade',
                updatedAt: machineData?.latest_piece_weight_updated_at || null,
                updatedBy: machineData?.latest_piece_weight_user || null
            };
        }

        const planningWeight = resolvePieceWeightGrams(
            machineData?.piece_weight_grams,
            machineData?.piece_weight,
            machineData?.weight,
            machineData?.produto?.weight
        );
        if (planningWeight > 0) {
            return {
                grams: planningWeight,
                source: 'planning',
                label: 'Peso planejado',
                updatedAt: null,
                updatedBy: null
            };
        }

        return { grams: 0, source: 'undefined', label: 'Indefinido', updatedAt: null, updatedBy: null };
    }

    function formatPieceWeightInfo(info) {
        if (!info || !info.grams) return 'Peso da peça não definido';
        const parts = [`${(info.grams).toFixed(3)} g`];
        if (info.source === 'quality_release') {
            parts.push('(Qualidade)');
        } else if (info.source === 'planning') {
            parts.push('(Planejamento)');
        }
        return parts.join(' ');
    }

    function getCatalogPieceWeight(machineData = selectedMachineData) {
        if (!machineData) {
            return 0;
        }

        const codeCandidates = [
            machineData.product_cod,
            machineData.product_code,
            machineData.part_code,
            machineData.cod,
            machineData.codigo
        ];

        for (const candidate of codeCandidates) {
            if (candidate === undefined || candidate === null || candidate === '') continue;
            const catalogEntry = getProductByCode(candidate);
            if (catalogEntry && catalogEntry.weight !== undefined && catalogEntry.weight !== null) {
                let weightGrams = parseFloat(catalogEntry.weight);
                if (Number.isFinite(weightGrams) && weightGrams > 0) {
                    // Se o peso for menor que 1, considerar como MILIGRAMAS e converter para gramas
                    // Ex: 0.19 no database = 0.19mg = 0.00019g (mas na verdade queremos 0.19g)
                    // Ajuste: valores < 1 já estão em gramas, não precisa converter
                    // Valores >= 1 também estão em gramas
                    // O database.js usa gramas como unidade padrão
                    return weightGrams;
                }
            }
        }

        return 0;
    }

    function getActivePieceWeightGrams(machineData = selectedMachineData) {
        if (!machineData) return 0;

        // Buscar peso do catálogo para comparação/validação
        const catalogWeight = getCatalogPieceWeight(machineData);

        const planInfo = getPlanPieceWeightInfo(machineData);
        if (planInfo.grams > 0) {
            // Se o catálogo tem peso e o planejamento tem peso muito diferente,
            // preferir o catálogo (pode ser erro de unidade no planejamento)
            if (catalogWeight > 0 && planInfo.grams > catalogWeight * 100) {
                console.warn(`[PESO] Peso do planejamento (${planInfo.grams}g) parece muito alto comparado ao catálogo (${catalogWeight}g). Usando catálogo.`);
                return catalogWeight;
            }
            return planInfo.grams;
        }

        const fallbackWeight = resolvePieceWeightGrams(
            machineData.latest_piece_weight_grams,
            machineData.latest_piece_weight,
            machineData.piece_weight_grams,
            machineData.piece_weight,
            machineData.weight,
            machineData.produto?.piece_weight,
            machineData.produto?.peso_unitario,
            machineData.produto?.weight,
            machineData.product?.piece_weight,
            machineData.product?.peso_unitario,
            machineData.product?.weight,
            machineData.order?.piece_weight,
            machineData.order?.peso_unitario,
            machineData.mp_weight
        );
        if (fallbackWeight > 0) {
            // Mesma validação para fallback
            if (catalogWeight > 0 && fallbackWeight > catalogWeight * 100) {
                console.warn(`[PESO] Peso fallback (${fallbackWeight}g) parece muito alto comparado ao catálogo (${catalogWeight}g). Usando catálogo.`);
                return catalogWeight;
            }
            return fallbackWeight;
        }

        if (catalogWeight > 0) {
            return catalogWeight;
        }

        return 0;
    }

    function updateQuickProductionPieceWeightUI({ forceUpdateInput = false } = {}) {
        const info = getPlanPieceWeightInfo();
        const sourceLabel = document.getElementById('quick-production-weight-source');
        const historyInfo = document.getElementById('quick-production-weight-history');

        if (sourceLabel) {
            sourceLabel.textContent = formatPieceWeightInfo(info);
        }

        if (historyInfo) {
            if (info.updatedAt) {
                const updatedDate = typeof info.updatedAt.toDate === 'function'
                    ? info.updatedAt.toDate()
                    : new Date(info.updatedAt);
                historyInfo.textContent = `Atualizado em ${updatedDate.toLocaleString('pt-BR')} por ${info.updatedBy || 'Qualidade'}`;
                historyInfo.classList.remove('hidden');
            } else {
                historyInfo.textContent = '';
                historyInfo.classList.add('hidden');
            }
        }

        if (typeof quickProductionUpdateFeedback === 'function') {
            quickProductionUpdateFeedback();
        }
    }

    let cachedProductionDataset = {
        productionData: [],
        planData: [],
        startDate: null,
        endDate: null,
        shift: 'all',
        machine: 'all'
    };
    let productionRateMode = 'day';

    // Variáveis globais para análise
    let machines = [];
    let currentAnalysisFilters = {};

    let productionOrdersCache = [];
    let filteredProductionOrders = [];
    let currentSelectedOrderForAnalysis = null;
    let currentActiveOrder = null;
    let currentOrderProgress = { executed: 0, planned: 0, expected: 0 };

    // DOM Element Selectors
    const navButtons = document.querySelectorAll('.nav-btn');
    const pageContents = document.querySelectorAll('.page-content');
    const pageTitle = document.getElementById('page-title');
    const confirmModal = document.getElementById('confirm-modal');
    
    const sidebar = document.getElementById('sidebar');
    const sidebarOpenBtn = document.getElementById('sidebar-open-btn');
    const sidebarCloseBtn = document.getElementById('sidebar-close-btn');
    const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
    const sidebarOverlay = document.getElementById('sidebar-overlay');

    const planningDateSelector = document.getElementById('planning-date-selector');
    const planningForm = document.getElementById('planning-form');
    const planningOrderSelect = document.getElementById('planning-order-select');
    const planningOrderSearch = document.getElementById('planning-order-search');
    const planningOrderResults = document.getElementById('planning-order-results');
    const planningOrderSearchLoading = document.getElementById('planning-order-search-loading');
    const planningOrderInfo = document.getElementById('planning-order-info');
    const planningTableBody = document.getElementById('planning-table-body');
    const planningMachineSelect = document.getElementById('planning-machine');
    const planningMpInput = document.getElementById('planning-mp');
    const leaderLaunchPanel = document.getElementById('leader-launch-panel');
    const leaderModal = document.getElementById('leader-entry-modal');
    const leaderModalForm = document.getElementById('leader-entry-form');
    const leaderModalTitle = document.getElementById('leader-modal-title');
    
    const launchPanelContainer = document.getElementById('launch-panel-container');
    const productionModal = document.getElementById('production-entry-modal');
    const productionModalForm = document.getElementById('production-entry-form');
    const productionModalTitle = document.getElementById('production-modal-title');
    // Elementos do novo painel de lançamento
    const machineSelector = document.getElementById('machine-selector');
    const machineCardGrid = document.getElementById('machine-card-grid');
    const machineCardEmptyState = document.getElementById('machine-card-empty');
    const productionControlPanel = document.getElementById('production-control-panel');
    const hourlyProductionChart = document.getElementById('hourly-production-chart');
    const opProductionChart = document.getElementById('op-production-chart');
    const launchChartModeHourlyBtn = document.getElementById('launch-chart-mode-hourly');
    const launchChartModeOpBtn = document.getElementById('launch-chart-mode-op');
    let launchChartMode = 'hourly'; // 'hourly' | 'op'
    const analysisHourlyProductionChart = document.getElementById('analysis-hourly-production-chart');
    const analysisMachineProductionTimelineChart = document.getElementById('analysis-machine-production-timeline');
    const currentShiftDisplay = document.getElementById('current-shift-display');
    const machineIcon = document.getElementById('machine-icon');
    const machineName = document.getElementById('machine-name');
    const productName = document.getElementById('product-name');
    const productMp = document.getElementById('product-mp');
    const finalizeOrderBtn = document.getElementById('finalize-order-btn');
    const activateOrderBtn = document.getElementById('activate-order-btn');
    const shiftTarget = document.getElementById('shift-target');
    const productionTimeDisplay = document.getElementById('production-time');
    const producedToday = document.getElementById('produced-today');
    const efficiencyToday = document.getElementById('efficiency-today');
    const lossesToday = document.getElementById('losses-today');
    const downtimeToday = document.getElementById('downtime-today');
    const recentEntriesList = document.getElementById('recent-entries-list');
    const recentEntriesLoading = document.getElementById('recent-entries-loading');
    const recentEntriesEmpty = document.getElementById('recent-entries-empty');
    const refreshRecentEntriesBtn = document.getElementById('refresh-recent-entries');

    // Elementos da aba Teste Piloto
    const pilotReportForm = document.getElementById('pilot-report-form');
    const pilotReportDateInput = document.getElementById('pilot-report-date');
    const pilotReportTitleInput = document.getElementById('pilot-report-title');
    const pilotReportDescriptionInput = document.getElementById('pilot-report-description');
    const pilotReportStatus = document.getElementById('pilot-report-status');
    const pilotReportList = document.getElementById('pilot-report-list');
    const pilotReportEmpty = document.getElementById('pilot-report-empty');
    const pilotReportLoading = document.getElementById('pilot-report-loading');
    const pilotFilterDateInput = document.getElementById('pilot-filter-date');
    const pilotRefreshBtn = document.getElementById('pilot-refresh-btn');
    const pilotReportUserDisplay = document.getElementById('pilot-report-user-display');
    const pilotReportSubmitBtn = document.getElementById('pilot-report-submit');

    // Elementos da aba de Ordens de Produção
    const productionOrderForm = document.getElementById('production-order-form');
    const productionOrderStatusMessage = document.getElementById('production-order-status-message');
    const productionOrderTableBody = document.getElementById('production-order-table-body');
    const productionOrderEmptyState = document.getElementById('production-order-empty');
    const productionOrderCodeInput = document.getElementById('order-part-code');
    const productionOrderCodeDatalist = document.getElementById('order-product-code-list');
    const productionOrderFeedback = document.getElementById('order-product-feedback');
    const productionOrderProductInput = document.getElementById('order-product');
    const productionOrderCustomerInput = document.getElementById('order-customer');
    const productionOrderRawMaterialInput = document.getElementById('order-raw-material');

    // Elementos da aba de Qualidade
    const qualityPlanSelect = document.getElementById('quality-plan-select');
    const qualityDateInput = document.getElementById('quality-date');
    const qualityLoadBtn = document.getElementById('quality-load-btn');
    const qualityStatusMessage = document.getElementById('quality-status-message');
    const qualityInfoGrid = document.getElementById('quality-info-grid');
    const qualitySummaryCards = document.getElementById('quality-summary-cards');
    const qualityOperatorsChip = document.getElementById('quality-operators-chip');
    const qualityShiftTbody = document.getElementById('quality-shift-tbody');
    const qualityShiftEmpty = document.getElementById('quality-shift-empty');
    const qualityHourlyTableBody = document.getElementById('quality-hourly-tbody');
    const qualityHourlyEmpty = document.getElementById('quality-hourly-empty');
    const qualityHourlyTotal = document.getElementById('quality-hourly-total');
    const qualityHourlyContainer = document.getElementById('quality-hourly-container');
    const qualityDowntimeList = document.getElementById('quality-downtime-list');
    const qualityDowntimeEmpty = document.getElementById('quality-downtime-empty');
    const qualityDowntimeTotal = document.getElementById('quality-downtime-total');
    const qualityProcessForm = document.getElementById('quality-process-form');
    const qualityChecklistStatus = document.getElementById('quality-checklist-status');
    const qualityResponsavelInput = document.getElementById('quality-responsavel');
    const qualityNotesInput = document.getElementById('quality-notes');
    const qualityActionsInput = document.getElementById('quality-actions');
    const qualityHistoryList = document.getElementById('quality-history-list');
    const qualityHistoryEmpty = document.getElementById('quality-history-empty');
    const qualityHistoryChip = document.getElementById('quality-history-chip');
    const qualityContextContainer = document.getElementById('quality-context-container');

    // Filtros da aba de Ordens de Produção
    const ordersFilterMachine = document.getElementById('orders-filter-machine');
    const ordersFilterStatus = document.getElementById('orders-filter-status');
    const ordersFilterSearch = document.getElementById('orders-filter-search');
    
    // Elementos da aba Ajustes (restrita)
    const ajustesPage = document.getElementById('ajustes-page');
    const ajustesSearchForm = document.getElementById('ajustes-search-form');
    const ajustesCollectionSelect = document.getElementById('ajustes-collection');
    const ajustesDocIdInput = document.getElementById('ajustes-doc-id');
    const ajustesMachineInput = document.getElementById('ajustes-machine');
    const ajustesWorkdayInput = document.getElementById('ajustes-workday');
    const ajustesRefreshBtn = document.getElementById('ajustes-refresh-btn');
    const ajustesSearchStatus = document.getElementById('ajustes-search-status');
    const ajustesResultsBody = document.getElementById('ajustes-results-body');
    const ajustesEditForm = document.getElementById('ajustes-edit-form');
    const ajustesEditId = document.getElementById('ajustes-edit-id');
    const ajustesEditCollection = document.getElementById('ajustes-edit-collection');
    const ajustesEditOriginal = document.getElementById('ajustes-edit-original');
    const ajustesEditMachine = document.getElementById('ajustes-edit-machine');
    const ajustesEditDate = document.getElementById('ajustes-edit-date');
    const ajustesEditExecuted = document.getElementById('ajustes-edit-executed');
    const ajustesEditPlanned = document.getElementById('ajustes-edit-planned');
    const ajustesEditLossesKg = document.getElementById('ajustes-edit-losses-kg');
    const ajustesEditLossesPcs = document.getElementById('ajustes-edit-losses-pcs');
    const ajustesEditNotes = document.getElementById('ajustes-edit-notes');
    const ajustesEditStatus = document.getElementById('ajustes-edit-status');
    const ajustesCancelBtn = document.getElementById('ajustes-cancel-btn');
    const ajustesLogBody = document.getElementById('ajustes-log-body');

    const AJUSTES_DEFAULT_LIMIT = 25;
    const AJUSTES_LOG_COLLECTION = 'ajustes_logs';
    const AJUSTES_COLLECTIONS = {
        production_entries: {
            key: 'production_entries',
            collection: 'production_entries',
            label: 'Produção Executada',
            machineField: 'machine',
            altMachineFields: ['machine_id', 'maquina'],
            dateFields: ['workDay', 'data'],
            turnoField: 'turno',
            executedField: 'produzido',
            lossesKgField: 'refugo_kg',
            lossesPcsField: 'refugo_qty',
            plannedField: null,
            orderCandidates: ['timestamp', 'createdAt', 'dataHoraInformada'],
            supportsEditing: true,
            editorConfig: { executed: true, planned: false, lossesKg: true, lossesPcs: true },
            fieldLabels: {
                produzido: 'Quantidade executada',
                refugo_kg: 'Perdas (kg)',
                refugo_qty: 'Perdas (peças)'
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.perdas) parts.push(`Motivo: ${data.perdas}`);
                if (data.observacoes) parts.push(data.observacoes);
                if (data.manual) parts.push('Origem: Manual');
                if (data.horaInformada) parts.push(`Hora ${data.horaInformada}`);
                return parts.filter(Boolean).join(' – ') || 'Lançamento de produção';
            }
        },
        losses: {
            key: 'losses',
            collection: 'production_entries',
            label: 'Perdas Registradas',
            machineField: 'machine',
            altMachineFields: ['machine_id', 'maquina'],
            dateFields: ['workDay', 'data'],
            turnoField: 'turno',
            executedField: 'produzido',
            lossesKgField: 'refugo_kg',
            lossesPcsField: 'refugo_qty',
            plannedField: null,
            orderCandidates: ['timestamp', 'createdAt', 'dataHoraInformada'],
            supportsEditing: true,
            editorConfig: { executed: true, planned: false, lossesKg: true, lossesPcs: true },
            fieldLabels: {
                produzido: 'Quantidade executada',
                refugo_kg: 'Perdas (kg)',
                refugo_qty: 'Perdas (peças)'
            },
            filter: (data) => {
                const lossesKg = Number(data?.refugo_kg) || 0;
                const lossesQty = Number(data?.refugo_qty) || 0;
                return lossesKg > 0 || lossesQty > 0 || Boolean((data?.perdas || '').trim());
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.perdas) parts.push(`Motivo: ${data.perdas}`);
                if (data.observacoes) parts.push(data.observacoes);
                if (data.manual) parts.push('Origem: Manual');
                return parts.filter(Boolean).join(' – ') || 'Registro de perda';
            }
        },
        planning: {
            key: 'planning',
            collection: 'planning',
            label: 'Planejamento',
            machineField: 'machine',
            dateFields: ['date'],
            turnoField: null,
            executedField: null,
            lossesKgField: null,
            lossesPcsField: null,
            plannedField: 'planned_quantity',
            orderCandidates: ['updatedAt', 'createdAt'],
            supportsEditing: true,
            editorConfig: { executed: false, planned: true, lossesKg: false, lossesPcs: false },
            fieldLabels: {
                planned_quantity: 'Planejado (un)'
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.product) parts.push(`Produto: ${data.product}`);
                if (data.client) parts.push(`Cliente: ${data.client}`);
                if (data.order_number) parts.push(`OP ${data.order_number}`);
                return parts.filter(Boolean).join(' – ') || 'Item do planejamento';
            }
        },
        production_orders: {
            key: 'production_orders',
            collection: 'production_orders',
            label: 'Ordens de Produção',
            machineField: 'machine_id',
            altMachineFields: ['machine', 'machineId'],
            dateFields: ['planned_start', 'createdAt'],
            turnoField: null,
            executedField: null,
            lossesKgField: null,
            lossesPcsField: null,
            plannedField: 'lot_size',
            orderCandidates: ['updatedAt', 'createdAt'],
            supportsEditing: false,
            editorConfig: { executed: false, planned: false, lossesKg: false, lossesPcs: false },
            fieldLabels: {
                lot_size: 'Quantidade planejada'
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.product) parts.push(`Produto: ${data.product}`);
                if (data.status) parts.push(`Status: ${data.status}`);
                if (data.customer) parts.push(`Cliente: ${data.customer}`);
                return parts.filter(Boolean).join(' – ') || 'Ordem de produção';
            }
        },
        downtime_entries: {
            key: 'downtime_entries',
            collection: 'downtime_entries',
            label: 'Paradas',
            machineField: 'machine',
            dateFields: ['date'],
            turnoField: null,
            executedField: null,
            lossesKgField: null,
            lossesPcsField: null,
            plannedField: null,
            orderCandidates: ['createdAt'],
            supportsEditing: false,
            editorConfig: { executed: false, planned: false, lossesKg: false, lossesPcs: false },
            fieldLabels: {},
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.reason) parts.push(`Motivo: ${data.reason}`);
                if (data.observations) parts.push(data.observations);
                if (data.startTime && data.endTime) parts.push(`${data.startTime} - ${data.endTime}`);
                return parts.filter(Boolean).join(' – ') || 'Registro de parada';
            }
        }
    };

    let currentAjustesResults = [];
    let lastAjustesFilters = null;
    let ajustesSearchInFlight = false;

    // Elementos de controle de processos (tabelas de turno)
    const qualityProcessHeader = document.getElementById('quality-process-header');
    const qualityHeaderProduct = document.getElementById('quality-header-product');
    const qualityHeaderMachine = document.getElementById('quality-header-machine');
    const qualityHeaderOrder = document.getElementById('quality-header-order');
    const qualityProcessTables = document.getElementById('quality-process-tables');
    const qualityObservationsSection = document.getElementById('quality-observations-section');
    const qualityProcessEmpty = document.getElementById('quality-process-empty');
    
    // Elementos de controle de preenchimento
    const qualityControlBar = document.getElementById('quality-control-bar');
    const qualityAutoFillBtn = document.getElementById('quality-auto-fill-btn');
    const qualityManualClearBtn = document.getElementById('quality-manual-clear-btn');
    const qualityClearAllBtn = document.getElementById('quality-clear-all-btn');
    const qualityPrintBtn = document.getElementById('quality-print-btn');
    
    // Elementos de observações
    const qualityProdObsTime = document.getElementById('quality-prod-obs-time');
    const qualityProdObsText = document.getElementById('quality-prod-obs-text');
    const qualityProdObsSave = document.getElementById('quality-prod-obs-save');
    const qualityProdObsList = document.getElementById('quality-prod-obs-list');
    const qualityQualObsTime = document.getElementById('quality-qual-obs-time');
    const qualityQualObsText = document.getElementById('quality-qual-obs-text');
    const qualityQualObsSave = document.getElementById('quality-qual-obs-save');
    const qualityQualObsList = document.getElementById('quality-qual-obs-list');

    // Elementos de dados dinmicos da qualidade
    const qualityCavitiesDisplay = document.getElementById('quality-cavities-display');
    const qualityCavitiesInput = document.getElementById('quality-cavities-input');
    const qualityBagNumberDisplay = document.getElementById('quality-bag-number-display');
    const qualityBagNumberInput = document.getElementById('quality-bag-number-input');
    const qualityCycleDisplay = document.getElementById('quality-cycle-display');
    const qualityCycleInput = document.getElementById('quality-cycle-input');
    const qualityLastMeasurementDisplay = document.getElementById('quality-last-measurement-display');
    const qualityOkCavitiesCheckbox = document.getElementById('quality-ok-cavities');
    const qualityOkCycleCheckbox = document.getElementById('quality-ok-cycle');

    updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
    setRecentEntriesState({ loading: false, empty: true });
    
    const analysisTabButtons = document.querySelectorAll('.analysis-tab-btn');
    const analysisViews = document.querySelectorAll('.analysis-view');
    const resumoDateSelector = document.getElementById('resumo-date-selector');
    const printReportBtn = document.getElementById('print-report-btn');
    const reportQuantBtn = document.getElementById('report-quant-btn');
    const reportEfficBtn = document.getElementById('report-effic-btn');
    const resumoContentContainer = document.getElementById('resumo-content-container');
    const startDateSelector = document.getElementById('start-date-selector');
    const endDateSelector = document.getElementById('end-date-selector');
    const dateRangeButtons = document.querySelectorAll('.date-range-btn');
    const machineFilter = document.getElementById('machine-filter');
    const refreshDashboardBtn = document.getElementById('refresh-dashboard-btn');
    
    const graphMachineFilter = document.getElementById('graph-machine-filter');

    let qualityTabInitialized = false;
    let currentQualityContext = null;
    let qualityPlansCache = {
        lastDate: null,
        plans: []
    };

    // Gerenciador centralizado para garantir que todos os modais fiquem visíveis mesmo com conflitos de CSS.
    const MODAL_FORCE_PROPS = [
        'display',
        'opacity',
        'visibility',
        'pointer-events',
        'position',
        'inset',
        'background-color',
        'z-index',
        'width',
        'height',
        'transform'
    ];
    const MODAL_CONTENT_FORCE_PROPS = [
        'display',
        'opacity',
        'visibility',
        'pointer-events',
        'position',
        'z-index',
        'transform'
    ];

    const modalManager = (() => {
        const rootId = 'global-modal-root';
        let root = document.getElementById(rootId);
        if (!root) {
            root = document.createElement('div');
            root.id = rootId;
            root.style.position = 'relative';
            root.style.zIndex = '2147483600';
            document.body.appendChild(root);
        }

        const portalize = (modal) => {
            if (!modal) return modal;
            if (modal.parentElement !== root) {
                root.appendChild(modal);
            }
            if (!modal.dataset.portalized) {
                modal.dataset.portalized = 'true';
            }
            return modal;
        };

        const applyStyles = (modal) => {
            if (!modal) return;
            const pairs = [
                ['display', 'flex'],
                ['opacity', '1'],
                ['visibility', 'visible'],
                ['pointer-events', 'auto'],
                ['position', 'fixed'],
                ['inset', '0'],
                ['background-color', 'rgba(0, 0, 0, 0.6)'],
                ['z-index', '2147483601'],
                ['width', '100vw'],
                ['height', '100vh'],
                ['transform', 'none']
            ];
            pairs.forEach(([prop, value]) => modal.style.setProperty(prop, value, 'important'));
        };

        const clearStyles = (modal) => {
            if (!modal) return;
            MODAL_FORCE_PROPS.forEach((prop) => modal.style.removeProperty(prop));
        };

        const applyContentStyles = (content) => {
            if (!content) return;
            const pairs = [
                ['display', 'block'],
                ['opacity', '1'],
                ['visibility', 'visible'],
                ['pointer-events', 'auto'],
                ['position', 'relative'],
                ['z-index', '2147483602'],
                ['transform', 'none']
            ];
            pairs.forEach(([prop, value]) => content.style.setProperty(prop, value, 'important'));
        };

        const clearContentStyles = (content) => {
            if (!content) return;
            MODAL_CONTENT_FORCE_PROPS.forEach((prop) => content.style.removeProperty(prop));
        };

        const verify = (modal) => {
            if (!modal) return;
            const computed = window.getComputedStyle(modal);
            const rect = modal.getBoundingClientRect();
            if (computed.visibility !== 'visible' || computed.display === 'none' || rect.width < 1 || rect.height < 1) {
                console.warn('⚠️ [ModalManager] Modal ainda não visível após forçar estilos', {
                    id: modal.id,
                    visibility: computed.visibility,
                    display: computed.display,
                    rect
                });
                modal.style.setProperty('z-index', '2147483647', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '1', 'important');
                modal.style.setProperty('pointer-events', 'auto', 'important');
                modal.style.setProperty('transform', 'none', 'important');
            }
        };

        return { root, portalize, applyStyles, clearStyles, applyContentStyles, clearContentStyles, verify };
    })();

    window.__modalManager = modalManager;

    // Portalizar todos os modais logo no carregamento evita que fiquem presos a containers com overflow ou z-index baixo.
    document.querySelectorAll('div[id$="-modal"]').forEach((modal) => {
        modalManager.portalize(modal);
        if (!modal.classList.contains('hidden')) {
            modal.classList.add('hidden');
        }
        modalManager.clearStyles(modal);
        const content = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
        if (content) {
            modalManager.clearContentStyles(content);
        }
    });

    // --- FUNÇÕES UTILITÁRIAS ---

    // Carregar OPs abertas para o cache (usado na busca)
    async function loadPlanningOrders() {
        try {
            // Usar função cacheada para economizar leituras do Firebase
            const orders = await getProductionOrdersCached();
            
            // Salvar no cache para uso posterior
            productionOrdersCache = orders;
            
            console.log(`[Planejamento] ${orders.length} OPs carregadas (cache/Firebase)`);
        } catch (err) {
            console.error('Erro ao carregar OPs:', err);
        }
    }

    // Buscar OP pelo número digitado
    function searchPlanningOrder(searchTerm) {
        const resultsContainer = document.getElementById('planning-order-results');
        
        if (!searchTerm || searchTerm.trim() === '') {
            if (resultsContainer) resultsContainer.classList.add('hidden');
            return;
        }

        const term = searchTerm.trim().toLowerCase();
        const blocked = ['concluida','cancelada','finalizada','encerrada'];
        
        console.log(`[Planejamento] Buscando OP com termo: "${term}", cache tem ${productionOrdersCache?.length || 0} OPs`);
        
        // Se o cache está vazio, tentar recarregar
        if (!productionOrdersCache || productionOrdersCache.length === 0) {
            console.warn('[Planejamento] Cache vazio, recarregando OPs...');
            loadPlanningOrders().then(() => {
                searchPlanningOrder(searchTerm);
            });
            return;
        }
        
        // Filtrar OPs abertas que correspondem ao termo de busca
        const matchedOrders = productionOrdersCache.filter(o => {
            if (blocked.includes(String(o.status||'').toLowerCase())) return false;
            
            const orderNum = String(o.order_number || o.order_number_original || o.id || '').toLowerCase();
            const productName = String(o.product || o.product_snapshot?.name || '').toLowerCase();
            const partCode = String(o.part_code || o.product_cod || o.product_snapshot?.cod || '').toLowerCase();
            
            return orderNum.includes(term) || productName.includes(term) || partCode.includes(term);
        });
        
        console.log(`[Planejamento] Encontradas ${matchedOrders.length} OPs`);

        // Ordenar por número da OP
        matchedOrders.sort((a,b) => {
            const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
            return toNum(a.order_number || a.order_number_original || a.id) - toNum(b.order_number || b.order_number_original || b.id);
        });

        // Limitar a 10 resultados
        const limitedResults = matchedOrders.slice(0, 10);

        // Renderizar resultados
        renderPlanningOrderResults(limitedResults);
    }

    // Renderizar resultados da busca de OP
    function renderPlanningOrderResults(orders) {
        const resultsContainer = document.getElementById('planning-order-results');
        if (!resultsContainer) {
            console.error('[Planejamento] Container de resultados não encontrado!');
            return;
        }

        if (orders.length === 0) {
            resultsContainer.innerHTML = `
                <div class="p-3 text-center text-gray-500 text-sm">
                    <i data-lucide="search-x" class="w-5 h-5 mx-auto mb-1 text-gray-400"></i>
                    <p>Nenhuma OP encontrada</p>
                </div>
            `;
            resultsContainer.classList.remove('hidden');
            if (typeof lucide !== 'undefined') lucide.createIcons();
            return;
        }

        const html = orders.map(o => {
            const orderNum = o.order_number || o.order_number_original || o.id;
            const productName = o.product || o.product_snapshot?.name || '';
            const snapshotData = o.product_snapshot || {};
            const lot = Number(o.lot_size)||0;
            
            return `
                <div class="planning-order-result p-2 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-b-0 transition-colors"
                    data-order-id="${o.id}"
                    data-part-code="${o.part_code||o.product_cod||snapshotData.cod||''}"
                    data-product="${o.product||snapshotData.name||''}"
                    data-customer="${o.customer||o.client||snapshotData.client||''}"
                    data-lot-size="${lot > 0 ? lot : ''}"
                    data-order-number="${orderNum}"
                    data-machine-id="${o.machine_id||o.machine||''}"
                    data-raw-material="${o.raw_material || snapshotData.mp || ''}"
                    data-mp-type="${o.mp_type || ''}">
                    <div class="flex items-center justify-between">
                        <div>
                            <span class="font-bold text-blue-600 text-sm">${orderNum}</span>
                            <span class="text-gray-400 mx-1">–</span>
                            <span class="text-gray-700 text-xs">${productName || 'Sem produto'}</span>
                        </div>
                        ${lot > 0 ? `<span class="text-xs text-gray-500 bg-gray-100 px-2 py-0.5 rounded">${lot.toLocaleString('pt-BR')} pcs</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        resultsContainer.innerHTML = html;
        resultsContainer.classList.remove('hidden');
        
        console.log(`[Planejamento] Renderizados ${orders.length} resultados`);

        // Adicionar eventos de clique nos resultados
        resultsContainer.querySelectorAll('.planning-order-result').forEach(item => {
            item.addEventListener('click', () => selectPlanningOrderFromSearch(item));
        });
    }

    // Selecionar OP da lista de resultados
    function selectPlanningOrderFromSearch(item) {
        const dataset = item.dataset;
        const orderId = dataset.orderId;
        const orderNumber = dataset.orderNumber;
        
        const searchInput = document.getElementById('planning-order-search');
        const hiddenSelect = document.getElementById('planning-order-select');
        const resultsContainer = document.getElementById('planning-order-results');
        const machineSelect = document.getElementById('planning-machine');

        console.log('[Planejamento] Dataset do item clicado:', dataset);
        console.log('[Planejamento] orderId:', orderId, 'orderNumber:', orderNumber);

        // Atualizar campo de busca com o número da OP selecionada
        if (searchInput) {
            searchInput.value = orderNumber;
        }

        // Atualizar campo hidden com o ID da OP
        if (hiddenSelect) {
            hiddenSelect.value = orderId;
        }

        // Ocultar resultados
        if (resultsContainer) {
            resultsContainer.classList.add('hidden');
        }

        // Converter dataset para objeto simples (dataset usa camelCase)
        const datasetObj = {
            partCode: dataset.partCode || '',
            product: dataset.product || '',
            customer: dataset.customer || '',
            lotSize: dataset.lotSize || '',
            orderNumber: dataset.orderNumber || '',
            machineId: dataset.machineId || '',
            rawMaterial: dataset.rawMaterial || '',
            mpType: dataset.mpType || ''
        };

        console.log('[Planejamento] OP selecionada via busca:', { orderId, orderNumber, datasetObj });

        const productCodInput = document.getElementById('planning-product-cod');
        if (productCodInput && datasetObj.partCode) {
            if (productCodInput.value !== datasetObj.partCode) {
                productCodInput.value = datasetObj.partCode;
            }
            productCodInput.dispatchEvent(new Event('change', { bubbles: true }));
        }

        if (machineSelect && datasetObj.machineId) {
            const hasOption = Array.from(machineSelect.options).some(opt => opt.value === datasetObj.machineId);
            if (hasOption) machineSelect.value = datasetObj.machineId;
        }

        const selectedOrder = Array.isArray(productionOrdersCache)
            ? productionOrdersCache.find(order => order && order.id === orderId)
            : null;
        
        console.log('[Planejamento] Ordem encontrada no cache:', selectedOrder);

        fillPlanningFormWithOrder(selectedOrder || null, datasetObj);
    }

    // Debounce para busca
    let planningSearchTimeout = null;
    function onPlanningOrderSearchInput(e) {
        const searchTerm = e.target.value;
        const loadingEl = document.getElementById('planning-order-search-loading');
        const resultsContainer = document.getElementById('planning-order-results');
        const hiddenSelect = document.getElementById('planning-order-select');
        
        // Mostrar loading
        if (loadingEl) {
            loadingEl.classList.remove('hidden');
        }

        // Cancelar busca anterior
        if (planningSearchTimeout) {
            clearTimeout(planningSearchTimeout);
        }

        // Se campo vazio, limpar formulário
        if (!searchTerm || searchTerm.trim() === '') {
            if (loadingEl) loadingEl.classList.add('hidden');
            if (resultsContainer) resultsContainer.classList.add('hidden');
            if (hiddenSelect) hiddenSelect.value = '';
            
            const productCodInput = document.getElementById('planning-product-cod');
            if (productCodInput) {
                productCodInput.value = '';
                productCodInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            fillPlanningFormWithOrder(null);
            return;
        }

        // Aguardar 300ms antes de buscar (debounce)
        planningSearchTimeout = setTimeout(() => {
            searchPlanningOrder(searchTerm);
            if (loadingEl) {
                loadingEl.classList.add('hidden');
            }
        }, 300);
    }

    // Fechar resultados ao clicar fora
    function onPlanningOrderSearchBlur(e) {
        const resultsContainer = document.getElementById('planning-order-results');
        // Delay para permitir clique no resultado antes de fechar
        setTimeout(() => {
            if (resultsContainer && !resultsContainer.contains(document.activeElement)) {
                resultsContainer.classList.add('hidden');
            }
        }, 200);
    }

    function onPlanningOrderChange() {
        // Função mantida para compatibilidade, mas agora o fluxo principal é pela busca
        const hiddenSelect = document.getElementById('planning-order-select');
        if (!hiddenSelect || !hiddenSelect.value) {
            const productCodInput = document.getElementById('planning-product-cod');
            if (productCodInput) {
                productCodInput.value = '';
                productCodInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            fillPlanningFormWithOrder(null);
            return;
        }
        // O preenchimento é feito pela função selectPlanningOrderFromSearch
    }

    function fillPlanningFormWithOrder(order, dataset = {}) {
        const infoElement = planningOrderInfo;
        const productNameDisplay = document.getElementById('product-name-display');
        const productNameText = document.getElementById('product-name-text');
        const orderNumberDisplay = document.getElementById('planning-order-number');
        const orderCustomerDisplay = document.getElementById('planning-order-customer');
        const mpInput = planningMpInput || document.getElementById('planning-mp');
        const mpTypeSelect = document.getElementById('planning-mp-type');
        const cycleInput = document.getElementById('budgeted-cycle');
        const cavitiesInput = document.getElementById('mold-cavities');
        const weightInput = document.getElementById('piece-weight');
        const plannedQtyInput = document.getElementById('planned-quantity');
        const lotSizeInput = document.getElementById('planning-lot-size');

        // Limpar todos os campos se não houver ordem
        if (!order) {
            if (infoElement) {
                infoElement.style.display = 'none';
            }
            if (orderNumberDisplay) orderNumberDisplay.textContent = '-';
            if (orderCustomerDisplay) orderCustomerDisplay.textContent = '-';
            if (mpInput) mpInput.value = '';
            if (mpTypeSelect) mpTypeSelect.value = '';
            if (cycleInput) cycleInput.value = '';
            if (cavitiesInput) cavitiesInput.value = '';
            if (weightInput) weightInput.value = '';
            if (plannedQtyInput) plannedQtyInput.value = '';
            if (lotSizeInput) lotSizeInput.value = '';
            if (productNameDisplay) {
                productNameDisplay.style.display = 'none';
            }
            if (productNameText) productNameText.textContent = '';
            return;
        }

        // === SEÇÃO 1: Dados da OP (do Excel/Firebase) ===
        const resolvedOrderNumber = order.order_number || order.order_number_original || dataset.orderNumber || order.id || '';
        const partCode = dataset.partCode || order.part_code || order.product_cod || '';
        const productName = order.product || dataset.product || order.product_snapshot?.name || '';
        const customer = order.customer || order.client || dataset.customer || order.product_snapshot?.client || '';
        const machineId = dataset.machineId || order.machine_id || order.machine || '';
        
        // Tamanho do lote (da OP)
        const lotSize = (() => {
            if (dataset.lotSize) {
                const dsValue = Number(dataset.lotSize);
                if (Number.isFinite(dsValue) && dsValue > 0) return dsValue;
            }
            const fromOrder = parseOptionalNumber(order.lot_size);
            return typeof fromOrder === 'number' && Number.isFinite(fromOrder) && fromOrder > 0 ? fromOrder : 0;
        })();

        // Preencher campos da OP
        if (lotSizeInput) {
            lotSizeInput.value = lotSize > 0 ? lotSize : '';
        }

        // Exibir info da OP
        if (infoElement) {
            infoElement.style.display = 'block';
        }
        if (orderNumberDisplay) {
            orderNumberDisplay.textContent = resolvedOrderNumber || '-';
        }
        if (orderCustomerDisplay) {
            orderCustomerDisplay.textContent = customer || '-';
        }

        // === SEÇÃO 2: Dados do Produto (do productDatabase via databaseModule) ===
        // Buscar produto no database pelo código usando a função helper getProductByCode
        const partCodeStr = String(partCode || '').trim();
        const productCode = parseInt(partCodeStr, 10);
        
        console.log(`[Planejamento] Buscando produto com código: "${partCodeStr}" (parseado: ${productCode})`);
        
        // Usar função helper com fallback seguro
        const productFromDatabase = getProductByCode(partCodeStr);

        let resolvedCycle = 0;
        let resolvedCavities = 0;
        let resolvedWeight = 0;
        let resolvedProductName = productName;
        let resolvedClient = customer;

        if (productFromDatabase) {
            // Usar dados do database de produtos (prioridade)
            resolvedCycle = Number(productFromDatabase.cycle) || 0;
            resolvedCavities = Number(productFromDatabase.cavities) || 0;
            resolvedWeight = Number(productFromDatabase.weight) || 0;
            resolvedProductName = productFromDatabase.name || productName;
            resolvedClient = productFromDatabase.client || customer;
            
            console.log(`[Planejamento] ✅ Produto encontrado no database:`, {
                codigo: productCode,
                nome: resolvedProductName,
                ciclo: resolvedCycle,
                cavidades: resolvedCavities,
                peso: resolvedWeight,
                cliente: resolvedClient
            });
        } else {
            // Fallback: usar dados do snapshot da OP ou do dataset
            console.warn(`[Planejamento] ⚠️ Produto Cod ${productCode} NÃO encontrado no database. Usando dados da OP.`, {
                partCode,
                productCode,
                databaseModuleExists: !!window.databaseModule,
                productByCodeExists: !!(window.databaseModule?.productByCode),
                productDatabaseLength: window.databaseModule?.productDatabase?.length || 0
            });
            
            resolvedCycle = (() => {
                if (dataset.cycle) {
                    const parsed = Number(dataset.cycle);
                    if (Number.isFinite(parsed) && parsed > 0) return parsed;
                }
                const snapshotCycle = Number(order.product_snapshot?.cycle);
                if (Number.isFinite(snapshotCycle) && snapshotCycle > 0) return snapshotCycle;
                const orderCycle = Number(order.budgeted_cycle);
                if (Number.isFinite(orderCycle) && orderCycle > 0) return orderCycle;
                return 0;
            })();

            resolvedCavities = (() => {
                if (dataset.cavities) {
                    const parsed = Number(dataset.cavities);
                    if (Number.isFinite(parsed) && parsed > 0) return parsed;
                }
                const snapshotCavities = Number(order.product_snapshot?.cavities);
                if (Number.isFinite(snapshotCavities) && snapshotCavities > 0) return snapshotCavities;
                const orderCavities = Number(order.mold_cavities);
                if (Number.isFinite(orderCavities) && orderCavities > 0) return orderCavities;
                return 0;
            })();

            resolvedWeight = (() => {
                if (dataset.weight) {
                    const parsed = Number(dataset.weight);
                    if (Number.isFinite(parsed) && parsed > 0) return parsed;
                }
                const snapshotWeight = Number(order.product_snapshot?.weight);
                if (Number.isFinite(snapshotWeight) && snapshotWeight > 0) return snapshotWeight;
                const orderWeight = Number(order.piece_weight);
                if (Number.isFinite(orderWeight) && orderWeight > 0) return orderWeight;
                return 0;
            })();
            
            if (partCode) {
                console.warn(`[Planejamento] Produto Cod ${partCode} não encontrado no database. Usando dados da OP.`);
            }
        }

        console.log('[Planejamento] Valores resolvidos:', {
            resolvedCycle,
            resolvedCavities,
            resolvedWeight,
            resolvedProductName
        });

        // Preencher campos do produto
        console.log('[Planejamento] Inputs encontrados:', {
            cycleInput: !!cycleInput,
            cavitiesInput: !!cavitiesInput,
            weightInput: !!weightInput
        });

        if (cycleInput) {
            cycleInput.value = resolvedCycle > 0 ? resolvedCycle : '';
            console.log('[Planejamento] Ciclo preenchido:', cycleInput.value);
        }
        if (cavitiesInput) {
            cavitiesInput.value = resolvedCavities > 0 ? resolvedCavities : '';
            console.log('[Planejamento] Cavidades preenchido:', cavitiesInput.value);
        }
        if (weightInput) {
            weightInput.value = resolvedWeight > 0 ? resolvedWeight : '';
            console.log('[Planejamento] Peso preenchido:', weightInput.value);
        }

        // Exibir nome do produto
        if (productNameDisplay && productNameText) {
            const displayName = resolvedProductName || '';
            if (displayName) {
                productNameText.textContent = displayName;
                productNameDisplay.style.display = 'block';
            } else {
                productNameDisplay.style.display = 'none';
            }
        } else if (productNameDisplay) {
            // Fallback para estrutura antiga
            const label = [resolvedProductName, resolvedClient ? `(${resolvedClient})` : ''].filter(Boolean).join(' ');
            productNameDisplay.textContent = label;
            productNameDisplay.style.display = label ? 'block' : 'none';
        }

        // === SEÇÃO 3: Matéria-prima ===
        const rawMaterial = (dataset.rawMaterial || order.raw_material || order.product_snapshot?.mp || '').trim();
        if (mpInput && rawMaterial) {
            mpInput.value = rawMaterial;
        }

        if (mpTypeSelect) {
            const mpTypeValue = dataset.mpType || order.mp_type || '';
            mpTypeSelect.value = mpTypeValue;
        }

        // === Calcular Quantidade Planejada ===
        if (plannedQtyInput) {
            const cycle = resolvedCycle;
            const cavities = resolvedCavities;
            const plannedQty = cycle > 0 && cavities > 0
                ? Math.floor((86400 / cycle) * cavities * 0.85)
                : 0;
            if (plannedQty > 0) {
                plannedQtyInput.value = plannedQty;
                // Calcular e mostrar distribuição por turno
                updateShiftDistribution(plannedQty, cycle, cavities);
            } else {
                plannedQtyInput.value = '';
                hideShiftDistribution();
            }
        }
    }
    
    // ========================================
    // DISTRIBUIÇÃO POR TURNO - OPÇÃO 3 (HÍBRIDO)
    // ========================================
    
    // Configuração de horas por turno (para cálculo proporcional)
    const SHIFT_CONFIG = {
        t1: { name: '1º Turno', hours: 8.5, percent: 0.35, start: '06:30', end: '15:00' },  // 35%
        t2: { name: '2º Turno', hours: 8.33, percent: 0.35, start: '15:00', end: '23:20' }, // 35%
        t3: { name: '3º Turno', hours: 7.17, percent: 0.30, start: '23:20', end: '06:29' }  // 30%
    };
    
    // Armazena os dados de distribuição por turno atual
    let shiftDistributionData = {
        totalQty: 0,
        baseCycle: 0,
        baseCavities: 0,
        t1: { cycle: 0, cavities: 0, qty: 0, customized: false },
        t2: { cycle: 0, cavities: 0, qty: 0, customized: false },
        t3: { cycle: 0, cavities: 0, qty: 0, customized: false }
    };
    
    /**
     * Calcula a quantidade planejada para um turno específico
     * @param {number} cycle - Ciclo em segundos
     * @param {number} cavities - Número de cavidades
     * @param {number} hoursAvailable - Horas disponíveis no turno
     * @param {number} efficiency - Eficiência (padrão 0.85 = 85%)
     */
    function calculateShiftQuantity(cycle, cavities, hoursAvailable, efficiency = 0.85) {
        if (!cycle || !cavities || cycle <= 0 || cavities <= 0) return 0;
        const secondsAvailable = hoursAvailable * 3600;
        return Math.floor((secondsAvailable / cycle) * cavities * efficiency);
    }
    
    /**
     * Atualiza a distribuição por turno e exibe a seção
     */
    function updateShiftDistribution(totalQty, cycle, cavities) {
        console.log('[SHIFT DISTRIBUTION] updateShiftDistribution chamada:', { totalQty, cycle, cavities });
        const section = document.getElementById('shift-distribution-section');
        if (!section) {
            console.warn('[SHIFT DISTRIBUTION] Seção não encontrada no DOM');
            return;
        }
        
        // Armazenar dados base
        shiftDistributionData.totalQty = totalQty;
        shiftDistributionData.baseCycle = cycle;
        shiftDistributionData.baseCavities = cavities;
        
        // Calcular para cada turno usando o mesmo ciclo/cavidades (distribuição proporcional)
        const t1Qty = Math.round(totalQty * SHIFT_CONFIG.t1.percent);
        const t2Qty = Math.round(totalQty * SHIFT_CONFIG.t2.percent);
        const t3Qty = totalQty - t1Qty - t2Qty; // Garantir que soma = total
        
        // Atualizar dados
        shiftDistributionData.t1 = { cycle, cavities, qty: t1Qty, customized: false };
        shiftDistributionData.t2 = { cycle, cavities, qty: t2Qty, customized: false };
        shiftDistributionData.t3 = { cycle, cavities, qty: t3Qty, customized: false };
        
        // Atualizar UI
        updateShiftDistributionUI();
        
        // Mostrar seção
        section.style.display = 'block';
        
        // Atualizar campos ocultos do formulário
        updateShiftHiddenFields();
    }
    
    /**
     * Oculta a seção de distribuição por turno
     */
    function hideShiftDistribution() {
        const section = document.getElementById('shift-distribution-section');
        if (section) {
            section.style.display = 'none';
        }
        // Limpar dados
        shiftDistributionData = {
            totalQty: 0, baseCycle: 0, baseCavities: 0,
            t1: { cycle: 0, cavities: 0, qty: 0, customized: false },
            t2: { cycle: 0, cavities: 0, qty: 0, customized: false },
            t3: { cycle: 0, cavities: 0, qty: 0, customized: false }
        };
    }
    
    /**
     * Atualiza a UI da seção de distribuição por turno
     */
    function updateShiftDistributionUI() {
        // T1
        const t1El = document.getElementById('shift-t1-qty');
        const t1Input = document.getElementById('planned-qty-t1');
        if (t1El) t1El.textContent = shiftDistributionData.t1.qty.toLocaleString('pt-BR');
        if (t1Input) t1Input.value = shiftDistributionData.t1.qty;
        
        // T2
        const t2El = document.getElementById('shift-t2-qty');
        const t2Input = document.getElementById('planned-qty-t2');
        if (t2El) t2El.textContent = shiftDistributionData.t2.qty.toLocaleString('pt-BR');
        if (t2Input) t2Input.value = shiftDistributionData.t2.qty;
        
        // T3
        const t3El = document.getElementById('shift-t3-qty');
        const t3Input = document.getElementById('planned-qty-t3');
        if (t3El) t3El.textContent = shiftDistributionData.t3.qty.toLocaleString('pt-BR');
        if (t3Input) t3Input.value = shiftDistributionData.t3.qty;
    }
    
    /**
     * Atualiza os campos ocultos do formulário de planejamento
     */
    function updateShiftHiddenFields() {
        // Ciclo por turno
        const cycleT1 = document.getElementById('cycle-t1');
        const cycleT2 = document.getElementById('cycle-t2');
        const cycleT3 = document.getElementById('cycle-t3');
        if (cycleT1) cycleT1.value = shiftDistributionData.t1.cycle;
        if (cycleT2) cycleT2.value = shiftDistributionData.t2.cycle;
        if (cycleT3) cycleT3.value = shiftDistributionData.t3.cycle;
        
        // Cavidades por turno
        const cavitiesT1 = document.getElementById('cavities-t1');
        const cavitiesT2 = document.getElementById('cavities-t2');
        const cavitiesT3 = document.getElementById('cavities-t3');
        if (cavitiesT1) cavitiesT1.value = shiftDistributionData.t1.cavities;
        if (cavitiesT2) cavitiesT2.value = shiftDistributionData.t2.cavities;
        if (cavitiesT3) cavitiesT3.value = shiftDistributionData.t3.cavities;
    }
    
    /**
     * Abre o modal de customização por turno
     */
    function openShiftCustomizeModal() {
        console.log('[SHIFT DISTRIBUTION] Abrindo modal de customização');
        const modal = document.getElementById('shift-customize-modal');
        if (!modal) {
            console.warn('[SHIFT DISTRIBUTION] Modal não encontrado');
            return;
        }
        
        // Preencher campos com valores atuais
        document.getElementById('custom-cycle-t1').value = shiftDistributionData.t1.cycle || shiftDistributionData.baseCycle;
        document.getElementById('custom-cavities-t1').value = shiftDistributionData.t1.cavities || shiftDistributionData.baseCavities;
        document.getElementById('custom-qty-t1').value = shiftDistributionData.t1.qty;
        
        document.getElementById('custom-cycle-t2').value = shiftDistributionData.t2.cycle || shiftDistributionData.baseCycle;
        document.getElementById('custom-cavities-t2').value = shiftDistributionData.t2.cavities || shiftDistributionData.baseCavities;
        document.getElementById('custom-qty-t2').value = shiftDistributionData.t2.qty;
        
        document.getElementById('custom-cycle-t3').value = shiftDistributionData.t3.cycle || shiftDistributionData.baseCycle;
        document.getElementById('custom-cavities-t3').value = shiftDistributionData.t3.cavities || shiftDistributionData.baseCavities;
        document.getElementById('custom-qty-t3').value = shiftDistributionData.t3.qty;
        
        // Atualizar resumo
        updateShiftModalSummary();
        
        modal.classList.remove('hidden');
        
        // Reinicializar ícones Lucide no modal
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
    
    /**
     * Fecha o modal de customização por turno
     */
    function closeShiftCustomizeModal() {
        const modal = document.getElementById('shift-customize-modal');
        if (modal) modal.classList.add('hidden');
    }
    
    /**
     * Recalcula a quantidade para um turno específico baseado no ciclo e cavidades
     * @param {string} shiftId - 't1', 't2' ou 't3'
     */
    window.recalculateShiftQty = function(shiftId) {
        const cycleInput = document.getElementById(`custom-cycle-${shiftId}`);
        const cavitiesInput = document.getElementById(`custom-cavities-${shiftId}`);
        const qtyInput = document.getElementById(`custom-qty-${shiftId}`);
        
        if (!cycleInput || !cavitiesInput || !qtyInput) return;
        
        const cycle = parseFloat(cycleInput.value) || 0;
        const cavities = parseInt(cavitiesInput.value) || 0;
        
        const shiftConfig = SHIFT_CONFIG[shiftId];
        if (!shiftConfig) return;
        
        const qty = calculateShiftQuantity(cycle, cavities, shiftConfig.hours);
        qtyInput.value = qty;
        
        updateShiftModalSummary();
    };
    
    /**
     * Atualiza o resumo no modal de customização
     */
    function updateShiftModalSummary() {
        const t1Qty = parseInt(document.getElementById('custom-qty-t1')?.value) || 0;
        const t2Qty = parseInt(document.getElementById('custom-qty-t2')?.value) || 0;
        const t3Qty = parseInt(document.getElementById('custom-qty-t3')?.value) || 0;
        
        const total = t1Qty + t2Qty + t3Qty;
        
        const totalEl = document.getElementById('shift-total-qty');
        const summaryT1 = document.getElementById('shift-summary-t1');
        const summaryT2 = document.getElementById('shift-summary-t2');
        const summaryT3 = document.getElementById('shift-summary-t3');
        
        if (totalEl) totalEl.textContent = total.toLocaleString('pt-BR');
        if (summaryT1) summaryT1.textContent = t1Qty.toLocaleString('pt-BR');
        if (summaryT2) summaryT2.textContent = t2Qty.toLocaleString('pt-BR');
        if (summaryT3) summaryT3.textContent = t3Qty.toLocaleString('pt-BR');
    }
    
    /**
     * Restaura a distribuição padrão (proporcional)
     */
    function resetShiftDistribution() {
        const total = shiftDistributionData.totalQty;
        const cycle = shiftDistributionData.baseCycle;
        const cavities = shiftDistributionData.baseCavities;
        
        if (total > 0 && cycle > 0 && cavities > 0) {
            // Recalcular distribuição proporcional
            const t1Qty = Math.round(total * SHIFT_CONFIG.t1.percent);
            const t2Qty = Math.round(total * SHIFT_CONFIG.t2.percent);
            const t3Qty = total - t1Qty - t2Qty;
            
            // Preencher modal
            document.getElementById('custom-cycle-t1').value = cycle;
            document.getElementById('custom-cavities-t1').value = cavities;
            document.getElementById('custom-qty-t1').value = t1Qty;
            
            document.getElementById('custom-cycle-t2').value = cycle;
            document.getElementById('custom-cavities-t2').value = cavities;
            document.getElementById('custom-qty-t2').value = t2Qty;
            
            document.getElementById('custom-cycle-t3').value = cycle;
            document.getElementById('custom-cavities-t3').value = cavities;
            document.getElementById('custom-qty-t3').value = t3Qty;
            
            updateShiftModalSummary();
        }
    }
    
    /**
     * Aplica a distribuição customizada ao formulário de planejamento
     */
    function applyShiftDistribution() {
        // Capturar valores do modal
        const t1Cycle = parseFloat(document.getElementById('custom-cycle-t1')?.value) || shiftDistributionData.baseCycle;
        const t1Cavities = parseInt(document.getElementById('custom-cavities-t1')?.value) || shiftDistributionData.baseCavities;
        const t1Qty = parseInt(document.getElementById('custom-qty-t1')?.value) || 0;
        
        const t2Cycle = parseFloat(document.getElementById('custom-cycle-t2')?.value) || shiftDistributionData.baseCycle;
        const t2Cavities = parseInt(document.getElementById('custom-cavities-t2')?.value) || shiftDistributionData.baseCavities;
        const t2Qty = parseInt(document.getElementById('custom-qty-t2')?.value) || 0;
        
        const t3Cycle = parseFloat(document.getElementById('custom-cycle-t3')?.value) || shiftDistributionData.baseCycle;
        const t3Cavities = parseInt(document.getElementById('custom-cavities-t3')?.value) || shiftDistributionData.baseCavities;
        const t3Qty = parseInt(document.getElementById('custom-qty-t3')?.value) || 0;
        
        // Atualizar dados
        shiftDistributionData.t1 = { cycle: t1Cycle, cavities: t1Cavities, qty: t1Qty, customized: true };
        shiftDistributionData.t2 = { cycle: t2Cycle, cavities: t2Cavities, qty: t2Qty, customized: true };
        shiftDistributionData.t3 = { cycle: t3Cycle, cavities: t3Cavities, qty: t3Qty, customized: true };
        
        // Atualizar total planejado
        const newTotal = t1Qty + t2Qty + t3Qty;
        shiftDistributionData.totalQty = newTotal;
        
        // Atualizar campo principal de quantidade planejada
        const plannedQtyInput = document.getElementById('planned-quantity');
        if (plannedQtyInput) {
            plannedQtyInput.value = newTotal;
        }
        
        // Atualizar UI da seção de distribuição
        updateShiftDistributionUI();
        
        // Atualizar campos ocultos
        updateShiftHiddenFields();
        
        // Fechar modal
        closeShiftCustomizeModal();
        
        // Feedback
        if (typeof window.showNotification === 'function') {
            window.showNotification('Distribuição por turno aplicada com sucesso!', 'success');
        } else {
            console.log('✅ Distribuição por turno aplicada com sucesso!');
        }
    }
    
    // Event Listeners para o modal de customização por turno
    // Registrar eventos diretamente (já estamos dentro de um DOMContentLoaded)
    setTimeout(function() {
        // Botão customizar na seção principal
        const customizeBtn = document.getElementById('customize-shifts-btn');
        if (customizeBtn) {
            customizeBtn.addEventListener('click', openShiftCustomizeModal);
        }
        
        // Botão fechar modal
        const closeBtn = document.getElementById('shift-customize-close');
        if (closeBtn) {
            closeBtn.addEventListener('click', closeShiftCustomizeModal);
        }
        
        // Botão restaurar padrão
        const resetBtn = document.getElementById('shift-reset-btn');
        if (resetBtn) {
            resetBtn.addEventListener('click', resetShiftDistribution);
        }
        
        // Botão aplicar distribuição
        const applyBtn = document.getElementById('shift-apply-btn');
        if (applyBtn) {
            applyBtn.addEventListener('click', applyShiftDistribution);
        }
        
        // Fechar modal ao clicar fora
        const modal = document.getElementById('shift-customize-modal');
        if (modal) {
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeShiftCustomizeModal();
                }
            });
        }
        
        // Recalcular ao alterar campos no modal
        ['t1', 't2', 't3'].forEach(shift => {
            const cycleInput = document.getElementById(`custom-cycle-${shift}`);
            const cavitiesInput = document.getElementById(`custom-cavities-${shift}`);
            
            if (cycleInput) {
                cycleInput.addEventListener('input', () => {
                    recalculateShiftQty(shift);
                });
            }
            if (cavitiesInput) {
                cavitiesInput.addEventListener('input', () => {
                    recalculateShiftQty(shift);
                });
            }
        });
        
        console.log('[SHIFT DISTRIBUTION] Event listeners registrados com sucesso');
    }, 500); // Delay para garantir que o DOM está completamente carregado
    
    // ========================================
    // FIM - DISTRIBUIÇÃO POR TURNO
    // ========================================
    
    let cachedResolvedUserName = null;

    // Recupera sessão diretamente do armazenamento (sessionStorage > localStorage)
    function getStoredUserSession() {
        const storageSources = [() => sessionStorage, () => localStorage];
        for (const getStorage of storageSources) {
            try {
                const storage = getStorage();
                if (!storage) continue;
                const data = storage.getItem('synchro_user');
                if (data) {
                    const parsed = JSON.parse(data);
                    if (parsed && typeof parsed === 'object' && typeof parsed.name === 'string') {
                        parsed.name = parsed.name.trim();
                    }
                    console.log('📍 [DEBUG] getStoredUserSession() encontrou:', parsed);
                    return parsed;
                }
            } catch (error) {
                console.warn('⚠️ [DEBUG] Erro ao ler sessão armazenada:', error);
            }
        }
        console.warn('⚠️ [DEBUG] getStoredUserSession() não encontrou dados');
        return null;
    }

    // Obtém usuário ativo com fallback para sessão armazenada
    function getActiveUser() {
        const authUser = window.authSystem?.getCurrentUser?.();
        if (authUser && (authUser.username || authUser.name)) {
            return authUser;
        }

        const storedUser = getStoredUserSession();
        if (storedUser) {
            const sanitizedUser = { ...storedUser };
            if (typeof sanitizedUser.name === 'string') {
                sanitizedUser.name = sanitizedUser.name.trim();
            }
            if (window.authSystem?.setCurrentUser) {
                window.authSystem.setCurrentUser(sanitizedUser);
            } else if (window.authSystem) {
                window.authSystem.currentUser = sanitizedUser;
            }
            return sanitizedUser;
        }

        return {};
    }

    /**
     * Verifica se o usuário atual é gestor, suporte, lider ou tem acesso total (Leandro Camargo)
     * Usada para restringir funções de edição e exclusão
     */
    function isUserGestorOrAdmin() {
        const user = getActiveUser();
        if (!user) return false;
        
        // Usuários com acesso total (Leandro Camargo, Davi Batista ou role 'suporte')
        const isAuthorizedAdmin = 
            user.name === 'Leandro Camargo' || user.email === 'leandro@hokkaido.com.br' ||
            user.name === 'Davi Batista' || user.email === 'davi@hokkaido.com.br' ||
            user.role === 'suporte';
        if (isAuthorizedAdmin) return true;
        
        // Verificar se é gestor ou lider
        return user.role === 'gestor' || user.role === 'lider';
    }

    /**
     * Exibe notificação de permissão negada para operações restritas
     */
    function showPermissionDeniedNotification(action = 'realizar esta ação') {
        const message = `⮝ Permissão negada: Apenas gestores podem ${action}.`;
        showNotification(message, 'error');
        return false;
    }

    function deriveNameFromIdentifier(identifier) {
        if (!identifier || typeof identifier !== 'string') return '';
        const trimmed = identifier.trim();
        if (!trimmed) return '';
        const base = trimmed.includes('@') ? trimmed.split('@')[0] : trimmed;
        const sanitized = base.replace(/[^\w�-�.\-_\s]/g, ' ');
        const parts = sanitized.split(/[._\-\s]+/).filter(Boolean);
        if (!parts.length) return '';
        return parts.map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()).join(' ');
    }

    function persistResolvedUserName(name, currentUser) {
        if (!name || typeof name !== 'string') return;
        cachedResolvedUserName = name.trim();
        if (!cachedResolvedUserName) return;
        if (currentUser && typeof currentUser === 'object') {
            const updatedUser = { ...currentUser, name: cachedResolvedUserName };
            if (window.authSystem?.setCurrentUser) {
                window.authSystem.setCurrentUser(updatedUser);
            } else if (window.authSystem) {
                window.authSystem.currentUser = updatedUser;
            }
        }
    }

    // Função para obter o nome do usuário com fallback seguro
    function getCurrentUserName() {
        if (cachedResolvedUserName && cachedResolvedUserName !== 'Desconhecido') {
            return cachedResolvedUserName;
        }

        const currentUser = getActiveUser();
        console.log('📍 [DEBUG] getCurrentUserName() - currentUser:', currentUser);

        const candidateSources = [
            currentUser?.name,
            currentUser?.displayName,
            currentUser?.fullName,
            currentUser?.profile?.name,
            currentUser?.user?.name,
            currentUser?.user?.displayName
        ];

        for (const source of candidateSources) {
            if (typeof source === 'string' && source.trim()) {
                console.log('✅ [DEBUG] Nome obtido de fonte primária:', source.trim());
                persistResolvedUserName(source.trim(), currentUser);
                return cachedResolvedUserName;
            }
        }

        const usernameDerived = deriveNameFromIdentifier(currentUser?.username || currentUser?.user?.username);
        if (usernameDerived) {
            console.log('✅ [DEBUG] Nome derivado do username:', usernameDerived);
            persistResolvedUserName(usernameDerived, currentUser);
            return cachedResolvedUserName;
        }

        const emailDerived = deriveNameFromIdentifier(currentUser?.email || currentUser?.user?.email);
        if (emailDerived) {
            console.log('✅ [DEBUG] Nome derivado do e-mail:', emailDerived);
            persistResolvedUserName(emailDerived, currentUser);
            return cachedResolvedUserName;
        }

        const storedSession = getStoredUserSession();
        if (storedSession && typeof storedSession === 'object') {
            const storedCandidates = [
                storedSession.name,
                storedSession.displayName,
                storedSession.fullName
            ];
            for (const stored of storedCandidates) {
                if (typeof stored === 'string' && stored.trim()) {
                    console.log('✅ [DEBUG] Nome recuperado da sessão armazenada:', stored.trim());
                    persistResolvedUserName(stored.trim(), currentUser || storedSession);
                    return cachedResolvedUserName;
                }
            }

            const fallbackFromIdentifier = deriveNameFromIdentifier(storedSession.username || storedSession.email);
            if (fallbackFromIdentifier) {
                console.log('✅ [DEBUG] Nome derivado da sessão armazenada:', fallbackFromIdentifier);
                persistResolvedUserName(fallbackFromIdentifier, currentUser || storedSession);
                return cachedResolvedUserName;
            }
        }

        console.warn('⚠️ [DEBUG] Nenhum nome encontrado, retornando "Desconhecido"');
        cachedResolvedUserName = 'Desconhecido';
        return cachedResolvedUserName;
    }
    
    // Funções para normalizar datas conforme o ciclo de trabalho (6h30 a 6h29 do dia seguinte)
    // Turno 1: 06:30 - 14:59 | Turno 2: 15:00 - 23:19 | Turno 3: 23:20 - 06:29

    function getWorkDay(dateStr, timeStr) {
        if (!dateStr) return null;

        let hours = 12; // padrão neutro (meio-dia)
        let mins = 0;
        if (typeof timeStr === 'string' && timeStr.includes(':')) {
            const [timeHours, timeMinutes] = timeStr.split(':').map(Number);
            if (!Number.isNaN(timeHours)) {
                hours = timeHours;
                mins = timeMinutes || 0;
            }
        }

        // Se for 6:30 ou depois, é do dia atual
        if (hours > 6 || (hours === 6 && mins >= 30)) {
            return dateStr;
        }

        const [year, month, day] = dateStr.split('-').map(Number);
        if ([year, month, day].some(n => Number.isNaN(n))) return dateStr;

        const baseDate = new Date(year, (month || 1) - 1, day || 1);
        baseDate.setDate(baseDate.getDate() - 1);
        return baseDate.toISOString().split('T')[0];
    }

    // Wrapper para compatibilidade com chamadas antigas
    function getWorkDayFromDate(dateStr, timeStr) {
        return getWorkDay(dateStr, timeStr);
    }

    function normalizeToDate(value) {
        if (!value) return null;
        if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? null : value;
        }
        if (value && typeof value.toDate === 'function') {
            const converted = value.toDate();
            return converted instanceof Date && !Number.isNaN(converted.getTime()) ? converted : null;
        }
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
    }

    function resolveProductionDateTime(raw) {
        if (!raw || typeof raw !== 'object') return null;

        const candidates = [];

        if (raw.dataHoraInformada) {
            candidates.push(raw.dataHoraInformada);
        }

        if (raw.horaInformada && (raw.data || raw.date)) {
            candidates.push(`${raw.data || raw.date}T${raw.horaInformada}`);
        }

        if (raw.datetime) {
            candidates.push(raw.datetime);
        }

        candidates.push(raw.timestamp);
        candidates.push(raw.createdAt);
        candidates.push(raw.updatedAt);

        for (const candidate of candidates) {
            const dateObj = normalizeToDate(candidate);
            if (dateObj) {
                return dateObj;
            }
        }

        return null;
    }

    function getWorkDayFromTimestamp(timestamp) {
        const dateObj = normalizeToDate(timestamp);
        if (!(dateObj instanceof Date)) return null;
        if (Number.isNaN(dateObj.getTime())) return null;
        const isoString = new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60000).toISOString();
        const [datePart, timePart] = isoString.split('T');
        return getWorkDay(datePart, timePart?.substring(0, 5));
    }

    const PRODUCTION_DAY_START_HOUR = 7;
    const HOURS_IN_PRODUCTION_DAY = 24;

    const PROGRESS_PALETTE = {
        danger: { start: '#ef4444', end: '#f87171', textClass: 'text-red-600' },
        warning: { start: '#f59e0b', end: '#fbbf24', textClass: 'text-amber-500' },
        success: { start: '#10b981', end: '#34d399', textClass: 'text-emerald-600' }
    };
    const ANALYSIS_LINE_COLORS = [
        { border: '#2563EB', fill: 'rgba(37, 99, 235, 0.15)' },
        { border: '#10B981', fill: 'rgba(16, 185, 129, 0.15)' },
        { border: '#F59E0B', fill: 'rgba(245, 158, 11, 0.15)' },
        { border: '#9333EA', fill: 'rgba(147, 51, 234, 0.15)' },
        { border: '#EC4899', fill: 'rgba(236, 72, 153, 0.15)' },
        { border: '#0EA5E9', fill: 'rgba(14, 165, 233, 0.15)' },
        { border: '#22C55E', fill: 'rgba(34, 197, 94, 0.15)' },
        { border: '#F97316', fill: 'rgba(249, 115, 22, 0.15)' }
    ];

    function hexToRgb(hex) {
        if (!hex) return { r: 0, g: 0, b: 0 };
        const normalized = hex.replace('#', '');
        const expanded = normalized.length === 3
            ? normalized.split('').map((char) => char + char).join('')
            : normalized.padEnd(6, '0');
        const value = parseInt(expanded, 16);
        return {
            r: (value >> 16) & 255,
            g: (value >> 8) & 255,
            b: value & 255
        };
    }

    function rgbToHex({ r, g, b }) {
        const clamp = (value) => Math.max(0, Math.min(255, Math.round(value)));
        const toHex = (value) => clamp(value).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function mixHexColors(hexA, hexB, factor = 0) {
        const ratio = Math.max(0, Math.min(1, factor));
        const colorA = hexToRgb(hexA);
        const colorB = hexToRgb(hexB);
        const mixChannel = (channel) => colorA[channel] + (colorB[channel] - colorA[channel]) * ratio;
        return rgbToHex({
            r: mixChannel('r'),
            g: mixChannel('g'),
            b: mixChannel('b')
        });
    }

    function resolveProgressPalette(percent = 0) {
        const clamped = Math.max(0, percent);
        if (clamped >= 85) {
            return {
                start: PROGRESS_PALETTE.success.start,
                end: PROGRESS_PALETTE.success.end,
                textClass: PROGRESS_PALETTE.success.textClass
            };
        }

        if (clamped <= 60) {
            const ratio = Math.min(clamped / 60, 1);
            return {
                start: mixHexColors(PROGRESS_PALETTE.danger.start, PROGRESS_PALETTE.warning.start, ratio),
                end: mixHexColors(PROGRESS_PALETTE.danger.end, PROGRESS_PALETTE.warning.end, ratio),
                textClass: clamped >= 45 ? PROGRESS_PALETTE.warning.textClass : PROGRESS_PALETTE.danger.textClass
            };
        }

        const transitionRatio = Math.min((clamped - 60) / 25, 1);
        return {
            start: mixHexColors(PROGRESS_PALETTE.warning.start, PROGRESS_PALETTE.success.start, transitionRatio),
            end: mixHexColors(PROGRESS_PALETTE.warning.end, PROGRESS_PALETTE.success.end, transitionRatio),
            textClass: clamped >= 75 ? PROGRESS_PALETTE.success.textClass : PROGRESS_PALETTE.warning.textClass
        };
    }

    function hexWithAlpha(hex, alpha) {
        const { r, g, b } = hexToRgb(hex);
        return `rgba(${r}, ${g}, ${b}, ${Math.max(0, Math.min(1, alpha))})`;
    }

    function formatHourLabel(hourValue) {
        const normalized = ((hourValue % 24) + 24) % 24;
        return `${String(normalized).padStart(2, '0')}:00`;
    }

    function formatShortDateLabel(dateStr) {
        if (!dateStr) return '--';
        const safeValue = String(dateStr).slice(0, 10);
        const parsed = new Date(`${safeValue}T00:00:00`);
        if (!Number.isNaN(parsed.getTime())) {
            return parsed.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
        }
        const parts = safeValue.split('-');
        if (parts.length === 3) {
            return `${parts[2]}/${parts[1]}`;
        }
        return safeValue;
    }

    function getProductionHoursOrder() {
        const ordered = [];
        for (let hour = PRODUCTION_DAY_START_HOUR; hour < 24; hour++) {
            ordered.push(formatHourLabel(hour));
        }
        for (let hour = 0; hour < PRODUCTION_DAY_START_HOUR; hour++) {
            ordered.push(formatHourLabel(hour));
        }
        return ordered;
    }

    function getProductionHourLabel(date = new Date()) {
        return formatHourLabel(date.getHours());
    }

    function getHoursElapsedInProductionDay(date = new Date()) {
        const reference = new Date(date);
        if (Number.isNaN(reference.getTime())) return 0;

        const productionStart = new Date(reference);
        if (productionStart.getHours() < PRODUCTION_DAY_START_HOUR) {
            productionStart.setDate(productionStart.getDate() - 1);
        }
        productionStart.setHours(PRODUCTION_DAY_START_HOUR, 0, 0, 0);

        const diffMs = Math.max(0, reference.getTime() - productionStart.getTime());
        const elapsedHours = Math.floor(diffMs / (60 * 60 * 1000));
        const clamped = Math.min(elapsedHours + 1, HOURS_IN_PRODUCTION_DAY);
        return Math.max(0, clamped);
    }

    function normalizeShiftValue(value) {
        if (value === undefined || value === null) return null;
        if (typeof value === 'number' && Number.isFinite(value)) {
            return `T${value}`;
        }
        const str = String(value).toUpperCase();
        const match = str.match(/T?\s*(\d)/);
        return match ? `T${match[1]}` : null;
    }

    function formatShiftLabel(shiftKey) {
        switch (shiftKey) {
            case 'T1':
                return '1º Turno';
            case 'T2':
                return '2º Turno';
            case 'T3':
                return '3º Turno';
            default:
                return 'Turno atual';
        }
    }

    function getGroupedLossReasons() {
        if (window.databaseModule && window.databaseModule.groupedLossReasons) {
            return window.databaseModule.groupedLossReasons;
        }
        return {
            "PROCESSO": [
                "BOLHA", "CHUPAGEM", "CONTAMINAÇÃO", "DEGRADAÇÃO", "EMPENAMENTO", "FALHA", 
                "FIAPO", "FORA DE COR", "INÍCIO/REÍNICIO", "JUNÇÃO", "MANCHAS", 
                "MEDIDA FORA DO ESPECIFICADO", "MOÍDO", "PEÇAS PERDIDAS", "QUEIMA", "REBARBA"
            ],
            "FERRAMENTARIA": [
                "DEFORMAÇÃO", "GALHO PRESO", "MARCA D'ÁGUA", "MARCA EXTRATOR", "RISCOS", "SUJIDADE"
            ],
            "QUALIDADE": [
                "INSPEÇÃO DE LINHA"
            ]
        };
    }

    function getGroupedDowntimeReasons() {
        if (window.databaseModule && window.databaseModule.groupedDowntimeReasons) {
            return window.databaseModule.groupedDowntimeReasons;
        }
        return {
            "FERRAMENTARIA": ["CORRETIVA DE MOLDE", "PREVENTIVA DE MOLDE", "TROCA DE VERSÃO"],
            "PROCESSO": ["ABERTURA DE CAVIDADE", "AJUSTE DE PROCESSO", "FECHAMENTO DE CAVIDADE", "TRY OUT","PRENDENDO GALHO", "PRENDENDO PEÇAS"],
            "COMPRAS": ["FALTA DE MATÉRIA PRIMA","FALTA DE SACO PLÁSTICO", "FALTA DE CAIXA DE PAPELÃO","FALTA DE MASTER", "ANÁLISE ADMINISTRATIVA", "LEAD TIME"],
            "PREPARAÇÃO": ["AGUARDANDO PREPARAÇÃO DE MATERIAL", "AGUARDANDO ESTUFAGEM DE M.P", "FORA DE COR", "TESTE DE COR", "MATERIAL CONTAMINADO"],
            "QUALIDADE": ["AGUARDANDO CLIENTE/FORNECEDOR", "LIBERAÇÃO INÍCIAL","AGUARDANDO DISPOSIÇÃO DA QUALIDADE"],
            "MANUTENÇÃO": ["MANUTENÇÃO CORRETIVA", "MANUTENÇÃO PREVENTIVA", "MANUTENÇÃO EXTERNA"],
            "PRODUÇÃO": ["FALTA DE OPERADOR", "TROCA DE COR", "F.O REVEZAMENTO ALMOÇO", "F.O REVEZAMENTO JANTA","INICIO/REINICIO"],
            "SETUP": ["INSTALAÇÃO DE MOLDE", "RETIRADA DE MOLDE", "INSTALAÇÃO DE PERÍFÉRICOS", "AGUARDANDO SETUP"],
            "ADMINISTRATIVO": ["FALTA DE ENERGIA"],
            "PCP": ["SEM PROGRAMAÇÃO", "SEM PROGRAMAÇÃO-FIM DE SEMANA", "ESTRATÉGIA PCP" ],
            "COMERCIAL": ["SEM PEDIDO"],
            "OUTROS": ["VAZAMENTO DO BICO", "QUEIMA DE RESISTÊNCIA"],
            "HOKKAIDO": ["HOKKAIDO"]
        };
    }
    
    // Função para obter a categoria de um motivo de parada
    function getDowntimeCategory(reason) {
        if (!reason) return 'OUTROS';
        const reasonUpper = reason.trim().toUpperCase();
        const grouped = getGroupedDowntimeReasons();
        
        for (const [category, reasons] of Object.entries(grouped)) {
            const reasonsUpper = reasons.map(r => r.toUpperCase());
            if (reasonsUpper.includes(reasonUpper)) {
                return category;
            }
        }
        return 'OUTROS';
    }

    function populateLossOptions() {
        const perdasSelect = document.getElementById('production-entry-perdas');
        if (!perdasSelect) return;
        
        const groupedReasons = getGroupedLossReasons();
        let options = '<option value="">Nenhum</option>';
        
        // Adicionar opções agrupadas
        Object.entries(groupedReasons).forEach(([group, reasons]) => {
            options += `<optgroup label="${group}">`;
            reasons.forEach(reason => {
                options += `<option value="${reason}">${reason}</option>`;
            });
            options += `</optgroup>`;
        });
        
        perdasSelect.innerHTML = options;
    }

    function showLoadingState(panel, isLoading, noData = false) {
        const loadingEl = document.getElementById(`${panel}-loading`);
        const noDataEl = document.getElementById(`${panel}-no-data`);
        const contentEl = panel === 'leader-panel' ? leaderLaunchPanel : 
                        panel === 'launch-panel' ? launchPanelContainer : 
                        panel === 'resumo' ? resumoContentContainer :
                        document.getElementById('dashboard-content');

        if (isLoading) {
            if (loadingEl) loadingEl.style.display = 'block';
            if (noDataEl) noDataEl.style.display = 'none';
            if (contentEl) contentEl.style.display = 'none';
        } else {
            if (loadingEl) loadingEl.style.display = 'none';
            if (noData) {
                if (noDataEl) noDataEl.style.display = 'block';
                if (contentEl) contentEl.style.display = 'none';
            } else {
                if (noDataEl) noDataEl.style.display = 'none';
                if (contentEl) {
                    if (panel.includes('dashboard') || panel.includes('resumo') || panel.includes('list')) {
                        contentEl.style.display = 'block';
                    } else {
                        contentEl.style.display = 'grid';
                    }
                }
            }
        }
    }

    function showConfirmModal(id, collection) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir registros');
            return;
        }
        
        docIdToDelete = id;
        collectionToDelete = collection;
        try { console.log('[TRACE][showConfirmModal] target', { id, collection }); } catch(e) { /* noop */ }

        let message = 'Tem a certeza de que deseja excluir este lançamento? Esta ação não pode ser desfeita.';
        if (collection === 'downtime_entries') {
            message = 'Tem a certeza de que deseja excluir este registro de parada? Esta ação não pode ser desfeita.';
        } else if (collection === 'planning') {
            message = 'Tem a certeza de que deseja excluir este planejamento? Todos os lançamentos de produção associados também serão removidos.';
        }

        // Usar confirm nativo para garantir que o usuário consiga confirmar mesmo se o modal customizado falhar
        const userConfirmed = window.confirm(message);
        if (userConfirmed) {
            executeDelete();
        } else {
            hideConfirmModal();
        }
    }
    
    function hideConfirmModal() {
        docIdToDelete = null;
        collectionToDelete = null;
        if (confirmModal) confirmModal.classList.add('hidden');
    }
    
    async function executeDelete() {
        try { console.log('[TRACE][executeDelete] called', { docIdToDelete, collectionToDelete }); } catch(e){}
        if (!docIdToDelete || !collectionToDelete) {
            try { console.warn('[TRACE][executeDelete] missing target', { docIdToDelete, collectionToDelete }); } catch(e){}
            return;
        }
        
        const docRef = db.collection(collectionToDelete).doc(docIdToDelete);

        try {
            console.log('[TRACE][executeDelete] deleting', { id: docIdToDelete, collection: collectionToDelete });
            
            // 🔄 CRÍTICO: Se for production_entries, subtrair o valor da OP antes de excluir
            if (collectionToDelete === 'production_entries') {
                const entryDoc = await docRef.get();
                if (entryDoc.exists) {
                    const entryData = entryDoc.data();
                    const produzido = coerceToNumber(entryData.produzido || entryData.produced || entryData.quantity, 0);
                    const orderId = entryData.orderId || entryData.order_id;
                    const planId = entryData.planId;
                    
                    console.log('[SYNC-DELETE] Subtraindo produção da OP:', { produzido, orderId, planId });
                    
                    // Subtrair da OP (production_orders)
                    if (orderId && produzido > 0) {
                        try {
                            const orderRef = db.collection('production_orders').doc(orderId);
                            const orderSnap = await orderRef.get();
                            if (orderSnap.exists) {
                                const orderData = orderSnap.data() || {};
                                const currentTotal = coerceToNumber(orderData.total_produzido ?? orderData.totalProduced, 0);
                                const newTotal = Math.max(0, currentTotal - produzido);
                                await orderRef.update({
                                    total_produzido: newTotal,
                                    totalProduced: newTotal,
                                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                                });
                                console.log(`[SYNC-DELETE] OP ${orderId} atualizada: total_produzido ${currentTotal} → ${newTotal}`);
                            }
                        } catch (orderErr) {
                            console.warn('[SYNC-DELETE] Falha ao atualizar total da OP:', orderErr);
                        }
                    }
                    
                    // Subtrair do planejamento também
                    if (planId && produzido > 0) {
                        try {
                            const planRef = db.collection('planning').doc(planId);
                            const planSnap = await planRef.get();
                            if (planSnap.exists) {
                                const planData = planSnap.data() || {};
                                const currentPlanTotal = coerceToNumber(planData.total_produzido, 0);
                                const newPlanTotal = Math.max(0, currentPlanTotal - produzido);
                                await planRef.update({
                                    total_produzido: newPlanTotal,
                                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                                });
                                console.log(`[SYNC-DELETE] Plano ${planId} atualizado: total_produzido ${currentPlanTotal} → ${newPlanTotal}`);
                            }
                        } catch (planErr) {
                            console.warn('[SYNC-DELETE] Falha ao atualizar total do plano:', planErr);
                        }
                    }
                }
            }
            
            if (collectionToDelete === 'planning') {
                const prodEntriesSnapshot = await db.collection('production_entries').where('planId', '==', docIdToDelete).get();
                const batch = db.batch();
                prodEntriesSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
            }

            await docRef.delete();
            try { showNotification('Item excluído com sucesso.', 'success'); } catch(e) { /* noop */ }
            
            // Registrar log da exclusão
            registrarLogSistema('EXCLUSÃO DE REGISTRO', collectionToDelete, {
                docId: docIdToDelete,
                collection: collectionToDelete
            });
            
            if (pageTitle && pageTitle.textContent === 'Análise' && currentAnalysisView === 'resumo') {
                loadResumoData();
            }

            if (collectionToDelete === 'production_entries' || collectionToDelete === 'downtime_entries' || collectionToDelete === 'rework_entries') {
                recentEntriesCache.delete(docIdToDelete);
                await loadRecentEntries(false);
                
                // 🔄 Recarregar ordens para atualizar os cards
                if (collectionToDelete === 'production_entries') {
                    productionOrdersCache = null; // Invalidar cache
                    // Se estiver na view de ordens, recarregar
                    if (currentAnalysisView === 'orders') {
                        await loadOrdersAnalysis();
                    }
                }
            }


        } catch (error) {
            console.error("Erro ao excluir: ", error);
            const code = error && (error.code || error.name) || '';
            const msg = code === 'permission-denied'
                ? 'Permissão negada para excluir este item. Verifique seu perfil de acesso.'
                : 'Não foi possível excluir o item e/ou seus dados associados.';
            try { showNotification(msg, 'error'); } catch(e) { /* noop */ }
            alert(msg);
        } finally {
            hideConfirmModal();
        }
    }

    // --- BANCO DE DADOS DE CAIXAS DE TARA ---
    const taraBoxesDatabase = {
        "H-01": { "peso": 0, "descricao": "caixa plastica" },
        "H-02": { "peso": 0, "descricao": "caixa plastica" },
        "H-03": { "peso": 0, "descricao": "caixa plastica" },
        "H-04": { "peso": 0, "descricao": "caixa plastica" },
        "H-05": { "peso": 0, "descricao": "caixa plastica" },
        "H-06": { "peso": 0, "descricao": "caixa plastica" },
        "H-07": { "peso": 0, "descricao": "caixa plastica" },
        "H-08": { "peso": 0, "descricao": "caixa plastica" },
        "H-09": { "peso": 0, "descricao": "caixa plastica" },
        "H-10": { "peso": 0, "descricao": "caixa plastica" },
        "H-11": { "peso": 0, "descricao": "caixa plastica" },
        "H-12": { "peso": 0, "descricao": "caixa plastica" },
        "H-13": { "peso": 0, "descricao": "caixa plastica" },
        "H-14": { "peso": 0, "descricao": "caixa plastica" },
        "H-15": { "peso": 0, "descricao": "caixa plastica" },
        "H-16": { "peso": 0, "descricao": "caixa plastica" },
        "H-17": { "peso": 0, "descricao": "caixa plastica" },
        "H-18": { "peso": 0, "descricao": "caixa plastica" },
        "H-19": { "peso": 0, "descricao": "caixa plastica" },
        "H-20": { "peso": 0, "descricao": "caixa plastica" },
        "H-26": { "peso": 0, "descricao": "caixa plastica" },
        "H-27": { "peso": 0, "descricao": "caixa plastica" },
        "H-28": { "peso": 0, "descricao": "caixa plastica" },
        "H-29": { "peso": 0, "descricao": "caixa plastica" },
        "H-30": { "peso": 0, "descricao": "caixa plastica" },
        "H-31": { "peso": 0, "descricao": "caixa plastica" },
        "H-32": { "peso": 0, "descricao": "caixa plastica" }
    };

    // --- FUNÇÕES DO NOVO SISTEMA DE LANÇAMENTOS POR HORA ---

    // Função para carregar lançamentos por hora
    async function loadHourlyEntries(planId, turno) {
        const entriesRef = db.collection('hourly_production_entries');
        const q = entriesRef.where('planId', '==', planId).where('turno', '==', turno);
        const querySnapshot = await q.get();
        
        const entriesContainer = document.getElementById('hourly-entries-container');
        if (!entriesContainer) return;
        
        entriesContainer.innerHTML = '';
        
        const hours = [
            '08:00', '09:00', '10:00', '11:00', '12:00',
            '13:00', '14:00', '15:00', '16:00', '17:00', '18:00',
            '19:00', '20:00', '21:00', '22:00', '23:00', '00:00',
            '01:00', '02:00', '03:00', '04:00', '05:00', '06:00', '07:00'
        ];
        
        const existingEntries = {};
        querySnapshot.forEach(doc => {
            const data = doc.data();
            existingEntries[data.hora] = { id: doc.id, ...data };
        });
        
        hours.forEach(hora => {
            const entry = existingEntries[hora] || { hora, peso_bruto: '', usar_tara: false, embalagem_fechada: '' };
            const entryElement = createHourlyEntryElement(entry, planId, turno);
            entriesContainer.appendChild(entryElement);
        });
        
        updateTotalCalculation();
        lucide.createIcons();
            // Atualizar aba de análise se estiver aberta
            await refreshAnalysisIfActive();
    }

    // Função para criar elemento de lançamento por hora
    function createHourlyEntryElement(entry, planId, turno) {
        const div = document.createElement('div');
        div.className = 'hourly-entry grid grid-cols-13 gap-2 items-center p-2 border-b text-sm';
        div.innerHTML = `
            <div class="col-span-2 font-medium">${entry.hora}</div>
            <div class="col-span-3">
                <input type="number" step="0.01" 
                       value="${entry.peso_bruto || ''}" 
                       placeholder="Peso bruto (kg)"
                       class="peso-bruto-input w-full p-1 border rounded"
                       data-hora="${entry.hora}">
            </div>
            <div class="col-span-2 flex items-center">
                <input type="checkbox" ${entry.usar_tara ? 'checked' : ''} 
                       class="usar-tara-checkbox mr-1"
                       data-hora="${entry.hora}">
                <span class="text-xs">Usar Tara</span>
            </div>
            <div class="col-span-2">
                <input type="number" 
                       value="${entry.embalagem_fechada || ''}" 
                       placeholder="Embalagens"
                       class="embalagem-fechada-input w-full p-1 border rounded"
                       data-hora="${entry.hora}">
            </div>
            <div class="col-span-3">
                <span class="pecas-calculadas text-sm font-semibold">0 peças</span>
            </div>
            <div class="col-span-1">
                ${entry.id ? 
                    `<button type="button" class="delete-hourly-entry text-red-600 hover:text-red-800" data-id="${entry.id}">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>` : 
                    ''
                }
            </div>
        `;
        return div;
    }

    // Função para buscar peso da peça do planejamento
    async function getPieceWeightFromPlan(planId) {
        try {
            const planDoc = await db.collection('planning').doc(planId).get();
            if (planDoc.exists) {
                return planDoc.data().piece_weight || 0;
            }
        } catch (error) {
            console.error("Erro ao buscar peso da peça:", error);
        }
        return 0;
    }

    // Função para calcular totais
    async function updateTotalCalculation() {
        const planId = document.getElementById('production-entry-plan-id').value;
        const pieceWeight = await getPieceWeightFromPlan(planId);
        const useTara = document.getElementById('use-tara-box').checked;
        const taraWeight = parseFloat(document.getElementById('tara-box-weight').value) || 0;
        
        let totalPesoLiquido = 0;
        let totalPecas = 0;
        
        // Calcular totais de cada hora
        document.querySelectorAll('.hourly-entry').forEach(entry => {
            const pesoBruto = parseFloat(entry.querySelector('.peso-bruto-input').value) || 0;
            const usarTara = entry.querySelector('.usar-tara-checkbox').checked;
            const embalagemFechada = parseInt(entry.querySelector('.embalagem-fechada-input').value) || 0;
            
            const pesoLiquido = usarTara && useTara ? 
                Math.max(0, pesoBruto - taraWeight) : pesoBruto;
            
            // Calcular peças: por peso + por embalagem fechada
            const pecasPorPeso = pieceWeight > 0 ? Math.round((pesoLiquido * 1000) / pieceWeight) : 0;
            const pecasPorEmbalagem = embalagemFechada; // Assumindo 1 embalagem = 1 peça
            
            const pecasTotal = pecasPorPeso + pecasPorEmbalagem;
            
            if (entry.querySelector('.pecas-calculadas')) {
                entry.querySelector('.pecas-calculadas').textContent = `${pecasTotal} peças`;
            }
            
            totalPesoLiquido += pesoLiquido;
            totalPecas += pecasTotal;
        });
        
        // Atualizar totais
        const totalPesoLiquidoEl = document.getElementById('total-peso-liquido');
        const totalPecasEl = document.getElementById('total-pecas');
        const produzidoInput = document.getElementById('production-entry-produzido');
        
        if (totalPesoLiquidoEl) totalPesoLiquidoEl.textContent = `${totalPesoLiquido.toFixed(3)} kg`;
        if (totalPecasEl) totalPecasEl.textContent = totalPecas.toLocaleString('pt-BR');
        if (produzidoInput) produzidoInput.value = totalPecas;
    }

    // Função para salvar lançamentos por hora
    async function saveHourlyEntries(planId, turno) {
        const entries = [];
        
        document.querySelectorAll('.hourly-entry').forEach(entry => {
            const hora = entry.querySelector('.peso-bruto-input').dataset.hora;
            const pesoBruto = parseFloat(entry.querySelector('.peso-bruto-input').value) || 0;
            const usarTara = entry.querySelector('.usar-tara-checkbox').checked;
            const embalagemFechada = parseInt(entry.querySelector('.embalagem-fechada-input').value) || 0;
            
            if (pesoBruto > 0 || embalagemFechada > 0) {
                entries.push({
                    planId,
                    turno,
                    hora,
                    peso_bruto: pesoBruto,
                    usar_tara: usarTara,
                    embalagem_fechada: embalagemFechada,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
        });
        
        // Salvar no Firestore
        const batch = db.batch();
        entries.forEach(entry => {
            const docRef = db.collection('hourly_production_entries').doc();
            batch.set(docRef, entry);
        });
        
        await batch.commit();
    }

    // --- INITIALIZATION ---
    function init() {
        // Verificar autenticação primeiro (com pequeno delay para garantir carregamento)
        setTimeout(() => {
            if (!window.authSystem || !window.authSystem.getCurrentUser()) {
                console.warn('⚠️ Autenticação não encontrada. Redirecionando para login...');
                window.location.href = 'login.html';
                return;
            }
            
            console.log('✅ Usuário autenticado. Inicializando interface...');
            
            // Atualizar interface com informações do usuário
            if (window.authSystem && typeof window.authSystem.updateUserInterface === 'function') {
                window.authSystem.updateUserInterface();
            }
            
            setTodayDate();
            restoreSidebarState();
            setupEventListeners();
            setupPlanningTab();
            setupProductionOrdersTab();
            setupLaunchTab();
            setupExtendedDowntimeTab();
            setupAnalysisTab();
            setupQualityTab();
            populateLossOptions();
            
            // Iniciar timer de atualização automática de paradas longas (a cada 30 min)
            startExtendedDowntimeAutoUpdate();
            
            // Inicializar dados básicos
            loadAnalysisMachines();
            populateQuickFormOptions();
            
            // Verificar se os elementos críticos existem
            setTimeout(() => {
                console.log('📍 Verificando elementos críticos...');
                console.log('machine-selector:', !!document.getElementById('machine-selector'));
                console.log('quick-production-form:', !!document.getElementById('quick-production-form'));
                console.log('quick-losses-form:', !!document.getElementById('quick-losses-form'));
                console.log('quick-downtime-form:', !!document.getElementById('quick-downtime-form'));
                console.log('btn-losses:', !!document.getElementById('btn-losses'));
                console.log('btn-downtime:', !!document.getElementById('btn-downtime'));
            }, 1000);
            
            if (productionModalForm && !document.getElementById('production-entry-plan-id')) {
                const planIdInput = document.createElement('input');
                planIdInput.type = 'hidden';
                planIdInput.id = 'production-entry-plan-id';
                planIdInput.name = 'planId';
                productionModalForm.prepend(planIdInput);
            }
            
            // Iniciar atualização automática de OEE em tempo real (a cada 30 minutos - otimizado para economizar quota)
            setInterval(updateRealTimeOeeData, 30 * 60 * 1000);
            
            // Iniciar atualização automática da timeline (a cada 10 minutos - otimizado para economizar quota)
            setInterval(updateTimelineIfVisible, 10 * 60 * 1000);
            
            // Atualizar imediatamente se estivermos na aba de dashboard ou análise
            setTimeout(updateRealTimeOeeData, 2000);
            
            // Adicionar listener para redimensionar gráficos
            window.addEventListener('resize', debounce(handleWindowResize, 250));
            
            // Final da inicialização - carregar aba de lançamento por padrão
            loadLaunchPanel();
            lucide.createIcons();
        }, 300); // Fim do setTimeout da autenticação
    }
    
    // Verificar se a aba está visível (otimização para não fazer refresh em background)
    function isPageVisible() {
        return document.visibilityState === 'visible';
    }
    
    // Função para atualizar dados de OEE em tempo real
    async function updateRealTimeOeeData() {
        try {
            // Otimização: Não atualizar se a aba não estiver visível
            if (!isPageVisible()) {
                console.log('[OEE] Aba não visível, pulando atualização');
                return;
            }
            
            // Verificar se estamos na aba de dashboard ou análise
            const currentPage = document.querySelector('.nav-btn.active')?.dataset.page;
            if (currentPage !== 'analise') {
                return;
            }
            
            // Verificar se estamos visualizando dados de hoje
            const today = getProductionDateString();
            const selectedDate = resumoDateSelector ? resumoDateSelector.value : today;
            
            if (selectedDate !== today) {
                return;
            }
            
            // Recarregar dados apenas se estiver na visualização atual
            const currentView = document.querySelector('.analysis-tab-btn.active')?.dataset.view;
            
            if (currentView === 'dashboard') {
                // Atualizar dados do dashboard sem mostrar loading
                const startDate = startDateSelector ? startDateSelector.value : today;
                const endDate = endDateSelector ? endDateSelector.value : today;
                
                if (startDate === today && endDate === today) {
                    const prodSnapshot = await db.collection('production_entries')
                        .where('data', '==', today)
                        .get();
                    const productions = prodSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    
                    if (productions.length > 0) {
                        const planIds = [...new Set(productions.map(p => p.planId))];
                        const plans = {};
                        
                        for (let i = 0; i < planIds.length; i += 10) {
                            const batchIds = planIds.slice(i, i + 10);
                            if (batchIds.length > 0) {
                                const planBatchSnapshot = await db.collection('planning')
                                    .where(firebase.firestore.FieldPath.documentId(), 'in', batchIds)
                                    .get();
                                planBatchSnapshot.docs.forEach(doc => {
                                    plans[doc.id] = doc.data();
                                });
                            }
                        }
                        
                        const combinedData = productions.filter(prod => plans[prod.planId])
                            .map(prod => ({ ...prod, ...plans[prod.planId] }));
                        
                        fullDashboardData = { perdas: combinedData };
                        processAndRenderDashboard(fullDashboardData);
                    }
                }
            } else if (currentView === 'resumo') {
                // Atualizar dados do resumo silenciosamente
                loadResumoData(false); // false = não mostrar loading
            }
            
        } catch (error) {
            console.error("Erro ao atualizar dados OEE em tempo real: ", error);
        }
    }
    
    // Função para configurar a aba de lançamento
    // Configuração da aba de análise avançada
    function setupAnalysisTab() {
        console.log('🔧 Configurando aba de análise...');
        
        // Event listeners para as abas de análise
        document.querySelectorAll('.analysis-tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const view = e.target.getAttribute('data-view');
                if (view) switchAnalysisView(view);
            });
        });

        // Event listeners para filtros
        const periodSelector = document.getElementById('analysis-period');
        const machineSelector = document.getElementById('analysis-machine');
        const applyFiltersBtn = document.getElementById('apply-analysis-filters');

        if (periodSelector) {
            periodSelector.addEventListener('change', (e) => {
                const customRange = document.getElementById('custom-date-range');
                if (e.target.value === 'custom') {
                    customRange.classList.remove('hidden');
                } else {
                    customRange.classList.add('hidden');
                }
            });
        }

        if (machineSelector) {
            machineSelector.addEventListener('change', updateAnalysisInfoPanel);
        }

        if (applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', applyAnalysisFilters);
        }

        // Event listeners para comparação
        const generateComparisonBtn = document.getElementById('generate-comparison');
        if (generateComparisonBtn) {
            generateComparisonBtn.addEventListener('click', generateComparison);
        }

        // Event listener para botão de teste
        const testChartsBtn = document.getElementById('test-charts-btn');
        if (testChartsBtn) {
            testChartsBtn.addEventListener('click', () => {
                console.log('🧪 [TEST] Teste manual iniciado');
                testAllCharts();
                diagnosticFirestoreData();
            });
        }

        const rateDayBtn = document.getElementById('production-rate-mode-day');
        const rateShiftBtn = document.getElementById('production-rate-mode-shift');
        if (rateDayBtn && rateShiftBtn) {
            rateDayBtn.addEventListener('click', () => {
                if (productionRateMode === 'day') return;
                productionRateMode = 'day';
                updateProductionRateToggle();
                updateProductionRateDisplay();
            });
            rateShiftBtn.addEventListener('click', () => {
                if (productionRateMode === 'shift') return;
                productionRateMode = 'shift';
                updateProductionRateToggle();
                updateProductionRateDisplay();
            });
            updateProductionRateToggle();
        }

        // Carregar dados iniciais
        loadAnalysisMachines();
        setAnalysisDefaultDates();
        
        // Executar diagnósticos
        diagnosticFirestoreData();
        
        // Carregar dados da view inicial (overview)
        setTimeout(() => {
            loadAnalysisData('overview');
            // Testar todos os gráficos após 2 segundos
            setTimeout(() => {
                testAllCharts();
            }, 2000);
        }, 100);
        
        console.log('✅ Aba de análise configurada');
    }

    // Função para trocar entre views de análise
    function switchAnalysisView(viewName) {
        // Atualizar botões - remover classes active
        document.querySelectorAll('.analysis-tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Adicionar classe active ao botão selecionado
        const activeBtn = document.querySelector(`.analysis-tab-btn[data-view="${viewName}"]`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        }

        // Mostrar/ocultar views
        document.querySelectorAll('.analysis-view').forEach(view => {
            view.classList.add('hidden');
        });
        
        const targetView = document.getElementById(`${viewName}-view`);
        if (targetView) {
            targetView.classList.remove('hidden');
            // Carregar dados específicos da view
            loadAnalysisData(viewName);
        }
    }

    // Função para aplicar filtros de análise
    async function applyAnalysisFilters() {
        const period = document.getElementById('analysis-period').value;
        const machine = document.getElementById('analysis-machine').value;
        const shift = document.getElementById('analysis-shift').value;
        
        const toIsoDate = (dateObj) => new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60000).toISOString().split('T')[0];
        let startDate, endDate;
        const workToday = getProductionDateString();
        const baseDate = new Date(`${workToday}T12:00:00`);
        
        switch (period) {
            case 'today':
                startDate = endDate = workToday;
                break;
            case 'yesterday':
                const yesterday = new Date(baseDate);
                yesterday.setDate(yesterday.getDate() - 1);
                startDate = endDate = toIsoDate(yesterday);
                break;
            case '7days':
                const week = new Date(baseDate);
                week.setDate(week.getDate() - 6);
                startDate = toIsoDate(week);
                endDate = workToday;
                break;
            case '30days':
                const month = new Date(baseDate);
                month.setDate(month.getDate() - 29);
                startDate = toIsoDate(month);
                endDate = workToday;
                break;
            case 'month':
                startDate = toIsoDate(new Date(baseDate.getFullYear(), baseDate.getMonth(), 1));
                endDate = workToday;
                break;
            case 'lastmonth':
                const lastMonth = new Date(baseDate.getFullYear(), baseDate.getMonth() - 1, 1);
                const lastMonthEnd = new Date(baseDate.getFullYear(), baseDate.getMonth(), 0);
                startDate = toIsoDate(lastMonth);
                endDate = toIsoDate(lastMonthEnd);
                break;
            case 'custom':
                startDate = document.getElementById('analysis-start-date').value;
                endDate = document.getElementById('analysis-end-date').value;
                break;
        }

        if (!startDate) startDate = workToday;
        if (!endDate) endDate = workToday;

        // Atualizar dados com filtros
        currentAnalysisFilters = { startDate, endDate, machine, shift };
        
        // Recarregar a view atual
        const activeView = document.querySelector('.analysis-tab-btn.active')?.getAttribute('data-view') || 'overview';
        loadAnalysisData(activeView);
    }

    // Função para carregar dados de análise
    async function loadAnalysisData(viewName = 'overview') {
        console.log('[TRACE][loadAnalysisData] start', { viewName, filters: currentAnalysisFilters });
        
        // Garantir que os filtros estejam inicializados
        if (!currentAnalysisFilters.startDate || !currentAnalysisFilters.endDate) {
            console.log('[TRACE][loadAnalysisData] initializing default filters');
            setAnalysisDefaultDates();
        }
        
        showAnalysisLoading(true);
        
        try {
            switch (viewName) {
                case 'overview':
                    await loadOverviewData();
                    break;
                case 'production':
                    await loadProductionAnalysis();
                    break;
                case 'efficiency':
                    await loadEfficiencyAnalysis();
                    break;
                case 'losses':
                    await loadLossesAnalysis();
                    break;
                case 'downtime':
                    await loadDowntimeAnalysis();
                    break;
                case 'comparative':
                    await loadComparativeAnalysis();
                    break;
                case 'orders':
                    await loadOrdersAnalysis();
                    break;
                case 'predictive':
                    await loadPredictiveAnalysis();
                    break;
            }
        } catch (error) {
            console.error('Erro ao carregar dados de análise:', error);
            showAnalysisError();
        } finally {
            showAnalysisLoading(false);
            console.log('[TRACE][loadAnalysisData] end', { viewName });
        }
    }

    function populateOrdersMachineFilter(orders) {
        // Popular filtro na aba Análises/Ordens
        const machineFilter = document.getElementById('analysis-orders-machine-filter');
        if (!machineFilter) return;

        // Preservar valor atual
        const currentValue = machineFilter.value;

        // Recriar opções usando machineDatabase (todas as máquinas do sistema)
        machineFilter.innerHTML = '<option value="">Todas as Máquinas</option>';
        
        if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
            machineDatabase.forEach(function(machine) {
                const mid = normalizeMachineId(machine.id);
                const option = document.createElement('option');
                option.value = mid;
                option.textContent = mid + ' - ' + machine.model;
                machineFilter.appendChild(option);
            });
        }

        // Restaurar valor anterior
        if (currentValue) machineFilter.value = currentValue;
    }

    function computeOrderExecutionMetrics(order, productionTotalsByOrderId) {
        const lotSize = coerceToNumber(order.lot_size, 0);
        const status = (order.status || '').toLowerCase();
        const isFinishedStatus = ['concluida', 'finalizada', 'encerrada'].includes(status);

        const aggregateTotals = productionTotalsByOrderId.get(order.id) || 0;
        const storedTotals = coerceToNumber(order.total_produzido ?? order.totalProduced, 0);

        // CORREÇÃO: Sempre usar o MAIOR valor entre armazenado e agregado
        // Isso garante que novos lançamentos após edição manual sejam contabilizados
        const totalProduced = Math.max(aggregateTotals, storedTotals, 0);

        const computedProgress = lotSize > 0
            ? Math.min((totalProduced / lotSize) * 100, 100)
            : 0;
        const progress = isFinishedStatus && computedProgress < 100 ? 100 : computedProgress;
        const remaining = isFinishedStatus
            ? 0
            : Math.max(0, lotSize - totalProduced);

        return {
            lotSize,
            totalProduced,
            progress,
            remaining,
            isComplete: isFinishedStatus || (lotSize > 0 && totalProduced >= lotSize),
            hasProduction: totalProduced > 0
        };
    }

    async function loadOrdersAnalysis() {
        console.log('📋 Carregando análise de ordens de produção');

        // Usar cache otimizado para reduzir leituras do Firebase
        let ordersDataset = Array.isArray(productionOrdersCache) ? [...productionOrdersCache] : [];

        if (ordersDataset.length === 0) {
            try {
                // Usar função cacheada para economizar leituras
                ordersDataset = await getProductionOrdersCached();
                productionOrdersCache = ordersDataset;
                console.log('📋 Ordens carregadas (cache/Firebase):', ordersDataset.length);
            } catch (error) {
                console.error('Erro ao recuperar ordens de produção para análise:', error);
            }
        } else {
            console.log('📋 Usando cache de ordens:', ordersDataset.length);
        }

        if (!ordersDataset || ordersDataset.length === 0) {
            console.warn('❌ Nenhuma ordem de produção encontrada.');
            showAnalysisNoData('Nenhuma ordem de produção cadastrada.');
            return;
        }

        const ordersGrid = document.getElementById('orders-grid');
        if (!ordersGrid) {
            console.error('❌ Elemento orders-grid não encontrado no DOM');
            return;
        }

        const startDateStr = currentAnalysisFilters.startDate;
        const endDateStr = currentAnalysisFilters.endDate;

        const normalizedOrders = ordersDataset.map(order => ({
            ...order,
            normalizedCode: String(order.part_code || order.product_cod || '').trim()
        }));

        // CORREÇÃO: Mapear produção por ID de ordem SEM filtro de data
        // Isso garante que o progresso exibido seja o mesmo dos cards de máquinas
        // Os valores são pegos diretamente do total_produzido armazenado na OP (atualizado a cada lançamento)
        // ou calculados a partir de TODOS os lançamentos da ordem (sem filtro de data)
        const productionTotalsByOrderId = new Map();

        try {
            // Buscar TODOS os lançamentos de produção (sem filtro de data)
            // para garantir consistência com os cards de máquinas
            const orderIds = normalizedOrders.map(o => o.id).filter(id => id);
            
            if (orderIds.length > 0) {
                // Buscar em lotes de 10 (limite do Firestore para 'in')
                const batchSize = 10;
                for (let i = 0; i < orderIds.length; i += batchSize) {
                    const batchIds = orderIds.slice(i, i + batchSize);
                    const productionSnapshot = await db.collection('production_entries')
                        .where('orderId', 'in', batchIds)
                        .get();

                    productionSnapshot.docs.forEach(doc => {
                        const data = doc.data();
                        const orderId = data.orderId || data.order_id;
                        
                        if (!orderId) return;

                        const producedQty = coerceToNumber(data.produzido ?? data.quantity, 0);
                        if (!Number.isFinite(producedQty) || producedQty <= 0) {
                            return;
                        }

                        productionTotalsByOrderId.set(
                            orderId,
                            (productionTotalsByOrderId.get(orderId) || 0) + producedQty
                        );
                    });
                }
            }
        } catch (error) {
            console.error('Erro ao carregar lançamentos para análise de ordens:', error);
        }

        // Preencher dropdown de máquinas com máquinas usadas nas ordens
        populateOrdersMachineFilter(normalizedOrders);

        const ordersWithProgress = normalizedOrders.map(order => {
            const metrics = computeOrderExecutionMetrics(order, productionTotalsByOrderId);
            return { ...order, ...metrics };
        });

        // Aplicar filtros de status, máquina e pesquisa
        const ordersStatusFilter = document.getElementById('orders-status-filter')?.value || '';
        const ordersMachineFilter = document.getElementById('analysis-orders-machine-filter')?.value || '';
        const ordersSearchQuery = document.getElementById('orders-search')?.value.toLowerCase() || '';
        const ordersSortValue = document.getElementById('orders-sort-filter')?.value || 'recent';

        let filteredOrders = ordersWithProgress;

        // Filtro por status
        if (ordersStatusFilter) {
            filteredOrders = filteredOrders.filter(order => {
                const status = (order.status || '').toLowerCase();
                if (ordersStatusFilter === 'planejada') return status === 'planejada';
                if (ordersStatusFilter === 'em_andamento') return status === 'em_andamento';
                if (ordersStatusFilter === 'ativa') return status === 'ativa';
                if (ordersStatusFilter === 'concluida') return status === 'concluida' || status === 'finalizada';
                if (ordersStatusFilter === 'cancelada') return status === 'cancelada';
                return true;
            });
        }

        // Filtro por máquina
        if (ordersMachineFilter) {
            filteredOrders = filteredOrders.filter(order => {
                return order.machine_id === ordersMachineFilter;
            });
        }

        // Filtro de busca
        if (ordersSearchQuery) {
            filteredOrders = filteredOrders.filter(order => 
                (order.order_number || '').toLowerCase().includes(ordersSearchQuery) ||
                (order.product || '').toLowerCase().includes(ordersSearchQuery) ||
                (order.part_code || '').toLowerCase().includes(ordersSearchQuery) ||
                (order.customer || '').toLowerCase().includes(ordersSearchQuery)
            );
        }

        // Ordenação
        filteredOrders.sort((a, b) => {
            switch (ordersSortValue) {
                case 'recent':
                    const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt) || new Date(0);
                    const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt) || new Date(0);
                    return dateB - dateA;
                case 'oldest':
                    const dateA2 = a.createdAt?.toDate?.() || new Date(a.createdAt) || new Date(0);
                    const dateB2 = b.createdAt?.toDate?.() || new Date(b.createdAt) || new Date(0);
                    return dateA2 - dateB2;
                case 'progress-desc':
                    return (b.progress || 0) - (a.progress || 0);
                case 'progress-asc':
                    return (a.progress || 0) - (b.progress || 0);
                case 'lot-desc':
                    return (Number(b.lot_size) || 0) - (Number(a.lot_size) || 0);
                case 'lot-asc':
                    return (Number(a.lot_size) || 0) - (Number(b.lot_size) || 0);
                case 'alpha':
                case 'name-asc':
                    return (a.order_number || '').localeCompare(b.order_number || '');
                default:
                    return 0;
            }
        });

        // ===== ATUALIZAR KPIs =====
        const totalOrders = ordersWithProgress.length;
        const activeOrders = ordersWithProgress.filter(o => ['ativa', 'em_andamento'].includes((o.status || '').toLowerCase())).length;
        const completedOrders = ordersWithProgress.filter(o => ['concluida', 'finalizada'].includes((o.status || '').toLowerCase())).length;
        const avgProgress = totalOrders > 0 
            ? Math.round(ordersWithProgress.reduce((sum, o) => sum + (o.progress || 0), 0) / totalOrders)
            : 0;

        // Atualizar elementos KPI no DOM
        const kpiTotal = document.getElementById('orders-kpi-total');
        const kpiActive = document.getElementById('orders-kpi-active');
        const kpiCompleted = document.getElementById('orders-kpi-completed');
        const kpiProgress = document.getElementById('orders-kpi-avg-progress');

        if (kpiTotal) kpiTotal.textContent = totalOrders.toLocaleString('pt-BR');
        if (kpiActive) kpiActive.textContent = activeOrders.toLocaleString('pt-BR');
        if (kpiCompleted) kpiCompleted.textContent = completedOrders.toLocaleString('pt-BR');
        if (kpiProgress) kpiProgress.textContent = `${avgProgress}%`;

        // ===== GERAR CARDS DE ORDENS =====
        const ordersHtml = filteredOrders.map(order => {
            const progressPercent = Math.min(order.progress || 0, 100);
            const progressColor = progressPercent >= 100 ? 'bg-emerald-500' : progressPercent >= 70 ? 'bg-blue-500' : progressPercent >= 40 ? 'bg-amber-500' : 'bg-red-500';
            const progressRingColor = progressPercent >= 100 ? 'text-emerald-500' : progressPercent >= 70 ? 'text-blue-500' : progressPercent >= 40 ? 'text-amber-500' : 'text-red-500';
            const lotSizeNumeric = Number(order.lot_size) || 0;
            const status = (order.status || '').toLowerCase();

            // Mapa de cores para status
            const statusColorMap = {
                'planejada': { badge: 'bg-slate-100 text-slate-600 border border-slate-300', icon: 'calendar', label: 'Planejada' },
                'em_andamento': { badge: 'bg-amber-100 text-amber-700 border border-amber-300', icon: 'play-circle', label: 'Em Andamento' },
                'ativa': { badge: 'bg-blue-100 text-blue-700 border border-blue-300', icon: 'zap', label: 'Ativa' },
                'concluida': { badge: 'bg-emerald-100 text-emerald-700 border border-emerald-300', icon: 'check-circle-2', label: 'Concluída' },
                'finalizada': { badge: 'bg-emerald-100 text-emerald-700 border border-emerald-300', icon: 'check-circle-2', label: 'Finalizada' },
                'cancelada': { badge: 'bg-red-100 text-red-700 border border-red-300', icon: 'x-circle', label: 'Cancelada' }
            };

            const statusDisplay = statusColorMap[status] || statusColorMap['planejada'];
            const isActive = status === 'ativa' || status === 'em_andamento';

            // Buscar modelo da máquina
            const machineInfo = window.databaseModule?.machineById?.get(order.machine_id);
            const machineLabel = machineInfo ? `${order.machine_id} - ${machineInfo.model}` : (order.machine_id || 'N/A');

            // Data de criação formatada
            const createdDate = order.createdAt?.toDate?.() || new Date(order.createdAt);
            const formattedDate = createdDate instanceof Date && !isNaN(createdDate) 
                ? createdDate.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' })
                : '';

            // Verificar se pode reativar
            const isReactivatable = ['concluida','finalizada','encerrada'].includes(status);

            return `
                <div class="group bg-white rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 border border-gray-100 overflow-hidden ${isActive ? 'ring-2 ring-blue-400 ring-offset-1' : ''}">
                    <!-- Header do Card -->
                    <div class="p-4 border-b border-gray-50 bg-gradient-to-r ${isActive ? 'from-blue-50 to-white' : 'from-gray-50 to-white'}">
                        <div class="flex items-start justify-between gap-2">
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center gap-2">
                                    <span class="text-lg font-bold text-gray-800 truncate">${escapeHtml(order.order_number)}</span>
                                    ${formattedDate ? `<span class="text-xs text-gray-400">${formattedDate}</span>` : ''}
                                </div>
                                <p class="text-sm text-gray-600 truncate mt-0.5" title="${escapeHtml(order.product || '')}">${escapeHtml(order.product || 'Produto não especificado')}</p>
                            </div>
                            <span class="flex-shrink-0 inline-flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium ${statusDisplay.badge}">
                                <i data-lucide="${statusDisplay.icon}" class="w-3 h-3"></i>
                                ${statusDisplay.label}
                            </span>
                        </div>
                    </div>

                    <!-- Corpo do Card -->
                    <div class="p-4">
                        <!-- Informações principais em grid compacto -->
                        <div class="grid grid-cols-2 gap-3 text-sm mb-4">
                            <div class="flex items-center gap-2">
                                <i data-lucide="user" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(order.customer || '')}">${escapeHtml(order.customer || 'N/A')}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <i data-lucide="cog" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(machineLabel)}">${escapeHtml(machineLabel)}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <i data-lucide="hash" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(order.part_code || '')}">${escapeHtml(order.part_code || 'N/A')}</span>
                            </div>
                            ${order.raw_material ? `
                            <div class="flex items-center gap-2">
                                <i data-lucide="package" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(order.raw_material)}">${escapeHtml(order.raw_material)}</span>
                            </div>
                            ` : '<div></div>'}
                        </div>

                        <!-- Progresso Visual -->
                        <div class="bg-gray-50 rounded-lg p-3">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-medium text-gray-500 uppercase tracking-wide">Progresso da OP</span>
                                <span class="text-sm font-bold ${progressRingColor}">${Math.round(progressPercent)}%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                <div class="${progressColor} h-2 rounded-full transition-all duration-500" style="width: ${progressPercent}%"></div>
                            </div>
                            <div class="flex justify-between text-xs text-gray-500">
                                <span><strong class="text-emerald-600">${order.totalProduced.toLocaleString('pt-BR')}</strong> produzido</span>
                                <span><strong class="text-gray-700">${lotSizeNumeric.toLocaleString('pt-BR')}</strong> planejado</span>
                            </div>
                            ${order.remaining > 0 ? `<div class="text-center mt-1 text-xs text-amber-600">Faltam <strong>${order.remaining.toLocaleString('pt-BR')}</strong> un</div>` : ''}
                        </div>
                    </div>

                    <!-- Footer com Ações -->
                    <div class="px-4 pb-4 flex gap-2">
                        ${status === 'planejada' ? `
                        <button class="activate-order-btn flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg font-medium text-sm transition-colors" data-order-id="${order.id}" data-machine-id="${order.machine_id || ''}">
                            <i data-lucide="play" class="w-4 h-4"></i>
                            Ativar
                        </button>
                        ` : ''}
                        ${isReactivatable ? `
                        <button class="reactivate-order-btn flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium text-sm transition-colors" data-order-id="${order.id}">
                            <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                            Reativar
                        </button>
                        ` : ''}
                        <button class="edit-order-btn ${(status === 'planejada' || isReactivatable) ? 'flex-1' : 'w-full'} flex items-center justify-center gap-1.5 px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg font-medium text-sm transition-colors" data-order-id="${order.id}">
                            <i data-lucide="edit-3" class="w-4 h-4"></i>
                            Editar
                        </button>
                    </div>
                </div>
            `;
        }).join('');

        if (filteredOrders.length === 0) {
            ordersGrid.innerHTML = `
                <div class="col-span-full flex flex-col items-center justify-center py-16">
                    <div class="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mb-4">
                        <i data-lucide="inbox" class="w-8 h-8 text-gray-400"></i>
                    </div>
                    <h3 class="text-lg font-medium text-gray-700 mb-1">Nenhuma ordem encontrada</h3>
                    <p class="text-sm text-gray-500">Tente ajustar os filtros de busca</p>
                </div>
            `;
        } else {
            ordersGrid.innerHTML = ordersHtml;
        }

        try {
            lucide.createIcons();
        } catch (iconError) {
            console.warn('Falha ao renderizar ícones lucide na aba de ordens:', iconError);
        }

        const noDataContainer = document.getElementById('analysis-no-data');
        if (filteredOrders.length > 0 && noDataContainer) {
            noDataContainer.classList.add('hidden');
        }

        // Configurar event listeners para filtros
        const ordersStatusFilterBtn = document.getElementById('orders-status-filter');
        const ordersMachineFilterBtn = document.getElementById('analysis-orders-machine-filter');
        const ordersSearchInput = document.getElementById('orders-search');
        const ordersSortSelect = document.getElementById('orders-sort-filter');
        const ordersClearFiltersBtn = document.getElementById('orders-clear-filters');
        const ordersRefreshBtn = document.getElementById('orders-refresh-btn');
        const ordersResultsCount = document.getElementById('orders-results-count');
        
        // Atualizar contador de resultados
        if (ordersResultsCount) {
            ordersResultsCount.textContent = `${filteredOrders.length} ordem${filteredOrders.length !== 1 ? 'ns' : ''} encontrada${filteredOrders.length !== 1 ? 's' : ''}`;
        }
        
        if (ordersStatusFilterBtn && !ordersStatusFilterBtn.dataset.listenerAttached) {
            ordersStatusFilterBtn.addEventListener('change', () => loadOrdersAnalysis());
            ordersStatusFilterBtn.dataset.listenerAttached = 'true';
        }

        if (ordersMachineFilterBtn && !ordersMachineFilterBtn.dataset.listenerAttached) {
            ordersMachineFilterBtn.addEventListener('change', () => loadOrdersAnalysis());
            ordersMachineFilterBtn.dataset.listenerAttached = 'true';
        }
        
        if (ordersSearchInput && !ordersSearchInput.dataset.listenerAttached) {
            ordersSearchInput.addEventListener('input', debounce(() => loadOrdersAnalysis(), 300));
            ordersSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    loadOrdersAnalysis();
                }
            });
            ordersSearchInput.dataset.listenerAttached = 'true';
        }

        // Botão de busca explícito
        const ordersSearchBtn = document.getElementById('orders-search-btn');
        if (ordersSearchBtn && !ordersSearchBtn.dataset.listenerAttached) {
            ordersSearchBtn.addEventListener('click', () => loadOrdersAnalysis());
            ordersSearchBtn.dataset.listenerAttached = 'true';
        }

        if (ordersSortSelect && !ordersSortSelect.dataset.listenerAttached) {
            ordersSortSelect.addEventListener('change', () => loadOrdersAnalysis());
            ordersSortSelect.dataset.listenerAttached = 'true';
        }

        if (ordersClearFiltersBtn && !ordersClearFiltersBtn.dataset.listenerAttached) {
            ordersClearFiltersBtn.addEventListener('click', () => {
                if (ordersStatusFilterBtn) ordersStatusFilterBtn.value = '';
                if (ordersMachineFilterBtn) ordersMachineFilterBtn.value = '';
                if (ordersSearchInput) ordersSearchInput.value = '';
                if (ordersSortSelect) ordersSortSelect.value = 'recent';
                loadOrdersAnalysis();
            });
            ordersClearFiltersBtn.dataset.listenerAttached = 'true';
        }

        if (ordersRefreshBtn && !ordersRefreshBtn.dataset.listenerAttached) {
            ordersRefreshBtn.addEventListener('click', async () => {
                productionOrdersCache = null;
                await loadOrdersAnalysis();
                showNotification('Ordens atualizadas!', 'success');
            });
            ordersRefreshBtn.dataset.listenerAttached = 'true';
        }

        // Toggle de visualização Grid/Lista
        const ordersViewGrid = document.getElementById('orders-view-grid');
        const ordersViewList = document.getElementById('orders-view-list');
        const ordersListContainer = document.getElementById('orders-list');
        
        if (ordersViewGrid && !ordersViewGrid.dataset.listenerAttached) {
            ordersViewGrid.addEventListener('click', () => {
                ordersGrid.classList.remove('hidden');
                if (ordersListContainer) ordersListContainer.classList.add('hidden');
                ordersViewGrid.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                ordersViewGrid.classList.remove('text-gray-500');
                if (ordersViewList) {
                    ordersViewList.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                    ordersViewList.classList.add('text-gray-500');
                }
            });
            ordersViewGrid.dataset.listenerAttached = 'true';
        }

        if (ordersViewList && !ordersViewList.dataset.listenerAttached) {
            ordersViewList.addEventListener('click', () => {
                ordersGrid.classList.add('hidden');
                if (ordersListContainer) {
                    ordersListContainer.classList.remove('hidden');
                    populateOrdersListView(filteredOrders);
                }
                ordersViewList.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                ordersViewList.classList.remove('text-gray-500');
                if (ordersViewGrid) {
                    ordersViewGrid.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                    ordersViewGrid.classList.add('text-gray-500');
                }
            });
            ordersViewList.dataset.listenerAttached = 'true';
        }

        // Função para preencher view de lista (tabela)
        function populateOrdersListView(orders) {
            const listBody = document.getElementById('orders-list-body');
            if (!listBody) return;

            const statusColorMap = {
                'planejada': { badge: 'bg-slate-100 text-slate-600', label: 'Planejada' },
                'em_andamento': { badge: 'bg-amber-100 text-amber-700', label: 'Em Andamento' },
                'ativa': { badge: 'bg-blue-100 text-blue-700', label: 'Ativa' },
                'concluida': { badge: 'bg-emerald-100 text-emerald-700', label: 'Concluída' },
                'finalizada': { badge: 'bg-emerald-100 text-emerald-700', label: 'Finalizada' },
                'cancelada': { badge: 'bg-red-100 text-red-700', label: 'Cancelada' }
            };

            listBody.innerHTML = orders.map(order => {
                const status = (order.status || '').toLowerCase();
                const statusDisplay = statusColorMap[status] || statusColorMap['planejada'];
                const progressPercent = Math.min(order.progress || 0, 100);
                const progressColor = progressPercent >= 100 ? 'bg-emerald-500' : progressPercent >= 70 ? 'bg-blue-500' : progressPercent >= 40 ? 'bg-amber-500' : 'bg-red-500';
                const lotSize = Number(order.lot_size) || 0;
                const machineInfo = window.databaseModule?.machineById?.get(order.machine_id);
                const machineLabel = machineInfo ? `${order.machine_id}` : (order.machine_id || 'N/A');

                return `
                    <tr class="hover:bg-gray-50 transition-colors">
                        <td class="px-4 py-3 text-sm font-semibold text-gray-800">${escapeHtml(order.order_number)}</td>
                        <td class="px-4 py-3 text-sm text-gray-600 max-w-xs truncate" title="${escapeHtml(order.product || '')}">${escapeHtml(order.product || 'N/A')}</td>
                        <td class="px-4 py-3 text-sm text-gray-600">${escapeHtml(machineLabel)}</td>
                        <td class="px-4 py-3">
                            <span class="inline-flex px-2 py-1 rounded-full text-xs font-medium ${statusDisplay.badge}">${statusDisplay.label}</span>
                        </td>
                        <td class="px-4 py-3">
                            <div class="flex items-center gap-2">
                                <div class="flex-1 bg-gray-200 rounded-full h-2 w-20">
                                    <div class="${progressColor} h-2 rounded-full" style="width: ${progressPercent}%"></div>
                                </div>
                                <span class="text-xs font-medium text-gray-600">${Math.round(progressPercent)}%</span>
                            </div>
                        </td>
                        <td class="px-4 py-3 text-sm text-right font-medium text-emerald-600">${order.totalProduced.toLocaleString('pt-BR')}</td>
                        <td class="px-4 py-3 text-sm text-right text-gray-600">${lotSize.toLocaleString('pt-BR')}</td>
                        <td class="px-4 py-3 text-center">
                            <button class="edit-order-btn p-1.5 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" data-order-id="${order.id}" title="Editar">
                                <i data-lucide="edit-3" class="w-4 h-4"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');

            lucide.createIcons();

            // Re-attach listeners para botões de edição na lista
            listBody.querySelectorAll('.edit-order-btn').forEach(btn => {
                if (!btn.dataset.listenerAttached) {
                    btn.addEventListener('click', async () => {
                        const orderId = btn.getAttribute('data-order-id');
                        if (!orderId) return;
                        // Simular click no botão do grid
                        const gridBtn = document.querySelector(`.edit-order-btn[data-order-id="${orderId}"]`);
                        if (gridBtn) gridBtn.click();
                    });
                    btn.dataset.listenerAttached = 'true';
                }
            });
        }

        lucide.createIcons();

        // Adicionar event listener para botões de reativação
        document.querySelectorAll('.reactivate-order-btn').forEach(btn => {
            if (!btn.dataset.listenerAttached) {
                btn.addEventListener('click', async (e) => {
                    const orderId = btn.getAttribute('data-order-id');
                    if (!orderId) return;
                    if (!confirm('Deseja realmente reativar esta ordem? Ela voltará ao status ATIVA.')) return;
                    try {
                        await db.collection('production_orders').doc(orderId).update({ status: 'ativa' });
                        showNotification('Ordem reativada com sucesso!', 'success');
                        await loadOrdersAnalysis();
                    } catch (err) {
                        showNotification('Erro ao reativar ordem. Tente novamente.', 'error');
                        console.error('Erro ao reativar ordem:', err);
                    }
                });
                btn.dataset.listenerAttached = 'true';
            }
        });

        // Adicionar event listener para botões de ativação (ordens planejadas)
        document.querySelectorAll('.activate-order-btn').forEach(btn => {
            if (!btn.dataset.listenerAttached) {
                btn.addEventListener('click', async (e) => {
                    const orderId = btn.getAttribute('data-order-id');
                    const machineId = btn.getAttribute('data-machine-id');
                    if (!orderId) return;
                    
                    // Verificar se há máquina definida
                    if (!machineId) {
                        showNotification('Esta ordem não tem máquina definida. Edite a ordem e selecione uma máquina primeiro.', 'warning');
                        return;
                    }
                    
                    if (!confirm(`Deseja ativar esta ordem na máquina ${machineId}?`)) return;
                    
                    try {
                        // Atualizar status para ativa
                        await db.collection('production_orders').doc(orderId).update({ 
                            status: 'ativa',
                            activatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        showNotification('Ordem ativada com sucesso!', 'success');

                        // Registrar no histórico do sistema
                        if (typeof logSystemAction === 'function') {
                            logSystemAction('ordem_ativada', `Ordem ${orderId} ativada`, {
                                maquina: machineId,
                                orderId: orderId
                            });
                        }
                        
                        // Atualizar cache e recarregar
                        productionOrdersCache = null;
                        await loadOrdersAnalysis();
                    } catch (err) {
                        showNotification('Erro ao ativar ordem. Tente novamente.', 'error');
                        console.error('Erro ao ativar ordem:', err);
                    }
                });
                btn.dataset.listenerAttached = 'true';
            }
        });

        // Adicionar event listener para botões de edição
        document.querySelectorAll('.edit-order-btn').forEach(btn => {
            if (!btn.dataset.listenerAttached) {
                btn.addEventListener('click', async (e) => {
                    const orderId = btn.getAttribute('data-order-id');
                    if (!orderId) return;
                    // Buscar dados da ordem
                    let orderData = null;
                    if (Array.isArray(productionOrdersCache)) {
                        orderData = productionOrdersCache.find(o => o.id === orderId);
                    }
                    if (!orderData) {
                        try {
                            const doc = await db.collection('production_orders').doc(orderId).get();
                            if (doc.exists) orderData = { id: doc.id, ...doc.data() };
                        } catch (err) { orderData = null; }
                    }
                    if (!orderData) {
                        showNotification('Ordem não encontrada.', 'error');
                        return;
                    }
                    // Preencher campos do modal
                    document.getElementById('edit-order-id').value = orderData.id;
                    // Preencher select de produtos
                    const productSelect = document.getElementById('edit-order-product');
                    productSelect.innerHTML = '';
                    if (window.databaseModule && window.databaseModule.productByCode) {
                        const products = Array.from(window.databaseModule.productByCode.values());
                        products.forEach(prod => {
                            const opt = document.createElement('option');
                            opt.value = prod.cod;
                            opt.textContent = `${prod.cod} - ${prod.name} (${prod.client})`;
                            if ((orderData.product_cod || orderData.part_code || orderData.product) == prod.cod || orderData.product == prod.name) opt.selected = true;
                            productSelect.appendChild(opt);
                        });
                    } else {
                        const opt = document.createElement('option');
                        opt.value = orderData.product || '';
                        opt.textContent = orderData.product || '';
                        opt.selected = true;
                        productSelect.appendChild(opt);
                    }

                    // Preencher select de máquinas
                    const machineSelect = document.getElementById('edit-order-machine');
                    machineSelect.innerHTML = '';
                    if (window.databaseModule && window.databaseModule.machineById) {
                        const machines = Array.from(window.databaseModule.machineById.values());
                        machines.forEach(mac => {
                            const opt = document.createElement('option');
                            opt.value = mac.id;
                            opt.textContent = `${mac.id} - ${mac.model}`;
                            if ((orderData.machine_id || orderData.machine) == mac.id) opt.selected = true;
                            machineSelect.appendChild(opt);
                        });
                    } else {
                        const opt = document.createElement('option');
                        opt.value = orderData.machine_id || orderData.machine || '';
                        opt.textContent = orderData.machine_id || orderData.machine || '';
                        opt.selected = true;
                        machineSelect.appendChild(opt);
                    }

                    document.getElementById('edit-order-customer').value = orderData.customer || orderData.client || '';
                    document.getElementById('edit-order-lot').value = orderData.lot || orderData.lot_size || '';
                    document.getElementById('edit-order-planned').value = orderData.lot_size || '';
                    document.getElementById('edit-order-executed').value = orderData.total_produzido || orderData.totalProduced || '';
                    
                    // Mostrar info de última edição
                    const lastAdj = orderData.lastManualAdjustment;
                    if (lastAdj && lastAdj.editedByName) {
                        const adjTime = lastAdj.timestamp?.toDate?.() || new Date();
                        const timeStr = adjTime.toLocaleString('pt-BR');
                        console.log(`[EDIT-ORDER] Última edição: ${lastAdj.editedByName} em ${timeStr}`);
                    }
                    
                    document.getElementById('edit-order-modal').classList.remove('hidden');
                });
                btn.dataset.listenerAttached = 'true';
            }
        });
// Modal de edição de ordem
document.getElementById('close-edit-order-modal').onclick = () => {
    document.getElementById('edit-order-modal').classList.add('hidden');
};
document.getElementById('cancel-edit-order').onclick = () => {
    document.getElementById('edit-order-modal').classList.add('hidden');
};
document.getElementById('edit-order-form').onsubmit = async function(e) {
    e.preventDefault();
    const id = document.getElementById('edit-order-id').value;
    const product = document.getElementById('edit-order-product').value;
    const machine = document.getElementById('edit-order-machine').value;
    const customer = document.getElementById('edit-order-customer').value;
    const lot = document.getElementById('edit-order-lot').value;
    const planned = Number(document.getElementById('edit-order-planned').value);
    const executed = Number(document.getElementById('edit-order-executed').value);
    if (!id) return;
    try {
        const currentUser = getActiveUser();
        
        const updateData = {
            product,
            machine_id: machine,
            customer,
            lot_size: planned,
            total_produzido: executed,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        if (executed > 0) {
            updateData.lastManualAdjustment = {
                value: executed,
                editedBy: currentUser?.username || 'desconhecido',
                editedByName: currentUser?.name || 'Desconhecido',
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                reason: 'Edição manual via interface'
            };
            console.log(`[AUDIT] ${currentUser?.name || 'Desconhecido'} editou quantidade da ordem ${id}: ${executed}`);
        }
        
        await db.collection('production_orders').doc(id).update(updateData);
        showNotification('Ordem atualizada com sucesso!', 'success');
        document.getElementById('edit-order-modal').classList.add('hidden');
        
        // CRÍTICO: Invalidar cache de ordens para forçar recarregamento do banco
        productionOrdersCache = null;
        
        // Aguardar Firestore processar E atualizar todas as visualizações
        console.log('[EDIT-ORDER-HANDLER] Iniciando refresh após edição...');
        
        // 1. Recarregar lista de análise de ordens
        await loadOrdersAnalysis();
        console.log('[EDIT-ORDER-HANDLER] loadOrdersAnalysis() concluído');
        
        // 2. CRÍTICO: Recarregar seletor de máquinas (atualiza aba Lançamentos)
        // Usar Promise para aguardar o evento machineDataUpdated
        const machineDataPromise = new Promise((resolve) => {
            const handler = () => {
                console.log('[EDIT-ORDER-HANDLER] Evento machineDataUpdated recebido');
                document.removeEventListener('machineDataUpdated', handler);
                resolve();
            };
            document.addEventListener('machineDataUpdated', handler);
            // Timeout de 3s para segurança
            setTimeout(() => {
                document.removeEventListener('machineDataUpdated', handler);
                console.warn('[EDIT-ORDER-HANDLER] Timeout aguardando machineDataUpdated');
                resolve();
            }, 3000);
        });
        
        await populateMachineSelector(); // Aguardar completamente
        await machineDataPromise; // Aguardar evento
        console.log('[EDIT-ORDER-HANDLER] populateMachineSelector() concluído e dados prontos');
        
        // 3. Recarregar dados atuais da máquina selecionada do machineCardData
        if (selectedMachineData && selectedMachineData.machine) {
            const machineName = selectedMachineData.machine;
            const machineDataArray = machineCardData[machineName];
            // machineCardData agora é array - pegar primeiro plano para compatibilidade
            const updatedMachineData = Array.isArray(machineDataArray) ? machineDataArray[0] : machineDataArray;
            if (updatedMachineData) {
                selectedMachineData = updatedMachineData;
                console.log('[EDIT-ORDER-HANDLER] selectedMachineData atualizado:', { 
                    total: selectedMachineData.total_produzido, 
                    lot: selectedMachineData.lot_size || selectedMachineData.order_lot_size 
                });
            }
            
            // 4. Forçar re-seleção da máquina para atualizar o painel completamente
            if (typeof onMachineSelected === 'function') {
                await onMachineSelected(machineName);
                console.log('[EDIT-ORDER-HANDLER] onMachineSelected() executado para', machineName);
            }
        }
        
        // 5. Forçar atualização visual da aba Lançamentos
        updateMachineInfo();
        console.log('[EDIT-ORDER-HANDLER] updateMachineInfo() concluído');
        
        // 6. Se gráfico OP estiver aberto, atualizar também
        if (launchChartMode === 'op') {
            await loadOpProductionChart();
            console.log('[EDIT-ORDER-HANDLER] loadOpProductionChart() concluído');
        }
        
        // 7. Atualizar estatísticas
        await loadTodayStats();
        console.log('[EDIT-ORDER-HANDLER] ✅ Refresh completo finalizado!');
    } catch (err) {
        showNotification('Erro ao atualizar ordem.', 'error');
        console.error('Erro ao atualizar ordem:', err);
    }
};
    }

    // Função para carregar visão geral
    async function loadOverviewData() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadOverviewData] fetching data', { startDate, endDate, machine, shift });
        
        if (!startDate || !endDate) {
            console.warn('[TRACE][loadOverviewData] missing date filters, initializing defaults');
            setAnalysisDefaultDates();
            return;
        }
        
        // Buscar dados do Firebase (sempre sem filtro de turno para permitir comparação geral)
        const [productionAll, lossesAll, downtimeAll, planData] = await Promise.all([
            getFilteredData('production', startDate, endDate, machine, 'all'),
            getFilteredData('losses', startDate, endDate, machine, 'all'),
            getFilteredData('downtime', startDate, endDate, machine, 'all'),
            getFilteredData('plan', startDate, endDate, machine, 'all')
        ]);

        console.log('[TRACE][loadOverviewData] datasets received', {
            productionCount: productionAll.length,
            lossesCount: lossesAll.length,
            downtimeCount: downtimeAll.length,
            planCount: planData.length,
            productionSample: productionAll.slice(0, 2),
            lossesSample: lossesAll.slice(0, 2),
            downtimeSample: downtimeAll.slice(0, 2)
        });

        // Atualizar informações do produto se uma máquina específica foi selecionada
        if (machine && machine !== 'all' && productionAll.length > 0) {
            const firstProduction = productionAll[0];
            if (firstProduction.product_code) {
                const productInfo = window.databaseModule?.productByCode?.get(Number(firstProduction.product_code)) || 
                                   window.databaseModule?.productByCode?.get(firstProduction.product_code);
                if (productInfo) {
                    updateAnalysisProductInfo(
                        firstProduction.product_code,
                        productInfo.cycle,
                        productInfo.cavities,
                        productInfo.weight,
                        productInfo.name
                    );
                }
            }
        }

        const normalizeShiftFilter = (value) => {
            if (value === undefined || value === null || value === 'all') return 'all';
            const num = Number(value);
            return Number.isFinite(num) ? num : 'all';
        };

        const appliedShift = normalizeShiftFilter(shift);

        const filterByShift = (data) => {
            if (appliedShift === 'all') return data;
            return data.filter(item => Number(item.shift || 0) === appliedShift);
        };

    const productionData = filterByShift(productionAll);
    const lossesData = filterByShift(lossesAll);
    const downtimeFiltered = filterByShift(downtimeAll);
    const planFiltered = filterByShift(planData);

        // CORREÇÃO: Usar consolidateDowntimeEvents para consistência com aba Paradas
        const downtimeConsolidated = consolidateDowntimeEvents(downtimeFiltered);

        // Calcular KPIs básicos
        const totalProduction = productionData.reduce((sum, item) => sum + item.quantity, 0);
    const totalLosses = lossesData.reduce((sum, item) => sum + (Number(item.scrapPcs ?? item.quantity ?? 0) || 0), 0);
        // Calcular tempo de paradas usando dados consolidados (igual à aba Paradas)
        const totalDowntime = downtimeConsolidated.reduce((sum, item) => sum + (item.duration || 0), 0);
        
        // Calcular OEE real usando disponibilidade  x  performance  x  qualidade
        const { overallOee, filteredOee } = calculateOverviewOEE(
            productionAll,
            lossesAll,
            downtimeAll,
            planData,
            appliedShift
        );
        const displayedOee = appliedShift === 'all' ? overallOee : filteredOee;
        
        // Atualizar KPIs na interface
        const overviewOee = document.getElementById('overview-oee');
        const overviewProduction = document.getElementById('overview-production');
        const overviewLosses = document.getElementById('overview-losses');
        const overviewDowntime = document.getElementById('overview-downtime');
        
        if (overviewOee) {
            if (appliedShift === 'all') {
                overviewOee.textContent = `${(overallOee * 100).toFixed(1)}%`;
            } else {
                overviewOee.textContent = `Turno: ${(filteredOee * 100).toFixed(1)}% | Geral: ${(overallOee * 100).toFixed(1)}%`;
            }
        }
        if (overviewProduction) overviewProduction.textContent = totalProduction.toLocaleString();
    if (overviewLosses) overviewLosses.textContent = totalLosses.toLocaleString('pt-BR');
        if (overviewDowntime) overviewDowntime.textContent = `${(totalDowntime / 60).toFixed(1)}h`;

        console.log('[TRACE][loadOverviewData] KPIs calculated', { 
            overallOee: (overallOee * 100).toFixed(1) + '%',
            filteredOee: (filteredOee * 100).toFixed(1) + '%',
            totalProduction, 
            totalLosses, 
            totalDowntime 
        });

        // Gerar gráficos
        await generateOEEDistributionChart(productionData, lossesData, downtimeConsolidated);
    await generateMachineRanking(productionData, planFiltered);
    }

    function aggregateOeeMetrics(productionData, lossesData, downtimeData, planData, shiftFilter = 'all') {
        console.log('[TRACE][aggregateOeeMetrics] iniciando com', {
            production: productionData.length,
            losses: lossesData.length,
            downtime: downtimeData.length,
            plan: planData.length,
            shiftFilter
        });

        const toShiftNumber = (value) => {
            if (value === null || value === undefined) return null;
            const num = Number(value);
            return Number.isFinite(num) && num > 0 ? num : null;
        };

        const determineShiftFromTime = (timeStr) => {
            if (!timeStr || typeof timeStr !== 'string') return null;
            const [hoursStr, minutesStr] = timeStr.split(':');
            const hours = Number(hoursStr);
            const minutes = Number(minutesStr) || 0;
            if (!Number.isFinite(hours)) return null;
            // T1: 06:30 - 14:59
            if ((hours === 6 && minutes >= 30) || (hours >= 7 && hours < 15)) return 1;
            // T2: 15:00 - 23:19
            if (hours >= 15 && (hours < 23 || (hours === 23 && minutes < 20))) return 2;
            // T3: 23:20 - 06:29
            return 3;
        };

        const determineShiftFromDate = (dateObj) => {
            if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return null;
            const hours = dateObj.getHours();
            return determineShiftFromTime(`${String(hours).padStart(2, '0')}:00`);
        };

        const inferShift = (item) => {
            const candidates = [
                item.shift,
                item?.raw?.shift,
                item?.raw?.turno,
                item?.raw?.Shift,
                item?.raw?.Turno
            ];
            for (const value of candidates) {
                const shiftNum = toShiftNumber(value);
                if (shiftNum) return shiftNum;
            }

            const timeCandidates = [
                item.startTime,
                item.endTime,
                item?.raw?.startTime,
                item?.raw?.endTime,
                item?.raw?.hora,
                item?.raw?.hour,
                item?.raw?.time,
                item?.raw?.horaInformada
            ];
            for (const time of timeCandidates) {
                const shiftNum = determineShiftFromTime(time);
                if (shiftNum) return shiftNum;
            }

            const dateCandidates = [];
            if (item.datetime) {
                const parsed = new Date(item.datetime);
                if (!Number.isNaN(parsed.getTime())) dateCandidates.push(parsed);
            }
            if (item?.raw?.timestamp?.toDate) {
                dateCandidates.push(item.raw.timestamp.toDate());
            }
            if (item?.raw?.createdAt?.toDate) {
                dateCandidates.push(item.raw.createdAt.toDate());
            }
            if (item?.raw?.updatedAt?.toDate) {
                dateCandidates.push(item.raw.updatedAt.toDate());
            }
            const resolvedDate = resolveProductionDateTime(item.raw);
            if (resolvedDate) {
                dateCandidates.push(resolvedDate);
            }
            for (const date of dateCandidates) {
                const shiftNum = determineShiftFromDate(date);
                if (shiftNum) return shiftNum;
            }

            // CORREÇÃO: Se não conseguir inferir o turno, assume turno 1 (padrão) para evitar descarte
            console.log('[TRACE][aggregateOeeMetrics] turno não identificado para item', item.id || 'sem-id', 'assumindo turno 1');
            return 1;
        };

        const inferMachine = (item) => item.machine || item?.raw?.machine || item?.raw?.machineRef || item?.raw?.machine_id || null;

        // CORREÇÃO: Incluir workDay/date no agrupamento para múltiplas datas
        const groupKey = (machine, shift, workDay) => `${machine || 'unknown'}_${shift ?? 'none'}_${workDay || 'nodate'}`;
        const grouped = {};

        const getOrCreateGroup = (item) => {
            const machine = inferMachine(item);
            const shiftNum = inferShift(item);
            const workDay = item.workDay || item.date || 'nodate';
            
            if (!machine) {
                console.log('[TRACE][aggregateOeeMetrics] máquina não identificada para item', item.id || 'sem-id');
                return null;
            }
            
            const key = groupKey(machine, shiftNum, workDay);
            if (!grouped[key]) {
                grouped[key] = {
                    machine,
                    shift: shiftNum,
                    workDay,
                    production: 0,
                    scrapPcs: 0,
                    scrapKg: 0,
                    downtimeMin: 0
                };
            }
            return grouped[key];
        };

        productionData.forEach(item => {
            const group = getOrCreateGroup(item);
            if (!group) return;
            group.production += item.quantity || 0;
        });

        lossesData.forEach(item => {
            const group = getOrCreateGroup(item);
            if (!group) return;
            const scrapPcs = Number(item.scrapPcs ?? item.quantity ?? 0) || 0;
            const scrapKg = Number(item.scrapKg ?? 0) || 0;
            group.scrapPcs += scrapPcs;
            group.scrapKg += scrapKg;
        });

        // Obter categorias excluídas do OEE (ex: HOKKAIDO)
        const oeeExcludedCategories = window.databaseModule?.oeeExcludedCategories || [];

        downtimeData.forEach(item => {
            const group = getOrCreateGroup(item);
            if (!group) return;
            
            // Verificar se a categoria deve ser excluída do cálculo de OEE
            const reason = item.reason || '';
            const category = getDowntimeCategory(reason);
            if (oeeExcludedCategories.includes(category)) {
                // Parada de categoria excluída - NÃO contabilizar no OEE
                console.log('[TRACE][aggregateOeeMetrics] Parada excluída do OEE:', category, reason);
                return;
            }
            
            group.downtimeMin += item.duration || 0;
        });

        const clamp01 = (value) => Math.max(0, Math.min(1, value));
        const groupsWithMetrics = [];

        console.log('[TRACE][aggregateOeeMetrics] grupos criados:', Object.keys(grouped).length);

        Object.values(grouped).forEach(group => {
            // CORREÇÃO: Buscar planos por máquina e data também
            const planCandidates = planData.filter(p => p && p.raw && p.machine === group.machine);
            
            if (!planCandidates.length) {
                console.log('[TRACE][aggregateOeeMetrics] sem plano para máquina', group.machine, 'usando valores padrão');
                // CORREÇÃO: Usar valores padrão quando não há plano disponível
                const metrics = calculateShiftOEE(
                    group.production,
                    group.downtimeMin,
                    0, // refugoPcs
                    30, // ciclo padrão de 30 segundos
                    2   // 2 cavidades padrão
                );

                groupsWithMetrics.push({
                    machine: group.machine,
                    shift: group.shift,
                    workDay: group.workDay,
                    disponibilidade: clamp01(metrics.disponibilidade),
                    performance: clamp01(metrics.performance),
                    qualidade: clamp01(metrics.qualidade),
                    oee: clamp01(metrics.oee)
                });
                return;
            }

            // Tentar encontrar plano específico para o turno
            let plan = planCandidates.find(p => {
                const planShift = Number(p.shift || 0);
                return planShift && planShift === group.shift;
            });

            // Se não encontrou plano específico, usar o primeiro disponível
            if (!plan) {
                plan = planCandidates[0];
                console.log('[TRACE][aggregateOeeMetrics] usando plano genérico para máquina', group.machine, 'turno', group.shift);
            }

            if (!plan || !plan.raw) {
                console.log('[TRACE][aggregateOeeMetrics] plano inválido para máquina', group.machine);
                return;
            }

            const shiftKey = `t${group.shift}`;
            const cicloReal = plan.raw[`real_cycle_${shiftKey}`] || plan.raw.budgeted_cycle || 30;
            const cavAtivas = plan.raw[`active_cavities_${shiftKey}`] || plan.raw.mold_cavities || 2;
            const pieceWeight = plan.raw.piece_weight || 0.1; // peso padrão de 100g

            let refugoPcs = Math.round(Math.max(0, group.scrapPcs || 0));
            if (!refugoPcs && group.scrapKg > 0 && pieceWeight > 0) {
                refugoPcs = Math.round((group.scrapKg * 1000) / pieceWeight);
            }

            const metrics = calculateShiftOEE(
                group.production,
                group.downtimeMin,
                refugoPcs,
                cicloReal,
                cavAtivas
            );

            console.log('[TRACE][aggregateOeeMetrics] grupo processado:', {
                machine: group.machine,
                shift: group.shift,
                workDay: group.workDay,
                production: group.production,
                downtimeMin: group.downtimeMin,
                refugoPcs,
                scrapPcs: group.scrapPcs,
                scrapKg: group.scrapKg,
                cicloReal,
                cavAtivas,
                metrics
            });

            groupsWithMetrics.push({
                machine: group.machine,
                shift: group.shift,
                workDay: group.workDay,
                disponibilidade: clamp01(metrics.disponibilidade),
                performance: clamp01(metrics.performance),
                qualidade: clamp01(metrics.qualidade),
                oee: clamp01(metrics.oee)
            });
        });

        const averageMetric = (items, selector) => {
            if (!items.length) return 0;
            const total = items.reduce((sum, item) => sum + selector(item), 0);
            return total / items.length;
        };

        const normalizedShift = shiftFilter === 'all' ? 'all' : toShiftNumber(shiftFilter);
        const filteredGroups = normalizedShift === 'all'
            ? groupsWithMetrics
            : groupsWithMetrics.filter(item => item.shift === normalizedShift);

        console.log('[TRACE][aggregateOeeMetrics] grupos com métricas:', groupsWithMetrics.length);
        console.log('[TRACE][aggregateOeeMetrics] grupos filtrados:', filteredGroups.length);

        const overall = {
            disponibilidade: averageMetric(groupsWithMetrics, item => item.disponibilidade),
            performance: averageMetric(groupsWithMetrics, item => item.performance),
            qualidade: averageMetric(groupsWithMetrics, item => item.qualidade),
            oee: averageMetric(groupsWithMetrics, item => item.oee)
        };

        const filtered = {
            disponibilidade: averageMetric(filteredGroups, item => item.disponibilidade),
            performance: averageMetric(filteredGroups, item => item.performance),
            qualidade: averageMetric(filteredGroups, item => item.qualidade),
            oee: averageMetric(filteredGroups, item => item.oee)
        };

        console.log('[TRACE][aggregateOeeMetrics] resultado final:', {
            overall,
            filtered,
            shiftFilter,
            normalizedShift
        });

        return {
            overall,
            filtered,
            groups: groupsWithMetrics
        };
    }

    // Função para calcular OEE real do overview agregando todos os turnos/máquinas
    function calculateOverviewOEE(productionData, lossesData, downtimeData, planData, shiftFilter = 'all') {
        const { overall, filtered } = aggregateOeeMetrics(
            productionData,
            lossesData,
            downtimeData,
            planData,
            shiftFilter
        );

        // CORREÇÃO: Calcular OEE como produto dos componentes médios (D × P × Q)
        // Este é o método padrão da indústria para OEE agregado
        const overallOee = (overall?.disponibilidade || 0) * (overall?.performance || 0) * (overall?.qualidade || 0);
        const filteredOee = (filtered?.disponibilidade || 0) * (filtered?.performance || 0) * (filtered?.qualidade || 0);

        return { overallOee, filteredOee };
    }

    // Função para carregar análise de produção
    async function loadProductionAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadProductionAnalysis] fetching data', { startDate, endDate, machine, shift });
        
        const productionData = await getFilteredData('production', startDate, endDate, machine, shift);
        const planData = await getFilteredData('plan', startDate, endDate, machine, shift);
        const lossesData = await getFilteredData('losses', startDate, endDate, machine, shift);
        const downtimeData = await getFilteredData('downtime', startDate, endDate, machine, shift);

        console.log('[TRACE][loadProductionAnalysis] datasets received', {
            productionCount: productionData.length,
            planCount: planData.length,
            lossesCount: lossesData.length,
            downtimeCount: downtimeData.length
        });
        
        // Calcular métricas
        const totalProduction = productionData.reduce((sum, item) => sum + item.quantity, 0);
        const totalPlan = planData.reduce((sum, item) => sum + item.quantity, 0);
        const targetVsActual = totalPlan > 0 ? (totalProduction / totalPlan * 100) : 0;
        
        // Encontrar máquina top
        const machineProduction = {};
        productionData.forEach(item => {
            machineProduction[item.machine] = (machineProduction[item.machine] || 0) + item.quantity;
        });
        const topMachine = Object.keys(machineProduction).reduce((a, b) => 
            machineProduction[a] > machineProduction[b] ? a : b, '---'
        );

        cachedProductionDataset = {
            productionData,
            planData,
            startDate,
            endDate,
            shift,
            machine
        };

        // Atualizar interface - KPIs
        // PLANEJADO
        const plannedProductionKpi = document.getElementById('planned-production-kpi');
        const plannedProductionSubtext = document.getElementById('planned-production-subtext');
        if (plannedProductionKpi) {
            let formattedPlan;
            if (totalPlan >= 1000000) {
                formattedPlan = (totalPlan / 1000000).toFixed(1) + 'M';
            } else if (totalPlan >= 1000) {
                formattedPlan = (totalPlan / 1000).toFixed(1) + 'K';
            } else {
                formattedPlan = totalPlan.toLocaleString('pt-BR');
            }
            plannedProductionKpi.textContent = formattedPlan;
        }
        if (plannedProductionSubtext) {
            plannedProductionSubtext.textContent = `${totalPlan.toLocaleString('pt-BR')} peças planejadas`;
        }

        // REALIZADO
        const actualProductionKpi = document.getElementById('actual-production-kpi');
        const actualProductionSubtext = document.getElementById('actual-production-subtext');
        if (actualProductionKpi) {
            let formattedTotal;
            if (totalProduction >= 1000000) {
                formattedTotal = (totalProduction / 1000000).toFixed(1) + 'M';
            } else if (totalProduction >= 1000) {
                formattedTotal = (totalProduction / 1000).toFixed(1) + 'K';
            } else {
                formattedTotal = totalProduction.toLocaleString('pt-BR');
            }
            actualProductionKpi.textContent = formattedTotal;
        }
        if (actualProductionSubtext) {
            actualProductionSubtext.textContent = `${totalProduction.toLocaleString('pt-BR')} peças produzidas`;
        }
        
        // META x REALIZADO
        const targetVsActualEl = document.getElementById('production-target-vs-actual');
        if (targetVsActualEl) {
            targetVsActualEl.textContent = `${targetVsActual.toFixed(1)}%`;
        }
        
        // TAXA DE PRODUÇÃO
        updateProductionRateDisplay();

        // ========== PREENCHER TOP 5 MÁQUINAS (aba Produção) ==========
        const machineRankingProduction = document.getElementById('machine-ranking-production');
        if (machineRankingProduction) {
            const sortedMachines = Object.entries(machineProduction)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            if (sortedMachines.length === 0) {
                machineRankingProduction.innerHTML = '<div class="text-center py-4 text-gray-400"><p class="text-xs">Sem dados de produção</p></div>';
            } else {
                const maxProduction = sortedMachines[0][1];
                machineRankingProduction.innerHTML = sortedMachines.map(([mach, qty], index) => {
                    const percentage = maxProduction > 0 ? (qty / maxProduction * 100) : 0;
                    const medalColors = ['bg-amber-500', 'bg-gray-400', 'bg-orange-400', 'bg-blue-400', 'bg-green-400'];
                    const medalColor = medalColors[index] || 'bg-gray-300';
                    return `
                        <div class="flex items-center gap-3 p-2 bg-gray-50 rounded-lg">
                            <div class="w-6 h-6 ${medalColor} text-white rounded-full flex items-center justify-center text-xs font-bold">${index + 1}</div>
                            <div class="flex-1">
                                <div class="flex justify-between items-center mb-1">
                                    <span class="text-sm font-medium text-gray-700">${mach}</span>
                                    <span class="text-sm font-bold text-blue-600">${qty.toLocaleString('pt-BR')}</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-1.5">
                                    <div class="bg-blue-500 h-1.5 rounded-full" style="width: ${percentage.toFixed(1)}%"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        }

        // ========== PREENCHER RESUMO DO DIA ==========
        const totalLosses = lossesData.reduce((sum, item) => sum + (Number(item.scrapPcs ?? item.quantity ?? 0) || 0), 0);
        // Filtrar borra de forma consistente com loadLossesAnalysis
        const borraData = lossesData.filter(item => {
            const reasonStr = (item.reason || item.raw?.perdas || '').toString().toLowerCase();
            const isTagged = (item.raw && item.raw.tipo_lancamento === 'borra');
            return isTagged || reasonStr.includes('borra');
        });
        const totalBorra = borraData.reduce((sum, item) => sum + (Number(item.raw?.refugo_kg ?? item.scrapKg ?? item.weight ?? 0) || 0), 0);
        const totalDowntime = downtimeData.reduce((sum, item) => sum + (Number(item.duration) || 0), 0);
        const goodProduction = totalProduction; // Produção boa é o total de produção (já exclui refugos)

        const summaryGood = document.getElementById('summary-good-production');
        const summaryLosses = document.getElementById('summary-losses');
        const summaryBorra = document.getElementById('summary-borra');
        const summaryDowntime = document.getElementById('summary-downtime');

        if (summaryGood) summaryGood.textContent = goodProduction.toLocaleString('pt-BR');
        if (summaryLosses) summaryLosses.textContent = totalLosses.toLocaleString('pt-BR');
        if (summaryBorra) summaryBorra.textContent = totalBorra.toFixed(2);
        if (summaryDowntime) summaryDowntime.textContent = totalDowntime.toLocaleString('pt-BR');

        // Gerar gráficos
        await generateHourlyProductionChart(productionData, {
            canvas: analysisHourlyProductionChart,
            targetCanvasId: 'analysis-hourly-production-chart',
            chartContext: 'analysis',
            dailyTargetOverride: totalPlan,
            updateTimeline: false
        });
        await generateShiftProductionChart(productionData);
        await generateMachineProductionTimeline(productionData, {
            canvas: analysisMachineProductionTimelineChart,
            targetCanvasId: 'analysis-machine-production-timeline'
        });
        
        // Gerar gráfico de Ciclo/Cavidades
        await generateCycleCavityChart(planData);
    }
    
    /**
     * Gera gráfico de Ciclo/Cavidades comparando planejado vs real por turno
     */
    async function generateCycleCavityChart(planData) {
        const canvas = document.getElementById('cycle-cavity-chart');
        if (!canvas) {
            console.warn('[CYCLE-CAVITY] Canvas não encontrado');
            return;
        }
        
        // Destruir gráfico existente
        const existingChart = Chart.getChart(canvas);
        if (existingChart) {
            existingChart.destroy();
        }
        
        // Processar dados por turno
        const turnosData = {
            t1: { cicloReal: 0, cicloOrçado: 0, cavLancada: 0, cavOrcada: 0, count: 0 },
            t2: { cicloReal: 0, cicloOrçado: 0, cavLancada: 0, cavOrcada: 0, count: 0 },
            t3: { cicloReal: 0, cicloOrçado: 0, cavLancada: 0, cavOrcada: 0, count: 0 }
        };
        
        planData.forEach(plan => {
            const raw = plan.raw || plan;
            const budgetedCycle = Number(raw.budgeted_cycle) || 0;
            const cavOrcada = Number(raw.mold_cavities || raw.cavities) || 0;
            
            // T1
            if (raw.real_cycle_t1 || budgetedCycle) {
                turnosData.t1.cicloReal += Number(raw.real_cycle_t1) || budgetedCycle;
                turnosData.t1.cicloOrçado += budgetedCycle;
                turnosData.t1.cavLancada += Number(raw.active_cavities_t1 || raw.active_cavities_T1 || raw.activeCavitiesT1) || 0;
                turnosData.t1.cavOrcada += cavOrcada;
                turnosData.t1.count++;
            }
            
            // T2
            if (raw.real_cycle_t2 || budgetedCycle) {
                turnosData.t2.cicloReal += Number(raw.real_cycle_t2) || budgetedCycle;
                turnosData.t2.cicloOrçado += budgetedCycle;
                turnosData.t2.cavLancada += Number(raw.active_cavities_t2 || raw.active_cavities_T2 || raw.activeCavitiesT2) || 0;
                turnosData.t2.cavOrcada += cavOrcada;
                turnosData.t2.count++;
            }
            
            // T3
            if (raw.real_cycle_t3 || budgetedCycle) {
                turnosData.t3.cicloReal += Number(raw.real_cycle_t3) || budgetedCycle;
                turnosData.t3.cicloOrçado += budgetedCycle;
                turnosData.t3.cavLancada += Number(raw.active_cavities_t3 || raw.active_cavities_T3 || raw.activeCavitiesT3) || 0;
                turnosData.t3.cavOrcada += cavOrcada;
                turnosData.t3.count++;
            }
        });
        
        // Calcular médias
        const labels = ['1º Turno', '2º Turno', '3º Turno'];
        const cicloOrcado = [
            turnosData.t1.count ? (turnosData.t1.cicloOrçado / turnosData.t1.count).toFixed(1) : 0,
            turnosData.t2.count ? (turnosData.t2.cicloOrçado / turnosData.t2.count).toFixed(1) : 0,
            turnosData.t3.count ? (turnosData.t3.cicloOrçado / turnosData.t3.count).toFixed(1) : 0
        ];
        const cicloReal = [
            turnosData.t1.count ? (turnosData.t1.cicloReal / turnosData.t1.count).toFixed(1) : 0,
            turnosData.t2.count ? (turnosData.t2.cicloReal / turnosData.t2.count).toFixed(1) : 0,
            turnosData.t3.count ? (turnosData.t3.cicloReal / turnosData.t3.count).toFixed(1) : 0
        ];
        const cavOrcada = [
            turnosData.t1.count ? Math.round(turnosData.t1.cavOrcada / turnosData.t1.count) : 0,
            turnosData.t2.count ? Math.round(turnosData.t2.cavOrcada / turnosData.t2.count) : 0,
            turnosData.t3.count ? Math.round(turnosData.t3.cavOrcada / turnosData.t3.count) : 0
        ];
        const cavLancada = [
            turnosData.t1.count ? Math.round(turnosData.t1.cavLancada / turnosData.t1.count) : 0,
            turnosData.t2.count ? Math.round(turnosData.t2.cavLancada / turnosData.t2.count) : 0,
            turnosData.t3.count ? Math.round(turnosData.t3.cavLancada / turnosData.t3.count) : 0
        ];
        
        const ctx = canvas.getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Ciclo Orçado (s)',
                        data: cicloOrcado,
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: 'rgba(59, 130, 246, 1)',
                        borderWidth: 1,
                        borderRadius: 4,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Ciclo Real (s)',
                        data: cicloReal,
                        backgroundColor: 'rgba(16, 185, 129, 0.7)',
                        borderColor: 'rgba(16, 185, 129, 1)',
                        borderWidth: 1,
                        borderRadius: 4,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Cavidade Orçada',
                        data: cavOrcada,
                        backgroundColor: 'rgba(249, 115, 22, 0.7)',
                        borderColor: 'rgba(249, 115, 22, 1)',
                        borderWidth: 1,
                        borderRadius: 4,
                        yAxisID: 'y1'
                    },
                    {
                        label: 'Cavidade Lançada',
                        data: cavLancada,
                        backgroundColor: 'rgba(139, 92, 246, 0.7)',
                        borderColor: 'rgba(139, 92, 246, 1)',
                        borderWidth: 1,
                        borderRadius: 4,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            font: { size: 11 }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(17, 24, 39, 0.9)',
                        padding: 12,
                        cornerRadius: 8,
                        titleFont: { size: 13, weight: 'bold' },
                        bodyFont: { size: 12 },
                        callbacks: {
                            label: function(context) {
                                const label = context.dataset.label || '';
                                const value = context.parsed.y;
                                if (label.includes('Ciclo')) {
                                    return `${label}: ${value}s`;
                                }
                                return `${label}: ${value}`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { display: false },
                        ticks: { font: { size: 11, weight: '500' } }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Ciclo (segundos)',
                            font: { size: 11 }
                        },
                        grid: { color: 'rgba(0, 0, 0, 0.05)' },
                        ticks: { font: { size: 10 } }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Cavidades',
                            font: { size: 11 }
                        },
                        grid: { drawOnChartArea: false },
                        ticks: { 
                            font: { size: 10 },
                            stepSize: 1
                        }
                    }
                }
            }
        });
        
        console.log('[CYCLE-CAVITY] Gráfico gerado com sucesso');
    }

    function updateProductionRateToggle() {
        const dayBtn = document.getElementById('production-rate-mode-day');
        const shiftBtn = document.getElementById('production-rate-mode-shift');
        if (!dayBtn || !shiftBtn) return;

        const applyState = (btn, isActive) => {
            btn.classList.remove('bg-green-600', 'text-white', 'bg-white', 'text-green-600', 'hover:bg-green-50');
            if (isActive) {
                btn.classList.add('bg-green-600', 'text-white');
            } else {
                btn.classList.add('bg-white', 'text-green-600', 'hover:bg-green-50');
            }
        };

        applyState(dayBtn, productionRateMode === 'day');
        applyState(shiftBtn, productionRateMode === 'shift');
    }

    function updateProductionRateDisplay() {
        const valueEl = document.getElementById('production-rate-value');
        const subtextEl = document.getElementById('production-rate-subtext');
        if (!valueEl) return;

        const dataset = cachedProductionDataset || {};
        const productionData = dataset.productionData || [];
        const startDate = dataset.startDate;
        const endDate = dataset.endDate;
        const shiftFilterRaw = dataset.shift;
        const shiftFilter = shiftFilterRaw != null ? String(shiftFilterRaw) : 'all';

        if (!productionData.length) {
            valueEl.textContent = '--- pcs/h';
            if (subtextEl) {
                const modeLabel = productionRateMode === 'shift' ? 'Modo turno' : 'Modo dia';
                subtextEl.textContent = `${modeLabel} – Sem registros no período selecionado.`;
            }
            return;
        }

        const totalProduction = productionData.reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);
        const workDaysSet = new Set(productionData.map(item => item.workDay || item.date).filter(Boolean));
        const workDaysCount = workDaysSet.size;

        let effectiveDays = workDaysCount;
        if (!effectiveDays) {
            if (startDate && endDate) {
                const baseStart = new Date(`${startDate}T00:00:00`);
                const baseEnd = new Date(`${endDate}T00:00:00`);
                const diffDays = Math.max(Math.round((baseEnd - baseStart) / (1000 * 60 * 60 * 24)) + 1, 1);
                effectiveDays = diffDays;
            } else {
                effectiveDays = 1;
            }
        }

        if (productionRateMode === 'day') {
            let hoursInPeriod = 0;
            if (startDate && endDate) {
                hoursInPeriod = calculateHoursInPeriod(startDate, endDate);
            }
            if (!hoursInPeriod) {
                hoursInPeriod = effectiveDays * 24;
            }

            const rate = hoursInPeriod > 0 ? totalProduction / hoursInPeriod : 0;
            valueEl.textContent = `${rate.toFixed(1)} pcs/h`;

            if (subtextEl) {
                const daysLabel = effectiveDays > 1 ? `${effectiveDays} dias` : '1 dia';
                const dataDaysLabel = workDaysCount && workDaysCount !== effectiveDays ? `, ${workDaysCount} com lançamentos` : '';
                subtextEl.textContent = `Modo dia – ${totalProduction.toLocaleString('pt-BR')} peças em ${daysLabel}${dataDaysLabel}.`;
            }
            return;
        }

        const hoursPerShift = 8;
        const denominator = Math.max(effectiveDays * hoursPerShift, 1);
        const shiftTotals = { '1': 0, '2': 0, '3': 0 };
        let unknownTotal = 0;

        productionData.forEach(item => {
            const shiftValue = item.shift;
            const normalizedShift = shiftValue != null ? String(shiftValue) : null;
            const qty = Number(item.quantity) || 0;
            if (normalizedShift && Object.prototype.hasOwnProperty.call(shiftTotals, normalizedShift)) {
                shiftTotals[normalizedShift] += qty;
            } else {
                unknownTotal += qty;
            }
        });

        const shiftRates = ['1', '2', '3'].map(shiftKey => {
            const total = shiftTotals[shiftKey] || 0;
            const rate = total > 0 ? total / denominator : 0;
            return { shift: shiftKey, total, rate };
        });

        const selectedShift = shiftFilter !== 'all' ? shiftFilter : 'all';

        if (selectedShift !== 'all' && ['1', '2', '3'].includes(selectedShift)) {
            const selectedData = shiftRates.find(r => r.shift === selectedShift);
            if (selectedData && selectedData.total > 0) {
                valueEl.textContent = `Turno ${selectedData.shift}: ${selectedData.rate.toFixed(1)} pcs/h`;
            } else {
                valueEl.textContent = `Turno ${selectedShift}: -- pcs/h`;
            }
        } else {
            const bestShift = shiftRates.reduce((best, current) => {
                if (current.total <= 0) return best;
                if (!best || current.rate > best.rate) {
                    return current;
                }
                return best;
            }, null);

            if (bestShift) {
                valueEl.textContent = `Melhor turno: T${bestShift.shift} ${bestShift.rate.toFixed(1)} pcs/h`;
            } else {
                valueEl.textContent = 'Sem dados por turno';
            }
        }

        if (subtextEl) {
            const detailParts = shiftRates.map(r => {
                const label = `T${r.shift}`;
                return r.total > 0 ? `${label}: ${r.rate.toFixed(1)} pcs/h` : `${label}: --`;
            });
            if (unknownTotal > 0) {
                detailParts.push(`Sem turno: ${unknownTotal.toLocaleString('pt-BR')} pcs`);
            }
            const daysLabel = effectiveDays > 1 ? `${effectiveDays} dias` : '1 dia';
            subtextEl.textContent = `Modo turno – ${detailParts.join(' – ')} – ${daysLabel} analisado(s).`;
        }
    }

    // Função para debug de eficiência
    async function debugEfficiencyCalculation() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('=== DEBUG EFICIÊNCIA ===');
        console.log('Filtros:', { startDate, endDate, machine, shift });
        
        // Buscar dados raw
        const [productionData, lossesData, downtimeData, planData] = await Promise.all([
            getFilteredData('production', startDate, endDate, machine, 'all'),
            getFilteredData('losses', startDate, endDate, machine, 'all'),
            getFilteredData('downtime', startDate, endDate, machine, 'all'),
            getFilteredData('plan', startDate, endDate, machine, 'all')
        ]);

        console.log('Dados Raw:', {
            production: productionData.length,
            losses: lossesData.length,
            downtime: downtimeData.length,
            plan: planData.length
        });

        console.log('Amostra Production:', productionData.slice(0, 3));
        console.log('Amostra Plan:', planData.slice(0, 3));

        // Normalizar shift para evitar problemas com undefined
        const normalizedShift = shift === undefined || shift === null || shift === '' ? 'all' : shift;
        const result = aggregateOeeMetrics(productionData, lossesData, downtimeData, planData, normalizedShift);
        console.log('Resultado Agregação:', result);

        alert(`Debug concluído! Verifique o console para detalhes.
        
Production: ${productionData.length} registros
Losses: ${lossesData.length} registros  
Downtime: ${downtimeData.length} registros
Plan: ${planData.length} registros

Disponibilidade: ${(result.filtered.disponibilidade * 100).toFixed(1)}%
Performance: ${(result.filtered.performance * 100).toFixed(1)}%
Qualidade: ${(result.filtered.qualidade * 100).toFixed(1)}%`);
    }

    // Função para carregar análise de eficiência
    async function loadEfficiencyAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadEfficiencyAnalysis] calculating', { startDate, endDate, machine, shift });
        
        const oeeData = await calculateDetailedOEE(startDate, endDate, machine, shift);

        console.log('[TRACE][loadEfficiencyAnalysis] oeeData', oeeData);
        
        // Atualizar gauges dos componentes
        updateGauge('availability-gauge', oeeData.availability);
        updateGauge('performance-gauge', oeeData.performance);
        updateGauge('quality-gauge', oeeData.quality);
        
        document.getElementById('availability-value').textContent = `${oeeData.availability.toFixed(1)}%`;
        document.getElementById('performance-value').textContent = `${oeeData.performance.toFixed(1)}%`;
        document.getElementById('quality-value').textContent = `${oeeData.quality.toFixed(1)}%`;

        // ========== PREENCHER OEE GERAL ==========
        const oeeGeneral = oeeData.oee || ((oeeData.availability * oeeData.performance * oeeData.quality) / 10000);
        const oeeGeneralValue = document.getElementById('oee-general-value');
        const oeeClassification = document.getElementById('oee-classification');
        
        if (oeeGeneralValue) {
            oeeGeneralValue.textContent = `${oeeGeneral.toFixed(1)}%`;
        }
        
        // Atualizar gauge OEE principal
        updateGauge('oee-main-gauge', oeeGeneral);
        
        // Classificação do OEE
        if (oeeClassification) {
            let classification = 'Inaceitável';
            let classColor = 'text-red-600';
            if (oeeGeneral >= 85) {
                classification = 'Classe Mundial';
                classColor = 'text-green-600';
            } else if (oeeGeneral >= 75) {
                classification = 'Excelente';
                classColor = 'text-blue-600';
            } else if (oeeGeneral >= 65) {
                classification = 'Bom';
                classColor = 'text-teal-600';
            } else if (oeeGeneral >= 50) {
                classification = 'Regular';
                classColor = 'text-amber-600';
            }
            oeeClassification.textContent = classification;
            oeeClassification.className = `font-semibold ${classColor}`;
        }

        // ========== PREENCHER RANKING DE OEE POR MÁQUINA ==========
        const machineOeeRanking = document.getElementById('machine-oee-ranking');
        if (machineOeeRanking) {
            try {
                // Calcular OEE por máquina
                const productionData = await getFilteredData('production', startDate, endDate, machine === 'all' ? null : machine, shift);
                const lossesData = await getFilteredData('losses', startDate, endDate, machine === 'all' ? null : machine, shift);
                const planData = await getFilteredData('plan', startDate, endDate, machine === 'all' ? null : machine, shift);
                
                // Agrupar por máquina
                const machineData = {};
                
                productionData.forEach(item => {
                    const m = item.machine || 'N/A';
                    if (!machineData[m]) machineData[m] = { production: 0, losses: 0, planned: 0 };
                    machineData[m].production += Number(item.quantity) || 0;
                });
                
                lossesData.forEach(item => {
                    const m = item.machine || 'N/A';
                    if (!machineData[m]) machineData[m] = { production: 0, losses: 0, planned: 0 };
                    machineData[m].losses += Number(item.scrapPcs ?? item.quantity ?? 0) || 0;
                });
                
                planData.forEach(item => {
                    const m = item.machine || 'N/A';
                    if (!machineData[m]) machineData[m] = { production: 0, losses: 0, planned: 0 };
                    machineData[m].planned += Number(item.quantity) || 0;
                });
                
                // Calcular OEE simplificado por máquina (Performance  x  Qualidade)
                const machineEntries = Object.entries(machineData)
                    .map(([mach, data]) => {
                        const totalOutput = data.production + data.losses;
                        const performance = data.planned > 0 ? Math.min((data.production / data.planned) * 100, 100) : 0;
                        const quality = totalOutput > 0 ? (data.production / totalOutput) * 100 : 100;
                        const oee = (performance * quality) / 100; // OEE simplificado
                        return { machine: mach, oee, production: data.production };
                    })
                    .filter(e => e.production > 0) // Só máquinas com produção
                    .sort((a, b) => b.oee - a.oee)
                    .slice(0, 5);
                
                if (machineEntries.length === 0) {
                    machineOeeRanking.innerHTML = '<div class="text-center py-4 text-gray-400"><p class="text-xs">Sem dados de OEE por máquina</p></div>';
                } else {
                    const getOeeColor = (oee) => {
                        if (oee >= 85) return 'bg-green-500';
                        if (oee >= 75) return 'bg-blue-500';
                        if (oee >= 65) return 'bg-teal-500';
                        if (oee >= 50) return 'bg-amber-500';
                        return 'bg-red-500';
                    };
                    machineOeeRanking.innerHTML = machineEntries.map((e, idx) => `
                        <div class="flex items-center gap-2 p-2 bg-gray-50 rounded-lg">
                            <div class="w-5 h-5 ${getOeeColor(e.oee)} text-white rounded-full flex items-center justify-center text-xs font-bold">${idx + 1}</div>
                            <span class="flex-1 text-sm font-medium text-gray-700">${e.machine}</span>
                            <span class="text-sm font-bold ${e.oee >= 75 ? 'text-green-600' : e.oee >= 50 ? 'text-amber-600' : 'text-red-600'}">${e.oee.toFixed(1)}%</span>
                        </div>
                    `).join('');
                }
            } catch (err) {
                console.error('[loadEfficiencyAnalysis] Erro ao calcular ranking OEE por máquina:', err);
                machineOeeRanking.innerHTML = '<div class="text-center py-4 text-gray-400"><p class="text-xs">Erro ao carregar</p></div>';
            }
        }

        // Gerar gráficos
        await generateOEEComponentsTimeline(startDate, endDate, machine);
        await generateOEEHeatmap(startDate, endDate, machine);
    }

    // Função para carregar análise de perdas
    async function loadLossesAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadLossesAnalysis] fetching data', { startDate, endDate, machine, shift });
        
        const lossesData = await getFilteredData('losses', startDate, endDate, machine, shift);
        const productionData = await getFilteredData('production', startDate, endDate, machine, shift);

        // =====================================================
        // BUSCAR BORRAS DA COLEÇÃO pmp_borra (Nova aba PMP)
        // =====================================================
        let pmpBorraData = [];
        try {
            // Buscar borras do período selecionado
            const pmpBorraSnapshot = await db.collection('pmp_borra')
                .where('date', '>=', startDate)
                .where('date', '<=', endDate)
                .get();
            
            pmpBorraSnapshot.forEach(doc => {
                const data = doc.data();
                const machineId = normalizeMachineId(data.machine || '');
                
                // Aplicar filtros de máquina e turno
                if (machine !== 'all' && machineId !== normalizeMachineId(machine)) {
                    return;
                }
                
                // Para turno, inferir pelo horário se disponível
                if (shift !== 'all' && data.hour) {
                    const hourParts = data.hour.split(':');
                    const hourNum = parseInt(hourParts[0], 10);
                    const minNum = parseInt(hourParts[1], 10) || 0;
                    let inferredShift = 1;
                    // T1: 06:30-14:59, T2: 15:00-23:19, T3: 23:20-06:29
                    if ((hourNum === 6 && minNum >= 30) || (hourNum >= 7 && hourNum < 15)) inferredShift = 1;
                    else if (hourNum >= 15 && (hourNum < 23 || (hourNum === 23 && minNum < 20))) inferredShift = 2;
                    else inferredShift = 3;
                    
                    if (inferredShift !== parseInt(shift, 10)) {
                        return;
                    }
                }
                
                // Mapear para formato compatível com análise
                pmpBorraData.push({
                    id: doc.id,
                    date: data.date,
                    machine: machineId,
                    quantity: 0, // Borra não tem peças, só peso
                    reason: 'BORRA - PMP',
                    mp: '',
                    mp_type: '',
                    workDay: data.date,
                    scrapPcs: 0,
                    scrapKg: data.quantityKg || 0,
                    pieceWeight: 0,
                    raw: {
                        ...data,
                        tipo_lancamento: 'borra',
                        refugo_kg: data.quantityKg || 0,
                        source: 'pmp_borra'
                    }
                });
            });
            
            console.log('[TRACE][loadLossesAnalysis] PMP Borra data loaded:', pmpBorraData.length);
        } catch (error) {
            console.warn('[TRACE][loadLossesAnalysis] Erro ao carregar pmp_borra:', error);
        }
        
        // Combinar dados de perdas com borras do PMP
        const allLossesData = [...lossesData, ...pmpBorraData];

        console.log('[TRACE][loadLossesAnalysis] datasets received', {
            lossesCount: lossesData.length,
            pmpBorraCount: pmpBorraData.length,
            totalLossesCount: allLossesData.length,
            productionCount: productionData.length
        });
        
        const totalLosses = allLossesData.reduce((sum, item) => sum + item.quantity, 0);
        const totalProduction = productionData.reduce((sum, item) => sum + item.quantity, 0);
        const lossesPercentage = totalProduction > 0 ? (totalLosses / totalProduction * 100) : 0;
        
        // Calcular principal motivo
        const reasonCounts = {};
        allLossesData.forEach(item => {
            reasonCounts[item.reason] = (reasonCounts[item.reason] || 0) + item.quantity;
        });
        const mainReason = Object.keys(reasonCounts).reduce((a, b) => 
            reasonCounts[a] > reasonCounts[b] ? a : b, '---'
        );
        
        // Separar dados de borra (inclui pmp_borra)
        const borraData = allLossesData.filter(item => {
            const reasonStr = (item.reason || item.raw?.perdas || '').toString().toLowerCase();
            const isTagged = (item.raw && item.raw.tipo_lancamento === 'borra');
            const isPmpBorra = item.raw?.source === 'pmp_borra';
            return isTagged || isPmpBorra || reasonStr.includes('borra');
        });
        const regularLossesData = allLossesData.filter(item => !borraData.includes(item));
        console.log('[TRACE][loadLossesAnalysis] borra split', {
            borraCount: borraData.length,
            regularLossesCount: regularLossesData.length,
            borraSample: borraData.slice(0, 3)
        });
        
        // Calcular total de borra em kg
        const totalBorraKg = borraData.reduce((sum, item) => {
            // Para borra, usar preferencialmente o peso em kg
            const weight = item.raw?.refugo_kg || item.raw?.quantityKg || item.scrapKg || 0;
            return sum + weight;
        }, 0);
        if (allLossesData.length > 0 && borraData.length === 0) {
            console.warn('[TRACE][loadLossesAnalysis] Atenção: há perdas mas nenhuma BORRA detectada. Verifique se os lançamentos de borra possuem tipo_lancamento="borra" ou motivo contendo "borra".');
        }

        // Calcular MP mais perdida
        const materialCounts = {};
        allLossesData.forEach(item => {
            const mpType = item.mp_type || 'Não especificado';
            materialCounts[mpType] = (materialCounts[mpType] || 0) + item.quantity;
        });
        const mainMaterialCode = Object.keys(materialCounts).length > 0 
            ? Object.keys(materialCounts).reduce((a, b) => 
                materialCounts[a] > materialCounts[b] ? a : b, '---'
            ) 
            : '---';
        const mainMaterial = mainMaterialCode !== '---' ? getDescricaoMP(mainMaterialCode) : '---';

        // Análise específica de borra
        const borraMPCounts = {};
        const borraReasonCounts = {};
        const borraMachineCounts = {};
        
        borraData.forEach(item => {
            const mpType = item.mp_type || item.raw?.mp_type || 'Não especificado';
            const reason = item.reason || item.raw?.perdas || 'Não especificado';
            const machine = item.machine || 'Não especificado';
            
            borraMPCounts[mpType] = (borraMPCounts[mpType] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
            borraReasonCounts[reason] = (borraReasonCounts[reason] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
            borraMachineCounts[machine] = (borraMachineCounts[machine] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
        });

        const topBorraMP = Object.keys(borraMPCounts).length > 0
            ? Object.keys(borraMPCounts).reduce((a, b) => borraMPCounts[a] > borraMPCounts[b] ? a : b, '---')
            : '---';
            
        const topBorraReason = Object.keys(borraReasonCounts).length > 0
            ? Object.keys(borraReasonCounts).reduce((a, b) => borraReasonCounts[a] > borraReasonCounts[b] ? a : b, '---')
            : '---';
            
        const topBorraMachine = Object.keys(borraMachineCounts).length > 0
            ? Object.keys(borraMachineCounts).reduce((a, b) => borraMachineCounts[a] > borraMachineCounts[b] ? a : b, '---')
            : '---';

        // Atualizar interface
        document.getElementById('total-losses').textContent = totalLosses.toLocaleString();
        document.getElementById('losses-percentage').textContent = `${lossesPercentage.toFixed(1)}%`;
        document.getElementById('total-borra').textContent = `${totalBorraKg.toFixed(3)}`;
        document.getElementById('main-loss-reason').textContent = mainReason;
        document.getElementById('main-loss-material').textContent = mainMaterial;
        
        // Atualizar dados específicos de borra
        const topBorraMPElement = document.getElementById('top-borra-mp');
        const topBorraReasonElement = document.getElementById('top-borra-reason');
        const topBorraMachineElement = document.getElementById('top-borra-machine');
        
        if (topBorraMPElement) topBorraMPElement.textContent = topBorraMP;
        if (topBorraReasonElement) topBorraReasonElement.textContent = topBorraReason.replace('BORRA - ', '');
        if (topBorraMachineElement) topBorraMachineElement.textContent = topBorraMachine;

        // Gerar gráficos (usando allLossesData que inclui pmp_borra)
        await generateLossesParetoChart(regularLossesData);
        await generateLossesByMachineChart(regularLossesData);
        await generateLossesByMaterialChart(regularLossesData); // ✅ CORRIGIDO: Usar apenas regularLossesData (sem borra)
        await generateLossesDailyChart(regularLossesData); // ✅ NOVO: Gráfico de perdas diárias
        
        // Gerar gráficos específicos de borra
        await generateBorraByMachineChart(borraData);
        await generateBorraMonthlyChart(borraData);
        
        // Preencher tabela de apontamentos de borra
        await populateBorraApontamentosTable(borraData);
        
        // ✅ Carregar análise de sucata
        if (typeof loadSucataAnalysis === 'function') {
            await loadSucataAnalysis(startDate, endDate, machine, shift);
        }
    }

    // Função para carregar análise de paradas
    async function loadDowntimeAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadDowntimeAnalysis] fetching data', { startDate, endDate, machine, shift });
        
        // Carregar paradas normais (do turno)
        const downtimeSegments = await getFilteredData('downtime', startDate, endDate, machine, shift);
        const downtimeData = consolidateDowntimeEvents(downtimeSegments);

        console.log('[TRACE][loadDowntimeAnalysis] normal downtime received', {
            segments: downtimeSegments.length,
            events: downtimeData.length
        });
        
        // ✅ OTIMIZADO: Carregar paradas longas usando cache
        let extendedDowntimeData = [];
        try {
            const allExtended = await getExtendedDowntimesCached();
            
            // Definir limites do período filtrado
            const filterStart = new Date(`${startDate}T00:00:00`);
            const filterEnd = new Date(`${endDate}T23:59:59`);
            const now = new Date();
            
            allExtended.forEach(data => {
                const d = data;
                const machineId = d.machine_id || d.machine || '';
                
                // Filtrar por máquina se selecionada
                if (machine && machine !== 'all' && machine !== '' && machineId !== machine) return;
                
                // Determinar início e fim reais da parada
                let paradaStart;
                if (d.start_datetime?.toDate) {
                    paradaStart = d.start_datetime.toDate();
                } else if (d.start_date && d.start_time) {
                    paradaStart = new Date(`${d.start_date}T${d.start_time}`);
                } else if (d.start_date) {
                    paradaStart = new Date(`${d.start_date}T00:00:00`);
                } else {
                    return; // Sem data de início, ignorar
                }
                
                let paradaEnd;
                const isActive = d.status === 'active';
                if (isActive) {
                    paradaEnd = now; // Parada ainda ativa - fim é agora
                } else if (d.end_datetime?.toDate) {
                    paradaEnd = d.end_datetime.toDate();
                } else if (d.end_date && d.end_time) {
                    paradaEnd = new Date(`${d.end_date}T${d.end_time}`);
                } else if (d.end_date) {
                    paradaEnd = new Date(`${d.end_date}T23:59:59`);
                } else {
                    paradaEnd = now; // Sem fim definido, assumir agora
                }
                
                // Verificar se a parada tem intersecção com o período filtrado
                if (paradaEnd < filterStart || paradaStart > filterEnd) {
                    return; // Parada completamente fora do período
                }
                
                // ✅ CALCULAR APENAS O TEMPO DENTRO DO PERÍODO FILTRADO
                const effectiveStart = paradaStart < filterStart ? filterStart : paradaStart;
                const effectiveEnd = paradaEnd > filterEnd ? filterEnd : paradaEnd;
                
                // Duração em minutos apenas do período filtrado
                const durationMinutes = Math.max(0, Math.floor((effectiveEnd - effectiveStart) / (1000 * 60)));
                
                if (durationMinutes <= 0) return; // Sem tempo no período
                
                // Mapear tipo para motivo legível
                const typeLabels = {
                    weekend: 'Fim de Semana',
                    maintenance: 'Manutenção Preventiva',
                    preventive: 'Manutenção Preventiva',
                    maintenance_planned: 'Manutenção Programada',
                    holiday: 'Feriado',
                    setup: 'Setup/Troca',
                    other: 'Outros (Parada Longa)'
                };
                
                extendedDowntimeData.push({
                    id: data.id || d.id, // FIX: usar data.id em vez de doc.id
                    machine: machineId,
                    reason: d.reason || typeLabels[d.type] || d.type || 'Parada Longa',
                    duration: durationMinutes,
                    type: d.type,
                    isExtended: true, // Flag para identificar paradas longas
                    // Info adicional para debug
                    _totalDuration: d.duration_minutes || Math.floor((paradaEnd - paradaStart) / (1000 * 60)),
                    _filteredDuration: durationMinutes
                });
                
                console.log(`[EXTENDED-DOWNTIME] ${machineId}: Total ${Math.floor((paradaEnd - paradaStart) / (1000 * 60))}min, No período: ${durationMinutes}min`);
            });
            
            console.log('[TRACE][loadDowntimeAnalysis] extended downtime received', {
                count: extendedDowntimeData.length
            });
        } catch (err) {
            console.warn('[loadDowntimeAnalysis] Erro ao carregar paradas longas:', err);
        }
        
        // ✅ Combinar paradas normais + paradas longas para os gráficos
        const allDowntimeData = [...downtimeData, ...extendedDowntimeData];
        
        console.log('[TRACE][loadDowntimeAnalysis] combined downtime data', {
            normal: downtimeData.length,
            extended: extendedDowntimeData.length,
            total: allDowntimeData.length
        });
        
        const totalDowntime = allDowntimeData.reduce((sum, item) => sum + (item.duration || 0), 0);
        const downtimeCount = allDowntimeData.length;
        const avgDowntime = downtimeCount > 0 ? (totalDowntime / downtimeCount) : 0;
        
        // Calcular MTBF (Mean Time Between Failures)
        const hoursInPeriod = calculateHoursInPeriod(startDate, endDate);
        const mtbf = downtimeCount > 0 ? (hoursInPeriod / downtimeCount) : 0;

        // Atualizar interface
        document.getElementById('total-downtime').textContent = `${(totalDowntime / 60).toFixed(1)}h`;
        document.getElementById('downtime-count').textContent = downtimeCount.toString();
        document.getElementById('avg-downtime').textContent = `${avgDowntime.toFixed(0)}min`;
        document.getElementById('mtbf-value').textContent = `${mtbf.toFixed(1)}h`;

        // ✅ Gerar gráficos com dados combinados (normais + longas)
        await generateDowntimeReasonsChart(allDowntimeData);
        setupDowntimeChartToggle(); // Setup dos botões de toggle categoria/motivo
        await generateDowntimeByMachineChart(allDowntimeData);
        await generateDowntimeTimelineChart(downtimeData); // Timeline mantém só normais para não distorcer

        // ✅ Popular filtro de motivos de parada com detalhes
        await populateDowntimeReasonFilter(allDowntimeData, downtimeSegments);

        // Carregar lista detalhada de paradas longas programadas
        await loadExtendedDowntimeAnalysis(startDate, endDate, machine);
    }

    // ==================== FILTRO POR MOTIVO DE PARADA ====================
    let cachedDowntimeDetails = []; // Cache para os detalhes das paradas
    let currentDowntimePage = 1;
    const DOWNTIME_PAGE_SIZE = 20;

    async function populateDowntimeReasonFilter(allDowntimeData, rawSegments) {
        const filterSelect = document.getElementById('downtime-reason-filter');
        const machineFilterSelect = document.getElementById('downtime-machine-filter');
        const countEl = document.getElementById('downtime-reason-count');
        
        if (!filterSelect) return;
        
        // Extrair todos os motivos únicos
        const reasons = new Set();
        const machines = new Set();
        allDowntimeData.forEach(item => {
            const reason = (item.reason || 'Sem motivo').trim();
            if (reason) reasons.add(reason);
            const machine = (item.machine || 'N/A').trim();
            if (machine && machine !== 'N/A') machines.add(machine);
        });
        
        // Popular o select de motivos
        filterSelect.innerHTML = '<option value="">-- Todos os Motivos --</option>';
        const sortedReasons = Array.from(reasons).sort((a, b) => a.localeCompare(b, 'pt-BR'));
        
        sortedReasons.forEach(reason => {
            const count = allDowntimeData.filter(d => (d.reason || 'Sem motivo').trim() === reason).length;
            const opt = document.createElement('option');
            opt.value = reason;
            opt.textContent = `${reason} (${count})`;
            filterSelect.appendChild(opt);
        });
        
        // Popular o select de máquinas
        if (machineFilterSelect) {
            machineFilterSelect.innerHTML = '<option value="">-- Todas as Máquinas --</option>';
            const sortedMachines = Array.from(machines).sort((a, b) => a.localeCompare(b, 'pt-BR'));
            
            sortedMachines.forEach(machine => {
                const count = allDowntimeData.filter(d => (d.machine || '').trim() === machine).length;
                const opt = document.createElement('option');
                opt.value = machine;
                opt.textContent = `${machine} (${count})`;
                machineFilterSelect.appendChild(opt);
            });
        }
        
        // Guardar detalhes no cache com dados completos
        cachedDowntimeDetails = rawSegments.map(seg => {
            const reason = (seg.reason || seg.motivo || 'Sem motivo').trim();
            return {
                date: seg.date || seg.data || '',
                startTime: seg.startTime || seg.start_time || '--:--',
                endTime: seg.endTime || seg.end_time || '--:--',
                machine: seg.machine || seg.maquina || 'N/A',
                reason: reason,
                category: getDowntimeCategory(reason),
                duration: seg.duration || 0,
                observations: seg.observations || seg.observacoes || seg.obs || seg.notes || seg.raw?.observations || seg.raw?.observacoes || seg.raw?.obs || '',
                nomeUsuario: seg.nomeUsuario || seg.raw?.nomeUsuario || '',
                userCod: seg.userCod ?? seg.raw?.userCod ?? null
            };
        });
        
        // Ordenar por data e hora (mais recente primeiro)
        cachedDowntimeDetails.sort((a, b) => {
            const dateA = a.date + ' ' + a.startTime;
            const dateB = b.date + ' ' + b.startTime;
            return dateB.localeCompare(dateA);
        });
        
        // Atualizar contador
        if (countEl) {
            countEl.textContent = `${cachedDowntimeDetails.length} ocorrências`;
        }
        
        // Função para aplicar filtros
        const applyFilters = () => {
            currentDowntimePage = 1;
            const reasonValue = filterSelect.value;
            const machineValue = machineFilterSelect ? machineFilterSelect.value : '';
            renderDowntimeReasonTable(reasonValue, machineValue);
        };
        
        // Event listeners para os filtros
        filterSelect.onchange = applyFilters;
        if (machineFilterSelect) {
            machineFilterSelect.onchange = applyFilters;
        }
        
        // Renderizar tabela inicial (todos)
        renderDowntimeReasonTable('', '');
    }

    function renderDowntimeReasonTable(reasonFilter, machineFilter) {
        const tbody = document.getElementById('downtime-reason-table-body');
        const countEl = document.getElementById('downtime-reason-count');
        const paginationEl = document.getElementById('downtime-reason-pagination');
        const showingInfo = document.getElementById('downtime-showing-info');
        const prevBtn = document.getElementById('downtime-prev-page');
        const nextBtn = document.getElementById('downtime-next-page');
        
        if (!tbody) return;
        
        // Filtrar dados por motivo e máquina
        let filteredData = cachedDowntimeDetails;
        if (reasonFilter) {
            filteredData = filteredData.filter(d => d.reason === reasonFilter);
        }
        if (machineFilter) {
            filteredData = filteredData.filter(d => d.machine === machineFilter);
        }
        
        // Atualizar contador
        if (countEl) {
            countEl.textContent = `${filteredData.length} ocorrência${filteredData.length !== 1 ? 's' : ''}`;
        }
        
        // Calcular paginação
        const totalPages = Math.ceil(filteredData.length / DOWNTIME_PAGE_SIZE);
        const startIndex = (currentDowntimePage - 1) * DOWNTIME_PAGE_SIZE;
        const endIndex = Math.min(startIndex + DOWNTIME_PAGE_SIZE, filteredData.length);
        const pageData = filteredData.slice(startIndex, endIndex);
        
        // Mostrar paginação se necessário
        if (paginationEl) {
            paginationEl.classList.toggle('hidden', filteredData.length <= DOWNTIME_PAGE_SIZE);
        }
        if (showingInfo) {
            showingInfo.textContent = `Mostrando ${startIndex + 1}-${endIndex} de ${filteredData.length} registros`;
        }
        if (prevBtn) {
            prevBtn.disabled = currentDowntimePage <= 1;
            prevBtn.onclick = () => {
                if (currentDowntimePage > 1) {
                    currentDowntimePage--;
                    renderDowntimeReasonTable(reasonFilter, machineFilter);
                }
            };
        }
        if (nextBtn) {
            nextBtn.disabled = currentDowntimePage >= totalPages;
            nextBtn.onclick = () => {
                if (currentDowntimePage < totalPages) {
                    currentDowntimePage++;
                    renderDowntimeReasonTable(reasonFilter, machineFilter);
                }
            };
        }
        
        // Renderizar tabela
        if (pageData.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" class="text-center py-8 text-gray-500">
                        <i data-lucide="inbox" class="w-6 h-6 mx-auto mb-2 text-gray-400"></i>
                        <p>${(reasonFilter || machineFilter) ? 'Nenhuma ocorrência encontrada para os filtros selecionados' : 'Nenhuma parada registrada no período'}</p>
                    </td>
                </tr>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
            return;
        }
        
        // Cores para as categorias
        const categoryColors = {
            'FERRAMENTARIA': 'bg-indigo-100 text-indigo-800',
            'PROCESSO': 'bg-purple-100 text-purple-800',
            'COMPRAS': 'bg-pink-100 text-pink-800',
            'PREPARAÇÃO': 'bg-amber-100 text-amber-800',
            'QUALIDADE': 'bg-emerald-100 text-emerald-800',
            'MANUTENÇÃO': 'bg-red-100 text-red-800',
            'PRODUÇÃO': 'bg-blue-100 text-blue-800',
            'SETUP': 'bg-teal-100 text-teal-800',
            'ADMINISTRATIVO': 'bg-orange-100 text-orange-800',
            'PCP': 'bg-lime-100 text-lime-800',
            'COMERCIAL': 'bg-cyan-100 text-cyan-800',
            'HOKKAIDO': 'bg-gray-200 text-gray-700',
            'OUTROS': 'bg-gray-100 text-gray-800'
        };
        
        tbody.innerHTML = pageData.map(item => {
            // Formatar data
            const dateFormatted = item.date ? formatDateBR(item.date) : '--';
            
            // Formatar duração
            let durationStr = '--';
            if (item.duration > 0) {
                if (item.duration >= 60) {
                    const hours = Math.floor(item.duration / 60);
                    const mins = item.duration % 60;
                    durationStr = `${hours}h${mins > 0 ? mins + 'min' : ''}`;
                } else {
                    durationStr = `${item.duration}min`;
                }
            }
            
            // Cor baseada na duração
            let durationClass = 'text-gray-700';
            if (item.duration >= 120) durationClass = 'text-red-600 font-semibold';
            else if (item.duration >= 60) durationClass = 'text-orange-600 font-medium';
            else if (item.duration >= 30) durationClass = 'text-amber-600';
            
            // Truncar observações se muito longas
            const obsText = item.observations || '-';
            const obsDisplay = obsText.length > 50 ? obsText.substring(0, 47) + '...' : obsText;
            
            // Operador
            const operadorDisplay = item.nomeUsuario ? `<span class="text-indigo-600 font-medium" title="Cód: ${item.userCod}">${item.nomeUsuario}</span>` : '<span class="text-gray-400">-</span>';
            
            // Categoria com cor
            const categoryClass = categoryColors[item.category] || categoryColors['OUTROS'];
            
            return `
                <tr class="hover:bg-gray-50 transition-colors">
                    <td class="py-2.5 px-3 text-gray-700">${dateFormatted}</td>
                    <td class="py-2.5 px-3 text-gray-700 font-mono">${item.startTime}</td>
                    <td class="py-2.5 px-3 text-gray-700 font-mono">${item.endTime}</td>
                    <td class="py-2.5 px-3">
                        <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-semibold bg-blue-100 text-blue-800">
                            ${item.machine}
                        </span>
                    </td>
                    <td class="py-2.5 px-3">
                        <span class="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${categoryClass}">
                            ${item.category}
                        </span>
                    </td>
                    <td class="py-2.5 px-3 text-gray-800 font-medium">${item.reason}</td>
                    <td class="py-2.5 px-3 text-center ${durationClass}">${durationStr}</td>
                    <td class="py-2.5 px-3 text-xs">${operadorDisplay}</td>
                    <td class="py-2.5 px-3 text-gray-500 text-xs" title="${obsText}">${obsDisplay}</td>
                </tr>
            `;
        }).join('');
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    // Helper para formatar data no padrão brasileiro
    function formatDateBR(dateStr) {
        if (!dateStr) return '--';
        const parts = dateStr.split('-');
        if (parts.length === 3) {
            return `${parts[2]}/${parts[1]}/${parts[0]}`;
        }
        return dateStr;
    }

    // Função para carregar paradas longas na análise
    async function loadExtendedDowntimeAnalysis(startDate, endDate, machine) {
        console.log('[EXTENDED-DOWNTIME] Carregando paradas longas para análise', { startDate, endDate, machine });
        
        try {
            // ✅ OTIMIZADO: Usar cache em vez de buscar diretamente do Firebase
            const allData = await getExtendedDowntimesCached();
            
            let data = [];
            const seenAnalysisIds = new Set();
            
            console.log('[EXTENDED-DOWNTIME] Total de registros (cache):', allData.length);
            
            allData.forEach(item => {
                const d = item;
                if (!item.id) return;
                if (seenAnalysisIds.has(item.id)) return; // FIX: usar item.id em vez de doc.id
                
                // Pegar data do registro (pode estar em diferentes campos)
                const recordDate = d.start_date || d.date || '';
                
                // Verificar se está no período OU se está ativa (paradas ativas sempre aparecem)
                const isActive = d.status === 'active';
                const isInPeriod = recordDate >= startDate && recordDate <= endDate;
                
                if (!isActive && !isInPeriod) {
                    return; // Fora do período e não está ativa
                }
                
                // Filtrar por máquina se selecionada
                const machineId = d.machine_id || d.machine || '';
                if (machine && machine !== 'all' && machine !== '' && machineId !== machine) {
                    return;
                }
                
                seenAnalysisIds.add(item.id); // FIX: usar item.id em vez de doc.id
                data.push({ id: item.id, ...d, machine_id: machineId }); // FIX: usar item.id em vez de doc.id
                
                // Log para debug
                if (isActive) {
                    console.log('[EXTENDED-DOWNTIME] Incluindo ATIVA:', machineId, recordDate, d.status);
                }
            });

            console.log('[EXTENDED-DOWNTIME] Registros filtrados:', data.length);
            console.log('[EXTENDED-DOWNTIME] Máquinas:', [...new Set(data.map(d => d.machine_id))].join(', '));
            
            // Log detalhado de cada registro
            data.forEach((d, i) => {
                console.log(`[EXTENDED-DOWNTIME] [${i+1}] ${d.machine_id} | ${d.start_date || d.date} | status: ${d.status || 'N/A'} | type: ${d.type}`);
            });

            // Calcular totais por tipo
            const typeHours = {
                weekend: 0,
                maintenance: 0,
                holiday: 0,
                other: 0
            };

            data.forEach(item => {
                // Calcular duração: se parada está finalizada, usar duration_minutes; senão calcular do início até agora
                let hours = 0;
                if (item.status === 'active' && item.start_datetime) {
                    // Parada ativa - calcular tempo desde o início até agora
                    const startTime = item.start_datetime?.toDate?.() || new Date(item.start_date);
                    const now = new Date();
                    const durationMin = Math.floor((now - startTime) / (1000 * 60));
                    hours = durationMin / 60;
                } else {
                    // Parada finalizada - usar duration_minutes
                    hours = (item.duration_minutes || 0) / 60;
                }
                
                const type = item.type || 'other';
                
                if (type === 'weekend') typeHours.weekend += hours;
                else if (type === 'maintenance' || type === 'preventive') typeHours.maintenance += hours;
                else if (type === 'holiday') typeHours.holiday += hours;
                else typeHours.other += hours;
            });

            // Atualizar cards de resumo
            document.getElementById('extended-weekend-hours').textContent = `${typeHours.weekend.toFixed(1)}h`;
            document.getElementById('extended-maintenance-hours').textContent = `${typeHours.maintenance.toFixed(1)}h`;
            document.getElementById('extended-holiday-hours').textContent = `${typeHours.holiday.toFixed(1)}h`;
            document.getElementById('extended-other-hours').textContent = `${typeHours.other.toFixed(1)}h`;
            document.getElementById('extended-downtime-total').textContent = `${data.length} registros`;

            // Renderizar lista
            const listContainer = document.getElementById('extended-downtime-analysis-list');
            if (data.length === 0) {
                listContainer.innerHTML = '<p class="text-sm text-gray-500 text-center py-4">Nenhuma parada longa no período selecionado.</p>';
            } else {
                const typeLabels = {
                    weekend: 'Fim de Semana',
                    maintenance: 'Manutenção Preventiva',
                    preventive: 'Manutenção Preventiva',
                    maintenance_planned: 'Manutenção Programada',
                    holiday: 'Feriado',
                    setup: 'Setup/Troca',
                    other: 'Outro'
                };

                const typeColors = {
                    weekend: 'bg-gray-100 text-gray-700',
                    maintenance: 'bg-blue-100 text-blue-700',
                    preventive: 'bg-blue-100 text-blue-700',
                    maintenance_planned: 'bg-blue-100 text-blue-700',
                    holiday: 'bg-amber-100 text-amber-700',
                    setup: 'bg-purple-100 text-purple-700',
                    other: 'bg-red-100 text-red-700'
                };

                listContainer.innerHTML = data.map(item => {
                    // Calcular duração: se ativa, calcular do início até agora; senão usar duration_minutes
                    let hours;
                    const isActive = item.status === 'active';
                    
                    if (isActive) {
                        // Parada ativa - calcular tempo desde o início até agora
                        let startTime;
                        if (item.start_datetime?.toDate) {
                            startTime = item.start_datetime.toDate();
                        } else if (item.start_date && item.start_time) {
                            startTime = new Date(`${item.start_date}T${item.start_time}`);
                        } else if (item.start_date) {
                            startTime = new Date(item.start_date);
                        } else {
                            startTime = new Date();
                        }
                        const now = new Date();
                        const durationMin = Math.max(0, Math.floor((now - startTime) / (1000 * 60)));
                        hours = (durationMin / 60).toFixed(1);
                    } else {
                        // Parada finalizada - usar duration_minutes
                        hours = ((item.duration_minutes || 0) / 60).toFixed(1);
                    }
                    
                    const typeLabel = typeLabels[item.type] || item.type || 'Outro';
                    const typeColor = typeColors[item.type] || 'bg-gray-100 text-gray-700';
                    
                    // Badge de status - considerar vários valores
                    let statusBadge;
                    if (isActive) {
                        statusBadge = '<span class="text-xs px-2 py-1 rounded bg-red-100 text-red-700 font-semibold animate-pulse">🔴 ATIVA</span>';
                    } else if (item.status === 'inactive' || item.status === 'registered' || item.status === 'finished') {
                        statusBadge = '<span class="text-xs px-2 py-1 rounded bg-green-100 text-green-700 font-semibold">✅ FINALIZADA</span>';
                    } else {
                        statusBadge = `<span class="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 font-semibold">${item.status || 'N/A'}</span>`;
                    }
                    
                    // Período detalhado com horários
                    const startTimeStr = item.start_time || '00:00';
                    const endTimeStr = item.end_time || '23:59';
                    let periodText;
                    if (isActive) {
                        periodText = `Início: ${item.start_date || ''} às ${startTimeStr} (em andamento)`;
                    } else {
                        periodText = `${item.start_date || ''} ${startTimeStr} → ${item.end_date || ''} ${endTimeStr}`;
                    }
                    
                    // Informações adicionais
                    const registeredBy = item.registered_by || item.registeredBy || item.created_by || '-';
                    const finishedBy = item.finished_by || item.finishedBy || '-';
                    const createdAt = item.createdAt?.toDate?.() 
                        ? item.createdAt.toDate().toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' })
                        : '-';
                    const finishedAt = item.finishedAt?.toDate?.()
                        ? item.finishedAt.toDate().toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' })
                        : (isActive ? '-' : (item.end_date || '-'));
                    
                    return `
                        <div class="p-4 ${isActive ? 'bg-red-50 border-2 border-red-300' : 'bg-gray-50 border border-gray-200'} rounded-xl hover:shadow-md transition-all">
                            <!-- Header com máquina e status -->
                            <div class="flex items-center justify-between mb-3">
                                <div class="flex items-center gap-3">
                                    <div class="w-10 h-10 bg-gradient-to-br ${isActive ? 'from-red-500 to-red-600' : 'from-gray-500 to-gray-600'} rounded-lg flex items-center justify-center text-white font-bold text-sm">
                                        ${(item.machine_id || '-').slice(-2)}
                                    </div>
                                    <div>
                                        <span class="font-bold text-base text-gray-800">${item.machine_id || '-'}</span>
                                        <div class="flex items-center gap-2 mt-0.5">
                                            <span class="text-xs px-2 py-0.5 rounded ${typeColor}">${typeLabel}</span>
                                            ${statusBadge}
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center gap-2">
                                    <span class="text-xl font-bold ${isActive ? 'text-red-600' : 'text-gray-700'}">${hours}h</span>
                                    <button class="btn-edit-extended-downtime-analysis bg-blue-500 hover:bg-blue-600 text-white px-2.5 py-1.5 rounded-lg text-xs font-semibold transition shadow-sm" data-id="${item.id}" data-machine="${item.machine_id}" data-type="${item.type}" data-start-date="${item.start_date}" data-end-date="${item.end_date || ''}" data-reason="${item.reason}" data-start-time="${startTimeStr}" data-end-time="${endTimeStr}">
                                        <i data-lucide="edit-2" class="w-3.5 h-3.5"></i>
                                    </button>
                                    <button class="btn-delete-extended-downtime-analysis bg-red-500 hover:bg-red-600 text-white px-2.5 py-1.5 rounded-lg text-xs font-semibold transition shadow-sm" data-id="${item.id}" data-machine="${item.machine_id}">
                                        <i data-lucide="trash-2" class="w-3.5 h-3.5"></i>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Motivo -->
                            <div class="mb-3 p-2 bg-white rounded-lg border ${isActive ? 'border-red-200' : 'border-gray-200'}">
                                <p class="text-xs text-gray-500 mb-1 font-medium">MOTIVO:</p>
                                <p class="text-sm text-gray-800">${item.reason || 'Não informado'}</p>
                            </div>
                            
                            <!-- Grid de informações detalhadas -->
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-xs">
                                <div class="bg-white p-2 rounded-lg border ${isActive ? 'border-red-100' : 'border-gray-100'}">
                                    <span class="text-gray-500 block">Período</span>
                                    <span class="font-semibold text-gray-700">${periodText}</span>
                                </div>
                                <div class="bg-white p-2 rounded-lg border ${isActive ? 'border-red-100' : 'border-gray-100'}">
                                    <span class="text-gray-500 block">Registrado por</span>
                                    <span class="font-semibold text-gray-700">${registeredBy}</span>
                                </div>
                                <div class="bg-white p-2 rounded-lg border ${isActive ? 'border-red-100' : 'border-gray-100'}">
                                    <span class="text-gray-500 block">Registro em</span>
                                    <span class="font-semibold text-gray-700">${createdAt}</span>
                                </div>
                                <div class="bg-white p-2 rounded-lg border ${isActive ? 'border-red-100' : 'border-gray-100'}">
                                    <span class="text-gray-500 block">${isActive ? 'Status' : 'Finalizado por'}</span>
                                    <span class="font-semibold ${isActive ? 'text-red-600' : 'text-gray-700'}">${isActive ? 'Em andamento' : finishedBy}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Attach listeners para os botões da análise
                document.querySelectorAll('.btn-edit-extended-downtime-analysis').forEach(btn => {
                    btn.removeEventListener('click', handleEditExtendedDowntimeFromAnalysis);
                    btn.addEventListener('click', handleEditExtendedDowntimeFromAnalysis);
                });
                
                document.querySelectorAll('.btn-delete-extended-downtime-analysis').forEach(btn => {
                    btn.removeEventListener('click', handleDeleteExtendedDowntimeFromAnalysis);
                    btn.addEventListener('click', handleDeleteExtendedDowntimeFromAnalysis);
                });
                
                lucide.createIcons();
            }

        } catch (error) {
            console.error('[EXTENDED-DOWNTIME] Erro ao carregar paradas longas:', error);
        }
    }

    // Handlers para editar/deletar da análise
    async function handleEditExtendedDowntimeFromAnalysis(e) {
        e.stopPropagation();
        
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('editar paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        
        console.log('[EXTENDED-DOWNTIME] Editando da análise:', recordId);
        
        // Abrir diretamente o modal de edição completa
        await openEditDowntimeModal(recordId);
    }

    async function handleDeleteExtendedDowntimeFromAnalysis(e) {
        e.stopPropagation();
        
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        const machine = btn.dataset.machine;

        if (!confirm(`Tem certeza que deseja excluir a parada da máquina ${machine}?`)) {
            return;
        }

        try {
            btn.disabled = true;
            await db.collection('extended_downtime_logs').doc(recordId).delete();
            
            // Recarregar análise
            const { startDate, endDate, machine } = currentAnalysisFilters;
            await loadExtendedDowntimeAnalysis(startDate, endDate, machine);

        } catch (error) {
            console.error('[EXTENDED-DOWNTIME] Erro ao excluir:', error);
            alert('Erro ao excluir: ' + error.message);
            btn.disabled = false;
        }
    }

    // Função para carregar análise comparativa
    async function loadComparativeAnalysis() {
        console.log('[TRACE][loadComparativeAnalysis] View comparativa não implementada no HTML');
        // A view comparativa ainda não foi implementada no HTML
        // TODO: Adicionar canvas comparison-chart e interface no index.html para habilitar esta funcionalidade
    }

    // Função para carregar análise preditiva
    async function loadPredictiveAnalysis() {
        console.log('[PREDICTIVE] Carregando view de analytics preditivos');
        
        try {
            // Inicializar sistema de analytics preditivos se não estiver ativo
            if (!window.predictiveAnalytics || !window.predictiveAnalytics.predictions) {
                console.log('[PREDICTIVE] Inicializando sistema preditivo...');
                await window.predictiveAnalytics.initialize();
            } else {
                // Se já estiver inicializado, apenas atualizar as previsões
                console.log('[PREDICTIVE] Atualizando previsões existentes...');
                await window.predictiveAnalytics.generatePredictions();
            }

            // Inicializar KPIs avançados se não estiver ativo
            if (!window.advancedKPIs || !window.advancedKPIs.cache.lastUpdate) {
                console.log('[ADVANCED-KPIs] Inicializando KPIs avançados...');
                await window.advancedKPIs.initialize();
            } else {
                // Se já estiver inicializado, apenas atualizar se necessário
                const lastUpdate = window.advancedKPIs.cache.lastUpdate;
                const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                
                if (hoursSinceUpdate > 1) { // Atualizar se foi há mais de 1 hora
                    console.log('[ADVANCED-KPIs] Atualizando KPIs avançados...');
                    await window.advancedKPIs.calculateAllKPIs();
                }
            }

            // Inicializar análise Pareto automática
            if (!window.autoParetoAnalysis || !window.autoParetoAnalysis.analytics.lastUpdate) {
                console.log('[AUTO-PARETO] Inicializando análise Pareto automática...');
                await window.autoParetoAnalysis.initialize();
            } else {
                // Se já estiver inicializado, verificar se precisa atualizar
                const lastUpdate = window.autoParetoAnalysis.analytics.lastUpdate;
                const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                
                if (hoursSinceUpdate > 2) { // Atualizar se foi há mais de 2 horas
                    console.log('[AUTO-PARETO] Atualizando análise Pareto...');
                    await window.autoParetoAnalysis.performCompleteAnalysis();
                }
            }

            // Inicializar sistema SPC automaticamente
            if (window.spcController) {
                if (!window.spcController.spcData.lastUpdate) {
                    console.log('[SPC] Inicializando sistema SPC...');
                    await window.spcController.initialize();
                } else {
                    // Verificar se precisa atualizar
                    const lastUpdate = window.spcController.spcData.lastUpdate;
                    const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                    
                    if (hoursSinceUpdate > 1) { // Atualizar se foi há mais de 1 hora
                        console.log('[SPC] Atualizando sistema SPC...');
                        await window.spcController.initialize();
                    }
                }
            } else {
                console.warn('[SPC] SPCController não disponível');
            }

            // Inicializar sistema de rastreabilidade total
            if (!window.traceabilitySystem || !window.traceabilitySystem.traceabilityData.lastUpdate) {
                console.log('[TRACEABILITY] Inicializando sistema de rastreabilidade total...');
                await window.traceabilitySystem.initialize();
            } else {
                // Se já estiver inicializado, verificar se precisa atualizar
                const lastUpdate = window.traceabilitySystem.traceabilityData.lastUpdate;
                const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                
                if (hoursSinceUpdate > 6) { // Atualizar se foi há mais de 6 horas
                    console.log('[TRACEABILITY] Atualizando dados de rastreabilidade...');
                    await window.traceabilitySystem.loadTraceabilityData();
                    window.traceabilitySystem.buildGenealogyTree();
                    window.traceabilitySystem.updateTraceabilityInterface();
                }
            }
            
            console.log('[PREDICTIVE] Todos os sistemas avançados carregados com sucesso');
            
        } catch (error) {
            console.error('[PREDICTIVE] Erro ao carregar analytics preditivos:', error);
            
            // Mostrar interface de erro
            const alertsContainer = document.getElementById('proactive-alerts');
            if (alertsContainer) {
                alertsContainer.innerHTML = `
                    <div class="text-center text-red-500 py-8">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto text-red-400 mb-2"></i>
                        <p class="font-semibold">Erro ao carregar sistema preditivo</p>
                        <p class="text-sm text-gray-600 mt-1">${error.message}</p>
                    </div>
                `;
            }
        }
    }

    // Função para gerar comparação
    async function generateComparison() {
        const comparisonType = document.getElementById('comparison-type').value;
        const metric = document.getElementById('comparison-metric').value;
        const { startDate, endDate } = currentAnalysisFilters;
        
        let comparisonData = [];
        
        switch (comparisonType) {
            case 'machines':
                comparisonData = await compareByMachines(metric, startDate, endDate);
                break;
            case 'shifts':
                comparisonData = await compareByShifts(metric, startDate, endDate);
                break;
            case 'periods':
                comparisonData = await compareByPeriods(metric);
                break;
            case 'products':
                comparisonData = await compareByProducts(metric, startDate, endDate);
                break;
        }

        // Gerar gráfico de comparação
        await generateComparisonChart(comparisonData, metric);
        generateComparisonRanking(comparisonData);
        generateComparisonStats(comparisonData);
    }

    // Funções auxiliares para análise
    
    // Função de diagnóstico para verificar dados no Firestore
    async function diagnosticFirestoreData() {
        console.log('📍 [DIAGNOSTIC] Iniciando diagnóstico de dados do Firestore...');
        
        try {
            // Verificar production_entries
            const prodSnapshot = await db.collection('production_entries').limit(5).get();
            console.log('📍 [DIAGNOSTIC] production_entries:', {
                size: prodSnapshot.size,
                samples: prodSnapshot.docs.map(d => ({
                    id: d.id,
                    data: d.data().data,
                    machine: d.data().machine,
                    produzido: d.data().produzido,
                    turno: d.data().turno
                }))
            });
            
            // Verificar downtime_entries
            const downtimeSnapshot = await db.collection('downtime_entries').limit(5).get();
            console.log('📍 [DIAGNOSTIC] downtime_entries:', {
                size: downtimeSnapshot.size,
                samples: downtimeSnapshot.docs.map(d => ({
                    id: d.id,
                    date: d.data().date,
                    machine: d.data().machine,
                    duration: d.data().duration,
                    reason: d.data().reason
                }))
            });
            
            // Verificar planning
            const planningSnapshot = await db.collection('planning').limit(5).get();
            console.log('📍 [DIAGNOSTIC] planning:', {
                size: planningSnapshot.size,
                samples: planningSnapshot.docs.map(d => ({
                    id: d.id,
                    date: d.data().date,
                    machine: d.data().machine,
                    mp: d.data().mp
                }))
            });
            
        } catch (error) {
            console.error('📍 [DIAGNOSTIC] Erro ao buscar dados:', error);
        }
    }

    // Função para testar todos os gráficos
    async function testAllCharts() {
        console.log('🧪 [TEST] Iniciando teste de todos os gráficos...');
        
        const chartTests = [
            { name: 'OEE Distribution', canvasId: 'oee-distribution-chart', view: 'overview' },
            { name: 'Hourly Production', canvasId: 'hourly-production-chart', view: 'production' },
            { name: 'Analysis Hourly Production', canvasId: 'analysis-hourly-production-chart', view: 'analysis-production' },
            { name: 'Shift Production', canvasId: 'shift-production-chart', view: 'production' },
            { name: 'Machine Production Timeline', canvasId: 'analysis-machine-production-timeline', view: 'analysis-production' },
            { name: 'OEE Components Timeline', canvasId: 'oee-components-timeline', view: 'efficiency' },
            { name: 'Losses Pareto', canvasId: 'losses-pareto-chart', view: 'losses' },
            { name: 'Losses by Machine', canvasId: 'losses-by-machine-chart', view: 'losses' },
            { name: 'Losses by Material', canvasId: 'losses-by-material-chart', view: 'losses' },
            { name: 'Losses Trend', canvasId: 'losses-trend-chart', view: 'losses' },
            { name: 'Downtime Reasons', canvasId: 'downtime-reasons-chart', view: 'downtime' },
            { name: 'Downtime by Machine', canvasId: 'downtime-by-machine-chart', view: 'downtime' },
            { name: 'Downtime Timeline', canvasId: 'downtime-timeline-chart', view: 'downtime' }
            // Nota: comparison-chart removido pois a view comparative não foi implementada no HTML
        ];
        
        for (const test of chartTests) {
            const canvas = document.getElementById(test.canvasId);
            const chart = canvas ? Chart.getChart(canvas) : null;
            
            const status = {
                canvasExists: !!canvas,
                chartCreated: !!chart,
                hasData: chart?.data?.datasets?.length > 0 || false,
                view: test.view
            };
            
            console.log(`🧪 [TEST] ${test.name}:`, status);
            
            if (!canvas) {
                console.error(`❌ [TEST] Canvas "${test.canvasId}" não encontrado no DOM`);
            } else if (!chart) {
                console.warn(`⚠️ [TEST] Gráfico "${test.name}" não inicializado (canvas existe mas sem Chart.js)`);
            } else if (!status.hasData) {
                console.warn(`⚠️ [TEST] Gráfico "${test.name}" sem dados`);
            } else {
                console.log(`✅ [TEST] Gráfico "${test.name}" OK`);
            }
        }
        
        console.log('🧪 [TEST] Teste completo');
    }
    
    // Helper para destruir gráficos Chart.js existentes
    function destroyChart(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (canvas) {
            const existingChart = Chart.getChart(canvas);
            if (existingChart) {
                existingChart.destroy();
            }
        }
    }
    
    // Helper para mostrar mensagem quando não há dados no gráfico
    function showNoDataMessage(canvasId, message = 'Nenhum dado disponível para o período selecionado') {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        // Limpar canvas
        const context = canvas.getContext('2d');
        if (context) {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Adicionar mensagem
        const container = canvas.parentElement;
        if (container) {
            let messageDiv = container.querySelector('.no-data-message');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.className = 'no-data-message absolute inset-0 flex items-center justify-center';
                container.style.position = 'relative';
                container.appendChild(messageDiv);
            }
            messageDiv.innerHTML = `<p class="text-gray-500 text-sm">${message}</p>`;
        }
    }
    
    // Helper para remover mensagem de "sem dados"
    function clearNoDataMessage(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const container = canvas.parentElement;
        if (container) {
            const messageDiv = container.querySelector('.no-data-message');
            if (messageDiv) messageDiv.remove();
        }
    }

    // Configurações responsivas globais para gráficos
    function getResponsiveChartOptions() {
        const isMobile = window.innerWidth < 768;
        const isTablet = window.innerWidth < 1024;
        
        return {
            responsive: true,
            maintainAspectRatio: false,
            devicePixelRatio: window.devicePixelRatio || 1,
            scales: {
                x: {
                    grid: {
                        display: !isMobile,
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: isMobile ? 8 : isTablet ? 10 : 12
                        },
                        maxRotation: isMobile ? 45 : 0,
                        minRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: isMobile ? 8 : isTablet ? 12 : 16
                    }
                },
                y: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: isMobile ? 9 : isTablet ? 11 : 12
                        },
                        maxTicksLimit: isMobile ? 6 : 8
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: isMobile ? 'bottom' : 'top',
                    labels: {
                        font: {
                            size: isMobile ? 10 : isTablet ? 11 : 12
                        },
                        usePointStyle: true,
                        padding: isMobile ? 10 : 20,
                        boxWidth: isMobile ? 8 : 12
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: 'white',
                    bodyColor: 'white',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    titleFont: {
                        size: isMobile ? 11 : 12
                    },
                    bodyFont: {
                        size: isMobile ? 10 : 11
                    },
                    padding: isMobile ? 6 : 10
                }
            },
            layout: {
                padding: {
                    top: isMobile ? 5 : 10,
                    right: isMobile ? 5 : 10,
                    bottom: isMobile ? 5 : 10,
                    left: isMobile ? 5 : 10
                }
            }
        };
    }

    // Função para mesclar configurações específicas com as responsivas
    function mergeChartOptions(specificOptions = {}) {
        const baseOptions = getResponsiveChartOptions();
        
        // Função helper para merge profundo
        function deepMerge(target, source) {
            for (const key in source) {
                if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                    target[key] = target[key] || {};
                    deepMerge(target[key], source[key]);
                } else {
                    target[key] = source[key];
                }
            }
            return target;
        }
        
        return deepMerge(JSON.parse(JSON.stringify(baseOptions)), specificOptions);
    }

    async function getFilteredData(collection, startDate, endDate, machine = 'all', shift = 'all') {
        try {
            console.log('[TRACE][getFilteredData] called', { collection, startDate, endDate, machine, shift });
            
            const normalizeShift = (value) => {
                if (value === undefined || value === null) return null;
                if (typeof value === 'number' && Number.isFinite(value)) return value;
                const match = String(value).match(/(\d+)/);
                return match ? Number(match[1]) : null;
            };
            // FIX: map cada tipo analítico para a coleção real no Firestore e normalizar os campos esperados pela aba de análise
            const collectionConfig = {
                production: {
                    collection: 'production_entries',
                    dateField: 'data',
                    mapper: (id, raw) => {
                        const mappedDate = raw.data || raw.date || '';
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                        const resolvedDateTime = resolveProductionDateTime(raw);
                        const timestamp = resolvedDateTime || normalizeToDate(primaryTimestamp);
                        const timeHint = raw.horaInformada || raw.hora || raw.hour || raw.time || null;
                        const workDay = getWorkDayFromTimestamp(resolvedDateTime || primaryTimestamp) || getWorkDay(mappedDate, timeHint);
                        const isoDateTime = timestamp ? new Date(timestamp.getTime() - timestamp.getTimezoneOffset() * 60000).toISOString() : null;
                        
                        // Resolver produto através de múltiplas fontes
                        const product = raw.product || raw.produto || raw.product_cod || raw.cod_produto || raw.productName || raw.mp || '';
                        
                        // CORREÇÃO: Usar mesma lógica do Dashboard TV para consistência
                        // Verificar todos os campos possíveis de quantidade produzida
                        const rawQty = Number(raw.produzido ?? raw.pecasBoas ?? raw.quantity ?? raw.produced ?? raw.qtd ?? raw.quantidade ?? raw.total_produzido ?? 0) || 0;
                        
                        return {
                            id,
                            date: mappedDate,
                            machine: normalizeMachineId(raw.machine || raw.machineRef || raw.machine_id || null),
                            quantity: Math.round(rawQty), // Sempre inteiro, consistente com Dashboard TV
                            shift: normalizeShift(raw.turno ?? raw.shift),
                            datetime: isoDateTime,
                            mp: raw.mp || '',
                            product: product,
                            workDay: workDay || mappedDate,
                            raw
                        };
                    }
                },
                losses: {
                    collection: 'production_entries',
                    dateField: 'data',
                    mapper: (id, raw) => {
                        const dateValue = raw.data || raw.date || '';
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                        const resolvedDateTime = resolveProductionDateTime(raw);
                        const timeHint = raw.horaInformada || raw.hora || raw.hour || raw.time || null;
                        const workDay = getWorkDayFromTimestamp(resolvedDateTime || primaryTimestamp) || getWorkDay(dateValue, timeHint);
                        const rawRefugoKg = Number(raw.refugo_kg ?? raw.refugoKg ?? raw.scrap_kg ?? raw.scrapKg ?? 0) || 0;
                        const rawRefugoPcs = Number(raw.refugo_qty ?? raw.refugo_qtd ?? raw.scrap_qty ?? raw.scrap_qtd ?? 0) || 0;
                        const pieceWeight = Number(raw.piece_weight ?? raw.peso_unitario ?? raw.pesoUnitario ?? raw.peso ?? 0) || 0;
                        const resolvedPcs = rawRefugoPcs > 0
                            ? rawRefugoPcs
                            : (rawRefugoKg > 0 && pieceWeight > 0 ? Math.round((rawRefugoKg * 1000) / pieceWeight) : 0);
                        const resolvedKg = rawRefugoKg > 0
                            ? rawRefugoKg
                            : (pieceWeight > 0 && resolvedPcs > 0 ? (resolvedPcs * pieceWeight) / 1000 : 0);
                        
                        // Resolver produto através de múltiplas fontes
                        const product = raw.product || raw.produto || raw.product_cod || raw.cod_produto || raw.productName || '';
                        
                        return {
                            id,
                            date: dateValue,
                            machine: normalizeMachineId(raw.machine || raw.machineRef || raw.machine_id || null),
                            quantity: resolvedPcs,
                            shift: normalizeShift(raw.turno ?? raw.shift),
                            reason: raw.perdas || raw.reason || '',
                            mp: raw.mp || '',
                            mp_type: raw.mp_type || raw.mp || '',
                            product: product,
                            workDay: workDay || dateValue,
                            scrapPcs: resolvedPcs,
                            scrapKg: resolvedKg,
                            pieceWeight,
                            raw
                        };
                    }
                },
                downtime: {
                    collection: 'downtime_entries',
                    dateField: 'date',
                    mapper: (id, raw) => {
                        const startMinutes = raw.startTime ? parseTimeToMinutes(raw.date, raw.startTime) : null;
                        const endMinutes = raw.endTime ? parseTimeToMinutes(raw.date, raw.endTime) : null;
                        let duration = Number(raw.duration ?? raw.duration_min ?? raw.duracao_min ?? 0) || 0;
                        if (!duration && startMinutes !== null && endMinutes !== null) {
                            duration = Math.max(0, endMinutes - startMinutes);
                        }
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                                const timeHint = raw.startTime || raw.endTime || null;
                                // Preferir calcular o workDay a partir da data/horário do próprio registro
                                // (evita classificar pelo createdAt quando o lançamento é retroativo)
                                const workDay = getWorkDay(raw.date || '', timeHint) || getWorkDayFromTimestamp(primaryTimestamp);
                        let mappedShift = normalizeShift(raw.shift ?? raw.turno);
                        if (!mappedShift) {
                            mappedShift = inferShiftFromSegment(raw.date || '', raw.startTime || '', raw.endTime || '');
                        }
                        return {
                            id,
                            date: raw.date || '',
                            machine: normalizeMachineId(raw.machine || null),
                            duration,
                            reason: raw.reason || '',
                            shift: mappedShift,
                            startTime: raw.startTime || '',
                            endTime: raw.endTime || '',
                            workDay: workDay || raw.date || '',
                            raw
                        };
                    }
                },
                plan: {
                    collection: 'planning',
                    dateField: 'date',
                    mapper: (id, raw) => {
                        const dateValue = raw.date || '';
                        const primaryTimestamp = raw.createdAt || raw.updatedAt || raw.timestamp;
                        // Calcular workDay usando timestamp (quando foi criado)
                        // Se não tiver timestamp, assumir que a data salva JÁ é uma data de trabalho
                        const workDay = getWorkDayFromTimestamp(primaryTimestamp) || dateValue;
                        
                        return {
                            id,
                            date: dateValue,
                            machine: normalizeMachineId(raw.machine || null),
                            quantity: getPlanQuantity(raw), // Usa função centralizada para consistência com Dashboard TV
                            shift: normalizeShift(raw.shift ?? raw.turno),
                            product: raw.product || '',
                            mp: raw.mp || '',
                            workDay: workDay || dateValue,
                            raw
                        };
                    }
                },
                rework: {
                    collection: 'rework_entries',
                    dateField: 'data',
                    mapper: (id, raw) => {
                        const dateValue = raw.data || '';
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                        const workDay = getWorkDayFromTimestamp(primaryTimestamp) || dateValue;
                        return {
                            id,
                            date: dateValue,
                            machine: normalizeMachineId(raw.machine || null),
                            quantity: Number(raw.quantidade ?? raw.quantity ?? 0) || 0,
                            shift: normalizeShift(raw.turno ?? raw.shift),
                            reason: raw.motivo || raw.reason || '',
                            mp: raw.mp || '',
                            workDay: workDay || dateValue,
                            raw
                        };
                    }
                }
            };

            const config = collectionConfig[collection];
            if (!config) {
                console.warn(`Coleção de análise desconhecida: ${collection}`);
                return [];
            }

            if (!startDate || !endDate) {
                console.warn('[TRACE][getFilteredData] datas inválidas fornecidas', { startDate, endDate });
                return [];
            }

            let query = db.collection(config.collection);
            
            // Buscar um período amplo (do dia anterior ao dia posterior)
            // para capturar dados do turno 3 (23h-7h)
            const startObj = new Date(startDate);
            startObj.setDate(startObj.getDate() - 1);
            const queryStartDate = Number.isNaN(startObj.getTime()) ? null : startObj.toISOString().split('T')[0];
            
            const endObj = new Date(endDate);
            endObj.setDate(endObj.getDate() + 1);
            const queryEndDate = Number.isNaN(endObj.getTime()) ? null : endObj.toISOString().split('T')[0];
            
            console.log('[TRACE][getFilteredData] query setup with expanded date range', { 
                collection: config.collection,
                dateField: config.dateField,
                userStartDate: startDate,
                userEndDate: endDate,
                queryStartDate,
                queryEndDate,
                machine,
                shift
            });
            
            if (queryStartDate && queryEndDate) {
                query = query.where(config.dateField, '>=', queryStartDate).where(config.dateField, '<=', queryEndDate);
            }

            let snapshot = await query.get();

            if (snapshot.empty && queryStartDate && queryEndDate) {
                console.warn('[TRACE][getFilteredData] snapshot vazio com filtro de datas, reconsultando sem faixa para aplicar filtro no cliente');
                snapshot = await db.collection(config.collection).get();
            }
            console.log('[TRACE][getFilteredData] raw snapshot', { 
                collection: config.collection,
                size: snapshot.size,
                empty: snapshot.empty
            });
            
            let data = snapshot.docs.map(doc => config.mapper(doc.id, doc.data()));

            const startWorkDay = startDate || null;
            const endWorkDay = endDate || null;

            data = data.filter(item => {
                const workDay = item.workDay || item.date;
                if (!workDay) return false;
                const meetsStart = !startWorkDay || workDay >= startWorkDay;
                const meetsEnd = !endWorkDay || workDay <= endWorkDay;
                return meetsStart && meetsEnd;
            });

            if (collection === 'losses') {
                data = data.filter(item => {
                    if (item.quantity > 0) return true;
                    const rawWeight = Number(item.raw?.refugo_kg ?? item.raw?.weight ?? 0) || 0;
                    return rawWeight > 0;
                });
            }

            if (machine !== 'all') {
                const target = normalizeMachineId(machine);
                data = data.filter(item => normalizeMachineId(item.machine) === target);
            }

            if (shift !== 'all') {
                data = data.filter(item => Number(item.shift || 0) === Number(shift));
            }

            console.log('[TRACE][getFilteredData] returning data', {
                collection,
                count: data.length,
                sample: data.slice(0, 3)
            });
            return data;
        } catch (error) {
            console.error('Erro ao buscar dados filtrados:', error);
            return [];
        }
    }

    function parseTimeToMinutes(dateStr, timeStr) {
        // FIX: utilitário para converter HH:MM em minutos absolutos para cálculos de duração
        if (!dateStr || !timeStr) return null;
        const [hours, minutes] = timeStr.split(':').map(Number);
        if (Number.isNaN(hours) || Number.isNaN(minutes)) return null;
        const date = new Date(`${dateStr}T${timeStr}:00`);
        return Math.floor(date.getTime() / 60000);
    }

    function combineDateAndTime(dateStr, timeStr) {
        if (!dateStr || !timeStr) return null;
        const [year, month, day] = dateStr.split('-').map(Number);
        const [hour, minute] = timeStr.split(':').map(Number);
        if ([year, month, day, hour, minute].some(value => Number.isNaN(value))) {
            return null;
        }
        return new Date(year, (month || 1) - 1, day || 1, hour || 0, minute || 0, 0, 0);
    }

    // Helpers para lidar com paradas multi-dia
    function pad2(n) { return String(n).padStart(2, '0'); }
    function formatDateYMD(d) {
        return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    }
    function formatTimeHM(d) { return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`; }

    // ========================================
    // SISTEMA ROBUSTO DE PARADAS - V2.0
    // ========================================
    
    /**
     * Definição dos turnos (configurável)
     * Turno 1: 06:30 - 14:59
     * Turno 2: 15:00 - 23:19
     * Turno 3: 23:20 - 06:29 (cruza meia-noite)
     */
    const SHIFT_DEFINITIONS = [
        { shift: 1, startHour: 6, startMin: 30, endHour: 14, endMin: 59 },
        { shift: 2, startHour: 15, startMin: 0, endHour: 23, endMin: 19 },
        { shift: 3, startHour: 23, startMin: 20, endHour: 6, endMin: 29, crossesMidnight: true }
    ];

    /**
     * Determina o turno de uma data/hora específica
     */
    function getShiftForDateTime(dateTime) {
        if (!(dateTime instanceof Date) || isNaN(dateTime.getTime())) return null;
        
        const hour = dateTime.getHours();
        const min = dateTime.getMinutes();
        const totalMinutes = hour * 60 + min;
        
        // Turno 1: 06:30 - 14:59 (390 - 899 minutos)
        if (totalMinutes >= 390 && totalMinutes < 900) return 1;
        // Turno 2: 15:00 - 23:19 (900 - 1399 minutos)
        if (totalMinutes >= 900 && totalMinutes < 1400) return 2;
        // Turno 3: 23:20 - 06:29 (1400 - 1439 ou 0 - 389 minutos)
        return 3;
    }

    /**
     * Retorna o início do turno para uma data e turno específicos
     */
    function getShiftStart(date, shift) {
        const d = new Date(date);
        switch (shift) {
            case 1: d.setHours(6, 30, 0, 0); break;
            case 2: d.setHours(15, 0, 0, 0); break;
            case 3: d.setHours(23, 20, 0, 0); break;
            default: d.setHours(6, 30, 0, 0);
        }
        return d;
    }

    /**
     * Retorna o fim do turno para uma data e turno específicos
     */
    function getShiftEnd(date, shift) {
        const d = new Date(date);
        const hour = d.getHours();
        
        switch (shift) {
            case 1: 
                d.setHours(14, 59, 59, 999); 
                break;
            case 2: 
                d.setHours(23, 19, 59, 999); 
                break;
            case 3: 
                // Turno 3 vai até 06:29
                // Se estamos entre 23:20-23:59, o fim é 06:29 do dia SEGUINTE
                // Se estamos entre 00:00-06:29, o fim é 06:29 do MESMO dia
                if (hour >= 23) {
                    d.setDate(d.getDate() + 1);
                }
                d.setHours(6, 29, 59, 999); 
                break;
            default: 
                d.setHours(14, 59, 59, 999);
        }
        return d;
    }

    /**
     * Calcula a data de produção (workday) para uma data/hora
     * O dia de produção é definido pelo turno 1 (começa às 07:00)
     */
    function getWorkdayForDateTime(dateTime) {
        if (!(dateTime instanceof Date) || isNaN(dateTime.getTime())) {
            return formatDateYMD(new Date());
        }
        
        const hour = dateTime.getHours();
        const minute = dateTime.getMinutes();
        // Se for entre 00:00 e 06:29, pertence ao dia anterior de produção
        if (hour < 6 || (hour === 6 && minute < 30)) {
            const prevDay = new Date(dateTime);
            prevDay.setDate(prevDay.getDate() - 1);
            return formatDateYMD(prevDay);
        }
        return formatDateYMD(dateTime);
    }

    /**
     * Quebra uma parada longa em segmentos por TURNO (não apenas por dia)
     * Isso garante que cada segmento tenha o turno correto associado
     */
    function splitDowntimeIntoShiftSegments(startDateStr, startTimeStr, endDateStr, endTimeStr) {
        const segments = [];
        
        // Validação e parsing das datas
        const startDateTime = parseDateTime(startDateStr, startTimeStr);
        const endDateTime = parseDateTime(endDateStr, endTimeStr);
        
        console.log('[DOWNTIME] splitDowntimeIntoShiftSegments input:', {
            startDateStr, startTimeStr, endDateStr, endTimeStr,
            startDateTime: startDateTime?.toISOString(),
            endDateTime: endDateTime?.toISOString()
        });
        
        if (!startDateTime || !endDateTime) {
            console.error('[DOWNTIME] Datas inválidas:', { startDateStr, startTimeStr, endDateStr, endTimeStr });
            return segments;
        }
        
        // Calcular diferença em milissegundos
        const diffMs = endDateTime.getTime() - startDateTime.getTime();
        
        // Se a diferença for negativa ou zero, criar segmento mínimo de 1 minuto
        if (diffMs <= 0) {
            console.warn('[DOWNTIME] Data fim anterior ou igual à data início - criando segmento mínimo', {
                diffMs,
                start: startDateTime.toISOString(),
                end: endDateTime.toISOString()
            });
            const currentShift = getShiftForDateTime(startDateTime);
            const workday = getWorkdayForDateTime(startDateTime);
            segments.push({
                date: workday,
                startTime: formatTimeHM(startDateTime),
                endTime: formatTimeHM(startDateTime), // Mesmo horário, duração mínima
                duration: 1,
                shift: currentShift,
                _segmentStart: startDateTime.toISOString(),
                _segmentEnd: startDateTime.toISOString()
            });
            return segments;
        }
        
        // Se a parada for muito curta (menos de 1 minuto), criar segmento mínimo
        if (diffMs < 60000) {
            console.log('[DOWNTIME] Parada muito curta (' + Math.round(diffMs/1000) + 's), criando segmento mínimo de 1 min');
            const currentShift = getShiftForDateTime(startDateTime);
            const workday = getWorkdayForDateTime(startDateTime);
            segments.push({
                date: workday,
                startTime: formatTimeHM(startDateTime),
                endTime: formatTimeHM(endDateTime),
                duration: 1,
                shift: currentShift,
                _segmentStart: startDateTime.toISOString(),
                _segmentEnd: endDateTime.toISOString()
            });
            return segments;
        }
        
        // Para paradas curtas (menos de 10 minutos), criar um único segmento sem divisão por turno
        if (diffMs < 600000) {
            console.log('[DOWNTIME] Parada curta (' + Math.round(diffMs/60000) + ' min), criando segmento único');
            const currentShift = getShiftForDateTime(startDateTime);
            const workday = getWorkdayForDateTime(startDateTime);
            const durationMin = Math.max(1, Math.round(diffMs / 60000));
            segments.push({
                date: workday,
                startTime: formatTimeHM(startDateTime),
                endTime: formatTimeHM(endDateTime),
                duration: durationMin,
                shift: currentShift,
                _segmentStart: startDateTime.toISOString(),
                _segmentEnd: endDateTime.toISOString()
            });
            return segments;
        }
        
        let cursor = new Date(startDateTime);
        let safetyCounter = 0;
        const MAX_ITERATIONS = 1000; // Proteção contra loop infinito
        
        while (cursor < endDateTime && safetyCounter < MAX_ITERATIONS) {
            safetyCounter++;
            
            const currentShift = getShiftForDateTime(cursor);
            const shiftEndTime = getShiftEnd(cursor, currentShift);
            
            // O segmento termina no menor entre: fim do turno ou fim da parada
            const segmentEnd = new Date(Math.min(shiftEndTime.getTime(), endDateTime.getTime()));
            
            // Calcular duração em minutos
            const durationMs = segmentEnd.getTime() - cursor.getTime();

            if (durationMs <= 0) {
                console.warn('[DOWNTIME] Segmento inválido detectado. Forçando avanço mínimo.', {
                    cursor: cursor.toISOString(),
                    shift: currentShift,
                    shiftEnd: shiftEndTime.toISOString()
                });
                cursor = new Date(cursor.getTime() + 60000);
                continue;
            }

            const durationMin = Math.max(1, Math.round(durationMs / 60000));
            
            // Determinar a data de trabalho (workday) do segmento
            const workday = getWorkdayForDateTime(cursor);
            
            segments.push({
                date: workday,
                startTime: formatTimeHM(cursor),
                endTime: formatTimeHM(segmentEnd),
                duration: durationMin,
                shift: currentShift,
                // Metadados adicionais para debug
                _segmentStart: cursor.toISOString(),
                _segmentEnd: segmentEnd.toISOString()
            });
            
            // Avançar cursor para o próximo ponto
            // Para o último segmento, não adiciona 1 minuto extra
            if (segmentEnd.getTime() >= endDateTime.getTime()) {
                break;
            }
            cursor = new Date(segmentEnd.getTime() + 60000);
        }
        
        if (safetyCounter >= MAX_ITERATIONS) {
            console.error('[DOWNTIME] Loop de segmentação excedeu limite de segurança');
        }
        
        // Se não gerou nenhum segmento, criar um mínimo
        if (segments.length === 0) {
            console.warn('[DOWNTIME] Nenhum segmento gerado, criando segmento mínimo');
            const currentShift = getShiftForDateTime(startDateTime);
            const workday = getWorkdayForDateTime(startDateTime);
            segments.push({
                date: workday,
                startTime: formatTimeHM(startDateTime),
                endTime: formatTimeHM(endDateTime),
                duration: Math.max(1, Math.round(diffMs / 60000)),
                shift: currentShift,
                _segmentStart: startDateTime.toISOString(),
                _segmentEnd: endDateTime.toISOString()
            });
        }
        
        console.log('[DOWNTIME] Segmentos gerados:', segments.length, segments);
        return segments;
    }

    /**
     * Consolida segmentos de parada em eventos únicos.
     * Segmentos com o mesmo originalStartTimestamp são agrupados.
     * Segmentos sem metadados são agrupados por proximidade (mesma máquina, mesmo motivo, horários consecutivos).
     */
    function consolidateDowntimeEvents(segments = []) {
        if (!Array.isArray(segments) || segments.length === 0) {
            return [];
        }

        const MAX_DURATION_MIN = 24 * 60; // 24h máximo por evento
        const eventsMap = new Map();
        
        // Primeiro passo: ordenar segmentos por máquina, data e hora de início
        const sortedSegments = [...segments].sort((a, b) => {
            const machineA = a.machine || '';
            const machineB = b.machine || '';
            if (machineA !== machineB) return machineA.localeCompare(machineB);
            
            const dateA = a.date || a.workDay || '';
            const dateB = b.date || b.workDay || '';
            if (dateA !== dateB) return dateA.localeCompare(dateB);
            
            const timeA = a.startTime || '00:00';
            const timeB = b.startTime || '00:00';
            return timeA.localeCompare(timeB);
        });

        sortedSegments.forEach((segment, index) => {
            if (!segment) return;

            const raw = segment.raw || {};
            const baseStart = raw.originalStartTimestamp || null;
            const baseEnd = raw.originalEndTimestamp || null;
            const machineId = segment.machine || 'unknown-machine';
            const reason = (segment.reason || raw.reason || '').trim().toLowerCase();
            
            let key;
            let isGrouped = false;
            
            // Estratégia 1: Se tem originalStartTimestamp, agrupa pelo evento pai
            if (baseStart) {
                key = `parent|${machineId}|${baseStart}|${baseEnd || ''}`;
                isGrouped = true;
            }
            // Estratégia 2: Se tem totalSegments/segmentIndex, faz parte de um evento segmentado
            else if (raw.totalSegments && raw.totalSegments > 1) {
                // Usar originalStartTimestamp do parent ou criar chave baseada em metadados
                const parentStart = raw.originalStartTimestamp || raw.startTimestamp || `${segment.date}T${segment.startTime || '00:00'}`;
                key = `segmented|${machineId}|${parentStart}`;
                isGrouped = true;
            }
            // Estratégia 3: Agrupar por proximidade temporal (mesmo motivo, mesmo dia, horários próximos)
            else {
                // Verificar se este segmento pode ser agrupado com algum evento existente
                const segmentDate = segment.date || segment.workDay || '';
                const segmentStartTime = segment.startTime || '';
                const segmentEndTime = segment.endTime || '';
                
                // Procurar evento existente que possa agrupar este segmento
                let matchingKey = null;
                for (const [existingKey, existingEvent] of eventsMap.entries()) {
                    if (!existingKey.startsWith('proximity|')) continue;
                    if (existingEvent.machine !== machineId) continue;
                    if (existingEvent.reason.toLowerCase() !== reason) continue;
                    
                    // Verificar se é do mesmo dia
                    const eventDate = existingEvent.workDay || existingEvent.date || '';
                    if (eventDate !== segmentDate) continue;
                    
                    // Verificar proximidade temporal (se o fim do evento existente está próximo do início deste)
                    const lastSegment = existingEvent.segments[existingEvent.segments.length - 1];
                    const lastEndTime = lastSegment?.endTime || '';
                    
                    if (lastEndTime && segmentStartTime) {
                        // Se o início deste segmento é igual ou próximo ao fim do último
                        if (segmentStartTime <= lastEndTime || isTimeClose(lastEndTime, segmentStartTime, 5)) {
                            matchingKey = existingKey;
                            break;
                        }
                    }
                }
                
                if (matchingKey) {
                    key = matchingKey;
                    isGrouped = true;
                } else {
                    // Criar novo grupo de proximidade
                    key = `proximity|${machineId}|${segmentDate}|${segmentStartTime}|${reason.substring(0, 20)}`;
                    isGrouped = false;
                }
            }

            let event = eventsMap.get(key);
            if (!event) {
                const startDateTime = baseStart ? new Date(baseStart) : combineDateAndTime(segment.date, segment.startTime);
                const endDateTime = baseEnd ? new Date(baseEnd) : combineDateAndTime(segment.date, segment.endTime);

                event = {
                    id: key,
                    machine: machineId,
                    reason: segment.reason || raw.reason || 'Não informado',
                    duration: 0,
                    startDateTime: startDateTime,
                    endDateTime: endDateTime,
                    workDay: segment.workDay || segment.date || '',
                    segments: [],
                    metadata: raw,
                    isGrouped: isGrouped,
                    date: segment.date || ''
                };
                eventsMap.set(key, event);
            }

            // Calcular duração do segmento
            const segmentDuration = Math.min(Number(segment.duration) || 0, MAX_DURATION_MIN);
            
            // Verificar se este segmento é duplicata (mesmo horário já adicionado)
            const isDuplicate = event.segments.some(s => 
                s.date === segment.date && 
                s.startTime === segment.startTime && 
                s.endTime === segment.endTime
            );
            
            if (!isDuplicate) {
                event.duration += segmentDuration;
                event.segments.push(segment);

                const segStart = combineDateAndTime(segment.date, segment.startTime);
                const segEnd = combineDateAndTime(segment.date, segment.endTime);

                if (segStart && (!event.startDateTime || segStart < event.startDateTime)) {
                    event.startDateTime = segStart;
                }
                if (segEnd && (!event.endDateTime || segEnd > event.endDateTime)) {
                    event.endDateTime = segEnd;
                }

                if (segment.workDay && (!event.workDay || segment.workDay < event.workDay)) {
                    event.workDay = segment.workDay;
                }
            }
        });

        return Array.from(eventsMap.values()).map(event => {
            // Aplicar cap final de duração para segurança
            const cappedDuration = Math.min(event.duration, MAX_DURATION_MIN);
            
            const startDate = event.startDateTime ? formatDateYMD(event.startDateTime) : (event.segments[0]?.date || '');
            const endDate = event.endDateTime ? formatDateYMD(event.endDateTime) : (event.segments[event.segments.length - 1]?.date || '');
            const startTime = event.startDateTime ? formatTimeHM(event.startDateTime) : (event.segments[0]?.startTime || '');
            const endTime = event.endDateTime ? formatTimeHM(event.endDateTime) : (event.segments[event.segments.length - 1]?.endTime || '');

            return {
                id: event.id,
                machine: event.machine,
                reason: event.reason,
                duration: cappedDuration,
                date: startDate,
                workDay: event.workDay || startDate,
                startTime,
                endTime,
                startDateTime: event.startDateTime,
                endDateTime: event.endDateTime,
                shift: event.segments[0]?.shift || inferShiftFromSegment(event.workDay || startDate, startTime, endTime),
                segments: event.segments,
                segmentCount: event.segments.length,
                raw: event.metadata
            };
        });
    }
    
    /**
     * Verifica se dois horários estão próximos (dentro de N minutos)
     */
    function isTimeClose(time1, time2, toleranceMinutes = 5) {
        if (!time1 || !time2) return false;
        
        const toMinutes = (t) => {
            const parts = t.split(':');
            if (parts.length < 2) return null;
            const h = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10);
            if (isNaN(h) || isNaN(m)) return null;
            return h * 60 + m;
        };
        
        const min1 = toMinutes(time1);
        const min2 = toMinutes(time2);
        
        if (min1 === null || min2 === null) return false;
        
        return Math.abs(min2 - min1) <= toleranceMinutes;
    }

    /**
     * Função auxiliar para fazer parse de data + hora
     */
    function parseDateTime(dateStr, timeStr) {
        if (!dateStr || !timeStr) return null;
        
        try {
            // Normalizar formato de hora
            const normalizedTime = timeStr.length === 5 ? `${timeStr}:00` : timeStr;
            const dateTimeStr = `${dateStr}T${normalizedTime}`;
            const dt = new Date(dateTimeStr);
            
            if (isNaN(dt.getTime())) {
                console.warn('[DOWNTIME] Parse falhou para:', dateTimeStr);
                return null;
            }
            
            return dt;
        } catch (e) {
            console.error('[DOWNTIME] Erro ao fazer parse de data:', e);
            return null;
        }
    }

    /**
     * Versão legada mantida para compatibilidade - agora usa a nova função internamente
     */
    function splitDowntimeIntoDailySegments(startDateStr, startTimeStr, endDateStr, endTimeStr) {
        // Redireciona para a nova função que segmenta por turno
        return splitDowntimeIntoShiftSegments(startDateStr, startTimeStr, endDateStr, endTimeStr);
    }

    // Inferir turno a partir de um segmento (usa o ponto médio do intervalo)
    function inferShiftFromSegment(dateStr, startTimeStr, endTimeStr) {
        const toMinutes = (t) => {
            if (!t || !t.includes(':')) return null;
            const [h, m] = t.split(':').map(Number);
            if (Number.isNaN(h) || Number.isNaN(m)) return null;
            return h * 60 + m;
        };
        const startMin = toMinutes(startTimeStr);
        const endMin = toMinutes(endTimeStr);
        // Se não houver ambos, tenta classificar pelo horário disponível
        const refMin = (startMin !== null && endMin !== null)
            ? Math.floor((startMin + endMin) / 2)
            : (startMin !== null ? startMin : endMin);
        if (refMin === null) return null;

        // Turno 1: 07:00–14:59 | Turno 2: 15:00–23:19 | Turno 3: 23:20–06:59
        if (refMin >= (7 * 60) && refMin < (15 * 60)) return 1;
        if (refMin >= (15 * 60) && refMin < (23 * 60 + 20)) return 2;
        return 3; // 23:20–23:59 ou 00:00–06:59
    }

    function calculateHoursInPeriod(startDate, endDate) {
        if (!startDate || !endDate) return 0;

        const start = new Date(`${startDate}T07:00:00`);
        let end = new Date(`${endDate}T07:00:00`);

        if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
            return 0;
        }

        if (end <= start) {
            end = new Date(start);
            end.setDate(end.getDate() + 1);
        }

        const diffHours = (end - start) / (1000 * 60 * 60);
        return Math.max(24, diffHours);
    }

    function showAnalysisLoading(show) {
        const loading = document.getElementById('analysis-loading');
        const noData = document.getElementById('analysis-no-data');
        
        if (show) {
            loading.classList.remove('hidden');
            noData.classList.add('hidden');
        } else {
            loading.classList.add('hidden');
        }
    }

    function showAnalysisError() {
        const loading = document.getElementById('analysis-loading');
        const noData = document.getElementById('analysis-no-data');
        
        loading.classList.add('hidden');
        noData.classList.remove('hidden');
    }

    function showAnalysisNoData(message = 'Nenhum dado disponível para os filtros selecionados.') {
        const loading = document.getElementById('analysis-loading');
        const noData = document.getElementById('analysis-no-data');

        if (loading) {
            loading.classList.add('hidden');
        }

        if (noData) {
            noData.classList.remove('hidden');
            const messageElement = noData.querySelector('[data-analysis-empty-message]') || noData.querySelector('p');
            if (messageElement && message) {
                messageElement.textContent = message;
            }
        }
    }

    function loadAnalysisMachines() {
        // Inicializar lista de máquinas com os dados do banco de dados (normalizados)
        machines = machineDatabase.map(machine => ({ 
            id: normalizeMachineId(machine.id), 
            name: normalizeMachineId(machine.id), 
            model: machine.model 
        }));
        
        // Carregar lista de máquinas para o filtro
        const machineSelector = document.getElementById('analysis-machine');
        if (machineSelector) {
            machineSelector.innerHTML = '<option value="all">Todas as máquinas</option>';
            machines.forEach(machine => {
                const option = document.createElement('option');
                option.value = machine.id;
                option.textContent = `${machine.id} - ${machine.model}`;
                machineSelector.appendChild(option);
            });
        }

        // Carregar lista de máquinas para o formulário de ordens
        populateOrderMachineSelect();
    }

    function populateOrderMachineSelect() {
        const orderMachineSelect = document.getElementById('order-machine');
        if (orderMachineSelect) {
            // Manter a opção vazia no início
            const currentValue = orderMachineSelect.value;
            orderMachineSelect.innerHTML = '<option value="">Selecione uma máquina</option>';
            
            machineDatabase.forEach(machine => {
                const option = document.createElement('option');
                const mid = normalizeMachineId(machine.id);
                option.value = mid;
                option.textContent = `${mid} - ${machine.model}`;
                orderMachineSelect.appendChild(option);
            });

            // Restaurar valor anterior se existisse
            if (currentValue) {
                orderMachineSelect.value = currentValue;
            }
        }
    }

    // Função para atualizar o painel de informações da máquina na análise
    function updateAnalysisInfoPanel() {
        const machineSelector = document.getElementById('analysis-machine');
        const infoPanel = document.getElementById('analysis-info-panel');
        
        if (!machineSelector || !infoPanel) return;
        
        const selectedMachineId = machineSelector.value;
        
        // Se nenhuma máquina específica foi selecionada, ocultar o painel
        if (selectedMachineId === 'all') {
            infoPanel.classList.add('hidden');
            return;
        }
        
        // Encontrar a máquina
        const machineInfo = machineDatabase.find(m => normalizeMachineId(m.id) === selectedMachineId);
        
        if (machineInfo) {
            infoPanel.classList.remove('hidden');
            
            // Atualizar apenas nome e modelo da máquina
            document.getElementById('analysis-info-machine').textContent = selectedMachineId;
            document.getElementById('analysis-info-machine-model').textContent = machineInfo.model || '-';
        }
    }
    
    // Função para limpar informações do produto
    function clearAnalysisProductInfo() {
        // Função simplificada - não usada mais
    }
    
    // Função para atualizar o painel com informações do produto
    function updateAnalysisProductInfo(productCode, cycle, cavities, weight, productName) {
        const infoPanel = document.getElementById('analysis-info-panel');
        
        if (!infoPanel) return;
        
        if (productCode) {
            document.getElementById('analysis-info-product').textContent = productName || `Produto ${productCode}`;
            document.getElementById('analysis-info-product-code').textContent = `Código: ${productCode}`;
        }
        
        if (cycle) document.getElementById('analysis-info-cycle').textContent = cycle.toFixed(2);
        if (cavities) document.getElementById('analysis-info-cavities').textContent = cavities;
        if (weight) document.getElementById('analysis-info-weight').textContent = weight.toFixed(3);
    }

    function setAnalysisDefaultDates() {
        const workdayDate = getProductionDateString();
        // CORREÇÃO: Usar apenas o workday, não o range de calendário
        // O range de calendário era usado para cobrir dados de dois dias, mas isso causa
        // discrepância com o Dashboard TV que só mostra o dia atual
        
        const startDateInput = document.getElementById('analysis-start-date');
        const endDateInput = document.getElementById('analysis-end-date');
        
        if (startDateInput) startDateInput.value = workdayDate;
        if (endDateInput) endDateInput.value = workdayDate;
        
        // Configurar filtros padrão - usar apenas o workday atual (consistente com Dashboard TV)
        currentAnalysisFilters = {
            startDate: workdayDate,
            endDate: workdayDate,
            machine: 'all',
            shift: 'all'
        };
        
        console.log('[ANALYSIS] Default dates set:', {
            workdayDate,
            filters: currentAnalysisFilters
        });
    }

    // Helper: atualiza a aba de análise se ela estiver ativa
    async function refreshAnalysisIfActive() {
        try {
            const currentPage = document.querySelector('.nav-btn.active')?.dataset.page;
            if (currentPage !== 'analise') return;

            const activeView = document.querySelector('.analysis-tab-btn.active')?.getAttribute('data-view') || 'overview';
            console.log('[TRACE][refreshAnalysisIfActive] refreshing analysis view', { activeView, filters: currentAnalysisFilters });
            await loadAnalysisData(activeView);
        } catch (err) {
            console.error('[TRACE][refreshAnalysisIfActive] erro ao refrescar análise', err);
        }
    }

    // Funções para geração de gráficos específicos da análise

    // Gráfico de distribuição OEE por máquina
    async function generateOEEDistributionChart(productionData, lossesData, downtimeData) {
        const ctx = document.getElementById('oee-distribution-chart');
        if (!ctx) return;

        destroyChart('oee-distribution-chart');

        const machines = [...new Set(productionData.map(item => item.machine))].filter(m => m);
        
        if (machines.length === 0) {
            showNoDataMessage('oee-distribution-chart');
            return;
        }
        
        clearNoDataMessage('oee-distribution-chart');
        
    const oeeByMachine = {};
    // Janela analisada em minutos (07:00 → 07:00)
    const periodMinutes = Math.max(1, calculateHoursInPeriod(currentAnalysisFilters.startDate, currentAnalysisFilters.endDate) * 60);

        machines.forEach(machine => {
            const machineProduction = productionData.filter(item => item.machine === machine);
            const machineLosses = lossesData.filter(item => item.machine === machine);
            const machineDowntime = downtimeData.filter(item => item.machine === machine);

            const totalProduced = machineProduction.reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);
            const totalLosses = machineLosses.reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);
            const totalDowntime = machineDowntime.reduce((sum, item) => sum + (Number(item.duration) || 0), 0);

            // Componentes em fração [0..1]
            const availability = Math.max(0, 1 - (totalDowntime / periodMinutes));
            const quality = totalProduced > 0 ? Math.max(0, (totalProduced - totalLosses) / totalProduced) : 1;
            const performance = 0.85; // aproximação conservadora até termos cálculo por máquina

            const oeeFraction = Math.max(0, Math.min(1, availability * performance * quality));
            oeeByMachine[machine] = oeeFraction * 100; // guardar já em %
        });

        const labels = Object.keys(oeeByMachine);
        const values = Object.values(oeeByMachine).map(value => Number((value || 0).toFixed(1)));

        renderModernDonutChart({
            canvasId: 'oee-distribution-chart',
            labels,
            data: values,
            colors: ['#10B981', '#3B82F6', '#F97316', '#8B5CF6', '#F59E0B', '#EC4899'],
            datasetLabel: 'OEE %',
            tooltipFormatter: (context) => `${context.label}: ${Number(context.parsed || 0).toFixed(1)}%`
        });
    }

    // Geração do ranking de máquinas
    async function generateMachineRanking(productionData, planData) {
        const rankingContainer = document.getElementById('machine-ranking');
        if (!rankingContainer) return;

        const producedByMachine = new Map();
        const plannedByMachine = new Map();

        (productionData || []).forEach(item => {
            const m = (item?.machine || '').toString();
            if (!m) return;
            producedByMachine.set(m, (producedByMachine.get(m) || 0) + (Number(item.quantity) || 0));
        });

        (planData || []).forEach(plan => {
            const m = (plan?.machine || '').toString();
            if (!m) return;
            plannedByMachine.set(m, (plannedByMachine.get(m) || 0) + (Number(plan.quantity) || 0));
        });

        const entries = Array.from(new Set([...producedByMachine.keys(), ...plannedByMachine.keys()]))
            .map(m => {
                const produced = producedByMachine.get(m) || 0;
                const planned = plannedByMachine.get(m) || 0;
                const perf = planned > 0 ? Math.max(0, (produced / planned) * 100) : null;
                return { machine: m, produced, planned, perf };
            })
            .filter(e => e.perf !== null)
            .sort((a, b) => (b.perf - a.perf));

        if (entries.length === 0) {
            rankingContainer.innerHTML = '<div class="p-4 text-sm text-gray-500">Sem dados de plano para calcular performance.</div>';
            return;
        }

        const getColor = (p) => {
            if (p >= 90) return 'bg-green-500';
            if (p >= 75) return 'bg-blue-500';
            if (p >= 60) return 'bg-yellow-500';
            return 'bg-red-500';
        };

        const html = entries.slice(0, 6).map((row, index) => `
            <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                <div class="flex items-center gap-4">
                    <div class="flex items-center justify-center w-8 h-8 ${getColor(row.perf)} text-white rounded-full font-bold">
                        ${index + 1}
                    </div>
                    <span class="font-semibold">${row.machine}</span>
                </div>
                <div class="text-right">
                    <span class="text-2xl font-bold text-gray-800">${row.perf.toFixed(1)}%</span>
                    <div class="w-24 h-2 bg-gray-200 rounded-full mt-1">
                        <div class="h-2 ${getColor(row.perf)} rounded-full" style="width: ${Math.min(100, row.perf).toFixed(1)}%"></div>
                    </div>
                    <div class="text-xs text-gray-500 mt-1">${row.produced.toLocaleString('pt-BR')} / ${row.planned.toLocaleString('pt-BR')} pcs</div>
                </div>
            </div>
        `).join('');

        rankingContainer.innerHTML = html;
    }

    // Gráfico de produção por hora
    async function generateHourlyProductionChart(productionData, options = {}) {
        const {
            canvas: providedCanvas = null,
            targetCanvasId = 'hourly-production-chart',
            chartContext = 'main',
            dailyTargetOverride = null,
            updateTimeline = chartContext === 'main'
        } = options;

        const canvas = providedCanvas || document.getElementById(targetCanvasId);
        if (!canvas) return;
        const canvasId = canvas.id || targetCanvasId;

        if (chartContext === 'analysis') {
            if (analysisHourlyChartInstance) {
                analysisHourlyChartInstance.destroy();
                analysisHourlyChartInstance = null;
            }
        } else if (hourlyChartInstance) {
            hourlyChartInstance.destroy();
            hourlyChartInstance = null;
        }

        if (!Array.isArray(productionData) || productionData.length === 0) {
            showNoDataMessage(canvasId);
            if (updateTimeline) {
                updateTimelineProgress(0, 0, 0);
            }
            return;
        }

        clearNoDataMessage(canvasId);

        const orderedHours = getProductionHoursOrder();
        const executedByHour = Object.fromEntries(orderedHours.map(label => [label, 0]));

        productionData.forEach(item => {
            if (!item?.datetime) return;
            const eventDate = new Date(item.datetime);
            if (Number.isNaN(eventDate.getTime())) return;
            const label = formatHourLabel(eventDate.getHours());
            executedByHour[label] = (executedByHour[label] || 0) + (Number(item.quantity) || 0);
        });

        const overrideTarget = Number(dailyTargetOverride);
        let dailyTarget = Number.isFinite(overrideTarget) && overrideTarget > 0 ? overrideTarget : Number(selectedMachineData?.daily_target) || 1000;
        if (!Number.isFinite(dailyTarget) || dailyTarget < 0) {
            dailyTarget = 0;
        }

        const hourlyTarget = HOURS_IN_PRODUCTION_DAY > 0 ? (dailyTarget / HOURS_IN_PRODUCTION_DAY) : 0;

        const executedSeries = orderedHours.map(label => executedByHour[label] || 0);
        const plannedSeries = orderedHours.map(() => hourlyTarget);

        const totalExecuted = executedSeries.reduce((sum, value) => sum + value, 0);
        const totalPlanned = Math.max(0, dailyTarget);
        const hoursElapsed = getHoursElapsedInProductionDay(new Date());
        const expectedByNow = totalPlanned > 0 ? Math.min(hoursElapsed * hourlyTarget, totalPlanned) : 0;

        const instance = createHourlyProductionChart({
            canvas,
            labels: orderedHours,
            executedPerHour: executedSeries,
            plannedPerHour: plannedSeries,
            highlightCurrentHour: chartContext === 'main'
        });

        if (chartContext === 'analysis') {
            analysisHourlyChartInstance = instance;
        } else {
            hourlyChartInstance = instance;
        }

        if (updateTimeline) {
            updateTimelineProgress(totalExecuted, totalPlanned, expectedByNow);
        }

    }

    // Função para atualizar a barra de timeline
    function updateTimelineProgress(executed, planned, expectedByNow) {
        const progressBar = document.getElementById('timeline-progress');
        const targetIndicator = document.getElementById('timeline-target-indicator');
        const percentageText = document.getElementById('timeline-percentage');
        const executedText = document.getElementById('timeline-executed');
        const plannedText = document.getElementById('timeline-planned');
        const statusIndicator = document.getElementById('timeline-status-indicator');
        const statusText = document.getElementById('timeline-status-text');
        const lastUpdateText = document.getElementById('timeline-last-update');

        if (!progressBar || !targetIndicator) return;

        // Calcular percentuais
        const executedPercentage = planned > 0 ? Math.min((executed / planned) * 100, 100) : 0;
        const expectedPercentage = planned > 0 ? Math.min((expectedByNow / planned) * 100, 100) : 0;
        const palette = resolveProgressPalette(executedPercentage);
        const orderStatus = (currentActiveOrder && typeof currentActiveOrder.status === 'string')
            ? currentActiveOrder.status.toLowerCase()
            : '';
        const blockedStatuses = ['concluida', 'cancelada', 'finalizada', 'encerrada'];
    const orderEligibleForFinalize = !!currentActiveOrder?.id && !blockedStatuses.includes(orderStatus);
    const orderEligibleForActivate = !!currentActiveOrder?.id && !blockedStatuses.includes(orderStatus) && orderStatus !== 'ativa';

        currentOrderProgress = {
            executed: Number.isFinite(executed) ? executed : 0,
            planned: Number.isFinite(planned) ? planned : 0,
            expected: Number.isFinite(expectedByNow) ? expectedByNow : 0
        };

        // Animar barra de progresso
        setTimeout(() => {
            progressBar.style.width = `${executedPercentage}%`;
            targetIndicator.style.left = `${expectedPercentage}%`;
        }, 100);

        progressBar.classList.add('timeline-progress');
        progressBar.style.background = `linear-gradient(90deg, ${palette.start}, ${palette.end})`;
        progressBar.style.boxShadow = `0 6px 18px ${hexWithAlpha(palette.end, 0.35)}`;
        targetIndicator.style.backgroundColor = palette.end;
    const lotCompleted = planned > 0 && executed >= planned;
    progressBar.classList.toggle('timeline-complete', lotCompleted);

        // Atualizar textos
        if (percentageText) {
            percentageText.textContent = `${executedPercentage.toFixed(1)}%`;
            percentageText.classList.remove('text-red-600', 'text-amber-500', 'text-emerald-600', 'text-green-600');
            if (palette.textClass) {
                percentageText.classList.add(palette.textClass);
            }
        }
        
        if (executedText) {
            executedText.textContent = `${executed.toLocaleString('pt-BR')} peças`;
        }
        
        if (plannedText) {
            plannedText.textContent = `${planned.toLocaleString('pt-BR')} un (Planejado)`;
        }

        // Determinar status
        let status = 'on-track';
        let statusMessage = 'No prazo';
        let indicatorClass = 'bg-green-500 animate-pulse';

        if (executed < expectedByNow * 0.8) {
            status = 'behind';
            statusMessage = 'Atrasado';
            indicatorClass = 'bg-red-500 animate-pulse';
        } else if (executed > expectedByNow * 1.2) {
            status = 'ahead';
            statusMessage = 'Adiantado';
            indicatorClass = 'bg-blue-500 animate-pulse';
        }

        if (lotCompleted) {
            status = 'completed';
            statusMessage = 'Lote concluído';
            indicatorClass = 'bg-emerald-500 animate-pulse';
        }

        // Atualizar indicador de status
        if (statusIndicator) {
            statusIndicator.className = `w-2 h-2 rounded-full ${indicatorClass}`;
        }
        
        if (statusText) {
            statusText.textContent = statusMessage;
            statusText.className = `text-gray-600 font-medium`;
            
            if (status === 'behind') {
                statusText.className = 'text-red-600 font-medium';
            } else if (status === 'ahead') {
                statusText.className = 'text-blue-600 font-medium';
            } else {
                statusText.className = 'text-green-600 font-medium';
            }
        }

        // Atualizar timestamp
        if (lastUpdateText) {
            const now = new Date();
            lastUpdateText.textContent = `Última atualização: ${now.toLocaleTimeString('pt-BR', { 
                hour: '2-digit', 
                minute: '2-digit' 
            })}`;
        }

        if (finalizeOrderBtn) {
            finalizeOrderBtn.classList.toggle('hidden', !orderEligibleForFinalize);
            finalizeOrderBtn.disabled = !orderEligibleForFinalize;
        }
        if (activateOrderBtn) {
            activateOrderBtn.classList.toggle('hidden', !orderEligibleForActivate);
            activateOrderBtn.disabled = !orderEligibleForActivate;
        }
    }

    // Ativa OP a partir do painel da máquina (botão azul)
    async function handleActivateOrderFromPanel(event) {
        event?.preventDefault?.();

        if (!selectedMachineData) {
            alert('Selecione uma máquina antes de ativar a OP.');
            return;
        }

        // Se já houver ordem ativa, não fazer nada
        if (currentActiveOrder && String(currentActiveOrder.status || '').toLowerCase() === 'ativa') {
            showNotification('Esta OP já está ativa nesta máquina.', 'info');
            return;
        }

        const machineId = selectedMachineData.machine;
        let targetOrder = currentActiveOrder;

        // Caso não exista uma ordem resolvida no contexto, localizar pela part_code atual
        if (!targetOrder || !targetOrder.id) {
            try {
                const partCode = selectedMachineData.product_cod || selectedMachineData.product_code;
                if (partCode) {
                    const lotsSnapshot = await db.collection('production_orders')
                        .where('part_code', '==', String(partCode))
                        .get();

                    if (!lotsSnapshot.empty) {
                        const orders = lotsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
                        const isOpen = (o) => !['concluida','cancelada','finalizada','encerrada'].includes(String(o.status||'').toLowerCase());
                        const sameMachine = orders.filter(o => (o.machine_id || o.machine) === machineId);
                        targetOrder = sameMachine.find(o => ['ativa','em_andamento'].includes(String(o.status||'').toLowerCase()))
                            || sameMachine.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orders.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orders.sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0];
                    }
                }
            } catch (error) {
                console.warn('Falha ao localizar OP para ativação:', error);
            }
        }

        if (!targetOrder || !targetOrder.id) {
            alert('Nenhuma OP elegível encontrada para ativação.');
            return;
        }

        try {
            const ok = await setOrderAsActive(targetOrder.id, machineId);
            if (!ok) {
                showNotification('Ativação cancelada ou não concluída.', 'warning');
                return;
            }

            // Atualizar status do planejamento para em_execucao
            const planId = selectedMachineData?.id;
            if (planId) {
                try {
                    await db.collection('planning').doc(planId).update({
                        status: 'em_execucao',
                        startedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        startedBy: getActiveUser()?.name || 'Sistema'
                    });
                } catch (planErr) {
                    console.warn('Não foi possível atualizar o status do planejamento ao ativar a OP:', planErr);
                }
            }

            // Atualizar listas e painel
            await Promise.allSettled([
                typeof loadProductionOrders === 'function' ? loadProductionOrders() : Promise.resolve(),
                populateMachineSelector()
            ]);
            if (selectedMachineData?.machine) {
                await onMachineSelected(selectedMachineData.machine);
            }

            showNotification('OP ativada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao ativar OP pelo painel:', error);
            alert('Erro ao ativar a OP. Tente novamente.');
        }
    }

    // Finalizar OP diretamente pelo botão do card
    async function handleCardFinalizeClick(buttonEl) {
        try {
            const orderId = buttonEl?.dataset?.orderId;
            const planId = buttonEl?.dataset?.planId;
            const card = buttonEl.closest('.machine-card');
            const machine = card?.dataset?.machine;
            if (!orderId) {
                alert('Ordem não encontrada para finalizar.');
                return;
            }

            if (typeof window.authSystem?.checkPermissionForAction === 'function') {
                const hasPermission = window.authSystem.checkPermissionForAction('close_production_order');
                if (hasPermission === false) return;
            }

            const confirmMsg = `Confirma a finalização desta OP?`;
            if (!window.confirm(confirmMsg)) return;

            const originalHtml = buttonEl.innerHTML;
            buttonEl.disabled = true;
            buttonEl.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Finalizando...</span>`;
            if (typeof lucide !== 'undefined') lucide.createIcons();

            const user = getActiveUser();
            const updatePayload = {
                status: 'concluida',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                completedBy: user?.username || null,
                completedByName: user?.name || null
            };
            await db.collection('production_orders').doc(orderId).update(updatePayload);

            if (planId) {
                try {
                    await db.collection('planning').doc(planId).update({
                        status: 'concluida',
                        finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        finishedBy: user?.name || user?.username || null
                    });
                } catch (e) {
                    console.warn('Falha ao atualizar planejamento ao finalizar pelo card:', e);
                }
            }

            // Se a OP finalizada for a ativa no painel, limpar contexto
            if (currentActiveOrder?.id === orderId) {
                currentActiveOrder = null;
                resetProductionTimer?.();
                if (productionControlPanel) productionControlPanel.classList.add('hidden');
            }

            showNotification('OP finalizada com sucesso!', 'success');

            // Recarregar cartões e, se a mesma máquina estiver selecionada, recarregar painel
            await populateMachineSelector();
            if (machine) {
                const stillSelected = selectedMachineData?.machine === machine;
                if (stillSelected) await onMachineSelected(machine);
            }
        } catch (err) {
            console.error('Erro ao finalizar OP pelo card:', err);
            alert('Erro ao finalizar OP. Tente novamente.');
        } finally {
            if (buttonEl) {
                buttonEl.disabled = false;
                buttonEl.classList.add('hidden');
            }
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    // Ativar próxima OP diretamente pelo botão do card
    async function handleCardActivateNextClick(buttonEl) {
        const card = buttonEl.closest('.machine-card');
        const machine = buttonEl?.dataset?.machine || card?.dataset?.machine;
        if (!machine) {
            alert('Máquina não identificada para ativar próxima OP.');
            return;
        }

        const originalHtml = buttonEl.innerHTML;
        buttonEl.disabled = true;
        buttonEl.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Ativando...</span>`;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        try {
            // Seleciona a máquina para garantir contexto e reaproveitar a lógica de ativação do painel
            await onMachineSelected(machine);
            await handleActivateOrderFromPanel();

            // Recarregar cards e painel
            await populateMachineSelector();
            await onMachineSelected(machine);
        } catch (err) {
            console.error('Erro ao ativar próxima OP pelo card:', err);
            alert('Erro ao ativar próxima OP. Tente novamente.');
        } finally {
            buttonEl.disabled = false;
            buttonEl.innerHTML = originalHtml;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    // Função de debounce para otimizar redimensionamento
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Função para lidar com redimensionamento da janela
    function handleWindowResize() {
        const chartInstances = [];

        if (typeof Chart !== 'undefined' && Chart.instances) {
            if (Array.isArray(Chart.instances)) {
                chartInstances.push(...Chart.instances);
            } else if (Chart.instances instanceof Map) {
                chartInstances.push(...Chart.instances.values());
            } else {
                chartInstances.push(...Object.values(Chart.instances));
            }
        }

        chartInstances.forEach(chart => {
            if (chart && typeof chart.resize === 'function') {
                chart.resize();
            }
        });

        // Recarregar dados da aba ativa se necessário
        const activeTab = document.querySelector('.nav-btn.active');
        if (activeTab) {
            const activePage = activeTab.getAttribute('data-page');
            
            // Só recarregar se for uma aba com gráficos e se houve mudança significativa no tamanho
            if (['analise', 'lancamento'].includes(activePage)) {
                // Verificar se mudou entre breakpoints importantes (mobile/desktop)
                const wasMobile = typeof window.previousWidth === 'number' ? window.previousWidth < 768 : window.innerWidth < 768;
                const isMobile = window.innerWidth < 768;
                
                if (wasMobile !== isMobile) {
                    // Recarregar gráficos com novas configurações responsivas
                    setTimeout(() => {
                        if (activePage === 'analise') {
                            loadAnalysisData();
                        } else if (activePage === 'lancamento') {
                            loadLaunchPanel();
                        }
                    }, 100);
                }
            }
        }
        
        // Salvar largura atual para comparação futura
        window.previousWidth = window.innerWidth;
    }

    // Função para atualizar timeline apenas se estiver visível
    async function updateTimelineIfVisible() {
        // Otimização: Não atualizar se a aba do navegador não estiver visível
        if (!isPageVisible()) {
            return;
        }
        
        const timelineElement = document.getElementById('timeline-progress');
        if (!timelineElement || timelineElement.offsetParent === null) {
            return; // Timeline não está visível
        }

        // Recarregar dados de produção atuais
        try {
            if (!selectedMachineData) {
                updateTimelineProgress(0, 0, 0);
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            const productionData = await getFilteredData('production', today, today, selectedMachineData.machine || 'all');

            const totalExecuted = productionData.reduce((sum, item) => sum + (item.quantity || 0), 0);
            const totalPlanned = Number(selectedMachineData.planned_quantity) || 0;
            const hourlyTarget = totalPlanned / HOURS_IN_PRODUCTION_DAY;
            const hoursElapsed = getHoursElapsedInProductionDay(new Date());
            const expectedByNow = Math.min(totalPlanned, hoursElapsed * hourlyTarget);

            updateTimelineProgress(totalExecuted, totalPlanned, expectedByNow);
        } catch (error) {
            console.warn('Erro ao atualizar timeline:', error);
        }
    }
    // Gráfico de produção por turno
    async function generateShiftProductionChart(productionData) {
        const ctx = document.getElementById('shift-production-chart');
        if (!ctx) return;

        destroyChart('shift-production-chart');

        if (productionData.length === 0) {
            showNoDataMessage('shift-production-chart');
            return;
        }
        
        clearNoDataMessage('shift-production-chart');

        const shiftData = [0, 0, 0]; // 1º, 2º, 3º Turno
        const shiftLabels = ['1º Turno', '2º Turno', '3º Turno'];

        productionData.forEach(item => {
            if (item.shift) {
                shiftData[item.shift - 1] += item.quantity;
            }
        });

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: shiftLabels,
                datasets: [{
                    label: 'Peças',
                    data: shiftData,
                    backgroundColor: ['#10B981', '#3B82F6', '#F59E0B'],
                    borderColor: ['#047857', '#1E40AF', '#D97706'],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: window.innerWidth < 768 ? 9 : 11
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: window.innerWidth < 768 ? 9 : 11
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y} pcs`;
                            }
                        }
                    }
                }
            }
        });
    }

    async function generateMachineProductionTimeline(productionData, options = {}) {
        const {
            canvas: providedCanvas = null,
            targetCanvasId = 'analysis-machine-production-timeline',
            maxMachines = 6
        } = options;

        const canvas = providedCanvas || document.getElementById(targetCanvasId);
        if (!canvas) return;
        const canvasId = canvas.id || targetCanvasId;

        if (machineProductionTimelineInstance) {
            machineProductionTimelineInstance.destroy();
            machineProductionTimelineInstance = null;
        }

        if (!Array.isArray(productionData) || productionData.length === 0) {
            showNoDataMessage(canvasId);
            return;
        }

        const dateSet = new Set();
        const totalsByMachine = new Map();
        const totalsByMachineDate = new Map();

        productionData.forEach(item => {
            const machine = (item?.machine || 'Sem máquina').toString();
            const rawDate = item?.workDay || item?.date || '';
            const dateKey = rawDate ? String(rawDate).slice(0, 10) : '';
            if (!dateKey) return;
            const quantity = Number(item?.quantity) || 0;

            dateSet.add(dateKey);
            totalsByMachine.set(machine, (totalsByMachine.get(machine) || 0) + quantity);
            const compositeKey = `${machine}__${dateKey}`;
            totalsByMachineDate.set(compositeKey, (totalsByMachineDate.get(compositeKey) || 0) + quantity);
        });

        if (dateSet.size === 0 || totalsByMachine.size === 0) {
            showNoDataMessage(canvasId);
            return;
        }

        const sortedDates = Array.from(dateSet).sort();
        const displayLabels = sortedDates.map(formatShortDateLabel);
        const machinesSorted = Array.from(totalsByMachine.entries())
            .sort((a, b) => b[1] - a[1])
            .map(entry => entry[0]);

        const machinesToPlot = machinesSorted.slice(0, Math.max(1, maxMachines));

        clearNoDataMessage(canvasId);

        const datasets = machinesToPlot.map((machine, index) => {
            const colors = ANALYSIS_LINE_COLORS[index % ANALYSIS_LINE_COLORS.length];
            const points = sortedDates.map(dateKey => totalsByMachineDate.get(`${machine}__${dateKey}`) || 0);
            return {
                label: machine,
                data: points,
                borderColor: colors.border,
                backgroundColor: colors.fill,
                tension: 0.3,
                pointRadius: 3,
                pointHoverRadius: 5,
                fill: false
            };
        });

        const context = canvas.getContext('2d');
        machineProductionTimelineInstance = new Chart(context, {
            type: 'line',
            data: {
                labels: displayLabels,
                datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: (value) => `${Number(value).toLocaleString('pt-BR')} pcs`
                        },
                        title: {
                            display: true,
                            text: 'Peças'
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: 0
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const label = context.dataset?.label || '';
                                const value = Number(context.parsed.y) || 0;
                                return `${label}: ${value.toLocaleString('pt-BR')} pcs`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Função para atualizar gráficos de eficiência em formato doughnut
    function updateGauge(canvasId, percentage) {
        console.log(`[GAUGE] Atualizando ${canvasId} com ${percentage}%`);
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error(`[GAUGE] Canvas "${canvasId}" não encontrado`);
            return;
        }

        const normalizedValue = Math.max(0, Math.min(Number(percentage) || 0, 100));
        const remainingValue = Math.max(0, 100 - normalizedValue);
        const style = gaugeChartStyles[canvasId] || { color: '#0F172A' };
        let activeColor = style.color;

        if (normalizedValue < 60 && style.dangerColor) {
            activeColor = style.dangerColor;
        } else if (normalizedValue < 80 && style.warningColor) {
            activeColor = style.warningColor;
        }

        const valueElementId = canvasId.replace('-gauge', '-value');
        const valueElement = document.getElementById(valueElementId);
        if (valueElement) {
            valueElement.style.color = activeColor;
        }

        if (gaugeChartInstances[canvasId]) {
            const chart = gaugeChartInstances[canvasId];
            chart.data.datasets[0].data = [normalizedValue, remainingValue];
            chart.data.datasets[0].backgroundColor = [
                activeColor,
                'rgba(229, 231, 235, 0.45)'
            ];
            chart.update();
            return;
        }

        gaugeChartInstances[canvasId] = new Chart(canvas, {
            type: 'doughnut',
            data: {
                labels: ['Atual', 'Restante'],
                datasets: [{
                    data: [normalizedValue, remainingValue],
                    backgroundColor: [
                        activeColor,
                        'rgba(229, 231, 235, 0.45)'
                    ],
                    borderWidth: 0,
                    hoverOffset: 4,
                    borderRadius: 10
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '72%',
                rotation: -90,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                animation: {
                    animateRotate: true,
                    duration: 800
                }
            }
        });
    }

    function renderModernDonutChart({
        canvasId,
        labels = [],
        data = [],
        colors = DEFAULT_DONUT_COLORS,
        datasetLabel = '',
        tooltipFormatter,
        legendPosition,
        cutout = '65%'
    }) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error(`[DONUT] Canvas "${canvasId}" não encontrado`);
            return null;
        }

        const existing = Chart.getChart(canvas);
        if (existing) existing.destroy();

        const palette = labels.map((_, index) => colors[index % colors.length]);
        const total = data.reduce((sum, value) => sum + (Number(value) || 0), 0);
        const isMobile = window.innerWidth < 768;
        const resolvedLegendPosition = legendPosition || (isMobile ? 'bottom' : 'right');

        const chart = new Chart(canvas, {
            type: 'doughnut',
            data: {
                labels,
                datasets: [{
                    label: datasetLabel,
                    data,
                    backgroundColor: palette,
                    borderWidth: 0,
                    hoverOffset: 6,
                    borderRadius: 12
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout,
                rotation: -90,
                plugins: {
                    legend: {
                        position: resolvedLegendPosition,
                        labels: {
                            usePointStyle: true,
                            padding: isMobile ? 10 : 14,
                            boxWidth: isMobile ? 10 : 12,
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    tooltip: {
                        mode: 'nearest',
                        callbacks: {
                            label: tooltipFormatter || ((context) => {
                                const label = context.label || '';
                                const value = Number(context.parsed || 0);
                                if (!total) {
                                    return `${label}: ${value.toLocaleString()}`;
                                }
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value.toLocaleString()} (${percentage}%)`;
                            })
                        },
                        backgroundColor: '#0F172A',
                        borderColor: 'rgba(15, 23, 42, 0.2)',
                        borderWidth: 1,
                        titleFont: {
                            size: isMobile ? 11 : 12
                        },
                        bodyFont: {
                            size: isMobile ? 10 : 11
                        },
                        padding: isMobile ? 8 : 10
                    }
                },
                animation: {
                    animateRotate: true,
                    animateScale: true,
                    duration: 900,
                    easing: 'easeOutQuart'
                }
            }
        });

        return chart;
    }

    function createHourlyProductionChart({
        canvas,
        labels,
        executedPerHour,
        plannedPerHour,
        highlightCurrentHour = false
    }) {
        if (!canvas) {
            console.error('[HOUR-CHART] Canvas não encontrado para renderização.');
            return null;
        }

        const ctx = canvas.getContext('2d');
        const canvasRect = canvas.getBoundingClientRect();
        const gradientHeight = canvasRect.height || canvas.height || 320;

        const fillGradient = ctx.createLinearGradient(0, 0, 0, gradientHeight);
        fillGradient.addColorStop(0, 'rgba(16, 185, 129, 0.65)');
        fillGradient.addColorStop(1, 'rgba(16, 185, 129, 0.1)');

        const executed = executedPerHour.map(value => Number(value) || 0);
        const planned = plannedPerHour.map(value => Number(value) || 0);

        const executedCumulative = [];
        const plannedCumulative = [];
        executed.reduce((sum, value, index) => {
            const total = sum + value;
            executedCumulative[index] = total;
            return total;
        }, 0);
        planned.reduce((sum, value, index) => {
            const total = sum + value;
            plannedCumulative[index] = total;
            return total;
        }, 0);

        let highlightIndex = -1;
        if (highlightCurrentHour) {
            const highlightLabel = getProductionHourLabel();
            highlightIndex = labels.indexOf(highlightLabel);
        }

        const barBackground = (context) => {
            if (!context) return fillGradient;
            const { dataIndex } = context;
            if (dataIndex === highlightIndex) {
                return 'rgba(14, 165, 233, 0.85)';
            }
            return fillGradient;
        };

        return new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [
                    {
                        type: 'line',
                        label: 'Produção Acumulada',
                        data: executedCumulative,
                        borderColor: '#10B981',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.35,
                        pointRadius: 0,
                        yAxisID: 'y1',
                        order: 1
                    },
                    {
                        type: 'line',
                        label: 'Meta Acumulada',
                        data: plannedCumulative,
                        borderColor: '#EF4444',
                        borderWidth: 2,
                        borderDash: [8, 6],
                        fill: false,
                        tension: 0.25,
                        pointRadius: 0,
                        yAxisID: 'y1',
                        order: 0
                    }
                ]
            },
            options: mergeChartOptions({
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                layout: {
                    padding: {
                        top: 8,
                        bottom: 0,
                        left: 6,
                        right: 12
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(148, 163, 184, 0.18)',
                            drawBorder: false
                        },
                        ticks: {
                            callback: (value) => `${Number(value).toLocaleString()} pcs`
                        }
                    },
                    y1: {
                        beginAtZero: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            callback: (value) => `${Number(value).toLocaleString()} pcs`
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        align: 'center',
                        labels: {
                            usePointStyle: true,
                            padding: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            title: (tooltipItems) => `Hora ${tooltipItems[0].label}`,
                            label: (context) => {
                                const label = context.dataset.label || '';
                                const rawValue = context.parsed?.y ?? context.parsed ?? 0;
                                const suffix = label.includes('Acumulada') ? ' peças acumuladas' : ' peças';
                                return `${label}: ${Number(rawValue).toLocaleString()}${suffix}`;
                            }
                        }
                    }
                }
            })
        });
    }

    // Gráfico Pareto de perdas
    async function generateLossesParetoChart(lossesData) {
        const canvas = document.getElementById('losses-pareto-chart');
        if (!canvas) return;

        destroyChart('losses-pareto-chart');

        if (!Array.isArray(lossesData) || lossesData.length === 0) {
            showNoDataMessage('losses-pareto-chart');
            return;
        }

        clearNoDataMessage('losses-pareto-chart');

        const aggregated = {};
        lossesData.forEach(item => {
            const reason = item?.reason || item?.category || item?.type || 'Sem classificação';
            // Usar refugo_kg para perdas, não quantity
            const quantity = Number(item?.raw?.refugo_kg || item?.quantity || 0);
            aggregated[reason] = (aggregated[reason] || 0) + quantity;
        });

        const sortedEntries = Object.entries(aggregated).sort((a, b) => b[1] - a[1]);
        const labels = sortedEntries.map(([label]) => label);
        const values = sortedEntries.map(([, value]) => value);
        const total = values.reduce((sum, value) => sum + value, 0);

        const cumulativePercentages = [];
        values.reduce((sum, value, index) => {
            const accumulated = sum + value;
            cumulativePercentages[index] = total ? (accumulated / total) * 100 : 0;
            return accumulated;
        }, 0);

        new Chart(canvas, {
            type: 'bar',
            data: {
                labels,
                datasets: [
                    {
                        type: 'bar',
                        label: 'Perdas (kg)',
                        data: values,
                        backgroundColor: 'rgba(239, 68, 68, 0.85)',
                        borderColor: '#B91C1C',
                        borderWidth: 1,
                        yAxisID: 'y'
                    },
                    {
                        type: 'line',
                        label: '% Acumulado',
                        data: cumulativePercentages,
                        borderColor: '#0EA5E9',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: mergeChartOptions({
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Perdas (kg)'
                        }
                    },
                    y1: {
                        beginAtZero: true,
                        suggestedMax: 100,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            callback: (value) => `${value}%`
                        },
                        title: {
                            display: true,
                            text: '% Acumulado'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                if (context.dataset.type === 'line') {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                }
                                return `${context.dataset.label}: ${Number(context.parsed.y).toLocaleString()} kg`;
                            }
                        }
                    }
                }
            })
        });
    }

    // Gerar gráfico de perdas por máquina
    async function generateLossesByMachineChart(lossesData) {
        const ctx = document.getElementById('losses-by-machine-chart');
        if (!ctx) return;

        destroyChart('losses-by-machine-chart');

        if (lossesData.length === 0) {
            showNoDataMessage('losses-by-machine-chart');
            return;
        }
        
        clearNoDataMessage('losses-by-machine-chart');

        const machineLosses = {};
        lossesData.forEach(item => {
            const machine = item.machine || 'Sem máquina';
            // Usar refugo_kg para perdas, não quantity
            machineLosses[machine] = (machineLosses[machine] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
        });

        const labels = Object.keys(machineLosses);
        const data = Object.values(machineLosses);

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Perdas (kg)',
                    data: data,
                    backgroundColor: 'rgba(239, 68, 68, 0.8)',
                    borderColor: '#EF4444',
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,

                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    y: {
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Gerar gráfico de perdas por tipo de matéria-prima
    async function generateLossesByMaterialChart(lossesData) {
        const ctx = document.getElementById('losses-by-material-chart');
        if (!ctx) return;

        destroyChart('losses-by-material-chart');

        if (lossesData.length === 0) {
            showNoDataMessage('losses-by-material-chart', 'Nenhuma perda com tipo de MP registrada');
            return;
        }
        
        clearNoDataMessage('losses-by-material-chart');

        // Agrupar perdas por tipo de MP
        const materialLosses = {};
        lossesData.forEach(item => {
            const mpType = item.mp_type || 'Não especificado';
            // Usar refugo_kg para perdas em kg, não quantity (que é em peças)
            materialLosses[mpType] = (materialLosses[mpType] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
        });

        const labels = Object.keys(materialLosses);
        const data = Object.values(materialLosses);

        // Se não houver dados com mp_type, mostrar mensagem
        if (labels.length === 0 || (labels.length === 1 && labels[0] === 'Não especificado')) {
            showNoDataMessage('losses-by-material-chart', 'Configure o tipo de MP no planejamento para visualizar esta análise');
            return;
        }

        const isMobile = window.innerWidth < 768;

        // Cores para diferentes tipos de MP
        const colors = [
            '#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'
        ];
        const totalLosses = data.reduce((sum, value) => sum + value, 0);

        renderModernDonutChart({
            canvasId: 'losses-by-material-chart',
            labels,
            data,
            colors,
            datasetLabel: 'Perdas (kg)',
            legendPosition: isMobile ? 'bottom' : 'right',
            tooltipFormatter: (context) => {
                const value = Number(context.parsed || 0);
                const percentage = totalLosses > 0 ? ((value / totalLosses) * 100).toFixed(1) : '0.0';
                return `${context.label}: ${value.toFixed(3)} kg (${percentage}%)`;
            }
        });
    }

    // ✅ NOVO: Gerar gráfico de perdas diárias
    async function generateLossesDailyChart(lossesData) {
        const ctx = document.getElementById('losses-daily-chart');
        if (!ctx) return;

        destroyChart('losses-daily-chart');

        if (!lossesData || lossesData.length === 0) {
            showNoDataMessage('losses-daily-chart', 'Nenhuma perda registrada no período');
            return;
        }
        
        clearNoDataMessage('losses-daily-chart');

        // Agrupar perdas por data
        const dailyLosses = {};
        lossesData.forEach(item => {
            // Tentar extrair a data do item
            let dateStr = item.date || item.raw?.date || item.raw?.data || '';
            
            // Se não tem data direta, tentar extrair do timestamp
            if (!dateStr && item.raw?.timestamp) {
                const ts = item.raw.timestamp?.toDate ? item.raw.timestamp.toDate() : new Date(item.raw.timestamp);
                if (ts instanceof Date && !isNaN(ts)) {
                    dateStr = ts.toISOString().split('T')[0];
                }
            }
            
            // Se ainda não tem data, usar data atual como fallback
            if (!dateStr) {
                dateStr = new Date().toISOString().split('T')[0];
            }
            
            // Usar refugo_kg para perdas em kg
            const lossKg = item.raw?.refugo_kg || item.quantity || 0;
            dailyLosses[dateStr] = (dailyLosses[dateStr] || 0) + lossKg;
        });

        // Ordenar as datas
        const sortedDates = Object.keys(dailyLosses).sort((a, b) => new Date(a) - new Date(b));
        
        // Formatar labels para exibição (DD/MM)
        const labels = sortedDates.map(date => {
            const parts = date.split('-');
            if (parts.length === 3) {
                return `${parts[2]}/${parts[1]}`;
            }
            return date;
        });
        
        const data = sortedDates.map(date => dailyLosses[date]);

        // Calcular média para linha de referência
        const avgLoss = data.length > 0 ? data.reduce((sum, val) => sum + val, 0) / data.length : 0;
        const avgLine = data.map(() => avgLoss);

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Perdas (kg)',
                        data: data,
                        backgroundColor: 'rgba(59, 130, 246, 0.7)',
                        borderColor: '#3B82F6',
                        borderWidth: 1,
                        borderRadius: 4,
                        order: 2
                    },
                    {
                        label: `Média (${avgLoss.toFixed(2)} kg)`,
                        data: avgLine,
                        type: 'line',
                        borderColor: '#EF4444',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 0,
                        fill: false,
                        order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: isMobile ? 9 : 11
                            },
                            maxRotation: 45,
                            minRotation: 0
                        }
                    },
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(0, 0, 0, 0.05)'
                        },
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            },
                            callback: function(value) {
                                return value.toFixed(1) + ' kg';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        titleFont: { size: 13 },
                        bodyFont: { size: 12 },
                        padding: 12,
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y;
                                if (context.dataset.label.includes('Média')) {
                                    return `Média: ${value.toFixed(2)} kg`;
                                }
                                return `Perdas: ${value.toFixed(3)} kg`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Variável para armazenar dados de downtime e modo atual do gráfico
    let cachedDowntimeDataForChart = [];
    let downtimeChartMode = 'category'; // 'category' ou 'reason'

    // Gerar gráfico de paradas por CATEGORIA ou MOTIVO
    async function generateDowntimeReasonsChart(downtimeData, mode = null) {
        const ctx = document.getElementById('downtime-reasons-chart');
        if (!ctx) return;

        // Se recebeu novos dados, armazenar no cache
        if (downtimeData && downtimeData.length >= 0) {
            cachedDowntimeDataForChart = downtimeData;
        }
        
        // Usar modo passado ou o modo atual
        if (mode) {
            downtimeChartMode = mode;
        }

        destroyChart('downtime-reasons-chart');

        if (cachedDowntimeDataForChart.length === 0) {
            showNoDataMessage('downtime-reasons-chart');
            return;
        }
        
        clearNoDataMessage('downtime-reasons-chart');

        let labels, data, colors;
        const isMobile = window.innerWidth < 768;
        
        // Cores para cada categoria - Sincronizadas com status do Dashboard TV
        // Usar cores do database.js se disponíveis
        const dbColors = window.databaseModule?.downtimeReasonColors || {};
        const categoryColors = {
            'FERRAMENTARIA': '#ff1744',      // Status Critical - Vermelho
            'PROCESSO': '#7c4dff',            // Status Maintenance - Roxo
            'COMPRAS': '#ffab00',             // Status Warning - Amarelo
            'PREPARAÇÃO': '#ffab00',          // Status Warning - Amarelo
            'QUALIDADE': '#7c4dff',           // Status Maintenance - Roxo
            'MANUTENÇÃO': '#ff1744',          // Status Critical - Vermelho
            'PRODUÇÃO': '#00e676',            // Status Running - Verde
            'SETUP': '#ffab00',               // Status Warning - Amarelo
            'ADMINISTRATIVO': '#78909c',      // Status Idle - Cinza
            'PCP': '#78909c',                 // Status Idle - Cinza
            'COMERCIAL': '#78909c',           // Status Idle - Cinza
            'HOKKAIDO': dbColors['HOKKAIDO'] || '#e5e7eb',  // Cinza claro
            'OUTROS': '#78909c'               // Status Idle - Cinza
        };

        if (downtimeChartMode === 'category') {
            // Agrupar por CATEGORIA
            const categoryDurations = {};
            cachedDowntimeDataForChart.forEach(item => {
                const reason = item.reason || 'Sem motivo';
                const category = getDowntimeCategory(reason);
                categoryDurations[category] = (categoryDurations[category] || 0) + (item.duration || 0);
            });

            labels = Object.keys(categoryDurations);
            data = Object.values(categoryDurations).map(d => Number(((d || 0) / 60).toFixed(2)));
            colors = labels.map(label => categoryColors[label] || '#6B7280');
        } else {
            // Agrupar por MOTIVO individual
            const reasonDurations = {};
            cachedDowntimeDataForChart.forEach(item => {
                const reason = item.reason || 'Sem motivo';
                reasonDurations[reason] = (reasonDurations[reason] || 0) + (item.duration || 0);
            });

            // Ordenar por duração (maior primeiro) e pegar os top 12
            const sortedReasons = Object.entries(reasonDurations)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 12);
            
            labels = sortedReasons.map(([reason]) => reason);
            data = sortedReasons.map(([, duration]) => Number(((duration || 0) / 60).toFixed(2)));
            
            // Atribuir cores baseadas na categoria de cada motivo
            colors = labels.map(reason => {
                const category = getDowntimeCategory(reason);
                return categoryColors[category] || '#6B7280';
            });
        }

        const totalHours = data.reduce((sum, value) => sum + value, 0);

        renderModernDonutChart({
            canvasId: 'downtime-reasons-chart',
            labels,
            data,
            colors: colors,
            datasetLabel: 'Paradas (h)',
            legendPosition: isMobile ? 'bottom' : 'right',
            tooltipFormatter: (context) => {
                const value = Number(context.parsed || 0);
                const percentage = totalHours > 0 ? ((value / totalHours) * 100).toFixed(1) : '0.0';
                return `${context.label}: ${value.toFixed(1)} h (${percentage}%)`;
            }
        });
    }

    // Setup dos botões de toggle do gráfico de paradas
    function setupDowntimeChartToggle() {
        const btnCategory = document.getElementById('btn-chart-category');
        const btnReason = document.getElementById('btn-chart-reason');
        
        if (!btnCategory || !btnReason) return;
        
        const updateToggleStyles = (activeBtn, inactiveBtn) => {
            activeBtn.classList.remove('text-gray-500', 'hover:text-gray-700');
            activeBtn.classList.add('bg-white', 'text-gray-800', 'shadow-sm');
            inactiveBtn.classList.remove('bg-white', 'text-gray-800', 'shadow-sm');
            inactiveBtn.classList.add('text-gray-500', 'hover:text-gray-700');
        };
        
        btnCategory.onclick = () => {
            if (downtimeChartMode === 'category') return;
            updateToggleStyles(btnCategory, btnReason);
            generateDowntimeReasonsChart(null, 'category');
        };
        
        btnReason.onclick = () => {
            if (downtimeChartMode === 'reason') return;
            updateToggleStyles(btnReason, btnCategory);
            generateDowntimeReasonsChart(null, 'reason');
        };
    }

    // Gerar gráfico de paradas por máquina
    async function generateDowntimeByMachineChart(downtimeData) {
        const ctx = document.getElementById('downtime-by-machine-chart');
        if (!ctx) return;

        destroyChart('downtime-by-machine-chart');

        if (downtimeData.length === 0) {
            showNoDataMessage('downtime-by-machine-chart');
            return;
        }
        
        clearNoDataMessage('downtime-by-machine-chart');

        const machineDowntime = {};
        downtimeData.forEach(item => {
            const machine = item.machine || 'Sem máquina';
            machineDowntime[machine] = (machineDowntime[machine] || 0) + (item.duration || 0);
        });

        const labels = Object.keys(machineDowntime);
        const data = Object.values(machineDowntime).map(d => (d / 60).toFixed(1)); // Converter para horas

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Tempo de Parada (h)',
                    data: data,
                    backgroundColor: 'rgba(239, 68, 68, 0.8)',
                    borderColor: '#EF4444',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,

                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            },
                            callback: function(value) {
                                return value + 'h';
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Gerar timeline de paradas
    async function generateDowntimeTimelineChart(downtimeData) {
        const ctx = document.getElementById('downtime-timeline-chart');
        if (!ctx) {
            console.error('[TIMELINE] Canvas não encontrado: downtime-timeline-chart');
            return;
        }

        destroyChart('downtime-timeline-chart');

        console.log('[TIMELINE] Dados recebidos:', downtimeData.length, 'registros');
        
        if (downtimeData.length === 0) {
            console.warn('[TIMELINE] Nenhum dado de parada para mostrar');
            showNoDataMessage('downtime-timeline-chart');
            return;
        }
        
        // Log amostra de dados para debug
        if (downtimeData.length > 0) {
            console.log('[TIMELINE] Amostra de dados:', JSON.stringify(downtimeData.slice(0, 3), null, 2));
        }
        
        clearNoDataMessage('downtime-timeline-chart');

        // Limitar aos últimos 20 eventos para visualização
        const recentDowntimes = downtimeData.slice(-20).reverse();
        
        console.log('[TIMELINE] Paradas recentes:', recentDowntimes.length);
        
        const labels = recentDowntimes.map((item, index) => {
            const dateStr = item.date || item.workDay || '';
            let dateLabel;
            try {
                const date = dateStr ? new Date(dateStr) : new Date();
                dateLabel = date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
            } catch (e) {
                dateLabel = dateStr;
            }
            return `${dateLabel} - ${item.machine || 'Máq'}`;
        });
        
        const data = recentDowntimes.map(item => item.duration || 0);
        
        console.log('[TIMELINE] Labels:', labels);
        console.log('[TIMELINE] Durações:', data);

        const isMobile = window.innerWidth < 768;

        try {
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Duração (min)',
                        data: data,
                        backgroundColor: recentDowntimes.map(item => {
                            const duration = item.duration || 0;
                            if (duration > 120) return '#EF4444'; // Vermelho para >2h
                            if (duration > 60) return '#F59E0B'; // Amarelo para >1h
                            return '#10B981'; // Verde para <1h
                        }),
                        borderWidth: 1,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                font: {
                                    size: isMobile ? 10 : 12
                                }
                            }
                        },
                        y: {
                            ticks: {
                                font: {
                                    size: isMobile ? 8 : 10
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = recentDowntimes[context.dataIndex];
                                    return [
                                        `Duração: ${context.parsed.x} min`,
                                        `Motivo: ${item.reason || 'Não informado'}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
            console.log('[TIMELINE] Gráfico criado com sucesso');
        } catch (error) {
            console.error('[TIMELINE] Erro ao criar gráfico:', error);
        }
    }

    // Gerar gráfico de borra por motivo
    async function generateBorraByReasonChart(borraData) {
        const ctx = document.getElementById('borra-by-reason-chart');
        if (!ctx) return;

        destroyChart('borra-by-reason-chart');

        if (borraData.length === 0) {
            showNoDataMessage('borra-by-reason-chart');
            return;
        }
        
        clearNoDataMessage('borra-by-reason-chart');

        const reasonCounts = {};
        borraData.forEach(item => {
            let reason = item.reason || item.raw?.perdas || 'Não especificado';
            // Remover prefixo "BORRA - " se existir
            reason = reason.replace(/^BORRA\s*-\s*/i, '');
            const weight = item.raw?.refugo_kg || item.raw?.quantityKg || item.scrapKg || item.quantity || 0;
            reasonCounts[reason] = (reasonCounts[reason] || 0) + weight;
        });

        const sortedReasons = Object.entries(reasonCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 8); // Top 8 motivos

        const labels = sortedReasons.map(([reason]) => reason);
        const data = sortedReasons.map(([,weight]) => weight);

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Borra (kg)',
                    data: data,
                    backgroundColor: 'rgba(251, 191, 36, 0.8)',
                    borderColor: '#F59E0B',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 10 : 12 }
                        }
                    },
                    y: {
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 9 : 11 }
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.x.toFixed(1)} kg`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Gerar gráfico de borra por máquina
    async function generateBorraByMachineChart(borraData) {
        const ctx = document.getElementById('borra-by-machine-chart');
        if (!ctx) return;

        destroyChart('borra-by-machine-chart');

        if (borraData.length === 0) {
            showNoDataMessage('borra-by-machine-chart');
            return;
        }
        
        clearNoDataMessage('borra-by-machine-chart');

        const machineCounts = {};
        borraData.forEach(item => {
            const machine = item.machine || 'Não especificado';
            const weight = item.raw?.refugo_kg || item.raw?.quantityKg || item.scrapKg || item.quantity || 0;
            machineCounts[machine] = (machineCounts[machine] || 0) + weight;
        });

        const labels = Object.keys(machineCounts);
        const data = Object.values(machineCounts);

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Borra (kg)',
                    data: data,
                    backgroundColor: 'rgba(251, 191, 36, 0.8)',
                    borderColor: '#F59E0B',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 10 : 12 }
                        }
                    },
                    x: {
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 10 : 12 }
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y.toFixed(1)} kg`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Gerar gráfico de borra mensal com acumulado
    async function generateBorraMonthlyChart(borraData) {
        const ctx = document.getElementById('borra-monthly-chart');
        if (!ctx) return;

        destroyChart('borra-monthly-chart');

        if (borraData.length === 0) {
            showNoDataMessage('borra-monthly-chart');
            return;
        }
        
        clearNoDataMessage('borra-monthly-chart');

        // Agrupar por mês
        const monthlyData = {};
        const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
        
        borraData.forEach(item => {
            const raw = item.raw || {};
            let date = null;
            
            // Extrair data do registro
            if (raw.date?.toDate) {
                date = raw.date.toDate();
            } else if (raw.datetime?.toDate) {
                date = raw.datetime.toDate();
            } else if (raw.timestamp?.toDate) {
                date = raw.timestamp.toDate();
            } else if (typeof raw.date === 'string') {
                date = new Date(raw.date);
            } else if (typeof raw.datetime === 'string') {
                date = new Date(raw.datetime);
            }
            
            if (!date || isNaN(date.getTime())) {
                date = new Date(); // Fallback para data atual
            }
            
            const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
            const weight = raw.refugo_kg || raw.quantityKg || item.scrapKg || item.quantity || 0;
            
            if (!monthlyData[monthKey]) {
                monthlyData[monthKey] = {
                    month: monthNames[date.getMonth()],
                    year: date.getFullYear(),
                    total: 0
                };
            }
            monthlyData[monthKey].total += weight;
        });

        // Ordenar por data e pegar últimos 6 meses
        const sortedMonths = Object.keys(monthlyData).sort().slice(-6);
        const labels = sortedMonths.map(key => `${monthlyData[key].month}/${String(monthlyData[key].year).slice(-2)}`);
        const monthlyTotals = sortedMonths.map(key => monthlyData[key].total);
        
        // Calcular acumulado
        const accumulated = [];
        let runningTotal = 0;
        monthlyTotals.forEach(val => {
            runningTotal += val;
            accumulated.push(runningTotal);
        });

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Mensal (kg)',
                        data: monthlyTotals,
                        backgroundColor: 'rgba(251, 191, 36, 0.8)',
                        borderColor: '#F59E0B',
                        borderWidth: 1,
                        order: 2
                    },
                    {
                        label: 'Acumulado (kg)',
                        data: accumulated,
                        type: 'line',
                        borderColor: '#DC2626',
                        backgroundColor: 'rgba(220, 38, 38, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.3,
                        pointRadius: 4,
                        pointBackgroundColor: '#DC2626',
                        yAxisID: 'y1',
                        order: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        position: 'left',
                        title: {
                            display: true,
                            text: 'Mensal (kg)',
                            font: { size: 10 }
                        },
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 9 : 10 }
                        }
                    },
                    y1: {
                        beginAtZero: true,
                        position: 'right',
                        title: {
                            display: true,
                            text: 'Acumulado (kg)',
                            font: { size: 10 }
                        },
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 9 : 10 }
                        }
                    },
                    x: {
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 9 : 10 }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            boxWidth: 12,
                            font: { size: 10 }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.dataset.label}: ${context.parsed.y.toFixed(1)} kg`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Variáveis globais para paginação da tabela de borra
    let borraTableData = [];
    let borraTableCurrentPage = 1;
    const borraTablePageSize = 10;

    // Função para preencher a tabela de apontamentos de borra
    async function populateBorraApontamentosTable(borraData) {
        const tableBody = document.getElementById('borra-apontamentos-table');
        if (!tableBody) return;

        // Preparar dados da tabela
        borraTableData = borraData.map(item => {
            const raw = item.raw || {};
            
            // Extrair data/hora
            let dateTime = '---';
            if (raw.date || raw.datetime) {
                const dateStr = raw.date || raw.datetime;
                if (dateStr?.toDate) {
                    const d = dateStr.toDate();
                    dateTime = `${d.toLocaleDateString('pt-BR')} ${d.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`;
                } else if (typeof dateStr === 'string') {
                    dateTime = dateStr;
                }
            } else if (raw.timestamp?.toDate) {
                const d = raw.timestamp.toDate();
                dateTime = `${d.toLocaleDateString('pt-BR')} ${d.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`;
            }

            // Extrair motivo (removendo prefixo BORRA)
            let reason = item.reason || raw.perdas || raw.motivo || 'Não especificado';
            reason = reason.replace(/^BORRA\s*-\s*/i, '');

            return {
                dateTime: dateTime,
                machine: item.machine || raw.machine_id || raw.maquina || '---',
                reason: reason,
                material: item.material || raw.mp || raw.materia_prima || '---',
                quantity: raw.refugo_kg || raw.quantityKg || item.scrapKg || item.quantity || 0,
                operator: raw.operator || raw.operador || raw.user || '---',
                shift: raw.turno || raw.shift || '---'
            };
        }).sort((a, b) => {
            // Ordenar por data mais recente primeiro
            if (a.dateTime === '---') return 1;
            if (b.dateTime === '---') return -1;
            return b.dateTime.localeCompare(a.dateTime);
        });

        borraTableCurrentPage = 1;
        renderBorraTable();
    }

    // Função para renderizar a tabela de borra
    function renderBorraTable() {
        const tableBody = document.getElementById('borra-apontamentos-table');
        if (!tableBody) return;

        const totalItems = borraTableData.length;
        const totalPages = Math.ceil(totalItems / borraTablePageSize);
        const startIndex = (borraTableCurrentPage - 1) * borraTablePageSize;
        const endIndex = Math.min(startIndex + borraTablePageSize, totalItems);
        const pageData = borraTableData.slice(startIndex, endIndex);

        if (totalItems === 0) {
            tableBody.innerHTML = `
                <tr>
                    <td colspan="4" class="px-4 py-8 text-center text-gray-400">
                        <i data-lucide="inbox" class="w-8 h-8 mx-auto mb-2"></i>
                        <p>Nenhum apontamento de borra encontrado no período</p>
                    </td>
                </tr>
            `;
            lucide.createIcons();
        } else {
            tableBody.innerHTML = pageData.map((row, idx) => `
                <tr class="hover:bg-amber-50/50 transition ${idx % 2 === 0 ? 'bg-white' : 'bg-amber-50/30'}">
                    <td class="px-4 py-3 text-gray-700 text-xs">${row.dateTime}</td>
                    <td class="px-4 py-3">
                        <span class="px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-medium">${row.machine}</span>
                    </td>
                    <td class="px-4 py-3 text-center">
                        <span class="px-2 py-1 bg-amber-100 text-amber-700 rounded text-xs font-semibold">${parseFloat(row.quantity).toFixed(3)}</span>
                    </td>
                    <td class="px-4 py-3">
                        <span class="px-2 py-1 ${getTurnoColor(row.shift)} rounded text-xs font-medium">${row.shift}</span>
                    </td>
                </tr>
            `).join('');
        }

        // Atualizar informações de paginação
        const showingEl = document.getElementById('borra-table-showing');
        const totalEl = document.getElementById('borra-table-total');
        const pageEl = document.getElementById('borra-table-page');
        const prevBtn = document.getElementById('borra-table-prev');
        const nextBtn = document.getElementById('borra-table-next');

        if (showingEl) showingEl.textContent = totalItems > 0 ? `${startIndex + 1}-${endIndex}` : '0';
        if (totalEl) totalEl.textContent = totalItems;
        if (pageEl) pageEl.textContent = `Página ${borraTableCurrentPage} de ${totalPages || 1}`;
        if (prevBtn) prevBtn.disabled = borraTableCurrentPage <= 1;
        if (nextBtn) nextBtn.disabled = borraTableCurrentPage >= totalPages;

        // Reinicializar ícones Lucide
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    // Função auxiliar para cor do turno
    function getTurnoColor(turno) {
        const turnoLower = (turno || '').toString().toLowerCase();
        if (turnoLower.includes('a') || turnoLower.includes('1') || turnoLower.includes('manhã') || turnoLower.includes('manha')) {
            return 'bg-green-100 text-green-700';
        } else if (turnoLower.includes('b') || turnoLower.includes('2') || turnoLower.includes('tarde')) {
            return 'bg-blue-100 text-blue-700';
        } else if (turnoLower.includes('c') || turnoLower.includes('3') || turnoLower.includes('noite')) {
            return 'bg-purple-100 text-purple-700';
        }
        return 'bg-gray-100 text-gray-700';
    }

    // Funções de navegação da tabela
    function borraTableNextPage() {
        const totalPages = Math.ceil(borraTableData.length / borraTablePageSize);
        if (borraTableCurrentPage < totalPages) {
            borraTableCurrentPage++;
            renderBorraTable();
        }
    }

    function borraTablePrevPage() {
        if (borraTableCurrentPage > 1) {
            borraTableCurrentPage--;
            renderBorraTable();
        }
    }

    // Função para exportar tabela de borra
    function exportBorraTable() {
        if (borraTableData.length === 0) {
            showNotification('Não há dados para exportar', 'warning');
            return;
        }

        const headers = ['Data/Hora', 'Máquina', 'Quantidade (kg)', 'Turno'];
        const csvContent = [
            headers.join(';'),
            ...borraTableData.map(row => [
                row.dateTime,
                row.machine,
                parseFloat(row.quantity).toFixed(3).replace('.', ','),
                row.shift
            ].join(';'))
        ].join('\n');

        const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        link.setAttribute('href', url);
        link.setAttribute('download', `apontamentos_borra_${new Date().toISOString().split('T')[0]}.csv`);
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        showNotification('Exportação concluída!', 'success');
    }

    // Função para calcular OEE detalhado
    async function calculateDetailedOEE(startDate, endDate, machine, shift) {
        try {
            // Normalizar shift: se não está definido ou é null, usar 'all'
            const normalizedShift = shift === undefined || shift === null || shift === '' ? 'all' : shift;
            
            console.log('[TRACE][calculateDetailedOEE] Buscando dados para:', { startDate, endDate, machine, shift: normalizedShift });
            
            const [productionData, lossesData, downtimeData, planData] = await Promise.all([
                getFilteredData('production', startDate, endDate, machine, 'all'),
                getFilteredData('losses', startDate, endDate, machine, 'all'),
                getFilteredData('downtime', startDate, endDate, machine, 'all'),
                getFilteredData('plan', startDate, endDate, machine, 'all')
            ]);

            console.log('[TRACE][calculateDetailedOEE] Dados recebidos:', {
                production: productionData.length,
                losses: lossesData.length,
                downtime: downtimeData.length,
                plan: planData.length
            });

            if (productionData.length === 0 && lossesData.length === 0 && downtimeData.length === 0) {
                console.warn('[TRACE][calculateDetailedOEE] PROBLEMA: Nenhum dado encontrado para o período!');
                return { availability: 0, performance: 0, quality: 0, oee: 0 };
            }

            const { filtered, groups } = aggregateOeeMetrics(
                productionData,
                lossesData,
                downtimeData,
                planData,
                normalizedShift  // <-- usar normalizedShift em vez de shift
            );

            console.log('[TRACE][calculateDetailedOEE] Resultado da agregação:', {
                gruposProcessados: groups.length,
                disponibilidade: (filtered.disponibilidade * 100).toFixed(1),
                performance: (filtered.performance * 100).toFixed(1),
                qualidade: (filtered.qualidade * 100).toFixed(1),
                oee: (filtered.oee * 100).toFixed(1)
            });

            // CORREÇÃO: Se todos os valores estão zero mas há dados, algo está errado
            if (filtered.disponibilidade === 0 && filtered.performance === 0 && filtered.qualidade === 0 && productionData.length > 0) {
                console.error('[TRACE][calculateDetailedOEE] PROBLEMA CRÍTICO: Valores zerados com dados disponíveis!');
                console.log('[TRACE][calculateDetailedOEE] Amostra production:', productionData.slice(0, 3));
                console.log('[TRACE][calculateDetailedOEE] Amostra plan:', planData.slice(0, 3));
            }

            // CORREÇÃO: Calcular OEE como produto dos componentes (D × P × Q)
            // em vez de usar a média dos OEEs individuais
            const availability = filtered.disponibilidade * 100;
            const performance = filtered.performance * 100;
            const quality = filtered.qualidade * 100;
            const oeeCalculated = (availability * performance * quality) / 10000;

            return {
                availability: availability,
                performance: performance,
                quality: quality,
                oee: oeeCalculated  // OEE = D × P × Q (correto!)
            };
        } catch (error) {
            console.error('Erro ao calcular OEE detalhado:', error);
            return { availability: 0, performance: 0, quality: 0, oee: 0 };
        }
    }

    // Função de comparação por máquinas
    async function compareByMachines(metric, startDate, endDate) {
        const machineIds = machines.map(m => m.id);
        const results = [];

        for (const machineId of machineIds) {
            const data = await getFilteredData('production', startDate, endDate, machineId, 'all');
            const value = data.reduce((sum, item) => sum + item.quantity, 0);
            
            results.push({
                name: machines.find(m => m.id === machineId)?.name || machineId,
                value: value
            });
        }

        return results.sort((a, b) => b.value - a.value);
    }

    // Gerar gráfico de comparação
    async function generateComparisonChart(data, metric) {
        const ctx = document.getElementById('comparison-chart');
        if (!ctx) return;

        destroyChart('comparison-chart');

        if (!data || data.length === 0) {
            showNoDataMessage('comparison-chart');
            return;
        }
        
        clearNoDataMessage('comparison-chart');

        const labels = data.map(item => item.name);
        const values = data.map(item => item.value);

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: metric.toUpperCase(),
                    data: values,
                    backgroundColor: 'rgba(59, 130, 246, 0.8)',
                    borderColor: '#3B82F6',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,

                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: isMobile ? 45 : 0,
                            minRotation: isMobile ? 45 : 0,
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Gerar ranking de comparação
    function generateComparisonRanking(data) {
        const container = document.getElementById('comparison-ranking');
        if (!container) return;

        const html = data.slice(0, 5).map((item, index) => `
            <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div class="flex items-center gap-3">
                    <span class="w-6 h-6 bg-primary-blue text-white rounded-full text-sm flex items-center justify-center font-bold">
                        ${index + 1}
                    </span>
                    <span class="font-medium">${item.name}</span>
                </div>
                <span class="text-lg font-bold text-gray-800">${item.value.toLocaleString()}</span>
            </div>
        `).join('');

        container.innerHTML = html;
    }

    // Gerar estatísticas de comparação
    function generateComparisonStats(data) {
        const container = document.getElementById('comparison-stats');
        if (!container) return;

        const values = data.map(item => item.value);
        const max = Math.max(...values);
        const min = Math.min(...values);
        const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
        const range = max - min;

        const html = `
            <div class="space-y-3">
                <div class="flex justify-between">
                    <span class="text-gray-600">Maior valor:</span>
                    <span class="font-bold">${max.toLocaleString()}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600">Menor valor:</span>
                    <span class="font-bold">${min.toLocaleString()}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600">Média:</span>
                    <span class="font-bold">${avg.toFixed(0).toLocaleString()}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600">Amplitude:</span>
                    <span class="font-bold">${range.toLocaleString()}</span>
                </div>
            </div>
        `;

        container.innerHTML = html;
    }

    // Implementações faltantes para análise completa

    // Gerar timeline de componentes OEE
    async function generateOEEComponentsTimeline(startDate, endDate, machine) {
        const ctx = document.getElementById('oee-components-timeline');
        if (!ctx) return;

        destroyChart('oee-components-timeline');

        // Buscar dados para calcular componentes OEE ao longo do tempo
        const productionData = await getFilteredData('production', startDate, endDate, machine);
        const downtimeData = await getFilteredData('downtime', startDate, endDate, machine);

        if (productionData.length === 0) {
            showNoDataMessage('oee-components-timeline');
            return;
        }
        
        clearNoDataMessage('oee-components-timeline');

        // Agrupar por data
        const dataByDate = {};
        
        productionData.forEach(item => {
            const date = item.date || '';
            if (!dataByDate[date]) {
                dataByDate[date] = {
                    produced: 0,
                    scrap: 0,
                    planned: 0,
                    downtime: 0
                };
            }
            dataByDate[date].produced += item.quantity || 0;
            dataByDate[date].scrap += item.scrap || 0;
            dataByDate[date].planned += item.planned || item.quantity || 0;
        });

        // Obter categorias excluídas do OEE
        const oeeExcludedCategoriesTimeline = window.databaseModule?.oeeExcludedCategories || [];

        downtimeData.forEach(item => {
            const date = item.date || '';
            if (dataByDate[date]) {
                // Verificar se a categoria deve ser excluída do cálculo de OEE
                const reason = item.reason || '';
                const category = getDowntimeCategory(reason);
                if (oeeExcludedCategoriesTimeline.includes(category)) {
                    // Parada de categoria excluída - NÃO contabilizar no OEE
                    return;
                }
                dataByDate[date].downtime += item.duration || 0;
            }
        });

        // Ordenar datas
        const sortedDates = Object.keys(dataByDate).sort();
        const dates = sortedDates.map(date => {
            const [year, month, day] = date.split('-');
            return `${day}/${month}`;
        });
        
        const availabilityData = [];
        const performanceData = [];
        const qualityData = [];

        sortedDates.forEach(date => {
            const data = dataByDate[date];
            
            // Disponibilidade: tempo disponível / tempo planejado
            const plannedMinutes = 480; // 8 horas
            const availability = Math.max(0, Math.min(100, ((plannedMinutes - data.downtime) / plannedMinutes) * 100));
            
            // Performance: produzido / planejado
            const performance = data.planned > 0 ? Math.min(100, (data.produced / data.planned) * 100) : 100;
            
            // Qualidade: (produzido - refugo) / produzido
            const quality = data.produced > 0 ? ((data.produced - data.scrap) / data.produced) * 100 : 100;
            
            availabilityData.push(availability.toFixed(1));
            performanceData.push(performance.toFixed(1));
            qualityData.push(quality.toFixed(1));
        });

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: dates,
                datasets: [{
                    label: 'Disponibilidade %',
                    data: availabilityData,
                    borderColor: '#10B981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: isMobile ? 2 : 4,
                    pointHoverRadius: isMobile ? 4 : 6,
                    tension: 0.3
                }, {
                    label: 'Performance %',
                    data: performanceData,
                    borderColor: '#3B82F6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: isMobile ? 2 : 4,
                    pointHoverRadius: isMobile ? 4 : 6,
                    tension: 0.3
                }, {
                    label: 'Qualidade %',
                    data: qualityData,
                    borderColor: '#F59E0B',
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: isMobile ? 2 : 4,
                    pointHoverRadius: isMobile ? 4 : 6,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,

                scales: {
                    y: {
                        beginAtZero: false,
                        min: 0,
                        max: 100,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            },
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: isMobile ? 45 : 0,
                            minRotation: isMobile ? 45 : 0,
                            font: {
                                size: isMobile ? 9 : 11
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: isMobile ? 'bottom' : 'top',
                        labels: {
                            font: {
                                size: isMobile ? 10 : 12
                            },
                            padding: isMobile ? 8 : 10
                        }
                    }
                }
            }
        });
    }

    // Gerar mapa de calor OEE
    async function generateOEEHeatmap(startDate, endDate, machineFilter = 'all') {
        const container = document.getElementById('oee-heatmap');
        if (!container) return;

        const normalizedMachine = (machineFilter && machineFilter !== 'all') ? machineFilter : 'all';

        try {
            const [productionData, lossesData, downtimeData, planData] = await Promise.all([
                getFilteredData('production', startDate, endDate, normalizedMachine, 'all'),
                getFilteredData('losses', startDate, endDate, normalizedMachine, 'all'),
                getFilteredData('downtime', startDate, endDate, normalizedMachine, 'all'),
                getFilteredData('plan', startDate, endDate, normalizedMachine, 'all')
            ]);

            const { groups } = aggregateOeeMetrics(
                productionData,
                lossesData,
                downtimeData,
                planData,
                'all'
            );

            if (!Array.isArray(groups) || groups.length === 0) {
                container.innerHTML = `
                    <div class="p-6 text-center text-sm text-slate-500 bg-slate-100 rounded-lg">
                        Nenhum dado de OEE encontrado para o período selecionado.
                    </div>
                `;
                return;
            }

            const shiftLabels = [
                { key: 1, label: '1º Turno' },
                { key: 2, label: '2º Turno' },
                { key: 3, label: '3º Turno' }
            ];

            const machineMap = new Map();
            const groupsMap = new Map();

            groups.forEach(item => {
                const machineId = item.machine || 'Sem máquina';
                machineMap.set(machineId, machineId);
                const groupKey = `${machineId}__${item.shift}`;
                groupsMap.set(groupKey, {
                    oee: Number(item.oee) * 100,
                    disponibilidade: Number(item.disponibilidade) * 100,
                    performance: Number(item.performance) * 100,
                    qualidade: Number(item.qualidade) * 100
                });
            });

            let machinesSorted = Array.from(machineMap.values());
            const hasMachineFilter = normalizedMachine !== 'all';
            if (!hasMachineFilter) {
                machinesSorted.sort((a, b) => a.localeCompare(b));
            }

            const resolveColorClass = (value) => {
                if (!Number.isFinite(value)) return 'bg-slate-200 text-slate-500';
                if (value >= 80) return 'bg-emerald-500 text-white';
                if (value >= 70) return 'bg-yellow-400 text-slate-900';
                if (value >= 60) return 'bg-orange-500 text-white';
                return 'bg-red-500 text-white';
            };

            let html = `
                <div class="overflow-x-auto">
                    <table class="min-w-full">
                        <thead>
                            <tr>
                                <th class="px-4 py-2 text-left">Máquina / Turno</th>
                                ${shiftLabels.map(shift => `<th class="px-4 py-2 text-center">${shift.label}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;

            machinesSorted.forEach(machineId => {
                html += `<tr><td class="px-4 py-2 font-semibold text-slate-800">${machineId}</td>`;

                shiftLabels.forEach(({ key }) => {
                    const metric = groupsMap.get(`${machineId}__${key}`);
                    if (metric) {
                        const value = Number.isFinite(metric.oee) ? metric.oee : 0;
                        const colorClass = resolveColorClass(value);
                        const title = `Disponibilidade: ${metric.disponibilidade.toFixed(1)}%\nPerformance: ${metric.performance.toFixed(1)}%\nQualidade: ${metric.qualidade.toFixed(1)}%`;
                        html += `
                            <td class="px-4 py-2 text-center">
                                <div class="heatmap-cell ${colorClass} rounded-lg p-2 m-1 cursor-pointer transition-all hover:scale-105" title="${title}">
                                    ${value.toFixed(1)}%
                                </div>
                            </td>
                        `;
                    } else {
                        html += `
                            <td class="px-4 py-2 text-center">
                                <div class="heatmap-cell bg-slate-100 text-slate-400 rounded-lg p-2 m-1">
                                    --
                                </div>
                            </td>
                        `;
                    }
                });

                html += '</tr>';
            });

            html += `
                        </tbody>
                    </table>
                </div>
                <div class="mt-4 flex items-center justify-center gap-4 text-sm">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-emerald-500 rounded"></div>
                        <span>≥ 80%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-yellow-400 rounded"></div>
                        <span>70-79%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-orange-500 rounded"></div>
                        <span>60-69%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-red-500 rounded"></div>
                        <span>&lt; 60%</span>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        } catch (error) {
            console.error('[OEE][HEATMAP] Erro ao gerar mapa de calor', error);
            container.innerHTML = `
                <div class="p-6 text-center text-sm text-red-600 bg-red-50 rounded-lg">
                    Erro ao carregar mapa de calor. Tente novamente.
                </div>
            `;
        }
    }

    // Funções de comparação faltantes
    async function compareByShifts(metric, startDate, endDate) {
        const shifts = ['1º Turno', '2º Turno', '3º Turno'];
        const results = [];

        for (let i = 1; i <= 3; i++) {
            const data = await getFilteredData('production', startDate, endDate, 'all', i.toString());
            const value = data.reduce((sum, item) => sum + item.quantity, 0);
            
            results.push({
                name: shifts[i - 1],
                value: value
            });
        }

        return results.sort((a, b) => b.value - a.value);
    }

    async function compareByPeriods(metric) {
        const today = new Date();
        const lastWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
        const lastMonth = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);

        const periods = [
            { name: 'Últimos 7 dias', start: lastWeek, end: today },
            { name: 'Últimos 30 dias', start: lastMonth, end: today },
            { name: 'Este mês', start: new Date(today.getFullYear(), today.getMonth(), 1), end: today }
        ];

        const results = [];

        for (const period of periods) {
            const startDate = period.start.toISOString().split('T')[0];
            const endDate = period.end.toISOString().split('T')[0];
            const data = await getFilteredData('production', startDate, endDate, 'all', 'all');
            const value = data.reduce((sum, item) => sum + item.quantity, 0);
            
            results.push({
                name: period.name,
                value: value
            });
        }

        return results;
    }

    async function compareByProducts(metric, startDate, endDate) {
        const productionData = await getFilteredData('production', startDate, endDate, 'all', 'all');
        const planData = await getFilteredData('plan', startDate, endDate, 'all', 'all');
        
        const productData = {};
        
        // Agrupar por produto da produção
        productionData.forEach(item => {
            const product = item.product || 'Produto Não Informado';
            productData[product] = (productData[product] || 0) + item.quantity;
        });

        const results = Object.entries(productData).map(([name, value]) => ({
            name: name,
            value: value
        }));

        return results.sort((a, b) => b.value - a.value);
    }

    // Expor o serviço de dados analíticos para módulos externos (ex.: predictive-analytics)
    if (!window.analyticsDataService) {
        window.analyticsDataService = {};
    }
    window.analyticsDataService.getFilteredData = getFilteredData;

    // Compatibilidade: garantir que outros módulos (Advanced KPIs, SPC, etc.) encontrem a versão completa
    window.getFilteredData = getFilteredData;
    
    // Expor funções da tabela de borra
    window.borraTableNextPage = borraTableNextPage;
    window.borraTablePrevPage = borraTablePrevPage;
    window.exportBorraTable = exportBorraTable;
        
    // Final da inicialização  
    init();

    function getProductionDateString(date = new Date()) {
        const dateObj = date instanceof Date ? date : new Date(date);
        const hour = dateObj.getHours();
        const minute = dateObj.getMinutes();
        
        // Se for antes das 6h30, pertence ao dia de trabalho anterior
        if (hour < 6 || (hour === 6 && minute < 30)) {
            const prevDay = new Date(dateObj);
            prevDay.setDate(prevDay.getDate() - 1);
            return new Date(prevDay.getTime() - (prevDay.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
        }
        
        return new Date(dateObj.getTime() - (dateObj.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
    }
    
    /**
     * Retorna o range de datas de calendário que cobrem um dia de trabalho específico
     * Um dia de trabalho começa às 7h e termina às 6h59 do dia seguinte
     * Exemplo: workday "2025-01-06" = calendário 2025-01-06 (7h) até 2025-01-07 (6h59)
     */
    function getCalendarDateRangeForWorkday(workdayDate) {
        if (!workdayDate || typeof workdayDate !== 'string') return { startDate: null, endDate: null };
        
        const [year, month, day] = workdayDate.split('-').map(Number);
        if ([year, month, day].some(n => Number.isNaN(n))) {
            return { startDate: null, endDate: null };
        }
        
        // Um workday começa no calendário de `workdayDate` e termina no calendário do dia seguinte
        const nextDay = new Date(year, month - 1, day + 1);
        
        return {
            startDate: workdayDate,  // 2025-01-06 representa 7h até 6h59
            endDate: nextDay.toISOString().split('T')[0]  // Próximo dia até 6h59
        };
    }

    function setTodayDate() {
        const todayString = getProductionDateString();
        if (planningDateSelector) planningDateSelector.value = todayString;
        if (resumoDateSelector) resumoDateSelector.value = todayString;
        if (pilotReportDateInput && !pilotReportDateInput.value) pilotReportDateInput.value = todayString;
        if (pilotFilterDateInput && !pilotFilterDateInput.value) pilotFilterDateInput.value = todayString;
        
        if (startDateSelector) startDateSelector.value = todayString;
        if (endDateSelector) endDateSelector.value = todayString;
    }

    function setupEventListeners() {
        // Usar event delegation para nav buttons (funciona com novos elementos)
        const navContainer = document.querySelector('nav');
        if (navContainer) {
            navContainer.addEventListener('click', (e) => {
                const navBtn = e.target.closest('.nav-btn');
                if (navBtn) {
                    // Se for link externo (sem data-page), deixar comportamento padrão
                    if (!navBtn.dataset.page) {
                        return; // Não interceptar
                    }
                    e.preventDefault();
                    handleNavClick({ currentTarget: navBtn, preventDefault: () => {} });
                }
            });
        } else {
            // Fallback: listener direto nos botões
            navButtons.forEach(button => button.addEventListener('click', handleNavClick));
        }
        
        analysisTabButtons.forEach(button => button.addEventListener('click', handleAnalysisTabClick));
        
        if (sidebarOpenBtn) sidebarOpenBtn.addEventListener('click', openSidebar);
        if (sidebarCloseBtn) sidebarCloseBtn.addEventListener('click', closeSidebar);
        if (sidebarToggleBtn) sidebarToggleBtn.addEventListener('click', toggleSidebarCollapse);
        if (sidebarOverlay) sidebarOverlay.addEventListener('click', closeSidebar);

    if (planningForm) planningForm.addEventListener('submit', handlePlanningFormSubmit);
    if (planningOrderSelect) planningOrderSelect.addEventListener('change', onPlanningOrderChange);
    
    // Event listeners para busca de OP
    const orderSearchInput = document.getElementById('planning-order-search');
    if (orderSearchInput) {
        console.log('[Planejamento] Adicionando event listeners ao campo de busca de OP');
        orderSearchInput.addEventListener('input', onPlanningOrderSearchInput);
        orderSearchInput.addEventListener('blur', onPlanningOrderSearchBlur);
        orderSearchInput.addEventListener('focus', (e) => {
            if (e.target.value.trim()) {
                searchPlanningOrder(e.target.value);
            }
        });
    } else {
        console.warn('[Planejamento] Campo de busca de OP não encontrado!');
    }
    
        if (planningDateSelector) planningDateSelector.addEventListener('change', (e) => listenToPlanningChanges(e.target.value));
        if (productionOrderForm) productionOrderForm.addEventListener('submit', handleProductionOrderFormSubmit);
        
        // Adicionar listener para código do produto
        const productCodInput = document.getElementById('planning-product-cod');
        if (productCodInput) {
            ['change', 'blur'].forEach(evt => {
                productCodInput.addEventListener(evt, onPlanningProductCodChange);
            });
            productCodInput.addEventListener('input', onPlanningProductCodChange);
        }
        
        if (planningTableBody) planningTableBody.addEventListener('click', handlePlanningTableClick);
        
        if (leaderLaunchPanel) leaderLaunchPanel.addEventListener('click', handleLeaderPanelClick);
        if (leaderModal) {
            const leaderModalCloseBtn = leaderModal.querySelector('#leader-modal-close-btn');
            if (leaderModalCloseBtn) leaderModalCloseBtn.addEventListener('click', hideLeaderModal);
        }
        if (leaderModalForm) leaderModalForm.addEventListener('submit', handleLeaderEntrySubmit);
        
        if (launchPanelContainer) launchPanelContainer.addEventListener('click', handleLaunchPanelClick);
        if (productionModal) {
            const prodCloseBtn = productionModal.querySelector('#production-modal-close-btn');
            const prodCancelBtn = productionModal.querySelector('#production-modal-cancel-btn');
            if (prodCloseBtn) prodCloseBtn.addEventListener('click', hideProductionModal);
            if (prodCancelBtn) prodCancelBtn.addEventListener('click', hideProductionModal);
        }
        if (productionModalForm) productionModalForm.addEventListener('submit', handleProductionEntrySubmit);
        if (refreshRecentEntriesBtn) refreshRecentEntriesBtn.addEventListener('click', () => loadRecentEntries());
        if (pilotReportForm) pilotReportForm.addEventListener('submit', handlePilotReportSubmit);
        if (pilotFilterDateInput) pilotFilterDateInput.addEventListener('change', () => refreshPilotReports());
        if (pilotRefreshBtn) pilotRefreshBtn.addEventListener('click', (event) => {
            event.preventDefault();
            refreshPilotReports(true);
        });
        if (recentEntriesList) recentEntriesList.addEventListener('click', handleRecentEntryAction);
        if (finalizeOrderBtn) finalizeOrderBtn.addEventListener('click', handleFinalizeOrderClick);
    if (activateOrderBtn) activateOrderBtn.addEventListener('click', handleActivateOrderFromPanel);
        
        // Event listeners para filtro de data e máquina de lançamentos históricos
        const entriesDateFilter = document.getElementById('entries-date-filter');
        const entriesMachineFilter = document.getElementById('entries-machine-filter');
        const entriesDateToday = document.getElementById('entries-date-today');
        const entriesClearAllFilters = document.getElementById('entries-clear-all-filters');
        
        // Popular seletor de máquinas
        if (entriesMachineFilter && typeof machineProductData !== 'undefined') {
            const machines = Object.keys(machineProductData).sort();
            machines.forEach(machine => {
                const option = document.createElement('option');
                option.value = machine;
                option.textContent = machine;
                entriesMachineFilter.appendChild(option);
            });
        }
        
        if (entriesDateFilter) {
            // Definir data atual como valor padrão
            entriesDateFilter.value = getProductionDateString();
            
            entriesDateFilter.addEventListener('change', () => {
                const selectedDate = entriesDateFilter.value;
                if (selectedDate) {
                    window.lancamentoFilterDate = selectedDate;
                    updateEntriesFilterIndicator();
                    loadRecentEntriesWithFilters();
                }
            });
        }
        
        if (entriesMachineFilter) {
            entriesMachineFilter.addEventListener('change', () => {
                const selectedMachine = entriesMachineFilter.value;
                window.lancamentoFilterMachine = selectedMachine || null;
                updateEntriesFilterIndicator();
                loadRecentEntriesWithFilters();
            });
        }
        
        if (entriesDateToday) {
            entriesDateToday.addEventListener('click', () => {
                const today = getProductionDateString();
                if (entriesDateFilter) entriesDateFilter.value = today;
                if (entriesMachineFilter) entriesMachineFilter.value = '';
                window.lancamentoFilterDate = null;
                window.lancamentoFilterMachine = null;
                hideEntriesFilterIndicator();
                loadRecentEntries(true);
            });
        }
        
        if (entriesClearAllFilters) {
            entriesClearAllFilters.addEventListener('click', () => {
                const today = getProductionDateString();
                if (entriesDateFilter) entriesDateFilter.value = today;
                if (entriesMachineFilter) entriesMachineFilter.value = '';
                window.lancamentoFilterDate = null;
                window.lancamentoFilterMachine = null;
                hideEntriesFilterIndicator();
                loadRecentEntries(true);
            });
        }
        
        // Event listeners para filtros de lançamentos recentes
        const filterButtons = document.querySelectorAll('.filter-entry-btn');
        filterButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const filter = btn.dataset.filter;
                applyEntryFilter(filter);
            });
        });
        
    if (resumoDateSelector) resumoDateSelector.addEventListener('change', loadResumoData);
        if (printReportBtn) printReportBtn.addEventListener('click', handlePrintReport);
    if (reportQuantBtn) reportQuantBtn.addEventListener('click', () => switchReportView('quant'));

    // Carregar OPs para o formulário de planejamento
    loadPlanningOrders().catch(err => console.warn('Erro ao carregar OPs para planejamento:', err));
        if (reportEfficBtn) reportEfficBtn.addEventListener('click', () => switchReportView('effic'));
        if (resumoContentContainer) resumoContentContainer.addEventListener('click', handleResumoTableClick);
        
        if (refreshDashboardBtn) refreshDashboardBtn.addEventListener('click', loadDashboardData);
        if (machineFilter) machineFilter.addEventListener('change', () => processAndRenderDashboard(fullDashboardData));
        if (graphMachineFilter) graphMachineFilter.addEventListener('change', () => processAndRenderDashboard(fullDashboardData));
        
        dateRangeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                dateRangeButtons.forEach(btn => btn.classList.remove('active'));
                e.currentTarget.classList.add('active');
                setDateRange(e.currentTarget.dataset.range);
            });
        });

        if (ajustesSearchForm) ajustesSearchForm.addEventListener('submit', handleAjustesSearch);
        if (ajustesRefreshBtn) ajustesRefreshBtn.addEventListener('click', handleAjustesRefresh);
        if (ajustesEditForm) ajustesEditForm.addEventListener('submit', handleAjustesEditSubmit);
        if (ajustesCancelBtn) ajustesCancelBtn.addEventListener('click', () => {
            resetAjustesEditor();
            updateAjustesEditStatus('Edição cancelada. Nenhuma alteração aplicada.', 'info');
        });

        // Confirm modal handlers are assigned dynamically inside showConfirmModal

        // NOVOS EVENT LISTENERS PARA O SISTEMA DE LANÇAMENTOS POR HORA
        document.addEventListener('input', function(e) {
            if (e.target.classList.contains('peso-bruto-input') || 
                e.target.classList.contains('embalagem-fechada-input')) {
                updateTotalCalculation();
            }
        });

        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('usar-tara-checkbox') || e.target.id === 'use-tara-box') {
                updateTotalCalculation();
            }
        });

        // Event listener para deletar lançamentos por hora
        document.addEventListener('click', async function(e) {
            if (e.target.closest('.delete-hourly-entry')) {
                const button = e.target.closest('.delete-hourly-entry');
                const entryId = button.dataset.id;
                
                try {
                    await db.collection('hourly_production_entries').doc(entryId).delete();
                    button.closest('.hourly-entry').remove();
                    updateTotalCalculation();
                } catch (error) {
                    console.error("Erro ao deletar lançamento:", error);
                    alert("Erro ao deletar lançamento.");
                }
            }
        });
    }

    // --- GESTÃO DE LISTENERS ---
    function detachActiveListener() {
        // O gerenciador de listeners cuida automaticamente de desinscrições
        // Esta função é mantida para compatibilidade
        console.log('✅ Listeners ativos desinscritos pelo listenerManager');
    }

    // --- GESTÃO DE ORDENS DE PRODUÇÃO ---
    let ordersCache = [];
    
    async function loadProductionOrders() {
        console.log('[Ordens] Carregando ordens de produção...');
        
        const grid = document.getElementById('orders-grid');
        const tableBody = document.getElementById('orders-table-body');
        const tableContainer = document.getElementById('orders-table-container');
        const emptyState = document.getElementById('orders-empty-state');
        const countEl = document.getElementById('orders-count');
        
        try {
            // Usar função cacheada para economizar leituras do Firebase
            ordersCache = await getProductionOrdersCached();
            console.log('[Ordens] ' + ordersCache.length + ' ordens carregadas (cache/Firebase)');
            
            // Atualizar KPIs
            updateOrdersKPIs(ordersCache);
            
            // Renderizar ordens
            renderOrders(ordersCache);
            
            // Popular filtro de máquinas
            populateOrdersMachineFilter();
            
            // Configurar filtros e eventos (apenas uma vez)
            if (!window.ordersFiltersConfigured) {
                setupOrdersFilters();
                setupOrdersViewToggle();
                window.ordersFiltersConfigured = true;
            }
            
        } catch (error) {
            console.error('[Ordens] Erro ao carregar:', error);
            if (countEl) countEl.textContent = 'Erro ao carregar ordens';
        }
    }
    
    function updateOrdersKPIs(orders) {
        const total = orders.length;
        const active = orders.filter(o => ['ativa', 'em_andamento'].includes((o.status || '').toLowerCase())).length;
        const suspended = orders.filter(o => (o.status || '').toLowerCase() === 'suspensa').length;
        const completed = orders.filter(o => ['concluida', 'finalizada'].includes((o.status || '').toLowerCase())).length;
        
        // Calcular totais de produção e perdas
        let totalProducedAll = 0;
        let totalLossesAll = 0;
        orders.forEach(o => {
            const produced = Number(o.total_produzido ?? o.totalProduced ?? o.total_produced) || 0;
            const losses = Number(o.total_perdas ?? o.totalLosses ?? o.total_losses ?? o.refugo ?? o.scrap) || 0;
            totalProducedAll += produced;
            totalLossesAll += losses;
        });
        
        // Atualizar elementos
        const kpiTotal = document.getElementById('orders-kpi-total');
        const kpiActive = document.getElementById('orders-kpi-active');
        const kpiSuspended = document.getElementById('orders-kpi-suspended');
        const kpiCompleted = document.getElementById('orders-kpi-completed');
        const kpiTotalProduced = document.getElementById('orders-kpi-total-produced');
        const kpiTotalLosses = document.getElementById('orders-kpi-total-losses');
        
        if (kpiTotal) kpiTotal.textContent = total;
        if (kpiActive) kpiActive.textContent = active;
        if (kpiSuspended) kpiSuspended.textContent = suspended;
        if (kpiCompleted) kpiCompleted.textContent = completed;
        if (kpiTotalProduced) kpiTotalProduced.textContent = totalProducedAll.toLocaleString('pt-BR');
        if (kpiTotalLosses) kpiTotalLosses.textContent = totalLossesAll.toLocaleString('pt-BR');
    }
    
    function renderOrders(orders) {
        const grid = document.getElementById('orders-grid');
        const tableBody = document.getElementById('orders-table-body');
        const tableContainer = document.getElementById('orders-table-container');
        const emptyState = document.getElementById('orders-empty-state');
        const countEl = document.getElementById('orders-count');
        
        // Atualizar contador
        if (countEl) countEl.textContent = orders.length + ' ordem' + (orders.length !== 1 ? 's' : '') + ' encontrada' + (orders.length !== 1 ? 's' : '');
        
        if (orders.length === 0) {
            if (grid) grid.innerHTML = '';
            if (tableBody) tableBody.innerHTML = '';
            if (emptyState) emptyState.classList.remove('hidden');
            return;
        }
        
        if (emptyState) emptyState.classList.add('hidden');
        
        // Renderizar Grid de Cards
        if (grid) {
            grid.innerHTML = orders.map(order => renderOrderCard(order)).join('');
        }
        
        // Renderizar Tabela
        if (tableBody) {
            tableBody.innerHTML = orders.map(order => renderOrderTableRow(order)).join('');
        }
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function renderOrderCard(order) {
        const status = (order.status || 'planejada').toLowerCase();
        const lotSize = Number(order.lot_size) || 0;
        // CORREÇÃO: Usar total_produzido OU totalProduced (nomes corretos do campo no Firebase)
        const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
        const losses = Number(order.total_perdas ?? order.totalLosses ?? order.total_losses ?? order.refugo ?? order.scrap) || 0;
        const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
        
        const statusConfig = {
            'planejada': { bg: 'bg-slate-100', text: 'text-slate-700', label: 'Planejada', icon: 'calendar' },
            'ativa': { bg: 'bg-blue-100', text: 'text-blue-700', label: 'Ativa', icon: 'zap' },
            'em_andamento': { bg: 'bg-amber-100', text: 'text-amber-700', label: 'Em Andamento', icon: 'play-circle' },
            'suspensa': { bg: 'bg-orange-100', text: 'text-orange-700', label: 'Suspensa', icon: 'pause-circle' },
            'concluida': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Concluída', icon: 'check-circle-2' },
            'finalizada': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Finalizada', icon: 'check-circle-2' },
            'cancelada': { bg: 'bg-red-100', text: 'text-red-700', label: 'Cancelada', icon: 'x-circle' }
        };
        
        const sc = statusConfig[status] || statusConfig['planejada'];
        const progressColor = progress >= 100 ? 'bg-emerald-500' : progress >= 50 ? 'bg-blue-500' : 'bg-amber-500';
        const isActive = ['ativa', 'em_andamento'].includes(status);
        const isSuspended = status === 'suspensa';
        const canActivate = status === 'planejada';
        const canReactivate = ['concluida', 'finalizada'].includes(status);
        const canSuspend = isActive;
        const canResume = isSuspended;
        
        return '<div class="bg-white rounded-xl border ' + (isActive ? 'border-blue-300 ring-2 ring-blue-100' : isSuspended ? 'border-orange-300 ring-2 ring-orange-100' : 'border-gray-200') + ' shadow-sm hover:shadow-md transition-all overflow-hidden">' +
            '<div class="p-4 border-b border-gray-100 ' + (isActive ? 'bg-blue-50' : isSuspended ? 'bg-orange-50' : 'bg-gray-50') + '">' +
                '<div class="flex items-start justify-between gap-2">' +
                    '<div class="flex-1 min-w-0">' +
                        '<h4 class="font-bold text-gray-800 truncate">OP ' + escapeHtml(order.order_number || '') + '</h4>' +
                        '<p class="text-sm text-gray-600 truncate">' + escapeHtml(order.product || order.part_code || 'Produto não definido') + '</p>' +
                    '</div>' +
                    '<span class="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ' + sc.bg + ' ' + sc.text + '">' +
                        '<i data-lucide="' + sc.icon + '" class="w-3 h-3"></i>' +
                        sc.label +
                    '</span>' +
                '</div>' +
            '</div>' +
            '<div class="p-4 space-y-3">' +
                '<div class="grid grid-cols-2 gap-2 text-sm">' +
                    '<div class="flex items-center gap-2 text-gray-600">' +
                        '<i data-lucide="user" class="w-4 h-4 text-gray-400"></i>' +
                        '<span class="truncate">' + escapeHtml(order.customer || 'N/A') + '</span>' +
                    '</div>' +
                    '<div class="flex items-center gap-2 text-gray-600">' +
                        '<i data-lucide="settings" class="w-4 h-4 text-gray-400"></i>' +
                        '<span class="truncate">' + escapeHtml(order.machine_id || 'N/A') + '</span>' +
                    '</div>' +
                '</div>' +
                '<div class="bg-gray-50 rounded-lg p-3">' +
                    '<div class="flex items-center justify-between text-xs text-gray-500 mb-1">' +
                        '<span>Progresso</span>' +
                        '<span class="font-semibold">' + Math.round(progress) + '%</span>' +
                    '</div>' +
                    '<div class="w-full bg-gray-200 rounded-full h-2">' +
                        '<div class="' + progressColor + ' h-2 rounded-full transition-all" style="width: ' + progress + '%"></div>' +
                    '</div>' +
                    '<div class="grid grid-cols-3 text-xs text-gray-500 mt-2">' +
                        '<span class="text-center"><span class="font-semibold text-green-600">' + produced.toLocaleString('pt-BR') + '</span><br>Produzido</span>' +
                        '<span class="text-center"><span class="font-semibold text-blue-600">' + lotSize.toLocaleString('pt-BR') + '</span><br>Planejado</span>' +
                        '<span class="text-center"><span class="font-semibold text-red-600">' + losses.toLocaleString('pt-BR') + '</span><br>Perdas</span>' +
                    '</div>' +
                '</div>' +
            '</div>' +
            '<div class="px-4 pb-4 grid grid-cols-2 gap-2">' +
                (canActivate ? '<button onclick="activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="play" class="w-4 h-4"></i>Ativar</button>' : '') +
                (canSuspend ? '<button onclick="suspendOrder(\'' + order.id + '\')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg text-sm font-medium transition"><i data-lucide="pause" class="w-4 h-4"></i>Suspender</button>' : '') +
                (canResume ? '<button onclick="resumeOrder(\'' + order.id + '\')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="play" class="w-4 h-4"></i>Retomar</button>' : '') +
                (canReactivate ? '<button onclick="reactivateOrder(\'' + order.id + '\')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="rotate-ccw" class="w-4 h-4"></i>Reativar</button>' : '') +
                '<button onclick="openOrderTraceability(\'' + order.id + '\')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="file-search" class="w-4 h-4"></i>Rastrear</button>' +
                '<button onclick="editOrder(\'' + order.id + '\')" class="flex items-center justify-center gap-1.5 px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg text-sm font-medium transition"><i data-lucide="edit-3" class="w-4 h-4"></i>Editar</button>' +
            '</div>' +
        '</div>';
    }
    
    function renderOrderTableRow(order) {
        const status = (order.status || 'planejada').toLowerCase();
        const lotSize = Number(order.lot_size) || 0;
        // CORREÇÃO: Usar total_produzido OU totalProduced (nomes corretos do campo no Firebase)
        const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
        const losses = Number(order.total_perdas ?? order.totalLosses ?? order.total_losses ?? order.refugo ?? order.scrap) || 0;
        const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
        
        const statusBadge = {
            'planejada': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-slate-100 text-slate-700">Planejada</span>',
            'ativa': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-700">Ativa</span>',
            'em_andamento': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-700">Em Andamento</span>',
            'suspensa': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-orange-100 text-orange-700">Suspensa</span>',
            'concluida': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-emerald-100 text-emerald-700">Concluída</span>',
            'finalizada': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-emerald-100 text-emerald-700">Finalizada</span>',
            'cancelada': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-700">Cancelada</span>'
        };
        
        const isActive = ['ativa', 'em_andamento'].includes(status);
        const isSuspended = status === 'suspensa';
        const canActivate = status === 'planejada';
        const canReactivate = ['concluida', 'finalizada'].includes(status);
        const canSuspend = isActive;
        const canResume = isSuspended;
        
        let actions = '';
        if (canActivate) {
            actions += '<button onclick="activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="px-2 py-1 bg-emerald-600 hover:bg-emerald-700 text-white rounded text-xs font-medium mr-1" title="Ativar"><i data-lucide="play" class="w-3 h-3 inline"></i></button>';
        }
        if (canSuspend) {
            actions += '<button onclick="suspendOrder(\'' + order.id + '\')" class="px-2 py-1 bg-orange-500 hover:bg-orange-600 text-white rounded text-xs font-medium mr-1" title="Suspender"><i data-lucide="pause" class="w-3 h-3 inline"></i></button>';
        }
        if (canResume) {
            actions += '<button onclick="resumeOrder(\'' + order.id + '\')" class="px-2 py-1 bg-emerald-600 hover:bg-emerald-700 text-white rounded text-xs font-medium mr-1" title="Retomar"><i data-lucide="play" class="w-3 h-3 inline"></i></button>';
        }
        if (canReactivate) {
            actions += '<button onclick="reactivateOrder(\'' + order.id + '\')" class="px-2 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-xs font-medium mr-1" title="Reativar"><i data-lucide="rotate-ccw" class="w-3 h-3 inline"></i></button>';
        }
        actions += '<button onclick="openOrderTraceability(\'' + order.id + '\')" class="px-2 py-1 bg-indigo-600 hover:bg-indigo-700 text-white rounded text-xs font-medium mr-1" title="Rastrear"><i data-lucide="file-search" class="w-3 h-3 inline"></i></button>';
        actions += '<button onclick="editOrder(\'' + order.id + '\')" class="px-2 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded text-xs font-medium" title="Editar"><i data-lucide="edit-3" class="w-3 h-3 inline"></i></button>';
        
        const progressBar = '<div class="w-full bg-gray-200 rounded-full h-2"><div class="bg-blue-500 h-2 rounded-full" style="width: ' + progress + '%"></div></div><span class="text-xs text-gray-500">' + Math.round(progress) + '%</span>';
        
        return '<tr class="hover:bg-gray-50">' +
            '<td class="px-4 py-3 font-medium">' + escapeHtml(order.order_number || '') + '</td>' +
            '<td class="px-4 py-3">' + escapeHtml(order.product || order.part_code || '-') + '</td>' +
            '<td class="px-4 py-3">' + escapeHtml(order.machine_id || '-') + '</td>' +
            '<td class="px-4 py-3 text-center">' + lotSize.toLocaleString('pt-BR') + '</td>' +
            '<td class="px-4 py-3 text-center text-green-600 font-semibold">' + produced.toLocaleString('pt-BR') + '</td>' +
            '<td class="px-4 py-3 text-center text-red-600 font-semibold">' + losses.toLocaleString('pt-BR') + '</td>' +
            '<td class="px-4 py-3 text-center"><div class="flex flex-col items-center gap-1">' + progressBar + '</div></td>' +
            '<td class="px-4 py-3 text-center">' + (statusBadge[status] || statusBadge['planejada']) + '</td>' +
            '<td class="px-4 py-3 text-center whitespace-nowrap">' + actions + '</td>' +
        '</tr>';
    }
    
    function populateOrdersMachineFilter() {
        const machineFilter = document.getElementById('orders-machine-filter');
        if (!machineFilter) return;
        
        machineFilter.innerHTML = '<option value="">Todas Máquinas</option>';
        
        if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
            machineDatabase.forEach(function(machine) {
                const mid = normalizeMachineId(machine.id);
                machineFilter.innerHTML += '<option value="' + mid + '">' + mid + ' - ' + machine.model + '</option>';
            });
        }
    }
    
    function setupOrdersFilters() {
        const searchInput = document.getElementById('orders-search');
        const statusFilter = document.getElementById('orders-status-filter');
        const machineFilter = document.getElementById('orders-machine-filter');
        const sortFilter = document.getElementById('orders-sort-filter');
        const clearBtn = document.getElementById('orders-clear-filters');
        
        function applyFilters() {
            let filtered = [...ordersCache];
            
            // Busca
            const query = (searchInput?.value || '').toLowerCase().trim();
            if (query) {
                filtered = filtered.filter(o => 
                    (o.order_number || '').toLowerCase().includes(query) ||
                    (o.product || '').toLowerCase().includes(query) ||
                    (o.part_code || '').toLowerCase().includes(query) ||
                    (o.customer || '').toLowerCase().includes(query)
                );
            }
            
            // Status
            const status = statusFilter?.value || '';
            if (status) {
                filtered = filtered.filter(o => {
                    const s = (o.status || '').toLowerCase();
                    if (status === 'concluida') return ['concluida', 'finalizada'].includes(s);
                    return s === status;
                });
            }
            
            // Máquina
            const machine = machineFilter?.value || '';
            if (machine) {
                filtered = filtered.filter(o => o.machine_id === machine);
            }
            
            // Ordenação
            const sort = sortFilter?.value || 'recent';
            filtered.sort((a, b) => {
                const lotA = Number(a.lot_size) || 0;
                const lotB = Number(b.lot_size) || 0;
                const prodA = Number(a.total_produzido ?? a.totalProduced ?? a.total_produced) || 0;
                const prodB = Number(b.total_produzido ?? b.totalProduced ?? b.total_produced) || 0;
                const progressA = lotA > 0 ? (prodA / lotA) : 0;
                const progressB = lotB > 0 ? (prodB / lotB) : 0;
                
                switch (sort) {
                    case 'recent':
                        return (b.createdAt?.toDate?.() || new Date(0)) - (a.createdAt?.toDate?.() || new Date(0));
                    case 'progress-desc':
                        return progressB - progressA;
                    case 'progress-asc':
                        return progressA - progressB;
                    case 'lot-desc':
                        return lotB - lotA;
                    case 'alpha':
                        return (a.order_number || '').localeCompare(b.order_number || '');
                    default:
                        return 0;
                }
            });
            
            updateOrdersKPIs(filtered);
            renderOrders(filtered);
        }
        
        if (searchInput) searchInput.addEventListener('input', debounce(applyFilters, 300));
        if (statusFilter) statusFilter.addEventListener('change', applyFilters);
        if (machineFilter) machineFilter.addEventListener('change', applyFilters);
        if (sortFilter) sortFilter.addEventListener('change', applyFilters);
        
        if (clearBtn) {
            clearBtn.addEventListener('click', function() {
                if (searchInput) searchInput.value = '';
                if (statusFilter) statusFilter.value = '';
                if (machineFilter) machineFilter.value = '';
                if (sortFilter) sortFilter.value = 'recent';
                applyFilters();
            });
        }
    }
    
    function setupOrdersViewToggle() {
        const gridBtn = document.getElementById('orders-view-grid-btn');
        const tableBtn = document.getElementById('orders-view-table-btn');
        const grid = document.getElementById('orders-grid');
        const tableContainer = document.getElementById('orders-table-container');
        
        if (gridBtn && tableBtn && grid && tableContainer) {
            gridBtn.addEventListener('click', function() {
                grid.classList.remove('hidden');
                tableContainer.classList.add('hidden');
                gridBtn.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                gridBtn.classList.remove('text-gray-500');
                tableBtn.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                tableBtn.classList.add('text-gray-500');
            });
            
            tableBtn.addEventListener('click', function() {
                grid.classList.add('hidden');
                tableContainer.classList.remove('hidden');
                tableBtn.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                tableBtn.classList.remove('text-gray-500');
                gridBtn.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                gridBtn.classList.add('text-gray-500');
            });
        }
    }
    
    // Funções globais para ações nas ordens
    window.activateOrder = async function(orderId, machineId) {
        if (!machineId) {
            showNotification('Esta ordem não tem máquina definida. Edite primeiro.', 'warning');
            return;
        }
        if (!confirm('Ativar ordem na máquina ' + machineId + '?')) return;
        try {
            await db.collection('production_orders').doc(orderId).update({
                status: 'ativa',
                activatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            showNotification('Ordem ativada!', 'success');
            loadProductionOrders();
        } catch (e) {
            showNotification('Erro ao ativar ordem', 'error');
        }
    };
    
    window.reactivateOrder = async function(orderId) {
        if (!confirm('Reativar esta ordem?')) return;
        try {
            await db.collection('production_orders').doc(orderId).update({ status: 'ativa' });
            showNotification('Ordem reativada!', 'success');
            loadProductionOrders();
        } catch (e) {
            showNotification('Erro ao reativar ordem', 'error');
        }
    };
    
    window.editOrder = function(orderId) {
        const order = ordersCache.find(o => o.id === orderId);
        if (!order) {
            showNotification('Ordem não encontrada', 'error');
            return;
        }
        openNewOrderModal(order);
    };
    
    // Suspender ordem de produção
    window.suspendOrder = async function(orderId) {
        const order = ordersCache.find(o => o.id === orderId);
        const orderNum = order?.order_number || orderId;
        
        const motivo = prompt('Informe o motivo da suspensão da OP ' + orderNum + ':');
        if (!motivo) {
            showNotification('Suspensão cancelada - motivo não informado', 'info');
            return;
        }
        
        try {
            await db.collection('production_orders').doc(orderId).update({
                status: 'suspensa',
                suspendedAt: firebase.firestore.FieldValue.serverTimestamp(),
                suspendedReason: motivo,
                previousStatus: order?.status || 'ativa'
            });
            showNotification('Ordem OP ' + orderNum + ' suspensa!', 'warning');
            loadProductionOrders();
        } catch (e) {
            console.error('Erro ao suspender ordem:', e);
            showNotification('Erro ao suspender ordem', 'error');
        }
    };
    
    // Retomar ordem suspensa
    window.resumeOrder = async function(orderId) {
        const order = ordersCache.find(o => o.id === orderId);
        const orderNum = order?.order_number || orderId;
        
        if (!confirm('Retomar ordem OP ' + orderNum + '?')) return;
        
        try {
            const previousStatus = order?.previousStatus || 'ativa';
            await db.collection('production_orders').doc(orderId).update({
                status: previousStatus,
                resumedAt: firebase.firestore.FieldValue.serverTimestamp(),
                suspendedReason: firebase.firestore.FieldValue.delete()
            });
            showNotification('Ordem OP ' + orderNum + ' retomada!', 'success');
            loadProductionOrders();
        } catch (e) {
            console.error('Erro ao retomar ordem:', e);
            showNotification('Erro ao retomar ordem', 'error');
        }
    };
    
    // Abrir modal de rastreabilidade da ordem
    window.openOrderTraceability = async function(orderId) {
        const order = ordersCache.find(o => o.id === orderId);
        if (!order) {
            showNotification('Ordem não encontrada', 'error');
            return;
        }
        
        const modal = document.getElementById('order-traceability-modal');
        if (!modal) {
            showNotification('Modal de rastreabilidade não encontrado', 'error');
            return;
        }
        
        // Atualizar cabeçalho
        const orderNumEl = document.getElementById('order-trace-number');
        if (orderNumEl) orderNumEl.textContent = 'OP #' + (order.order_number || 'N/A') + ' - ' + (order.product || order.part_code || 'Sem produto');
        
        // Mostrar loading
        const entriesContainer = document.getElementById('order-trace-entries');
        if (entriesContainer) entriesContainer.innerHTML = '<div class="p-4 text-center text-gray-500"><i data-lucide="loader-2" class="w-6 h-6 animate-spin mx-auto"></i><p class="mt-2">Carregando lançamentos...</p></div>';
        
        // Mostrar modal
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
        try {
            // Buscar lançamentos de produção - tentar múltiplas queries para cobrir todos os casos
            let entries = [];
            
            console.log('[TRACE] Buscando lançamentos para orderId:', orderId);
            
            // Query 1: Buscar por orderId (sem orderBy para evitar necessidade de índice)
            try {
                const snapshot1 = await db.collection('production_entries')
                    .where('orderId', '==', orderId)
                    .limit(500)
                    .get();
                console.log('[TRACE] Query orderId retornou:', snapshot1.size, 'documentos');
                snapshot1.forEach(doc => {
                    entries.push({ id: doc.id, ...doc.data() });
                });
            } catch (e) {
                console.warn('[TRACE] Query orderId falhou:', e);
            }
            
            // Query 2: Buscar por order_id (alternativo)
            if (entries.length === 0) {
                try {
                    const snapshot2 = await db.collection('production_entries')
                        .where('order_id', '==', orderId)
                        .limit(500)
                        .get();
                    console.log('[TRACE] Query order_id retornou:', snapshot2.size, 'documentos');
                    snapshot2.forEach(doc => {
                        if (!entries.find(e => e.id === doc.id)) {
                            entries.push({ id: doc.id, ...doc.data() });
                        }
                    });
                } catch (e) {
                    console.warn('[TRACE] Query order_id falhou:', e);
                }
            }
            
            // Query 3: Se ainda não encontrou, buscar pelo número da OP via planejamento
            if (entries.length === 0 && order.order_number) {
                try {
                    console.log('[TRACE] Buscando planejamentos para order_number:', order.order_number);
                    // Buscar planejamentos vinculados a esta OP
                    const planSnapshot = await db.collection('planning')
                        .where('order_number', '==', order.order_number)
                        .get();
                    
                    const planIds = planSnapshot.docs.map(d => d.id);
                    console.log('[TRACE] Encontrados', planIds.length, 'planejamentos');
                    
                    if (planIds.length > 0) {
                        // Buscar lançamentos por planId (em chunks de 10)
                        for (let i = 0; i < planIds.length; i += 10) {
                            const chunk = planIds.slice(i, i + 10);
                            const snapshot3 = await db.collection('production_entries')
                                .where('planId', 'in', chunk)
                                .limit(500)
                                .get();
                            console.log('[TRACE] Query planId chunk retornou:', snapshot3.size, 'documentos');
                            snapshot3.forEach(doc => {
                                if (!entries.find(e => e.id === doc.id)) {
                                    entries.push({ id: doc.id, ...doc.data() });
                                }
                            });
                        }
                    }
                } catch (e) {
                    console.warn('[TRACE] Query planId falhou:', e);
                }
            }
            
            // Remover duplicatas e ordenar
            const uniqueEntries = [];
            const seenIds = new Set();
            entries.forEach(e => {
                if (!seenIds.has(e.id)) {
                    seenIds.add(e.id);
                    uniqueEntries.push(e);
                }
            });
            
            // Ordenar por timestamp (mais recente primeiro)
            uniqueEntries.sort((a, b) => {
                const tsA = a.timestamp?.toMillis ? a.timestamp.toMillis() : (a.timestamp?.seconds || 0) * 1000;
                const tsB = b.timestamp?.toMillis ? b.timestamp.toMillis() : (b.timestamp?.seconds || 0) * 1000;
                return tsB - tsA;
            });
            
            // Processar lançamentos - CORRIGIDO: usar campos corretos
            let totalProduced = 0;
            let totalLosses = 0;
            const processedEntries = [];
            
            uniqueEntries.forEach(data => {
                // Quantidade produzida - campos usados no sistema
                const qty = Number(data.produzido || data.quantity || data.qty || 0);
                // Perdas/Refugo - campos usados no sistema
                const lossKg = Number(data.refugo_kg || data.refugo || 0);
                const lossQty = Number(data.refugo_qty || 0);
                const loss = lossQty > 0 ? lossQty : lossKg; // Preferir quantidade, senão peso
                
                // Só considerar se tem produção (ignorar lançamentos só de perda)
                if (qty > 0) {
                    totalProduced += qty;
                }
                totalLosses += loss;
                
                processedEntries.push({
                    ...data,
                    qty: qty,
                    loss: loss,
                    lossKg: lossKg
                });
            });
            
            console.log('[TRACE] Encontrados', uniqueEntries.length, 'lançamentos. Total:', totalProduced, 'peças,', totalLosses, 'perdas');
            
            // Atualizar resumo
            const lotSize = Number(order.lot_size) || 0;
            const progress = lotSize > 0 ? Math.min((totalProduced / lotSize) * 100, 100) : 0;
            
            const plannedEl = document.getElementById('order-trace-planned');
            const producedEl = document.getElementById('order-trace-produced');
            const lossesEl = document.getElementById('order-trace-losses');
            const progressEl = document.getElementById('order-trace-progress');
            const countEl = document.getElementById('order-trace-entries-count');
            
            if (plannedEl) plannedEl.textContent = lotSize.toLocaleString('pt-BR');
            if (producedEl) producedEl.textContent = totalProduced.toLocaleString('pt-BR');
            if (lossesEl) lossesEl.textContent = totalLosses.toLocaleString('pt-BR');
            if (progressEl) progressEl.textContent = Math.round(progress) + '%';
            if (countEl) countEl.textContent = processedEntries.length + ' registro(s)';
            
            // Renderizar lançamentos
            if (processedEntries.length === 0) {
                entriesContainer.innerHTML = '<div class="p-8 text-center text-gray-400"><i data-lucide="inbox" class="w-12 h-12 mx-auto mb-3"></i><p>Nenhum lançamento encontrado para esta ordem</p></div>';
            } else {
                entriesContainer.innerHTML = processedEntries.map(entry => {
                    let timestamp;
                    if (entry.timestamp?.toDate) {
                        timestamp = entry.timestamp.toDate();
                    } else if (entry.timestamp?.seconds) {
                        timestamp = new Date(entry.timestamp.seconds * 1000);
                    } else if (entry.createdAt?.toDate) {
                        timestamp = entry.createdAt.toDate();
                    } else {
                        timestamp = new Date();
                    }
                    
                    const dateStr = timestamp.toLocaleDateString('pt-BR');
                    const timeStr = timestamp.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    const turno = entry.turno || entry.shift || '-';
                    const operador = entry.nomeUsuario || entry.operador || entry.operator || entry.registradoPorNome || 'N/A';
                    const maquina = entry.machine || entry.machine_id || entry.machineId || 'N/A';
                    
                    // Determinar tipo de lançamento
                    let icon = 'package-check';
                    let bgColor = 'bg-green-100';
                    let iconColor = 'text-green-600';
                    let tipoLabel = 'Produção';
                    
                    if (entry.qty <= 0 && entry.loss > 0) {
                        icon = 'trash-2';
                        bgColor = 'bg-red-100';
                        iconColor = 'text-red-600';
                        tipoLabel = 'Perda';
                    }
                    
                    return '<div class="flex items-center justify-between px-4 py-3 border-b border-gray-100 hover:bg-gray-50">' +
                        '<div class="flex items-center gap-3">' +
                            '<div class="p-2 ' + bgColor + ' rounded-lg"><i data-lucide="' + icon + '" class="w-4 h-4 ' + iconColor + '"></i></div>' +
                            '<div>' +
                                '<p class="text-sm font-medium text-gray-800">' + maquina + ' <span class="text-xs text-gray-400">T' + turno + '</span></p>' +
                                '<p class="text-xs text-gray-500">' + dateStr + ' às ' + timeStr + '</p>' +
                                '<p class="text-xs text-gray-400">' + operador + '</p>' +
                            '</div>' +
                        '</div>' +
                        '<div class="flex items-center gap-4 text-sm">' +
                            (entry.qty > 0 ? '<div class="text-right"><span class="font-semibold text-green-600">+' + entry.qty.toLocaleString('pt-BR') + '</span><p class="text-xs text-gray-500">Peças</p></div>' : '') +
                            (entry.loss > 0 ? '<div class="text-right"><span class="font-semibold text-red-600">-' + entry.loss.toLocaleString('pt-BR') + '</span><p class="text-xs text-gray-500">' + (entry.lossKg > 0 ? 'kg' : 'pç') + '</p></div>' : '') +
                        '</div>' +
                    '</div>';
                }).join('');
            }
            
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
        } catch (error) {
            console.error('Erro ao carregar rastreabilidade:', error);
            entriesContainer.innerHTML = '<div class="p-8 text-center text-red-500"><i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3"></i><p>Erro ao carregar dados de rastreabilidade</p><p class="text-xs mt-2">' + error.message + '</p></div>';
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    };
    
    // Recalcular totais de todas as ordens
    window.recalculateAllOrdersTotals = async function() {
        if (!confirm('Recalcular totais de produção e perdas para todas as ordens?\n\nIsso pode levar alguns segundos.')) return;
        
        showNotification('Recalculando totais...', 'info');
        
        try {
            // Usar função cacheada mas forçar refresh pois é operação crítica
            const ordersData = await getProductionOrdersCached(true);
            let updated = 0;
            let errors = 0;
            
            for (const orderDoc of ordersData) {
                const orderId = orderDoc.id;
                
                try {
                    // Buscar todos os lançamentos da ordem
                    const entriesSnapshot = await db.collection('production_entries')
                        .where('orderId', '==', orderId)
                        .get();
                    
                    let totalProduced = 0;
                    let totalLosses = 0;
                    
                    entriesSnapshot.forEach(entryDoc => {
                        const data = entryDoc.data();
                        totalProduced += Number(data.produzido || data.quantity || data.qty) || 0;
                        totalLosses += Number(data.refugo_kg || data.refugo_qty || data.refugo || data.losses) || 0;
                    });
                    
                    // Atualizar ordem
                    await db.collection('production_orders').doc(orderId).update({
                        total_produzido: totalProduced,
                        total_perdas: totalLosses,
                        lastRecalculated: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    updated++;
                } catch (entryError) {
                    console.error('Erro ao recalcular ordem ' + orderId + ':', entryError);
                    errors++;
                }
            }
            
            // Invalidar cache após atualização
            if (window.DataStore) window.DataStore.set('productionOrders', null);
            productionOrdersCache = null;
            
            showNotification('✅ Recalculado! ' + updated + ' ordens atualizadas' + (errors > 0 ? ', ' + errors + ' erros' : ''), 'success');
            loadProductionOrders();
            
        } catch (error) {
            console.error('Erro ao recalcular totais:', error);
            showNotification('Erro ao recalcular totais', 'error');
        }
    };
    
    // Atualizar lista de ordens
    window.refreshOrdersList = function() {
        loadProductionOrders();
        showNotification('Lista de ordens atualizada!', 'success');
    };

    // Buscar MP por texto
    window.searchMP = function() {
        const searchTerm = prompt('Digite o código ou descrição da MP:');
        if (!searchTerm) return;
        
        const mpSelect = document.getElementById('order-form-mp');
        if (!mpSelect || typeof materiaPrimaDatabase === 'undefined') {
            showNotification('Database de MP não disponível', 'error');
            return;
        }
        
        const term = searchTerm.toLowerCase();
        const found = materiaPrimaDatabase.find(mp => 
            mp.codigo.toLowerCase().includes(term) || 
            mp.descricao.toLowerCase().includes(term)
        );
        
        if (found) {
            mpSelect.value = found.codigo;
            mpSelect.dispatchEvent(new Event('change'));
            showNotification(`✅ MP encontrada: ${found.codigo} - ${found.descricao}`, 'success');
        } else {
            showNotification(`❌ MP não encontrada para: ${searchTerm}`, 'warning');
        }
    };
    
    // Função para salvar ordem de produção
    window.saveOrderForm = async function() {
        console.log('📝 [saveOrderForm] Iniciando salvamento...');
        
        try {
            const id = document.getElementById('order-form-id')?.value;
            const orderData = {
                order_number: document.getElementById('order-form-number')?.value.trim() || '',
                part_code: document.getElementById('order-form-part-code')?.value.trim() || '',
                product: document.getElementById('order-form-product')?.value.trim() || '',
                lot_size: Number(document.getElementById('order-form-lot-size')?.value) || 0,
                batch_number: document.getElementById('order-form-batch')?.value.trim() || '',
                packaging_qty: Number(document.getElementById('order-form-packaging')?.value) || 0,
                customer: document.getElementById('order-form-customer')?.value.trim() || '',
                machine_id: document.getElementById('order-form-machine')?.value || '',
                raw_material: document.getElementById('order-form-mp')?.value || ''
            };
            
            console.log('📝 [saveOrderForm] Dados:', orderData);
            
            if (!orderData.order_number) {
                showNotification('Informe o número da OP', 'warning');
                return;
            }
            
            if (!orderData.lot_size || orderData.lot_size <= 0) {
                showNotification('Informe o tamanho do lote', 'warning');
                return;
            }
            
            if (id) {
                console.log('📝 [saveOrderForm] Atualizando ordem:', id);
                await db.collection('production_orders').doc(id).update(orderData);
                showNotification('Ordem atualizada com sucesso!', 'success');
                
                // Registrar log de edição
                registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            } else {
                console.log('📝 [saveOrderForm] Criando nova ordem...');
                orderData.status = 'planejada';
                orderData.total_produced = 0;
                orderData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                const docRef = await db.collection('production_orders').add(orderData);
                console.log('✅ [saveOrderForm] Ordem criada com ID:', docRef.id);
                showNotification('Ordem cadastrada com sucesso!', 'success');
                
                // Registrar log de criação
                registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: docRef.id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            }
            
            closeOrderFormModal();
            
            // Atualizar lista de ordens
            if (typeof loadProductionOrders === 'function') {
                loadProductionOrders();
            }
            // Atualizar módulo de ordens após um pequeno delay
            setTimeout(function() {
                if (window.OrdersPageModule && window.OrdersPageModule.refreshOrders) {
                    window.OrdersPageModule.refreshOrders();
                }
            }, 100);
            
        } catch (error) {
            console.error('❌ [saveOrderForm] Erro:', error);
            showNotification('Erro ao salvar: ' + error.message, 'error');
        }
    };
    
    window.openNewOrderModal = function(order) {
        const modal = document.getElementById('order-form-modal');
        if (!modal) return;
        
        const title = document.getElementById('order-form-title');
        if (title) title.textContent = order ? 'Editar Ordem de Produção' : 'Nova Ordem de Produção';
        
        // Popular select de máquinas
        const machineSelect = document.getElementById('order-form-machine');
        if (machineSelect) {
            machineSelect.innerHTML = '<option value="">Selecione uma máquina</option>';
            if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
                machineDatabase.forEach(function(machine) {
                    const mid = normalizeMachineId(machine.id);
                    machineSelect.innerHTML += '<option value="' + mid + '">' + mid + ' - ' + machine.model + '</option>';
                });
            }
        }
        
        // Popular select de Matéria-Prima
        const mpSelect = document.getElementById('order-form-mp');
        if (mpSelect) {
            mpSelect.innerHTML = '<option value="">Selecione a MP...</option>';
            if (typeof materiaPrimaDatabase !== 'undefined' && materiaPrimaDatabase.length > 0) {
                materiaPrimaDatabase.forEach(function(mp) {
                    mpSelect.innerHTML += '<option value="' + mp.codigo + '">' + mp.codigo + ' - ' + mp.descricao + '</option>';
                });
            }
        }
        
        // Preencher campos básicos
        document.getElementById('order-form-id').value = order?.id || '';
        document.getElementById('order-form-number').value = order?.order_number || '';
        document.getElementById('order-form-part-code').value = order?.part_code || '';
        document.getElementById('order-form-product').value = order?.product || '';
        document.getElementById('order-form-lot-size').value = order?.lot_size || '';
        document.getElementById('order-form-batch').value = order?.batch_number || '';
        document.getElementById('order-form-packaging').value = order?.packaging_qty || '';
        document.getElementById('order-form-customer').value = order?.customer || '';
        if (machineSelect) machineSelect.value = order?.machine_id || '';
        if (mpSelect) mpSelect.value = order?.mp || order?.raw_material || '';
        
        // Preencher campos do produto
        const cavitiesField = document.getElementById('order-form-cavities');
        const cycleField = document.getElementById('order-form-cycle');
        const weightField = document.getElementById('order-form-weight');
        const goalField = document.getElementById('order-form-goal');
        
        if (cavitiesField) cavitiesField.value = order?.cavities || '';
        if (cycleField) cycleField.value = order?.cycle || '';
        if (weightField) weightField.value = order?.weight || '';
        if (goalField) goalField.value = order?.pieces_per_hour_goal || '';
        
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    };
    
    window.closeOrderFormModal = function() {
        const modal = document.getElementById('order-form-modal');
        if (modal) modal.classList.add('hidden');
    };
    
    window.refreshOrdersList = function() {
        loadProductionOrders();
    };
    
    // Auto-completar dados do produto ao inserir código da peça
    window.onPartCodeChange = function(code) {
        if (!code || code.trim() === '') return;
        
        const partCode = code.trim();
        console.log('📍 Buscando produto pelo código:', partCode);
        
        // Buscar no productDatabase pelo código
        if (typeof productDatabase !== 'undefined' && productDatabase.length > 0) {
            // Tentar encontrar pelo cod (número)
            let product = productDatabase.find(p => String(p.cod) === partCode);
            
            // Se não encontrou, tentar pelo nome parcial
            if (!product) {
                product = productDatabase.find(p => 
                    p.name && p.name.toLowerCase().includes(partCode.toLowerCase())
                );
            }
            
            if (product) {
                console.log('✅ Produto encontrado:', product);
                
                // Preencher TODOS os campos automaticamente
                const productField = document.getElementById('order-form-product');
                const customerField = document.getElementById('order-form-customer');
                const cavitiesField = document.getElementById('order-form-cavities');
                const cycleField = document.getElementById('order-form-cycle');
                const weightField = document.getElementById('order-form-weight');
                const goalField = document.getElementById('order-form-goal');
                
                // Preencher nome do produto
                if (productField) {
                    productField.value = product.name || '';
                    productField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher cliente
                if (customerField) {
                    customerField.value = product.client || '';
                    customerField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher cavidades
                if (cavitiesField) {
                    cavitiesField.value = product.cavities || '';
                    cavitiesField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher ciclo
                if (cycleField) {
                    cycleField.value = product.cycle || '';
                    cycleField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher peso
                if (weightField) {
                    weightField.value = product.weight || '';
                    weightField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher meta peças/hora
                if (goalField) {
                    goalField.value = product.pieces_per_hour_goal || '';
                    goalField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher MP automaticamente se existir no produto
                const mpSelect = document.getElementById('order-form-mp');
                const mpInfoDiv = document.getElementById('order-form-mp-info');
                const mpDisplay = document.getElementById('order-form-mp-display');
                
                if (mpSelect && product.mp) {
                    mpSelect.value = product.mp;
                    mpSelect.classList.add('bg-green-50', 'border-green-300');
                    
                    // Mostrar info da MP
                    if (mpInfoDiv && mpDisplay && typeof materiaPrimaDatabase !== 'undefined') {
                        const mpInfo = materiaPrimaDatabase.find(m => m.codigo === product.mp);
                        if (mpInfo) {
                            mpDisplay.textContent = `${mpInfo.codigo} - ${mpInfo.descricao}`;
                            mpInfoDiv.classList.remove('hidden');
                        }
                    }
                }
                
                showNotification(`✅ Produto encontrado: ${product.name} (${product.client})`, 'success');
            } else {
                console.log('❌ Produto não encontrado para o código:', partCode);
                showNotification(`❌ Produto não encontrado para o código: ${partCode}`, 'warning');
                
                // Limpar campos
                const fields = ['order-form-product', 'order-form-customer', 'order-form-cavities', 'order-form-cycle', 'order-form-weight', 'order-form-goal', 'order-form-mp'];
                fields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        field.value = '';
                        field.classList.remove('bg-green-50', 'border-green-300');
                    }
                });
                
                // Esconder info da MP
                const mpInfoDiv = document.getElementById('order-form-mp-info');
                if (mpInfoDiv) {
                    mpInfoDiv.classList.add('hidden');
                }
            }
        } else {
            console.log('❌ productDatabase não disponível');
            showNotification('❌ Database de produtos não carregado', 'error');
        }
    };
    
    // Listener para o campo de código da peça
    document.addEventListener('DOMContentLoaded', function() {
        const partCodeInput = document.getElementById('order-form-part-code');
        if (partCodeInput) {
            // Ao perder o foco ou pressionar Enter
            partCodeInput.addEventListener('blur', function() {
                onPartCodeChange(this.value);
            });
            partCodeInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    onPartCodeChange(this.value);
                }
            });
        }
        
        // Listener para o select de MP
        const mpSelect = document.getElementById('order-form-mp');
        if (mpSelect) {
            mpSelect.addEventListener('change', function() {
                const mpInfoDiv = document.getElementById('order-form-mp-info');
                const mpDisplay = document.getElementById('order-form-mp-display');
                
                if (this.value && typeof materiaPrimaDatabase !== 'undefined') {
                    const mpInfo = materiaPrimaDatabase.find(m => m.codigo === this.value);
                    if (mpInfo && mpInfoDiv && mpDisplay) {
                        mpDisplay.textContent = `${mpInfo.codigo} - ${mpInfo.descricao}`;
                        mpInfoDiv.classList.remove('hidden');
                    }
                } else if (mpInfoDiv) {
                    mpInfoDiv.classList.add('hidden');
                }
            });
        }
    });
    
    // Form submit para nova ordem
    document.addEventListener('DOMContentLoaded', function() {
        const form = document.getElementById('order-form-modal-form');
        if (form) {
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const id = document.getElementById('order-form-id')?.value;
                const orderData = {
                    order_number: document.getElementById('order-form-number')?.value.trim() || '',
                    part_code: document.getElementById('order-form-part-code')?.value.trim() || '',
                    product: document.getElementById('order-form-product')?.value.trim() || '',
                    lot_size: Number(document.getElementById('order-form-lot-size')?.value) || 0,
                    batch_number: document.getElementById('order-form-batch')?.value.trim() || '',
                    packaging_qty: Number(document.getElementById('order-form-packaging')?.value) || 0,
                    customer: document.getElementById('order-form-customer')?.value.trim() || '',
                    machine_id: document.getElementById('order-form-machine')?.value || '',
                    raw_material: document.getElementById('order-form-mp')?.value || ''
                };
                
                if (!orderData.order_number || !orderData.lot_size) {
                    showNotification('Preencha os campos obrigatórios', 'warning');
                    return;
                }
                
                try {
                    if (id) {
                        await db.collection('production_orders').doc(id).update(orderData);
                        showNotification('Ordem atualizada!', 'success');
                        
                        // Registrar log de edição
                        registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                            orderId: id,
                            orderNumber: orderData.order_number,
                            product: orderData.product,
                            lotSize: orderData.lot_size
                        });
                    } else {
                        orderData.status = 'planejada';
                        orderData.total_produced = 0;
                        orderData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                        const docRef = await db.collection('production_orders').add(orderData);
                        showNotification('Ordem cadastrada!', 'success');
                        
                        // Registrar log de criação
                        registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                            orderId: docRef.id,
                            orderNumber: orderData.order_number,
                            product: orderData.product,
                            lotSize: orderData.lot_size
                        });
                    }
                    closeOrderFormModal();
                    loadProductionOrders();
                } catch (error) {
                    showNotification('Erro ao salvar', 'error');
                }
            });
        }
    });

    // --- NAVEGAÇÃO ---
    function handleNavClick(e) {
        const page = e.currentTarget.dataset.page;
        
        // Se for um link externo (sem data-page), não interceptar
        if (!page) {
            // Permitir comportamento padrão do link
            return;
        }
        
        e.preventDefault();
        
        // Verificar se o usuário tem permissão para acessar esta aba
        if (!window.authSystem.canAccessTab(page)) {
            window.authSystem.showPermissionError();
            return;
        }
        
        navButtons.forEach(btn => btn.classList.remove('active'));
        e.currentTarget.classList.add('active');
        
        pageContents.forEach(content => {
            content.classList.toggle('hidden', content.id !== `${page}-page`);
        });
        
        if (pageTitle) {
            pageTitle.textContent = e.currentTarget.querySelector('span').textContent;
        }
        
        detachActiveListener();

        if (page === 'lancamento') loadLaunchPanel();
        if (page === 'planejamento') listenToPlanningChanges(getProductionDateString());
        if (page === 'ordens') {
            // Carregar ordens de produção
            console.log('[Nav] Abrindo aba Ordens...');
            loadProductionOrders();
        }
        if (page === 'analise') {
            console.log('📊 Abrindo aba de análise');
            
            // Garantir que o listener de ordens de produção está ativo
            setupProductionOrdersTab();
            listenToProductionOrders();
            
            // Executar diagnóstico (apenas em desenvolvimento)
            diagnosticFirestoreData();
            
            // Garantir que os filtros estão configurados
            if (!currentAnalysisFilters.startDate || !currentAnalysisFilters.endDate) {
                setAnalysisDefaultDates();
            }
            // Carregar dados da view ativa
            const activeView = document.querySelector('.analysis-tab-btn.active')?.getAttribute('data-view') || 'overview';
            console.log('📊 View ativa:', activeView);
            loadAnalysisData(activeView);
        }

        if (page === 'qualidade') {
            if (!qualityTabInitialized) {
                setupQualityTab();
            }

            if (qualityResponsavelInput && !qualityResponsavelInput.value) {
                qualityResponsavelInput.value = getCurrentUserName();
            }

            if (qualityPlanSelect && qualityPlanSelect.value && !currentQualityContext) {
                loadQualityContext();
            } else if (!qualityPlanSelect?.value) {
                setQualityStatus('Selecione a data e o plano desejado para carregar o contexto.', 'info');
            }
        }

        if (page === 'teste') {
            setupTestPage();
        }

        if (page === 'teste-piloto') {
            setupPilotTab();
        }

        if (page === 'paradas-longas') {
            setupExtendedDowntimeTab();
            loadExtendedDowntimeList();
        }

        if (page === 'acompanhamento') {
            setupAcompanhamentoTurno();
            setupAcompanhamentoPerdas();
            setupAcompanhamentoParadas();
        }

        if (page === 'historico-sistema') {
            setupHistoricoSistema();
        }

        if (page === 'admin-dados') {
            setupAdminDadosPage();
        }

        if (page === 'lideranca-producao') {
            setupLiderancaProducaoPage();
        }

        if (page === 'setup-maquinas') {
            setupSetupMaquinasPage();
        }

        if (page === 'ferramentaria') {
            setupFerramentariaPage();
        }

        if (page === 'pcp') {
            setupPCPPage();
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (page === 'pmp') {
            // Inicializar aba PMP - Gestão de Materiais
            if (typeof initPMPPage === 'function') {
                initPMPPage();
            }
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (page === 'qualidade') {
            // Página em construção - apenas renderizar ícones
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (page === 'processo') {
            // Página em construção - apenas renderizar ícones
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (page === 'ajustes') {
            setupAjustesPage();
        }

        if (page === 'relatorios') {
            // O módulo de relatórios já está inicializado pelo DOMContentLoaded
            // Apenas garantir que os ícones lucide estão renderizados
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (window.innerWidth < 768) {
            closeSidebar();
        }
    }

    // --- ABA DE TESTES ---
    function setupTestPage() {
        updateTestPageInfo();
        setupTestConsole();
        setupTestTools();
    }

    function updateTestPageInfo() {
        const now = new Date();
        const timeStr = now.toLocaleString('pt-BR');
        const userName = getCurrentUserName();
        const shift = getCurrentShift();
        
        const versionEl = document.getElementById('test-system-version');
        const datetimeEl = document.getElementById('test-current-datetime');
        const userEl = document.getElementById('test-current-user');
        const shiftEl = document.getElementById('test-current-shift');
        
        if (versionEl) versionEl.textContent = 'v8.0 - Modo Teste';
        if (datetimeEl) datetimeEl.textContent = timeStr;
        if (userEl) userEl.textContent = userName;
        if (shiftEl) shiftEl.textContent = `${shift}º Turno`;
    }

    function setupTestConsole() {
        const runBtn = document.getElementById('test-console-run');
        const input = document.getElementById('test-console-input');
        const output = document.getElementById('test-console-output');
        
        if (!runBtn) return;
        
        runBtn.addEventListener('click', () => {
            const code = input?.value || '';
            if (!code.trim()) {
                addTestLog('❌ Código vazio!', 'error');
                return;
            }
            
            try {
                addTestLog(`▶ Executando: ${code.substring(0, 50)}...`, 'info');
                const result = eval(code);
                addTestLog(`✔ Resultado: ${JSON.stringify(result)}`, 'success');
            } catch (error) {
                addTestLog(`✖ Erro: ${error.message}`, 'error');
            }
        });
    }

    function setupTestTools() {
        const clearCacheBtn = document.getElementById('test-clear-cache');
        const reloadBtn = document.getElementById('test-reload-page');
        const devToolsBtn = document.getElementById('test-open-devtools');
        
        if (clearCacheBtn) {
            clearCacheBtn.addEventListener('click', () => {
                localStorage.clear();
                sessionStorage.clear();
                addTestLog('✔ Cache limpo!', 'success');
            });
        }
        
        if (reloadBtn) {
            reloadBtn.addEventListener('click', () => {
                addTestLog('↻ Recarregando página...', 'info');
                setTimeout(() => location.reload(), 500);
            });
        }
        
        if (devToolsBtn) {
            devToolsBtn.addEventListener('click', () => {
                addTestLog('📋 DevTools devem abrir automaticamente (F12)', 'info');
                console.log('🔧 [DEVTOOLS] Aberto manualmente pelo usuário');
            });
        }
    }

    function addTestLog(message, type = 'info') {
        const container = document.getElementById('test-logs-container');
        if (!container) return;
        
        const icons = { success: '✔', error: '✖', info: 'ℹ', warning: '⚠ ' };
        const colors = { success: 'text-green-400', error: 'text-red-400', info: 'text-blue-400', warning: 'text-yellow-400' };
        
        const line = document.createElement('p');
        line.className = colors[type] || colors.info;
        line.textContent = `${icons[type] || '–'} ${message}`;
        
        container.appendChild(line);
        container.scrollTop = container.scrollHeight;
        
        // Manter apenas as últimas 100 linhas
        while (container.children.length > 100) {
            container.removeChild(container.firstChild);
        }
    }

    // --- ABA TESTE PILOTO ---
    function setupPilotTab() {
        updatePilotUserDisplay();
        setPilotReportStatus('', 'info');

        if (!pilotTabInitialized) {
            const today = getProductionDateString();
            if (pilotReportDateInput && !pilotReportDateInput.value) {
                pilotReportDateInput.value = today;
            }
            if (pilotFilterDateInput && !pilotFilterDateInput.value) {
                pilotFilterDateInput.value = today;
            }
            pilotTabInitialized = true;
        }

        refreshPilotReports();
    }

    function updatePilotUserDisplay() {
        if (!pilotReportUserDisplay) return;
        const userName = getCurrentUserName();
        pilotReportUserDisplay.textContent = userName || 'Desconhecido';
    }

    async function handlePilotReportSubmit(event) {
        event.preventDefault();

        if (isSubmittingPilotReport) {
            return;
        }

        const title = pilotReportTitleInput?.value?.trim() || '';
        const description = pilotReportDescriptionInput?.value?.trim() || '';
        let workDay = pilotReportDateInput?.value;

        if (!title || !description) {
            setPilotReportStatus('Informe o problema identificado e a descrição antes de registrar.', 'error');
            return;
        }

        if (!workDay) {
            workDay = getProductionDateString();
            if (pilotReportDateInput) {
                pilotReportDateInput.value = workDay;
            }
        }

        const reporterName = getCurrentUserName() || 'Desconhecido';
        const activeUser = getActiveUser();
        const reporterIdentifier = activeUser?.username || activeUser?.email || activeUser?.id || null;
        const payload = {
            title,
            description,
            workDay,
            reporterName,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            createdAtLocal: new Date().toISOString(),
            status: 'aberto'
        };

        const currentShift = typeof getCurrentShift === 'function' ? getCurrentShift() : null;
        if (currentShift) {
            payload.shift = currentShift;
        }
        if (reporterIdentifier) {
            payload.reporterIdentifier = reporterIdentifier;
        }

        try {
            isSubmittingPilotReport = true;
            if (pilotReportSubmitBtn) {
                pilotReportSubmitBtn.disabled = true;
                pilotReportSubmitBtn.classList.add('opacity-60', 'cursor-not-allowed');
            }
            setPilotReportStatus('Registrando problema...', 'info');

            await db.collection('pilot_test_reports').add(payload);

            setPilotReportStatus('Problema registrado com sucesso!', 'success');
            if (pilotReportTitleInput) pilotReportTitleInput.value = '';
            if (pilotReportDescriptionInput) pilotReportDescriptionInput.value = '';
            updatePilotUserDisplay();

            if (pilotFilterDateInput && pilotFilterDateInput.value !== workDay) {
                pilotFilterDateInput.value = workDay;
                refreshPilotReports();
            }

            setTimeout(() => setPilotReportStatus('', 'info'), 4000);
        } catch (error) {
            console.error('❌ Erro ao registrar problema do Teste Piloto:', error);
            setPilotReportStatus('Erro ao registrar problema. Tente novamente.', 'error');
        } finally {
            isSubmittingPilotReport = false;
            if (pilotReportSubmitBtn) {
                pilotReportSubmitBtn.disabled = false;
                pilotReportSubmitBtn.classList.remove('opacity-60', 'cursor-not-allowed');
            }
        }
    }

    function refreshPilotReports(fromManualTrigger = false) {
        if (!db) return;

        const selectedDate = pilotFilterDateInput?.value || getProductionDateString();
        if (pilotFilterDateInput && !pilotFilterDateInput.value) {
            pilotFilterDateInput.value = selectedDate;
        }

        // Limpar listener anterior se existir
        listenerManager.unsubscribe('pilotReports');

        setPilotReportStatus(fromManualTrigger ? 'Atualizando registros...' : '', 'info');
        setPilotLoadingState(true);
        if (pilotReportEmpty) {
            pilotReportEmpty.textContent = 'Nenhum registro encontrado para a data selecionada.';
            pilotReportEmpty.classList.add('hidden');
        }
        if (pilotReportList) {
            pilotReportList.innerHTML = '';
        }

        try {
            const query = db.collection('pilot_test_reports').where('workDay', '==', selectedDate);
            listenerManager.subscribe('pilotReports', query,
                (snapshot) => {
                    setPilotLoadingState(false);

                    if (fromManualTrigger && !snapshot.metadata.hasPendingWrites) {
                        setPilotReportStatus('Registros atualizados.', 'success');
                        setTimeout(() => setPilotReportStatus('', 'info'), 2500);
                    } else if (!fromManualTrigger) {
                        setPilotReportStatus('', 'info');
                    }

                    const orderedDocs = [...snapshot.docs].sort((a, b) => {
                        const aData = a.data();
                        const bData = b.data();
                        const aMs = getPilotReportTimestamp(aData, a);
                        const bMs = getPilotReportTimestamp(bData, b);
                        return bMs - aMs;
                    });

                    renderPilotReports(orderedDocs);
                },
                (error) => {
                    console.error('❌ Erro ao escutar registros do Teste Piloto:', error);
                    setPilotLoadingState(false);
                    setPilotReportStatus('Erro ao carregar registros. Tente novamente mais tarde.', 'error');
                    if (pilotReportEmpty) {
                        pilotReportEmpty.textContent = 'Erro ao carregar registros para esta data.';
                        pilotReportEmpty.classList.remove('hidden');
                    }
                    if (pilotReportList) {
                        pilotReportList.innerHTML = '';
                    }
                }
            );
        } catch (error) {
            console.error('❌ Erro ao configurar listener do Teste Piloto:', error);
            setPilotLoadingState(false);
            setPilotReportStatus('Erro ao carregar registros. Tente novamente mais tarde.', 'error');
        }
    }

    function renderPilotReports(docSnapshots) {
        if (!pilotReportList) return;

        pilotReportList.innerHTML = '';
        if (pilotReportEmpty) {
            pilotReportEmpty.textContent = 'Nenhum registro encontrado para a data selecionada.';
        }

        if (!docSnapshots || docSnapshots.length === 0) {
            if (pilotReportEmpty) {
                pilotReportEmpty.classList.remove('hidden');
            }
            return;
        }

        if (pilotReportEmpty) {
            pilotReportEmpty.classList.add('hidden');
        }

        docSnapshots.forEach((docSnap) => {
            const data = docSnap.data() || {};
            const card = document.createElement('div');
            card.className = 'p-5 rounded-lg border border-gray-200 shadow-sm hover:border-teal-300 transition';

            const header = document.createElement('div');
            header.className = 'flex flex-col md:flex-row md:items-start md:justify-between gap-3';

            const titleEl = document.createElement('h4');
            titleEl.className = 'text-lg font-semibold text-gray-900 flex items-center gap-2';
            const titleIcon = document.createElement('i');
            titleIcon.setAttribute('data-lucide', 'alert-circle');
            titleIcon.className = 'text-teal-500';
            const titleText = document.createElement('span');
            titleText.textContent = data.title || 'Problema sem título';
            titleEl.appendChild(titleIcon);
            titleEl.appendChild(titleText);

            const meta = document.createElement('div');
            meta.className = 'text-sm text-gray-500 flex flex-col items-start';
            const reporterLine = document.createElement('span');
            reporterLine.textContent = `Registrado por ${data.reporterName || 'Desconhecido'}`;
            meta.appendChild(reporterLine);
            if (data.reporterIdentifier) {
                const identifierLine = document.createElement('span');
                identifierLine.className = 'text-xs text-gray-400';
                identifierLine.textContent = data.reporterIdentifier;
                meta.appendChild(identifierLine);
            }
            const createdAtLine = document.createElement('span');
            createdAtLine.textContent = formatPilotReportDate(data.createdAt, data.createdAtLocal, docSnap);
            meta.appendChild(createdAtLine);

            header.appendChild(titleEl);
            header.appendChild(meta);

            const descriptionEl = document.createElement('p');
            descriptionEl.className = 'mt-4 text-sm text-gray-700 whitespace-pre-line';
            descriptionEl.textContent = data.description || '-';

            const footer = document.createElement('div');
            footer.className = 'mt-4 flex flex-wrap items-center gap-3 text-xs text-gray-500';
            const badge = document.createElement('span');
            badge.className = 'inline-flex items-center gap-1 px-3 py-1 bg-teal-50 text-teal-700 rounded-full font-semibold';
            const badgeIcon = document.createElement('i');
            badgeIcon.setAttribute('data-lucide', 'calendar');
            const badgeText = document.createElement('span');
            badgeText.textContent = data.workDay ? `Dia ${data.workDay}` : 'Dia não informado';
            badge.appendChild(badgeIcon);
            badge.appendChild(badgeText);
            footer.appendChild(badge);

            if (data.shift) {
                const shiftBadge = document.createElement('span');
                shiftBadge.className = 'inline-flex items-center gap-1 px-3 py-1 bg-gray-100 text-gray-600 rounded-full font-semibold';
                const shiftIcon = document.createElement('i');
                shiftIcon.setAttribute('data-lucide', 'clock');
                const shiftText = document.createElement('span');
                shiftText.textContent = `Turno ${data.shift}`;
                shiftBadge.appendChild(shiftIcon);
                shiftBadge.appendChild(shiftText);
                footer.appendChild(shiftBadge);
            }

            card.appendChild(header);
            card.appendChild(descriptionEl);
            card.appendChild(footer);

            pilotReportList.appendChild(card);
        });

        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    function setPilotLoadingState(isLoading) {
        if (pilotReportLoading) {
            pilotReportLoading.classList.toggle('hidden', !isLoading);
        }
        if (pilotReportList) {
            pilotReportList.classList.toggle('opacity-50', isLoading);
        }
    }

    function setPilotReportStatus(message, variant = 'info') {
        if (!pilotReportStatus) return;
        pilotReportStatus.textContent = message || '';
        pilotReportStatus.className = 'text-sm font-semibold h-5';
        if (!message) {
            return;
        }
        const variantClass = variant === 'success' ? 'text-teal-600'
            : variant === 'error' ? 'text-red-600'
            : 'text-gray-600';
        pilotReportStatus.classList.add(variantClass);
    }

    function getPilotReportTimestamp(data, docSnap) {
        if (data?.createdAt && typeof data.createdAt.toMillis === 'function') {
            return data.createdAt.toMillis();
        }
        if (typeof data?.createdAt === 'number') {
            return data.createdAt;
        }
        if (data?.createdAtLocal) {
            const parsed = Date.parse(data.createdAtLocal);
            if (!Number.isNaN(parsed)) {
                return parsed;
            }
        }
        if (docSnap?.updateTime?.toMillis) {
            return docSnap.updateTime.toMillis();
        }
        if (docSnap?.readTime?.toMillis) {
            return docSnap.readTime.toMillis();
        }
        if (docSnap?.metadata?.hasPendingWrites) {
            return Date.now();
        }
        return 0;
    }

    function formatPilotReportDate(createdAt, createdAtLocal, docSnap) {
        let date = null;
        if (createdAt && typeof createdAt.toDate === 'function') {
            date = createdAt.toDate();
        } else if (createdAt && typeof createdAt.toMillis === 'function') {
            date = new Date(createdAt.toMillis());
        } else if (createdAtLocal) {
            const parsed = new Date(createdAtLocal);
            if (!Number.isNaN(parsed.getTime())) {
                date = parsed;
            }
        } else if (docSnap?.updateTime?.toMillis) {
            date = new Date(docSnap.updateTime.toMillis());
        }

        if (!date || Number.isNaN(date.getTime())) {
            return 'Data não disponível';
        }

        return date.toLocaleString('pt-BR', { dateStyle: 'short', timeStyle: 'short' });
    }

    // --- ABA DE AJUSTES (MESTRE) ---
    function setupAjustesPage() {
        if (!ajustesPage) return;

        if (!ajustesPageInitialized) {
            attachAjustesTableListener();
            resetAjustesResults();
            resetAjustesEditor();
            updateAjustesEditStatus('Selecione um registro para habilitar o formulário.', 'info');
            ajustesPageInitialized = true;
            
            // Carregar lista de máquinas para o datalist
            loadAjustesMachinesList().catch((error) => {
                console.warn('[AJUSTES] Falha ao carregar lista de máquinas:', error);
            });
        }

        if (lastAjustesFilters) {
            performAjustesSearch(lastAjustesFilters, { silent: true }).catch((error) => {
                console.warn('[AJUSTES] Falha ao recarregar resultados anteriores:', error);
            });
        }

        lucide.createIcons();
    }

    function handleAjustesSearch(event) {
        event?.preventDefault();

        if (ajustesSearchInFlight) {
            updateAjustesSearchStatus('Já existe uma busca em andamento. Aguarde finalizar.', 'warning');
            return;
        }

        const filters = buildAjustesFiltersFromForm();
        lastAjustesFilters = filters;

        performAjustesSearch(filters).catch((error) => {
            console.error('[AJUSTES] Erro ao executar busca:', error);
            updateAjustesSearchStatus('Erro ao buscar registros. Verifique os filtros e tente novamente.', 'error');
            renderAjustesPlaceholderRow('Não foi possível carregar os registros. Consulte o console para detalhes.', 'error');
        });
    }

    function handleAjustesRefresh(event) {
        event?.preventDefault();

        if (ajustesSearchInFlight) {
            updateAjustesSearchStatus('Uma busca está em execução. Aguarde antes de recarregar.', 'warning');
            return;
        }

        if (lastAjustesFilters) {
            performAjustesSearch(lastAjustesFilters, { fromRefresh: true }).catch((error) => {
                console.error('[AJUSTES] Erro ao atualizar resultados:', error);
                updateAjustesSearchStatus('Erro ao atualizar a lista. Tente novamente.', 'error');
            });
        } else {
            resetAjustesResults();
            resetAjustesEditor();
            updateAjustesSearchStatus('Lista reiniciada. Informe os filtros desejados e clique em Buscar.', 'info');
            updateAjustesEditStatus('Selecione um registro para habilitar o formulário.', 'info');
        }
    }

    async function handleAjustesEditSubmit(event) {
        event?.preventDefault();

        if (ajustesEditForm?.dataset.busy === 'true') {
            updateAjustesEditStatus('Um ajuste já está em andamento. Aguarde.', 'warning');
            return;
        }

        const docId = ajustesEditId?.value?.trim();
        const collectionKey = ajustesEditCollection?.value?.trim();
        if (!docId || !collectionKey) {
            updateAjustesEditStatus('Selecione um registro válido antes de salvar.', 'warning');
            return;
        }

        const config = AJUSTES_COLLECTIONS[collectionKey];
        if (!config) {
            updateAjustesEditStatus('Coleção não suportada para ajustes.', 'error');
            return;
        }

        if (!config.supportsEditing) {
            updateAjustesEditStatus('Este registro é somente leitura nesta ferramenta.', 'warning');
            return;
        }

        const observation = (ajustesEditNotes?.value || '').trim();
        if (!observation) {
            updateAjustesEditStatus('Informe o motivo do ajuste nas observações.', 'warning');
            ajustesEditNotes?.focus();
            return;
        }

        let originalSnapshot = {};
        try {
            originalSnapshot = JSON.parse(ajustesEditOriginal?.value || '{}');
        } catch (error) {
            console.warn('[AJUSTES] Snapshot original inválido:', error);
        }

        const payload = extractAjustesPayloadFromForm(config);
    const diff = computeAjustesDiff(originalSnapshot, payload);
        if (!diff || diff.changedFields.length === 0) {
            updateAjustesEditStatus('Nenhum campo alterado. Ajuste não aplicado.', 'warning');
            return;
        }

        try {
            ajustesEditForm.dataset.busy = 'true';
            setAjustesFormDisabled(true);
            updateAjustesEditStatus('Aplicando ajuste...', 'info');

            const result = await applyAjusteTransaction(config, docId, payload, diff, observation);
            let auditError = null;
            try {
                await registerAjusteLog(config, docId, diff, observation, result.beforeState, result.afterState);
            } catch (logError) {
                auditError = logError;
                console.error('[AJUSTES] Erro ao registrar log de auditoria:', logError);
            }

            if (auditError) {
                updateAjustesEditStatus('Ajuste aplicado, porém falhou ao registrar a auditoria. Verifique os logs.', 'warning');
            } else {
                updateAjustesEditStatus('Ajuste aplicado com sucesso!', 'success');
            }

            if (lastAjustesFilters) {
                await performAjustesSearch(lastAjustesFilters, { silent: true, preserveDocId: docId });
            }

            const updatedRecord = currentAjustesResults.find(
                (item) => item.id === docId && item.collectionKey === collectionKey
            );
            if (updatedRecord) {
                loadAjustesRecordForEditing(updatedRecord);
            }
        } catch (error) {
            console.error('[AJUSTES] Erro ao aplicar ajuste:', error);
            updateAjustesEditStatus(getFriendlyErrorMessage(error), 'error');
        } finally {
            ajustesEditForm.dataset.busy = 'false';
            setAjustesFormDisabled(false);
        }
    }

    function resetAjustesResults() {
        currentAjustesResults = [];
        renderAjustesPlaceholderRow('Nenhum registro carregado. Use os filtros acima para iniciar uma busca.', 'info');
        updateAjustesSearchStatus('Informe os filtros desejados e clique em Buscar.', 'info');
    }

    function resetAjustesEditor() {
        if (ajustesEditForm) ajustesEditForm.reset();
        if (ajustesEditForm) ajustesEditForm.dataset.busy = 'false';
        if (ajustesEditId) ajustesEditId.value = '';
        if (ajustesEditCollection) ajustesEditCollection.value = '';
        if (ajustesEditOriginal) ajustesEditOriginal.value = '';
        if (ajustesEditMachine) ajustesEditMachine.value = '--';
        if (ajustesEditDate) ajustesEditDate.value = '--';
        if (ajustesEditExecuted) ajustesEditExecuted.value = '';
        if (ajustesEditPlanned) ajustesEditPlanned.value = '';
        if (ajustesEditLossesKg) ajustesEditLossesKg.value = '';
        if (ajustesEditLossesPcs) ajustesEditLossesPcs.value = '';
        if (ajustesEditNotes) ajustesEditNotes.value = '';
        renderAjustesLogPlaceholder('Nenhum ajuste registrado ainda.');
        toggleAjustesInputsByConfig(null);
        highlightSelectedAjustesRow(-1);
    }

    function renderAjustesPlaceholderRow(message, tone = 'info') {
        if (!ajustesResultsBody) return;

        ajustesResultsBody.innerHTML = '';
    const row = document.createElement('tr');
    row.className = 'bg-white';
        const cell = document.createElement('td');
        cell.colSpan = 9;
        cell.className = `px-4 py-6 text-center text-sm ${resolveToneClass(tone)}`;
        cell.textContent = message;
        row.appendChild(cell);
        ajustesResultsBody.appendChild(row);
    }

    function updateAjustesSearchStatus(message, tone = 'info') {
        if (!ajustesSearchStatus) return;
        ajustesSearchStatus.className = `text-sm font-medium ${resolveToneClass(tone, 'text-gray-600')}`;
        ajustesSearchStatus.textContent = message;
    }

    function updateAjustesEditStatus(message, tone = 'info') {
        if (!ajustesEditStatus) return;
        ajustesEditStatus.className = `text-sm font-medium ${resolveToneClass(tone, 'text-gray-600')}`;
        ajustesEditStatus.textContent = message;
    }

    function resolveToneClass(tone, fallback = 'text-gray-500') {
        const toneMap = {
            info: 'text-gray-500',
            warning: 'text-amber-600',
            success: 'text-emerald-600',
            error: 'text-red-600'
        };
        return toneMap[tone] || fallback;
    }

    function buildAjustesFiltersFromForm() {
        const collectionKey = ajustesCollectionSelect?.value || 'production_entries';
        const docId = ajustesDocIdInput?.value?.trim() || '';
        const machineRaw = ajustesMachineInput?.value?.trim() || '';
        const machine = machineRaw ? normalizeMachineId(machineRaw) : '';
        const workday = ajustesWorkdayInput?.value || '';

        return {
            collectionKey,
            docId,
            machine,
            workday
        };
    }

    async function performAjustesSearch(filters, options = {}) {
        const { silent = false, fromRefresh = false, preserveDocId = null } = options;
        const config = AJUSTES_COLLECTIONS[filters.collectionKey] || AJUSTES_COLLECTIONS.production_entries;

        if (!silent) {
            updateAjustesSearchStatus('Buscando registros...', 'info');
            renderAjustesPlaceholderRow('Consultando dados. Aguarde...', 'info');
        }

        ajustesSearchInFlight = true;

        try {
            const records = await fetchAjustesRecords(filters, config);
            currentAjustesResults = records;

            if (!records.length) {
                renderAjustesPlaceholderRow('Nenhum registro encontrado com os filtros informados.', 'warning');
                updateAjustesSearchStatus('Nenhum registro encontrado.', 'warning');
                resetAjustesEditor();
                return;
            }

            renderAjustesResults(records, preserveDocId);
            updateAjustesSearchStatus(`${records.length} registro(s) carregado(s) da coleção ${config.label || config.collection}.`, 'success');

            if (fromRefresh) {
                updateAjustesEditStatus('Registros atualizados. Se necessário, selecione novamente para revisar os campos.', 'info');
            }
        } finally {
            ajustesSearchInFlight = false;
        }
    }

    async function fetchAjustesRecords(filters, config) {
        const { docId, machine, workday } = filters;

        if (docId) {
            const docRef = db.collection(config.collection).doc(docId);
            const snapshot = await docRef.get();
            if (!snapshot.exists) {
                throw new Error('Documento não encontrado.');
            }
            const record = buildAjustesResult(snapshot, config, filters.collectionKey);
            if (config.filter && !config.filter(record.data)) {
                return [];
            }
            if (machine && record.machine !== machine) {
                return [];
            }
            if (workday && record.workday !== workday) {
                return [];
            }
            return [record];
        }

        // Estratégia: se houver máquina ou workday, tenta filtrar. Caso contrário, carrega tudo.
        let query = db.collection(config.collection);
        let appliedFilter = false;

        // Tenta filtrar por máquina (com fallback para campos alternativos)
        if (machine && config.machineField) {
            try {
                const altQuery = db.collection(config.collection).where(config.machineField, '==', machine).limit(AJUSTES_DEFAULT_LIMIT);
                const altSnapshot = await altQuery.get();
                if (!altSnapshot.empty) {
                    let altRecords = altSnapshot.docs.map((doc) => buildAjustesResult(doc, config, filters.collectionKey));
                    if (config.filter) {
                        altRecords = altRecords.filter((item) => config.filter(item.data));
                    }
                    if (workday) {
                        altRecords = altRecords.filter((item) => item.workday === workday);
                    }
                    console.log(`[AJUSTES] Encontrados ${altRecords.length} registros para máquina ${machine} via campo ${config.machineField}`);
                    return altRecords;
                }
            } catch (error) {
                console.warn(`[AJUSTES] Falha ao consultar ${config.machineField}:`, error);
            }

            // Tenta campos alternativos de máquina
            if (Array.isArray(config.altMachineFields) && config.altMachineFields.length) {
                for (const altField of config.altMachineFields) {
                    try {
                        const altQuery = db.collection(config.collection).where(altField, '==', machine).limit(AJUSTES_DEFAULT_LIMIT);
                        const altSnapshot = await altQuery.get();
                        if (!altSnapshot.empty) {
                            let altRecords = altSnapshot.docs.map((doc) => buildAjustesResult(doc, config, filters.collectionKey));
                            if (config.filter) {
                                altRecords = altRecords.filter((item) => config.filter(item.data));
                            }
                            if (workday) {
                                altRecords = altRecords.filter((item) => item.workday === workday);
                            }
                            console.log(`[AJUSTES] Encontrados ${altRecords.length} registros para máquina ${machine} via campo alternativo ${altField}`);
                            return altRecords;
                        }
                    } catch (error) {
                        console.warn(`[AJUSTES] Falha ao consultar campo alternativo ${altField}:`, error);
                    }
                }
            }
        }

        // Se houver workday, tenta filtrar por data
        if (workday && Array.isArray(config.dateFields) && config.dateFields.length) {
            try {
                query = query.where(config.dateFields[0], '==', workday);
                appliedFilter = true;
            } catch (error) {
                console.warn('[AJUSTES] Falha ao aplicar filtro de data:', error);
            }
        }

        // Aplica ordenação se disponível
        if (Array.isArray(config.orderCandidates) && config.orderCandidates.length) {
            try {
                query = query.orderBy(config.orderCandidates[0], 'desc');
            } catch (error) {
                console.warn('[AJUSTES] Não foi possível aplicar ordenação:', error);
            }
        }

        query = query.limit(AJUSTES_DEFAULT_LIMIT);

        const snapshot = await query.get();
        let records = snapshot.docs.map((doc) => buildAjustesResult(doc, config, filters.collectionKey));

        if (config.filter) {
            records = records.filter((item) => config.filter(item.data));
        }

        // Filtros adicionais em memória
        if (machine) {
            records = records.filter((item) => item.machine === machine);
        }

        if (workday) {
            records = records.filter((item) => item.workday === workday);
        }

        console.log(`[AJUSTES] Carregados ${records.length} registros após filtros adicionais`);
        return records;
    }

    function buildAjustesResult(docSnapshot, config, collectionKey) {
        const data = docSnapshot.data() || {};
        const machine = resolveMachineFromData(data, config);
        const workday = resolveWorkdayFromData(data, config);
        const turno = resolveShiftLabel(data, config);
        const executed = resolveNumericField(data, config.executedField);
        const planned = resolveNumericField(data, config.plannedField);
        const lossesKg = resolveNumericField(data, config.lossesKgField);
        const lossesPcs = resolveNumericField(data, config.lossesPcsField);
        const description = typeof config.descriptionBuilder === 'function' ? config.descriptionBuilder(data) : '';
        const timestamp = resolveTimestampFromData(data, config);

        return {
            id: docSnapshot.id,
            collection: config.collection,
            collectionKey,
            label: config.label || config.collection,
            data,
            machine,
            workday,
            turno,
            executed,
            planned,
            lossesKg,
            lossesPcs,
            description,
            timestamp
        };
    }

    function renderAjustesResults(records, preserveDocId = null) {
        if (!ajustesResultsBody) return;
        ajustesResultsBody.innerHTML = '';

        records.forEach((record, index) => {
            const qtySegments = [];
            if (record.executed !== null && !Number.isNaN(record.executed)) {
                qtySegments.push(`${formatPieces(record.executed)} pcs`);
            }
            if (record.lossesKg !== null && !Number.isNaN(record.lossesKg)) {
                qtySegments.push(`${formatKg(record.lossesKg)} kg refugo`);
            }
            if (record.lossesPcs !== null && !Number.isNaN(record.lossesPcs)) {
                qtySegments.push(`${formatPieces(record.lossesPcs)} peças refugo`);
            }
            const qtyDisplay = qtySegments.length ? qtySegments.join(' – ') : '-';
            const plannedDisplay = record.planned !== null && !Number.isNaN(record.planned)
                ? `${formatPieces(record.planned)} un`
                : '-';
            const timestampDisplay = record.timestamp ? formatTimestamp(record.timestamp) : '-';

            const row = document.createElement('tr');
            row.className = 'ajustes-result-row hover:bg-amber-50 transition';
            row.dataset.index = index;

            row.innerHTML = `
                <td class="px-3 py-2 text-left font-medium text-gray-700">${escapeHtml(record.label)}</td>
                <td class="px-3 py-2 text-left text-xs break-all text-gray-600">${escapeHtml(record.id)}</td>
                <td class="px-3 py-2 text-left text-gray-700">${escapeHtml(record.machine || '-')}</td>
                <td class="px-3 py-2 text-left text-gray-700">${escapeHtml(record.workday || '-')}<div class="text-xs text-gray-400">${escapeHtml(timestampDisplay)}</div></td>
                <td class="px-3 py-2 text-left text-gray-700">${escapeHtml(record.turno || '-')}</td>
                <td class="px-3 py-2 text-left text-sm text-gray-700">${escapeHtml(record.description || '-')}</td>
                <td class="px-3 py-2 text-right text-gray-700">${qtyDisplay}</td>
                <td class="px-3 py-2 text-right text-gray-700">${plannedDisplay}</td>
                <td class="px-3 py-2 text-left">
                    <button type="button" class="ajustes-select-record inline-flex items-center gap-1 px-3 py-1.5 bg-amber-600 text-white rounded-md text-xs font-semibold hover:bg-amber-700 transition" data-index="${index}">
                        <i data-lucide="edit-3" class="w-3.5 h-3.5"></i>
                        Ajustar
                    </button>
                </td>
            `;

            ajustesResultsBody.appendChild(row);
        });

        lucide.createIcons();

        if (preserveDocId) {
            const selectedIndex = records.findIndex((item) => item.id === preserveDocId);
            if (selectedIndex >= 0) {
                loadAjustesRecordForEditing(records[selectedIndex]);
            }
        }
    }

    function handleAjustesResultClick(event) {
        const trigger = event.target.closest('.ajustes-select-record');
        if (!trigger) return;

        const index = Number(trigger.dataset.index);
        if (!Number.isFinite(index) || index < 0 || index >= currentAjustesResults.length) {
            console.warn('[AJUSTES] Índice inválido selecionado:', index);
            return;
        }

        loadAjustesRecordForEditing(currentAjustesResults[index]);
    }

    function loadAjustesRecordForEditing(record) {
        if (!record) return;
        const config = AJUSTES_COLLECTIONS[record.collectionKey];
        toggleAjustesInputsByConfig(config);

        ajustesEditId.value = record.id;
        ajustesEditCollection.value = record.collectionKey;
        ajustesEditOriginal.value = JSON.stringify(record.data || {});
        ajustesEditMachine.value = record.machine || '--';
        ajustesEditDate.value = record.workday || '-';

        if (config?.editorConfig?.executed && ajustesEditExecuted) {
            ajustesEditExecuted.value = record.executed !== null && !Number.isNaN(record.executed) ? record.executed : '';
        } else if (ajustesEditExecuted) {
            ajustesEditExecuted.value = '';
        }

        if (config?.editorConfig?.planned && ajustesEditPlanned) {
            ajustesEditPlanned.value = record.planned !== null && !Number.isNaN(record.planned) ? record.planned : '';
        } else if (ajustesEditPlanned) {
            ajustesEditPlanned.value = '';
        }

        if (config?.editorConfig?.lossesKg && ajustesEditLossesKg) {
            ajustesEditLossesKg.value = record.lossesKg !== null && !Number.isNaN(record.lossesKg) ? record.lossesKg : '';
        } else if (ajustesEditLossesKg) {
            ajustesEditLossesKg.value = '';
        }

        if (config?.editorConfig?.lossesPcs && ajustesEditLossesPcs) {
            ajustesEditLossesPcs.value = record.lossesPcs !== null && !Number.isNaN(record.lossesPcs) ? record.lossesPcs : '';
        } else if (ajustesEditLossesPcs) {
            ajustesEditLossesPcs.value = '';
        }

        if (ajustesEditNotes) ajustesEditNotes.value = '';

        updateAjustesEditStatus(
            config?.supportsEditing
                ? 'Revise os campos, descreva o motivo e clique em Salvar ajuste.'
                : 'Este registro é apenas para consulta. Ajustes indisponíveis.',
            config?.supportsEditing ? 'info' : 'warning'
        );

        highlightSelectedAjustesRow(record);
        loadAjustesLogsForRecord(record).catch((error) => {
            console.warn('[AJUSTES] Falha ao carregar logs de auditoria:', error);
            renderAjustesLogPlaceholder('Erro ao carregar logs de auditoria. Verifique o console.', 'error');
        });
    }

    function attachAjustesTableListener() {
        if (ajustesResultsBody && !ajustesResultsBody.dataset.listenerAttached) {
            ajustesResultsBody.addEventListener('click', handleAjustesResultClick);
            ajustesResultsBody.dataset.listenerAttached = 'true';
        }
    }

    function toggleAjustesInputsByConfig(config) {
        const controls = [
            { el: ajustesEditExecuted, enabled: Boolean(config?.editorConfig?.executed) },
            { el: ajustesEditPlanned, enabled: Boolean(config?.editorConfig?.planned) },
            { el: ajustesEditLossesKg, enabled: Boolean(config?.editorConfig?.lossesKg) },
            { el: ajustesEditLossesPcs, enabled: Boolean(config?.editorConfig?.lossesPcs) }
        ];

        controls.forEach(({ el, enabled }) => {
            if (!el) return;
            el.dataset.disabledByConfig = enabled ? 'false' : 'true';
            el.disabled = !enabled;
            el.classList.toggle('bg-gray-100', !enabled);
        });

        if (ajustesEditNotes) {
            ajustesEditNotes.disabled = false;
            ajustesEditNotes.classList.remove('bg-gray-100');
        }
    }

    function setAjustesFormDisabled(state) {
        const controls = [
            ajustesEditExecuted,
            ajustesEditPlanned,
            ajustesEditLossesKg,
            ajustesEditLossesPcs,
            ajustesEditNotes
        ];

        controls.forEach((el) => {
            if (!el) return;
            const lockedByConfig = el.dataset.disabledByConfig === 'true';
            el.disabled = state || lockedByConfig;
        });
    }

    function resolveMachineFromData(data, config) {
        if (!data || !config) return null;
        if (config.machineField && data[config.machineField]) {
            return normalizeMachineId(data[config.machineField]);
        }
        if (Array.isArray(config.altMachineFields)) {
            for (const field of config.altMachineFields) {
                if (data[field]) return normalizeMachineId(data[field]);
            }
        }
        if (data.machine) return normalizeMachineId(data.machine);
        if (data.machine_id) return normalizeMachineId(data.machine_id);
        return null;
    }

    function resolveWorkdayFromData(data, config) {
        if (!data) return null;
        const candidates = [...(config?.dateFields || []), 'workDay', 'data', 'date'];
        for (const field of candidates) {
            const value = data[field];
            if (typeof value === 'string' && value.length >= 8) return value;
            if (value instanceof Date && !Number.isNaN(value.getTime())) {
                return formatDateYMD(value);
            }
            if (value && typeof value.toDate === 'function') {
                try {
                    return formatDateYMD(value.toDate());
                } catch (error) {
                    console.warn('[AJUSTES] Falha ao converter campo de data:', field, error);
                }
            }
        }
        return null;
    }

    function resolveShiftLabel(data, config) {
        if (!data) return null;
        const field = config?.turnoField || 'turno';
        const value = data[field];
        if (value === undefined || value === null) return null;
        const numeric = Number(value);
        if (Number.isFinite(numeric) && numeric >= 1 && numeric <= 3) {
            return `${numeric}º Turno`;
        }
        if (typeof value === 'string' && value.trim()) return value.trim();
        return null;
    }

    function resolveNumericField(data, field) {
        if (!data || !field) return null;
        const value = data[field];
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return null;
        return numeric;
    }

    function resolveTimestampFromData(data, config) {
        const candidates = [...(config?.orderCandidates || []), 'timestamp', 'createdAt', 'updatedAt'];
        for (const field of candidates) {
            const value = data[field];
            if (value && typeof value.toDate === 'function') {
                try {
                    return value.toDate();
                } catch (error) {
                    console.warn('[AJUSTES] Não foi possível converter timestamp:', field, error);
                }
            }
        }
        return null;
    }

    function formatPieces(value) {
        return Number(value).toLocaleString('pt-BR');
    }

    function formatKg(value) {
        return Number(value).toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 });
    }

    function formatTimestamp(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '-';
        return date.toLocaleString('pt-BR');
    }

    function highlightSelectedAjustesRow(recordOrIndex) {
        const rows = ajustesResultsBody?.querySelectorAll('tr.ajustes-result-row') || [];
        rows.forEach((row) => row.classList.remove('ring', 'ring-amber-400', 'bg-amber-50/60'));

        let targetIndex = -1;
        if (typeof recordOrIndex === 'number') {
            targetIndex = recordOrIndex;
        } else if (recordOrIndex && typeof recordOrIndex === 'object') {
            targetIndex = currentAjustesResults.findIndex(
                (item) => item.id === recordOrIndex.id && item.collectionKey === recordOrIndex.collectionKey
            );
        }

        if (targetIndex >= 0 && targetIndex < rows.length) {
            const row = rows[targetIndex];
            row.classList.add('ring', 'ring-amber-400', 'bg-amber-50/60');
        }
    }

    function extractAjustesPayloadFromForm(config) {
        const payload = {};

        if (config?.editorConfig?.executed && ajustesEditExecuted) {
            payload[config.executedField || 'produzido'] = parseOptionalNumber(ajustesEditExecuted.value);
        }

        if (config?.editorConfig?.planned && ajustesEditPlanned) {
            payload[config.plannedField || 'planned_quantity'] = parseOptionalNumber(ajustesEditPlanned.value);
        }

        if (config?.editorConfig?.lossesKg && ajustesEditLossesKg) {
            payload[config.lossesKgField || 'refugo_kg'] = parseOptionalFloat(ajustesEditLossesKg.value, 3);
        }

        if (config?.editorConfig?.lossesPcs && ajustesEditLossesPcs) {
            payload[config.lossesPcsField || 'refugo_qty'] = parseOptionalNumber(ajustesEditLossesPcs.value);
        }

        return payload;
    }

    function parseOptionalFloat(value, decimals = 2) {
        if (value === null || value === undefined || value === '') return null;
        const numeric = parseFloat(value);
        if (!Number.isFinite(numeric)) return null;
        return Number(numeric.toFixed(decimals));
    }

    function computeAjustesDiff(originalData, newPayload) {
        const changedFields = [];
        const updates = {};

        Object.entries(newPayload).forEach(([field, value]) => {
            const originalValue = originalData ? originalData[field] : undefined;
            const normalizedOriginal = normalizeValueForComparison(originalValue);
            const normalizedNew = normalizeValueForComparison(value);

            if (normalizedOriginal === normalizedNew) {
                return;
            }

            changedFields.push(field);
            updates[field] = value === null ? firebase.firestore.FieldValue.delete() : value;
        });

        return { changedFields, updates };
    }

    function normalizeValueForComparison(value) {
        if (value === undefined || value === null) return null;
        if (typeof value === 'number') return Number(value.toFixed(6));
        if (typeof value === 'string') return value.trim();
        if (value instanceof Date) return value.getTime();
        if (value && typeof value.toDate === 'function') {
            try {
                return value.toDate().getTime();
            } catch (error) {
                console.warn('[AJUSTES] Falha ao normalizar valor para comparação:', error);
            }
        }
        return value;
    }

    async function applyAjusteTransaction(config, docId, payload, diff, observation) {
        const docRef = db.collection(config.collection).doc(docId);
        const currentUser = getActiveUser();
        const userName = getCurrentUserName();

        return db.runTransaction(async (transaction) => {
            const snapshot = await transaction.get(docRef);
            if (!snapshot.exists) {
                throw new Error('Documento não encontrado durante o ajuste.');
            }

            const beforeState = snapshot.data() || {};
            const afterState = { ...beforeState };

            diff.changedFields.forEach((field) => {
                const newValue = payload[field];
                if (newValue === null || newValue === undefined) {
                    delete afterState[field];
                } else {
                    afterState[field] = newValue;
                }
            });

            const updates = {
                ...diff.updates,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastManualAdjustment: {
                    executedBy: currentUser?.username || currentUser?.email || 'desconhecido',
                    executedByName: userName || 'Desconhecido',
                    executedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    notes: observation,
                    fields: diff.changedFields
                }
            };

            transaction.update(docRef, updates);

            return { beforeState, afterState };
        });
    }

    async function registerAjusteLog(config, docId, diff, observation, beforeState, afterState) {
        if (!diff || diff.changedFields.length === 0) return;

        const currentUser = getActiveUser();
        const userName = getCurrentUserName();

        const logEntry = {
            docPath: `${config.collection}/${docId}`,
            docId,
            collection: config.collection,
            collectionKey: config.key,
            changedFields: diff.changedFields,
            notes: observation,
            executedBy: currentUser?.username || currentUser?.email || 'desconhecido',
            executedByName: userName || 'Desconhecido',
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            beforeSnapshot: beforeState || null,
            afterSnapshot: afterState || null
        };

        const beforeFields = {};
        const afterFields = {};
        diff.changedFields.forEach((field) => {
            beforeFields[field] = sanitizeLogValue(beforeState ? beforeState[field] : null);
            afterFields[field] = sanitizeLogValue(afterState ? afterState[field] : null);
        });
        logEntry.beforeFields = beforeFields;
        logEntry.afterFields = afterFields;

        await db.collection(AJUSTES_LOG_COLLECTION).add(logEntry);
    }

    async function loadAjustesLogsForRecord(record) {
        renderAjustesLogPlaceholder('Carregando auditoria...');
        const docPath = `${record.collection}/${record.id}`;

        try {
            let query = db.collection(AJUSTES_LOG_COLLECTION)
                .where('docPath', '==', docPath)
                .orderBy('timestamp', 'desc')
                .limit(20);

            let snapshot;
            try {
                snapshot = await query.get();
            } catch (error) {
                console.warn('[AJUSTES] Falha ao ordenar logs (possível índice ausente). Tentando fallback.', error);
                query = db.collection(AJUSTES_LOG_COLLECTION)
                    .where('docPath', '==', docPath)
                    .limit(20);
                snapshot = await query.get();
            }

            const logs = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
            if (!logs.length) {
                renderAjustesLogPlaceholder('Nenhum ajuste registrado ainda para este documento.');
                return;
            }

            renderAjustesLogEntries(logs);
        } catch (error) {
            console.error('[AJUSTES] Erro ao carregar logs de auditoria:', error);
            renderAjustesLogPlaceholder('Erro ao carregar logs de auditoria. Verifique o console.', 'error');
        }
    }

    function renderAjustesLogEntries(logs) {
        if (!ajustesLogBody) return;
        ajustesLogBody.innerHTML = '';

        logs.forEach((log) => {
            const timestamp = log.timestamp && typeof log.timestamp.toDate === 'function'
                ? formatTimestamp(log.timestamp.toDate())
                : '-';
            const fields = Array.isArray(log.changedFields) ? log.changedFields.join(', ') : '-';
            const beforeFields = formatLogFields(log.beforeFields);
            const afterFields = formatLogFields(log.afterFields);
            const notes = log.notes ? escapeHtml(log.notes) : '-';

            const row = document.createElement('tr');
            row.className = 'bg-white hover:bg-gray-50';
            row.innerHTML = `
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(timestamp)}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(log.executedByName || log.executedBy || '-')}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(log.collectionKey || '-')}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(log.docId || '-')}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(fields)}</td>
                <td class="px-3 py-2 text-xs text-gray-600">${beforeFields}</td>
                <td class="px-3 py-2 text-xs text-gray-600">${afterFields}</td>
                <td class="px-3 py-2 text-xs text-gray-600">${notes}</td>
            `;
            ajustesLogBody.appendChild(row);
        });
    }

    function formatLogFields(fields) {
        if (!fields || typeof fields !== 'object') return '-';
        return Object.entries(fields)
            .map(([field, value]) => `${field}: ${value === null || value === undefined ? 'ˆ…' : escapeHtml(String(value))}`)
            .join(' – ');
    }

    function renderAjustesLogPlaceholder(message, tone = 'info') {
        if (!ajustesLogBody) return;
        ajustesLogBody.innerHTML = '';
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 8;
        cell.className = `px-4 py-6 text-center text-sm ${resolveToneClass(tone)}`;
        cell.textContent = message;
        row.appendChild(cell);
        ajustesLogBody.appendChild(row);
    }

    function getFriendlyErrorMessage(error) {
        if (!error) return 'Erro desconhecido. Verifique o console.';
        if (typeof error === 'string') return error;
        if (error.code === 'permission-denied') {
            return 'Permissão negada para ajustar este registro.';
        }
        if (error.message) return error.message;
        return 'Erro inesperado. Consulte o console para detalhes.';
    }

    function sanitizeLogValue(value) {
        if (value === undefined || value === null) return null;
        if (typeof value === 'number') return Number(value.toFixed(6));
        if (typeof value === 'string') return value.trim();
        if (value instanceof Date) return value.toISOString();
        if (value && typeof value.toDate === 'function') {
            try {
                return value.toDate().toISOString();
            } catch (error) {
                console.warn('[AJUSTES] Falha ao converter timestamp para log:', error);
                return null;
            }
        }
        if (typeof value === 'object') {
            try {
                return JSON.stringify(value);
            } catch (error) {
                console.warn('[AJUSTES] Falha ao serializar valor para log:', error);
            }
        }
        return value;
    }

    async function loadAjustesMachinesList() {
        const datalist = document.getElementById('ajustes-machines-list');
        if (!datalist) return;

        try {
            const machinesSet = new Set();

            // Buscar máquinas de production_entries
            try {
                const prodSnapshot = await db.collection('production_entries').limit(50).get();
                prodSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    const machine = resolveMachineFromData(data, AJUSTES_COLLECTIONS.production_entries);
                    if (machine) machinesSet.add(machine);
                });
            } catch (error) {
                console.warn('[AJUSTES] Erro ao carregar máquinas de production_entries:', error);
            }

            // Buscar máquinas de planning
            try {
                const planSnapshot = await db.collection('planning').limit(50).get();
                planSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    if (data.machine) machinesSet.add(normalizeMachineId(data.machine));
                });
            } catch (error) {
                console.warn('[AJUSTES] Erro ao carregar máquinas de planning:', error);
            }

            // Buscar máquinas de production_orders
            try {
                const ordersSnapshot = await db.collection('production_orders').limit(50).get();
                ordersSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    const machine = resolveMachineFromData(data, AJUSTES_COLLECTIONS.production_orders);
                    if (machine) machinesSet.add(machine);
                });
            } catch (error) {
                console.warn('[AJUSTES] Erro ao carregar máquinas de production_orders:', error);
            }

            // Popular datalist
            datalist.innerHTML = '';
            Array.from(machinesSet).sort().forEach((machine) => {
                const option = document.createElement('option');
                option.value = machine;
                datalist.appendChild(option);
            });

            console.log(`[AJUSTES] Carregadas ${machinesSet.size} máquinas únicas disponíveis`);
        } catch (error) {
            console.error('[AJUSTES] Erro ao carregar lista de máquinas:', error);
        }
    }

    async function diagnosticAjustesMachines() {
        console.log('[AJUSTES-DIAG] Iniciando diagnóstico de máquinas disponíveis...');

        try {
            console.log('[AJUSTES-DIAG] === PRODUCTION ENTRIES ===');
            const prodSnapshot = await db.collection('production_entries').limit(10).get();
            console.log(`Encontrados ${prodSnapshot.size} documentos. Máquinas (raw):`);
            prodSnapshot.docs.forEach((doc) => {
                const data = doc.data();
                console.log(`  ID: ${doc.id}, machine: ${data.machine}, machine_id: ${data.machine_id}, maquina: ${data.maquina}`);
            });

            console.log('[AJUSTES-DIAG] === PLANNING ===');
            const planSnapshot = await db.collection('planning').limit(10).get();
            console.log(`Encontrados ${planSnapshot.size} documentos. Máquinas (raw):`);
            planSnapshot.docs.forEach((doc) => {
                const data = doc.data();
                console.log(`  ID: ${doc.id}, machine: ${data.machine}`);
            });

            console.log('[AJUSTES-DIAG] === PRODUCTION ORDERS ===');
            const ordersSnapshot = await db.collection('production_orders').limit(10).get();
            console.log(`Encontrados ${ordersSnapshot.size} documentos. Máquinas (raw):`);
            ordersSnapshot.docs.forEach((doc) => {
                const data = doc.data();
                console.log(`  ID: ${doc.id}, machine_id: ${data.machine_id}, machine: ${data.machine}, machineId: ${data.machineId}`);
            });
        } catch (error) {
            console.error('[AJUSTES-DIAG] Erro no diagnóstico:', error);
        }
    }

    // --- ABA DE QUALIDADE ---
    function setupQualityTab() {
        if (qualityTabInitialized) return;
        qualityTabInitialized = true;

        const today = getProductionDateString();
        if (qualityDateInput && !qualityDateInput.value) {
            qualityDateInput.value = today;
        }

        const defaultShift = getCurrentShift();

        if (qualityResponsavelInput) {
            qualityResponsavelInput.value = getCurrentUserName();
        }

        if (qualityLoadBtn) {
            qualityLoadBtn.addEventListener('click', (event) => {
                event.preventDefault();
                loadQualityContext();
            });
        }

        if (qualityDateInput) {
            qualityDateInput.addEventListener('change', () => {
                qualityPlansCache = { lastDate: null, plans: [] };
                clearQualityContext(false);
                populateQualityPlanOptions(qualityDateInput.value);
            });
        }

        if (qualityPlanSelect) {
            qualityPlanSelect.addEventListener('change', () => {
                clearQualityContext(false);
                if (qualityPlanSelect.value) {
                    setQualityStatus('Plano selecionado. Clique em "Atualizar contexto" para carregar os dados.', 'info');
                }
            });
        }

        populateQualityPlanOptions(qualityDateInput?.value || today);
        setQualityStatus('Selecione a data e o plano desejado para carregar o contexto.', 'info');

        // Manipuladores de eventos para observações de produção
        if (qualityProdObsSave) {
            qualityProdObsSave.addEventListener('click', () => {
                saveQualityObservation('production');
            });
        }

        // Manipuladores de eventos para observações de qualidade
        if (qualityQualObsSave) {
            qualityQualObsSave.addEventListener('click', () => {
                saveQualityObservation('quality');
            });
        }

        // Manipuladores de eventos para controle de preenchimento
        if (qualityAutoFillBtn) {
            if (!QUALITY_AUTOFILL_ENABLED) {
                qualityAutoFillBtn.disabled = true;
                qualityAutoFillBtn.classList.add('opacity-60', 'cursor-not-allowed');
                qualityAutoFillBtn.title = 'Integração automática temporariamente desativada';
            }

            qualityAutoFillBtn.addEventListener('click', () => {
                if (!QUALITY_AUTOFILL_ENABLED) {
                    showNotification('Integração automática está desativada. Utilize o preenchimento manual.', 'info');
                    return;
                }
                loadQualityContext();
                showNotification('Preenchimento automático reativado!', 'success');
            });
        }

        if (qualityManualClearBtn) {
            qualityManualClearBtn.addEventListener('click', () => {
                clearQualityInputsForManualEntry();
                showNotification('Modo manual ativado. Campos limpos para preenchimento manual.', 'info');
            });
        }

        if (qualityClearAllBtn) {
            qualityClearAllBtn.addEventListener('click', () => {
                if (confirm('Tem certeza que deseja limpar TODOS os dados das tabelas? Esta ação não pode ser desfeita.')) {
                    clearAllQualityInputs();
                    showNotification('Todos os dados foram limpos!', 'success');
                }
            });
        }

        if (qualityPrintBtn && !qualityPrintBtn.dataset.listenerAttached) {
            qualityPrintBtn.addEventListener('click', handleQualityChecklistPrint);
            qualityPrintBtn.dataset.listenerAttached = 'true';
        }

        // Botões de adicionar linhas nas tabelas de molde (verificar se existem)
        var moldCloseAddRowBtn = document.getElementById('mold-close-add-row-btn');
        var moldOpenAddRowBtn = document.getElementById('mold-open-add-row-btn');
        var moldHistoryAddRowBtn = document.getElementById('mold-history-add-row-btn');

        if (moldCloseAddRowBtn && !moldCloseAddRowBtn.dataset.listenerAttached) {
            moldCloseAddRowBtn.addEventListener('click', (event) => {
                event.preventDefault();
                addMoldClosureRow();
            });
            moldCloseAddRowBtn.dataset.listenerAttached = 'true';
        }

        if (moldOpenAddRowBtn && !moldOpenAddRowBtn.dataset.listenerAttached) {
            moldOpenAddRowBtn.addEventListener('click', (event) => {
                event.preventDefault();
                addMoldOpeningRow();
            });
            moldOpenAddRowBtn.dataset.listenerAttached = 'true';
        }

        if (moldHistoryAddRowBtn && !moldHistoryAddRowBtn.dataset.listenerAttached) {
            moldHistoryAddRowBtn.addEventListener('click', (event) => {
                event.preventDefault();
                addMoldHistoryRow();
            });
            moldHistoryAddRowBtn.dataset.listenerAttached = 'true';
        }

        // Obter tbodys para adicionar listeners de remoção
        var moldCloseTbodyEl = document.getElementById('mold-closure-tbody');
        var moldOpenTbodyEl = document.getElementById('mold-opening-tbody');
        var moldHistoryTbodyEl = document.getElementById('mold-history-tbody');

        [moldCloseTbodyEl, moldOpenTbodyEl, moldHistoryTbodyEl].forEach(tbody => {
            if (tbody && !tbody.dataset.moldListenerAttached) {
                tbody.addEventListener('click', handleMoldRowRemoval);
                tbody.dataset.moldListenerAttached = 'true';
            }
        });

        // Tentar carregar dados de hoje automaticamente
        autoLoadQualityDataForToday(today);
    }

    function saveQualityObservation(type) {
        const timeInput = type === 'production' ? qualityProdObsTime : qualityQualObsTime;
        const textInput = type === 'production' ? qualityProdObsText : qualityQualObsText;
        const listContainer = type === 'production' ? qualityProdObsList : qualityQualObsList;

        const time = timeInput?.value || '';
        const text = textInput?.value || '';

        if (!time || !text) {
            showNotification('Por favor, preencha a hora e a observação.', 'warning');
            return;
        }

        // Criar card de observação
        const obsCard = document.createElement('div');
        obsCard.className = 'bg-gray-50 p-2 rounded border-l-2 ' + (type === 'production' ? 'border-blue-500' : 'border-emerald-500');
        obsCard.innerHTML = `
            <div class="flex justify-between items-start gap-2">
                <div>
                    <p class="text-xs font-semibold text-gray-700">${time}</p>
                    <p class="text-xs text-gray-600 mt-1">${escapeHtml(text)}</p>
                </div>
                <button class="text-xs text-red-500 hover:text-red-700 font-semibold">✕</button>
            </div>
        `;

        listContainer?.appendChild(obsCard);

        // Limpar inputs
        if (timeInput) timeInput.value = '';
        if (textInput) textInput.value = '';

        showNotification('Anotação adicionada com sucesso!', 'success');
    }

    async function autoLoadQualityDataForToday(dateValue) {
        try {
            // Buscar planos ativos para hoje
            const plansSnapshot = await db.collection('planning')
                .where('date', '==', dateValue)
                .where('status', '==', 'active')
                .limit(1)
                .get();

            if (plansSnapshot.empty) {
                console.log('ℹ️ Nenhum plano ativo para hoje');
                return;
            }

            // Pegar o primeiro plano ativo
            const planDoc = plansSnapshot.docs[0];
            const planId = planDoc.id;

            // Definir o plano no select
            if (qualityPlanSelect) {
                qualityPlanSelect.value = planId;
                // Disparar evento de mudança para atualizar a lista
                qualityPlanSelect.dispatchEvent(new Event('change'));
                
                // Aguardar um pouco para os dados carregarem
                setTimeout(() => {
                    setQualityStatus('Carregando dados de hoje automaticamente...', 'info');
                    loadQualityContext();
                }, 500);
            }
        } catch (error) {
            console.error('Erro ao carregar dados automaticamente:', error);
            // Não mostrar erro - deixar o usuário escolher manualmente se falhar
        }
    }


    function setQualityStatus(message, type = 'info') {
        if (!qualityStatusMessage) return;
        const classMap = {
            info: 'text-sm text-gray-600',
            success: 'text-sm font-semibold text-emerald-600',
            warning: 'text-sm font-semibold text-amber-600',
            error: 'text-sm font-semibold text-red-600'
        };
        qualityStatusMessage.textContent = message || '';
        qualityStatusMessage.className = classMap[type] || classMap.info;
    }

    function clearQualityContext(resetStatus = true) {
        currentQualityContext = null;

        if (qualityInfoGrid) qualityInfoGrid.innerHTML = '';
        if (qualitySummaryCards) qualitySummaryCards.innerHTML = '';
        if (qualityOperatorsChip) qualityOperatorsChip.textContent = '';
        if (qualityShiftTbody) qualityShiftTbody.innerHTML = '';
        if (qualityShiftEmpty) qualityShiftEmpty.classList.add('hidden');
        if (qualityHourlyTableBody) qualityHourlyTableBody.innerHTML = '';
        if (qualityHourlyEmpty) qualityHourlyEmpty.classList.add('hidden');
        if (qualityHourlyTotal) qualityHourlyTotal.textContent = '';
        if (qualityDowntimeList) qualityDowntimeList.innerHTML = '';
        if (qualityDowntimeEmpty) qualityDowntimeEmpty.classList.add('hidden');
        if (qualityDowntimeTotal) qualityDowntimeTotal.textContent = '';
        if (qualityChecklistStatus) qualityChecklistStatus.textContent = '';
        if (qualityNotesInput) qualityNotesInput.value = '';
        if (qualityActionsInput) qualityActionsInput.value = '';
        if (qualityHistoryList) qualityHistoryList.innerHTML = '';
        if (qualityHistoryEmpty) qualityHistoryEmpty.classList.add('hidden');
        if (qualityHistoryChip) qualityHistoryChip.textContent = '';

        if (qualityContextContainer) {
            qualityContextContainer.classList.remove('opacity-60');
        }

        if (resetStatus) {
            setQualityStatus('Selecione a data e o plano desejado para carregar o contexto.', 'info');
        }
    }

    function clearQualityInputsForManualEntry() {
        // Limpar apenas os inputs de cavidades e inspeção, mantendo o layout visível
        // Isso permite que o usuário preencha manualmente os valores
        
        const cavitiesInputs = document.querySelectorAll('.quality-cavities-input');
        const inspectionInputs = document.querySelectorAll('.quality-inspection-input');
        
        cavitiesInputs.forEach(input => {
            input.value = '';
            input.classList.remove('bg-gray-100', 'text-gray-600');
            input.classList.add('bg-white', 'text-gray-800');
            input.readOnly = false;
        });
        
        inspectionInputs.forEach(input => {
            input.value = '';
            input.classList.remove('bg-gray-100', 'text-gray-600');
            input.classList.add('bg-white', 'text-gray-800');
            input.readOnly = false;
        });

        enableManualPackagingInputs();

        // Limpar observações também
        if (qualityProdObsTime) qualityProdObsTime.value = '';
        if (qualityProdObsText) qualityProdObsText.value = '';
        if (qualityQualObsTime) qualityQualObsTime.value = '';
        if (qualityQualObsText) qualityQualObsText.value = '';
        if (qualityProdObsList) qualityProdObsList.innerHTML = '';
        if (qualityQualObsList) qualityQualObsList.innerHTML = '';
    }

    function clearAllQualityInputs() {
        // Limpar TUDO: cavidades, inspeções, observações
        clearQualityInputsForManualEntry();
        
        // Limpar a barra de controle também (esconder)
        if (qualityControlBar) {
            qualityControlBar.classList.add('hidden');
        }
        
        // Limpar header
        if (qualityProcessHeader) {
            qualityProcessHeader.classList.add('hidden');
        }
        
        // Limpar tabelas - manter a estrutura HTML mas esvaziar conteúdo
        const packagingSpans = document.querySelectorAll('[class*="quality-packaging"]');
        packagingSpans.forEach(span => {
            span.textContent = '-';
            span.title = '';
        });

        document.querySelectorAll('.quality-packaging-input').forEach(input => {
            input.value = '';
        });
        
        setQualityStatus('Todos os dados foram limpos. Selecione um plano para começar.', 'info');
    }

    function enableManualPackagingInputs() {
        const packagingSpans = document.querySelectorAll('[class*="quality-packaging-shift"]');
        packagingSpans.forEach(span => {
            const cell = span.parentElement;
            if (!cell) return;

            span.classList.add('hidden');

            let input = cell.querySelector('input.quality-packaging-input');
            if (!input) {
                input = document.createElement('input');
                input.type = 'text';
                input.className = 'quality-packaging-input w-full h-5 rounded border border-gray-300 bg-white text-center text-xs text-gray-800';
                input.placeholder = 'Saco';
                input.dataset.linkedSpanClass = span.className;
                cell.appendChild(input);
            }

            input.classList.remove('bg-gray-100', 'text-gray-600');
            input.classList.add('bg-white', 'text-gray-800');
            input.readOnly = false;
            input.value = '';
        });
    }

    function handleQualityChecklistPrint() {
        if (!currentQualityContext) {
            showNotification('Carregue um plano antes de imprimir o checklist.', 'warning');
            return;
        }

        const snapshot = buildQualityChecklistSnapshot();
        const html = renderQualityChecklistPrint(snapshot);
        const printWindow = window.open('', '_blank', 'width=1024,height=768');

        if (!printWindow) {
            showNotification('Não foi possível abrir a janela de impressão. Verifique o bloqueador de pop-ups.', 'error');
            return;
        }

        printWindow.document.write(html);
        printWindow.document.close();
        printWindow.focus();

        setTimeout(() => {
            try {
                printWindow.print();
            } catch (err) {
                console.error('Erro ao acionar impressão:', err);
            }
        }, 300);
    }

    function buildQualityChecklistSnapshot() {
        const plan = currentQualityContext?.plan || {};
        const dateValue = currentQualityContext?.date || qualityDateInput?.value || getProductionDateString();
        const responsavel = (qualityResponsavelInput?.value || getCurrentUserName() || '').trim();
        const notes = (qualityNotesInput?.value || '').trim();
        const actions = (qualityActionsInput?.value || '').trim();
        const status = (qualityChecklistStatus?.textContent || '').trim();
        const printedAt = new Date();

        const shiftHours = {
            1: [7, 8, 9, 10, 11, 12, 13, 14],
            2: [15, 16, 17, 18, 19, 20, 21, 22],
            3: [23, 0, 1, 2, 3, 4, 5, 6]
        };

        const shifts = [
            {
                id: 1,
                title: '1º Turno · 07h às 14h',
                theme: 'blue',
                data: collectQualityShiftData(1, shiftHours[1])
            },
            {
                id: 2,
                title: '2º Turno · 15h às 22h',
                theme: 'green',
                data: collectQualityShiftData(2, shiftHours[2])
            },
            {
                id: 3,
                title: '3º Turno · 23h às 06h',
                theme: 'amber',
                data: collectQualityShiftData(3, shiftHours[3])
            }
        ];

        const prodObservations = collectQualityObservations(qualityProdObsList, qualityProdObsTime, qualityProdObsText);
        const qualObservations = collectQualityObservations(qualityQualObsList, qualityQualObsTime, qualityQualObsText);

        return {
            plan,
            dateValue,
            responsavel,
            notes,
            actions,
            status,
            shifts,
            prodObservations,
            qualObservations,
            printedAt
        };
    }

    function collectQualityObservations(listContainer, pendingTimeInput, pendingTextInput) {
        const entries = [];

        if (listContainer) {
            Array.from(listContainer.children || []).forEach(card => {
                if (!(card instanceof HTMLElement)) return;
                const paragraphs = card.querySelectorAll('p');
                const time = paragraphs[0]?.textContent?.trim() || '';
                const text = paragraphs[1]?.textContent?.trim() || '';

                if (text) {
                    entries.push({ time, text });
                }
            });
        }

        const pendingTime = pendingTimeInput?.value?.trim();
        const pendingText = pendingTextInput?.value?.trim();

        if (pendingTime && pendingText) {
            entries.push({ time: pendingTime, text: `${pendingText} (não salvo)` });
        } else if (!pendingTime && pendingText) {
            entries.push({ time: '', text: `${pendingText} (não salvo)` });
        }

        return entries;
    }

    function collectQualityShiftData(shift, hours = []) {
        const rows = hours.map(hour => {
            const cavitiesInput = document.querySelector(`.quality-cavities-input.shift-${shift}.hour-${hour}`);
            const inspectionInput = document.querySelector(`.quality-inspection-input.shift-${shift}.hour-${hour}`);
            const packagingSpan = document.querySelector(`.quality-packaging-shift-${shift}-${hour}`);
            const packagingCell = packagingSpan?.parentElement || null;
            const packagingInput = packagingCell?.querySelector('.quality-packaging-input') || null;

            const cavities = cavitiesInput?.value?.trim() || '';
            const inspection = inspectionInput?.value?.trim() || '';
            const packagingFallback = packagingSpan?.textContent?.trim();
            const packagingValue = packagingInput?.value?.trim() || (packagingFallback === '-' ? '' : (packagingFallback || ''));

            return {
                hour,
                label: formatPrintHour(hour),
                cavities,
                packaging: packagingValue,
                inspection
            };
        });

        return {
            hours: rows.map(row => row.label),
            cavities: rows.map(row => row.cavities || ''),
            packaging: rows.map(row => row.packaging || ''),
            inspection: rows.map(row => row.inspection || '')
        };
    }

    function renderQualityChecklistPrint(snapshot) {
        const { plan, dateValue, responsavel, notes, actions, status, shifts, prodObservations, qualObservations, printedAt } = snapshot;
        const dateLabel = dateValue ? dateValue.split('-').reverse().join('/') : '-';
        const printedLabel = printedAt.toLocaleString('pt-BR');

        const formatMultiline = (value, emptyLabel) => {
            const safe = (value || '').trim();
            if (!safe) return escapeHtml(emptyLabel || '');
            return escapeHtml(safe).replace(/\n/g, '<br />');
        };

        const renderShiftTable = shift => {
            const data = shift.data;
            if (!data || data.hours.length === 0) {
                return '';
            }

            const renderCells = values => values.map(value => {
                const safe = (value || '').trim();
                return `<td>${safe ? escapeHtml(safe) : '&nbsp;'}</td>`;
            }).join('');
            const hoursHeader = data.hours.map(hourLabel => `<th>${escapeHtml(hourLabel)}</th>`).join('');
            const shiftClass = `shift-${shift.theme || 'neutral'}`;

            return `
                <section class="print-section ${shiftClass}">
                    <h3 class="section-title">${escapeHtml(shift.title)}</h3>
                    <table class="print-table print-table-grid">
                        <thead>
                            <tr>
                                <th class="desc-col">Desc</th>
                                ${hoursHeader}
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="row-label">Cavidades</td>
                                ${renderCells(data.cavities)}
                            </tr>
                            <tr>
                                <td class="row-label">Embalagem</td>
                                ${renderCells(data.packaging)}
                            </tr>
                            <tr>
                                <td class="row-label">Inspeção</td>
                                ${renderCells(data.inspection)}
                            </tr>
                        </tbody>
                    </table>
                </section>
            `;
        };

        const renderObs = (title, items) => {
            if (!items || items.length === 0) {
                return `
                    <div class="obs-block">
                        <h4 class="section-subtitle">${escapeHtml(title)}</h4>
                        <p class="muted">Nenhuma observação registrada.</p>
                    </div>
                `;
            }

            const obsItems = items.map(item => `
                <div class="obs-item">
                    <div class="obs-time">${escapeHtml(item.time || '--:--')}</div>
                    <div class="obs-text">${formatMultiline(item.text, '')}</div>
                </div>
            `).join('');

            return `
                <div class="obs-block">
                    <h4 class="section-subtitle">${escapeHtml(title)}</h4>
                    <div class="obs-list">${obsItems}</div>
                </div>
            `;
        };

        return `<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <title>Checklist de Qualidade - ${escapeHtml(plan.product || plan.product_name || plan.product_cod || 'Plano')}</title>
    <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; color: #1f2937; }
    h1 { font-size: 18px; margin: 0; font-weight: 700; }
    h2 { font-size: 12px; margin: 4px 0 0 0; color: #475569; letter-spacing: 0.08em; text-transform: uppercase; }
    header { border-bottom: 1px solid #e2e8f0; padding-bottom: 12px; margin-bottom: 16px; }
    .meta-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px; margin-bottom: 16px; }
    .meta-card { border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px; background: #fafafa; }
    .meta-label { font-size: 9px; text-transform: uppercase; color: #64748b; font-weight: 600; letter-spacing: 0.06em; }
    .meta-value { margin-top: 4px; font-size: 12px; font-weight: 600; color: #0f172a; }
    .print-section { margin-top: 18px; }
    .section-title { font-size: 12px; font-weight: 700; color: #0f172a; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.06em; }
    .print-table { width: 100%; border-collapse: collapse; font-size: 11px; }
    .print-table th, .print-table td { border: 1px solid #e2e8f0; padding: 5px 6px; text-align: center; }
    .print-table th { background: #f1f5f9; color: #0f172a; font-weight: 700; }
    .print-table td { background: #ffffff; font-weight: 500; }
    .print-table .desc-col { width: 70px; text-align: left; padding-left: 8px; }
    .print-table .row-label { background: #f8fafc; text-align: left; font-weight: 700; padding-left: 8px; }
    .print-table-grid td + td { border-left: 1px solid #e2e8f0; }
    .shift-blue .section-title { color: #1d4ed8; }
    .shift-blue .print-table th { background: #e0f2fe; }
    .shift-blue .row-label { background: #eff6ff; }
    .shift-green .section-title { color: #047857; }
    .shift-green .print-table th { background: #dcfce7; }
    .shift-green .row-label { background: #ecfdf5; }
    .shift-amber .section-title { color: #b45309; }
    .shift-amber .print-table th { background: #fef3c7; }
    .shift-amber .row-label { background: #fefce8; }
    .observations-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 14px; }
    .obs-block { display: flex; flex-direction: column; gap: 6px; }
    .section-subtitle { font-size: 11px; font-weight: 700; color: #0f172a; margin: 0; text-transform: uppercase; letter-spacing: 0.05em; }
    .obs-list { border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px; background: #ffffff; display: flex; flex-direction: column; gap: 6px; }
    .obs-item { display: grid; grid-template-columns: 56px 1fr; gap: 6px; font-size: 11px; }
    .obs-time { font-weight: 700; color: #2563eb; }
    .obs-text { color: #1f2937; }
    .muted { font-size: 11px; color: #94a3b8; }
    .notes { border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px; background: #ffffff; font-size: 11px; line-height: 1.5; }
    .footer { margin-top: 28px; display: flex; justify-content: space-between; font-size: 10px; color: #94a3b8; }
    .signature { margin-top: 32px; border-top: 1px solid #e2e8f0; width: 220px; padding-top: 6px; font-size: 10px; text-align: center; color: #475569; }
        @media print {
            body { margin: 16px; }
            .no-print { display: none !important; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Checklist digital de qualidade</h1>
        <h2>Inspeção hora-a-hora</h2>
    </header>

    <section class="meta-grid">
        <div class="meta-card">
            <div class="meta-label">Produto</div>
            <div class="meta-value">${escapeHtml(plan.product || plan.product_name || 'Não informado')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Máquina</div>
            <div class="meta-value">${escapeHtml(plan.machine || '-')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">OP / Plano</div>
            <div class="meta-value">${escapeHtml(plan.order_number || plan.order_id || plan.id || '-')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Data</div>
            <div class="meta-value">${escapeHtml(dateLabel)}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Responsável</div>
            <div class="meta-value">${escapeHtml(responsavel || '-')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Status</div>
            <div class="meta-value">${escapeHtml(status || 'Em preenchimento')}</div>
        </div>
    </section>

    ${shifts.map(renderShiftTable).join('')}

    <section class="print-section">
        <h3 class="section-title">Observações</h3>
        <div class="observations-grid">
            ${renderObs('Produção', prodObservations)}
            ${renderObs('Qualidade', qualObservations)}
        </div>
    </section>

    <section class="print-section">
        <h3 class="section-title">Anotações do checklist</h3>
        <div class="notes">
            <strong>Notas:</strong><br />${formatMultiline(notes, 'Sem anotações.')}
            <br /><br />
            <strong>Ações:</strong><br />${formatMultiline(actions, 'Sem ações registradas.')}
        </div>
    </section>

    <div class="footer">
        <div>Emitido em: ${escapeHtml(printedLabel)}</div>
        <div class="signature">Assinatura do responsável</div>
    </div>
</body>
</html>`;
    }

    function formatPrintHour(hour) {
        const normalized = Number(hour);
        if (!Number.isFinite(normalized)) return String(hour);
        const padded = String((normalized + 24) % 24).padStart(2, '0');
        return `${padded}h`;
    }

    async function populateQualityPlanOptions(dateValue) {
        if (!qualityPlanSelect) return;

        const effectiveDate = dateValue || getProductionDateString();
        if (qualityDateInput && !qualityDateInput.value) {
            qualityDateInput.value = effectiveDate;
        }

        qualityPlanSelect.disabled = true;
        const previousSelection = qualityPlanSelect.value;
        qualityPlanSelect.innerHTML = '<option value="">Carregando planos...</option>';

        try {
            if (!effectiveDate) {
                qualityPlanSelect.innerHTML = '<option value="">Informe a data para listar os planos</option>';
                return;
            }

            if (qualityPlansCache.lastDate === effectiveDate && Array.isArray(qualityPlansCache.plans)) {
                buildQualityPlanOptions(qualityPlansCache.plans, previousSelection);
                return;
            }

            // NOVO: Buscar todos os planejamentos e filtrar os ATIVOS no cliente
            const snapshot = await db.collection('planning').get();
            const allPlans = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const plans = allPlans.filter(isPlanActive);
            plans.sort((a, b) => (a.machine || '').localeCompare(b.machine || ''));
            qualityPlansCache = { lastDate: effectiveDate, plans };

            buildQualityPlanOptions(plans, previousSelection);
        } catch (error) {
            console.error('Erro ao carregar planos para a aba de qualidade:', error);
            qualityPlanSelect.innerHTML = '<option value="">Erro ao carregar planos</option>';
            setQualityStatus('Não foi possível carregar os planos do dia. Tente novamente.', 'error');
        } finally {
            qualityPlanSelect.disabled = false;
        }
    }

    function buildQualityPlanOptions(plans, previousSelection) {
        if (!qualityPlanSelect) return;

        if (!Array.isArray(plans) || plans.length === 0) {
            qualityPlanSelect.innerHTML = '<option value="">Nenhum plano ativo encontrado</option>';
            setQualityStatus('Nenhum plano ativo encontrado. Crie um planejamento para continuar.', 'warning');
            return;
        }

        const options = ['<option value="">Selecione a máquina ou OP planejada</option>'];
        plans.forEach(plan => {
            const machineLabel = escapeHtml(plan.machine || 'Máquina não definida');
            const productLabel = escapeHtml(plan.product || plan.product_cod || 'Produto não informado');
            const statusLabel = (plan.status || 'planejado').toString().replace(/_/g, ' ');
            const optionLabel = `${machineLabel} – ${productLabel} – ${escapeHtml(statusLabel.toUpperCase())}`;
            options.push(`<option value="${plan.id}">${optionLabel}</option>`);
        });

        qualityPlanSelect.innerHTML = options.join('');

        if (previousSelection && plans.some(plan => plan.id === previousSelection)) {
            qualityPlanSelect.value = previousSelection;
        } else if (plans.length === 1) {
            qualityPlanSelect.value = plans[0].id;
            setQualityStatus('Plano selecionado automaticamente. Clique em "Atualizar contexto" para visualizar os dados.', 'info');
        } else {
            qualityPlanSelect.value = '';
            setQualityStatus('Selecione o plano desejado e clique em "Atualizar contexto".', 'info');
        }
    }

    async function loadQualityContext() {
        if (!qualityPlanSelect) return;

        if (!window.authSystem.checkPermissionForAction('view_quality')) {
            return;
        }

        const planId = qualityPlanSelect.value;
        if (!planId) {
            setQualityStatus('Selecione um plano para carregar o contexto.', 'warning');
            return;
        }

        const dateValue = (qualityDateInput?.value || '').trim();
        if (!dateValue) {
            setQualityStatus('Informe a data de produção para continuar.', 'warning');
            return;
        }

        setQualityStatus('Carregando dados integrados do plano selecionado...', 'info');
        if (qualityContextContainer) {
            qualityContextContainer.classList.add('opacity-60');
        }

        try {
            const planDoc = await db.collection('planning').doc(planId).get();
            if (!planDoc.exists) {
                setQualityStatus('Plano não encontrado. Atualize a lista e tente novamente.', 'error');
                return;
            }

            const planData = { id: planDoc.id, ...planDoc.data() };
            const machineId = planData.machine || null;

            const productionSnapshot = await db.collection('production_entries').where('planId', '==', planId).get();
            const productionEntries = productionSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                .filter(entry => (entry.data || entry.workDay || '').slice(0, 10) === dateValue);

            const hourlySnapshot = await db.collection('hourly_production_entries').where('planId', '==', planId).get();
            console.log(`📊 Query 'hourly_production_entries' retornou ${hourlySnapshot.docs.length} documentos para planId=${planId}`);
            
            // Enriquecer hourlyEntries com dados de quantidade de production_entries
            const hourlyEntriesMap = {};
            hourlySnapshot.docs.forEach(doc => {
                const payload = { id: doc.id, ...doc.data() };
                const timestamp = doc.data().timestamp || doc.data().createdAt;
                if (timestamp && typeof timestamp.toDate === 'function') {
                    payload.timestampDate = timestamp.toDate();
                }
                const hora = payload.hora || '00:00';
                if (!hourlyEntriesMap[hora]) {
                    hourlyEntriesMap[hora] = [];
                }
                hourlyEntriesMap[hora].push(payload);
            });

            // Somar quantidades dos production_entries para cada hora
            productionEntries.forEach(entry => {
                const hora = entry.horaInformada || entry.hora || '00:00';
                if (!hourlyEntriesMap[hora]) {
                    hourlyEntriesMap[hora] = [];
                }
                
                // Encontrar ou criar entrada horária para essa quantidade
                let hourEntry = hourlyEntriesMap[hora].find(e => e.produzido === undefined);
                if (!hourEntry) {
                    hourEntry = { hora: hora };
                    hourlyEntriesMap[hora].push(hourEntry);
                }
                
                hourEntry.quantidade = (hourEntry.quantidade || 0) + (Number(entry.produzido || 0));
                hourEntry.produzido = hourEntry.quantidade;
                hourEntry.ciclo_real = (hourEntry.ciclo_real || 0) + (Number(entry.ciclo_real || 0));
                hourEntry.cavidades = entry.cavidades || Number(planData.mold_cavities || 1);
            });

            // Converter map de volta para array
            const hourlyEntries = Object.values(hourlyEntriesMap).flat();
            console.log(`📊 Após enriquecer com production_entries: ${hourlyEntries.length} registros`);
            hourlyEntries.forEach(e => {
                console.log(`  Hora ${e.hora}: ${e.produzido || e.quantidade || 0} peças, ${e.ciclo_real || 0} ciclos`);
            });

            let downtimeEntries = [];
            if (machineId) {
                const downtimeSnapshot = await db.collection('downtime_entries').where('machine', '==', machineId).get();
                downtimeEntries = downtimeSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(entry => (entry.date || entry.workDay || '').slice(0, 10) === dateValue);
            }

            const qualityMetrics = buildQualityMetrics(planData, productionEntries, hourlyEntries, downtimeEntries);

            currentQualityContext = {
                plan: planData,
                date: dateValue,
                machine: machineId,
                productionEntries,
                hourlyEntries,
                downtimeEntries,
                metrics: qualityMetrics,
                operators: qualityMetrics.operators,
                shiftSuggestion: qualityMetrics.shiftSuggestion
            };

            renderQualityContext(currentQualityContext);
            await loadQualityHistory(planId, dateValue);
            setQualityStatus('Dados carregados com sucesso.', 'success');
        } catch (error) {
            console.error('Erro ao carregar dados para a aba de qualidade:', error);
            setQualityStatus('Erro ao carregar os dados. Verifique sua conexão e tente novamente.', 'error');
        } finally {
            if (qualityContextContainer) {
                qualityContextContainer.classList.remove('opacity-60');
            }
            lucide.createIcons();
        }
    }

    function buildQualityMetrics(planData, productionEntries, hourlyEntries, downtimeEntries) {
        const metrics = {
            totals: {
                produced: 0,
                pesoBruto: 0,
                refugoQty: 0,
                refugoKg: 0
            },
            shifts: {
                1: { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 },
                2: { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 },
                3: { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 }
            },
            operators: [],
            downtime: {
                totalMinutes: 0,
                reasons: {}
            },
            hourly: {
                totalKg: 0,
                entries: hourlyEntries.length
            },
            shiftSuggestion: getCurrentShift()
        };

        const operatorSet = new Set();

        productionEntries.forEach(entry => {
            const turnValue = parseInt(entry.turno, 10);
            const produced = Number(entry.produzido || entry.quantity || 0);
            const pesoBruto = Number(entry.peso_bruto || 0);
            const refugoKg = Number(entry.refugo_kg || 0);
            const refugoQty = Number(entry.refugo_qty || entry.perdas_qty || 0);

            if (metrics.shifts[turnValue]) {
                metrics.shifts[turnValue].produced += produced;
                metrics.shifts[turnValue].pesoBruto += pesoBruto;
                metrics.shifts[turnValue].refugoKg += refugoKg;
                metrics.shifts[turnValue].refugoQty += refugoQty;
            }

            metrics.totals.produced += produced;
            metrics.totals.pesoBruto += pesoBruto;
            metrics.totals.refugoKg += refugoKg;
            metrics.totals.refugoQty += refugoQty;

            const operatorName = (entry.registradoPorNome || entry.registradoPor || entry.createdByName || '').toString().trim();
            if (operatorName) {
                operatorSet.add(operatorName);
            }
        });

        hourlyEntries.forEach(entry => {
            metrics.hourly.totalKg += Number(entry.peso_bruto || 0);
        });

        const downtimeReasons = {};
        downtimeEntries.forEach(entry => {
            const duration = Number(entry.duration || 0);
            metrics.downtime.totalMinutes += duration;
            const reasonKey = (entry.reason || 'Sem motivo').toString();
            downtimeReasons[reasonKey] = (downtimeReasons[reasonKey] || 0) + duration;
        });
        metrics.downtime.reasons = downtimeReasons;

        metrics.operators = Array.from(operatorSet);
        metrics.shiftSuggestion = determineSuggestedShift(metrics.shifts) || getCurrentShift();
        // CORREÇÃO: Usar planned_quantity (meta diária), não order_lot_size (tamanho total OP)
        metrics.planTarget = Number(planData?.planned_quantity || planData?.planned_qty || planData?.meta || 0);

        return metrics;
    }

    function determineSuggestedShift(shiftMetrics) {
        if (!shiftMetrics) return getCurrentShift();
        let bestShift = 1;
        let bestValue = shiftMetrics[1]?.produced || 0;
        [2, 3].forEach(shift => {
            const produced = shiftMetrics[shift]?.produced || 0;
            if (produced > bestValue) {
                bestValue = produced;
                bestShift = shift;
            }
        });
        return bestShift;
    }

    function formatLocaleNumber(value, fractionDigits = 0) {
        if (!Number.isFinite(value)) return (0).toLocaleString('pt-BR');
        return Number(value).toLocaleString('pt-BR', {
            minimumFractionDigits: fractionDigits,
            maximumFractionDigits: fractionDigits
        });
    }

    function formatMinutesToHuman(minutes) {
        if (!Number.isFinite(minutes) || minutes <= 0) {
            return '0 min';
        }
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        const parts = [];
        if (hours > 0) parts.push(`${hours}h`);
        if (mins > 0) parts.push(`${mins}min`);
        return parts.join(' ') || '0 min';
    }

    function renderQualityContext(context) {
        if (!context) return;

        const { plan, date, metrics, productionEntries, hourlyEntries, downtimeEntries } = context;

        if (qualityInfoGrid) {
            // CORREÇÃO: Usar planned_quantity (meta diária), não order_lot_size (tamanho total OP)
            const plannedQty = Number(plan?.planned_quantity || plan?.planned_qty || plan?.meta || 0);
            const producedTotal = metrics.totals.produced || 0;
            const progressPercent = plannedQty > 0 ? Math.min(100, Math.round((producedTotal / plannedQty) * 100)) : 0;
            const progressLabel = plannedQty > 0 ? `${progressPercent}%` : 'N/D';

            qualityInfoGrid.innerHTML = `
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-blue-50 p-2 text-blue-600"><i data-lucide="factory" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Máquina</p>
                        <p class="text-sm font-semibold text-gray-800">${escapeHtml(plan.machine || 'N/D')}</p>
                        <p class="text-xs text-gray-500">${escapeHtml(plan.machine_model || plan.model || '')}</p>
                    </div>
                </div>
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-indigo-50 p-2 text-indigo-600"><i data-lucide="package" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Produto / MP</p>
                        <p class="text-sm font-semibold text-gray-800">${escapeHtml(plan.product || 'Produto não informado')}</p>
                        <p class="text-xs text-gray-500">MP: ${escapeHtml(plan.mp || 'N/D')}</p>
                    </div>
                </div>
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-emerald-50 p-2 text-emerald-600"><i data-lucide="calendar" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Data · Turno sugerido</p>
                        <p class="text-sm font-semibold text-gray-800">${date.split('-').reverse().join('/')}</p>
                        <p class="text-xs text-gray-500">Turno destaque: ${metrics.shiftSuggestion}ú</p>
                    </div>
                </div>
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-orange-50 p-2 text-orange-500"><i data-lucide="target" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Meta x Produção</p>
                        <p class="text-sm font-semibold text-gray-800">${formatLocaleNumber(producedTotal)} / ${formatLocaleNumber(plannedQty)} pcs</p>
                        <p class="text-xs text-gray-500">Progresso estimado: ${progressLabel}</p>
                    </div>
                </div>
            `;
        }

        if (qualitySummaryCards) {
            const producedTotal = metrics.totals.produced || 0;
            const pesoTotal = metrics.totals.pesoBruto || 0;
            const refugoKg = metrics.totals.refugoKg || 0;
            const refugoQty = metrics.totals.refugoQty || 0;
            const downtimeMinutes = metrics.downtime.totalMinutes || 0;

            // Calcular peso médio por peça
            const pesoMedio = producedTotal > 0 ? pesoTotal / producedTotal : 0;
            // Converter refugo kg para quantidade usando peso médio
            const refugoQtyCalculated = pesoMedio > 0 ? Math.round(refugoKg / pesoMedio) : refugoQty;

            qualitySummaryCards.innerHTML = `
                <div class="rounded-xl border border-blue-200 bg-blue-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-blue-600">Produção total (pcs)</p>
                    <p class="mt-2 text-2xl font-bold text-blue-900">${formatLocaleNumber(producedTotal)}</p>
                </div>
                <div class="rounded-xl border border-amber-200 bg-amber-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-amber-600">Refugo total (pcs)</p>
                    <p class="mt-2 text-2xl font-bold text-amber-900">${formatLocaleNumber(refugoQtyCalculated)}</p>
                    <p class="text-xs text-amber-600 mt-1">${formatLocaleNumber(refugoKg, 2)} kg</p>
                </div>
                <div class="rounded-xl border border-rose-200 bg-rose-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-rose-600">Refugo acumulado (kg)</p>
                    <p class="mt-2 text-2xl font-bold text-rose-900">${formatLocaleNumber(refugoKg, 2)}</p>
                </div>
                <div class="rounded-xl border border-gray-300 bg-gray-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-gray-600">Paradas registradas</p>
                    <p class="mt-2 text-2xl font-bold text-gray-900">${formatMinutesToHuman(downtimeMinutes)}</p>
                </div>
            `;
        }

        if (qualityOperatorsChip) {
            if (metrics.operators.length > 0) {
                qualityOperatorsChip.textContent = `Operadores: ${metrics.operators.join(', ')}`;
            } else {
                qualityOperatorsChip.textContent = 'Nenhum operador identificado nos apontamentos.';
            }
        }

        if (qualityShiftTbody) {
            const rows = [1, 2, 3].map(shift => {
                const data = metrics.shifts[shift] || { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 };
                return `
                    <tr>
                        <td class="px-4 py-3 text-sm font-semibold text-gray-700">${shift}º Turno</td>
                        <td class="px-4 py-3 text-right text-sm text-gray-700">${formatLocaleNumber(data.produced)}</td>
                        <td class="px-4 py-3 text-right text-sm text-gray-700">${formatLocaleNumber(data.refugoQty)}</td>
                        <td class="px-4 py-3 text-right text-sm text-gray-700">${formatLocaleNumber(data.refugoKg, 2)}</td>
                    </tr>
                `;
            }).join('');
            qualityShiftTbody.innerHTML = rows;
            if (qualityShiftEmpty) {
                qualityShiftEmpty.classList.toggle('hidden', productionEntries.length > 0);
            }
        }

        if (qualityHourlyTableBody) {
            if (hourlyEntries.length === 0) {
                qualityHourlyTableBody.innerHTML = '';
                if (qualityHourlyEmpty) qualityHourlyEmpty.classList.remove('hidden');
            } else {
                const sortedHourly = [...hourlyEntries].sort((a, b) => (a.hora || '').localeCompare(b.hora || ''));
                qualityHourlyTableBody.innerHTML = sortedHourly.map(entry => {
                    const hour = entry.hora || '--:--';
                    const peso = formatLocaleNumber(Number(entry.peso_bruto || 0), 3);
                    const embalagens = formatLocaleNumber(Number(entry.embalagem_fechada || 0));
                    const tara = entry.usar_tara ? 'Sim' : 'Não';
                    return `
                        <tr>
                            <td class="px-4 py-3 text-sm text-gray-700">${escapeHtml(hour)}</td>
                            <td class="px-4 py-3 text-right text-sm text-gray-700">${peso}</td>
                            <td class="px-4 py-3 text-right text-sm text-gray-700">${embalagens}</td>
                            <td class="px-4 py-3 text-center text-sm text-gray-700">${tara}</td>
                        </tr>
                    `;
                }).join('');
                if (qualityHourlyEmpty) qualityHourlyEmpty.classList.add('hidden');
            }
        }

        if (qualityHourlyTotal) {
            qualityHourlyTotal.textContent = metrics.hourly.entries > 0
                ? `${metrics.hourly.entries} registro(s) · ${formatLocaleNumber(metrics.hourly.totalKg, 2)} kg`
                : '';
        }

        if (qualityDowntimeList) {
            if (downtimeEntries.length === 0) {
                qualityDowntimeList.innerHTML = '';
                if (qualityDowntimeEmpty) qualityDowntimeEmpty.classList.remove('hidden');
            } else {
                const reasonChips = Object.entries(metrics.downtime.reasons || {}).map(([reason, minutes]) => {
                    return `<span class="inline-flex items-center gap-1 rounded-full bg-rose-100 px-2 py-1 text-xs font-semibold text-rose-700">${escapeHtml(reason)} · ${formatMinutesToHuman(minutes)}</span>`;
                }).join('');

                const cards = downtimeEntries
                    .sort((a, b) => (a.startTime || '').localeCompare(b.startTime || ''))
                    .map(entry => {
                        const duration = formatMinutesToHuman(Number(entry.duration || 0));
                        const obs = entry.observations ? `<p class="text-xs text-gray-500 mt-1">${escapeHtml(entry.observations)}</p>` : '';
                        return `
                            <div class="rounded-lg border border-rose-100 bg-rose-50 p-4 shadow-sm">
                                <div class="flex items-start justify-between gap-3">
                                    <div>
                                        <p class="text-sm font-semibold text-rose-800">${escapeHtml(entry.reason || 'Sem motivo')}</p>
                                        <p class="text-xs text-gray-500">${escapeHtml(entry.startTime || '--:--')} ➜ ${escapeHtml(entry.endTime || '--:--')} · ${duration}</p>
                                        ${obs}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                qualityDowntimeList.innerHTML = `
                    <div class="flex flex-wrap items-center gap-2 mb-3">${reasonChips}</div>
                    <div class="space-y-3">${cards}</div>
                `;
                if (qualityDowntimeEmpty) qualityDowntimeEmpty.classList.add('hidden');
            }
        }

        if (qualityDowntimeTotal) {
            qualityDowntimeTotal.textContent = metrics.downtime.totalMinutes > 0
                ? formatMinutesToHuman(metrics.downtime.totalMinutes)
                : '';
        }

        if (qualityProcessForm) {
            const suggestedShift = metrics.shiftSuggestion || getCurrentShift();
            const shiftRadio = qualityProcessForm.querySelector(`input[name="quality-shift"][value="${suggestedShift}"]`);
            if (shiftRadio) {
                shiftRadio.checked = true;
            }
        }

        if (qualityChecklistStatus) {
            qualityChecklistStatus.textContent = `Plano vinculado: ${escapeHtml(plan.machine || '---')} · ${escapeHtml(plan.product || '---')}`;
        }

        // Renderizar tabelas de controle de processos
        renderQualityProcessTables(plan, hourlyEntries);

        lucide.createIcons();
    }

    function renderQualityProcessTables(plan, hourlyEntries) {
        if (!plan) {
            if (qualityProcessEmpty) qualityProcessEmpty.classList.remove('hidden');
            if (qualityProcessHeader) qualityProcessHeader.classList.add('hidden');
            if (qualityProcessTables) qualityProcessTables.classList.add('hidden');
            if (qualityControlBar) qualityControlBar.classList.add('hidden');
            if (qualityObservationsSection) qualityObservationsSection.classList.add('hidden');
            return;
        }

        // Mostrar cabeçalho com informações do plano
        if (qualityProcessEmpty) qualityProcessEmpty.classList.add('hidden');
        if (qualityProcessHeader) {
            qualityProcessHeader.classList.remove('hidden');
            if (qualityHeaderProduct) qualityHeaderProduct.textContent = plan.product || '-';
            if (qualityHeaderMachine) qualityHeaderMachine.textContent = plan.machine || '-';
            if (qualityHeaderOrder) qualityHeaderOrder.textContent = plan.order_number || plan.order_id || '-';
        }

        // Mostrar tabelas, barra de controle e observações
        if (qualityProcessTables) qualityProcessTables.classList.remove('hidden');
        if (qualityControlBar) qualityControlBar.classList.remove('hidden');
        if (qualityObservationsSection) qualityObservationsSection.classList.remove('hidden');

        if (!QUALITY_AUTOFILL_ENABLED) {
            clearQualityInputsForManualEntry();
            setQualityStatus('Modo manual ativo: preencha o checklist diretamente na tabela.', 'info');
            return;
        }

        // Popular cavidades e embalagens nas tabelas (modo automático)
        populateQualityProcessTables(hourlyEntries, plan);
    }

    function populateQualityProcessTables(hourlyEntries, plan) {
        if (!plan || !hourlyEntries || hourlyEntries.length === 0) {
            console.log('⚠️ Sem dados para popular tabelas');
            return;
        }

        // Obter cavidades padrão do plano
        const cavitiesStandard = Number(plan.mold_cavities || 1);
        
        // Se não houver capacidade de saco definida, usar quantidade planejada ou padrão
        let bagCapacity = Number(plan.bag_capacity || 0);
        if (bagCapacity <= 0) {
            // Calcular capacidade por saco: quantidade_planejada / 2 (estimativa de 2 sacos)
            // CORREÇÃO: Usar planned_quantity (meta diária), não order_lot_size (tamanho total OP)
            const plannedQty = Number(plan.planned_quantity || plan.planned_qty || plan.meta || 1000);
            bagCapacity = Math.ceil(plannedQty / 2);
        }

        console.log(`📊 Cavidades padrão: ${cavitiesStandard}, Capacidade do saco: ${bagCapacity}`);

        const parsePositiveInt = (value) => {
            const parsed = Number(value);
            return Number.isFinite(parsed) && parsed > 0 ? Math.round(parsed) : null;
        };

        const getShiftActiveCavities = (shift) => {
            const candidatesByShift = {
                1: [
                    plan.active_cavities_t1,
                    plan.active_cavities_T1,
                    plan.activeCavitiesT1,
                    plan.activeCavities?.t1
                ],
                2: [
                    plan.active_cavities_t2,
                    plan.active_cavities_T2,
                    plan.activeCavitiesT2,
                    plan.activeCavities?.t2
                ],
                3: [
                    plan.active_cavities_t3,
                    plan.active_cavities_T3,
                    plan.activeCavitiesT3,
                    plan.activeCavities?.t3
                ]
            };
            const candidates = candidatesByShift[shift] || [];
            for (const candidate of candidates) {
                const parsed = parsePositiveInt(candidate);
                if (parsed !== null) {
                    return parsed;
                }
            }
            return null;
        };

        const activeCavitiesByShift = {
            1: getShiftActiveCavities(1),
            2: getShiftActiveCavities(2),
            3: getShiftActiveCavities(3)
        };

        // Agrupar por hora
        const hourlyMap = {};
        hourlyEntries.forEach(entry => {
            const hora = entry.hora || entry.hour || '00:00';
            const hh = parseInt(hora.split(':')[0], 10);
            if (!hourlyMap[hh]) {
                hourlyMap[hh] = [];
            }
            hourlyMap[hh].push(entry);
        });

        console.log(`📊 Populando tabelas com ${Object.keys(hourlyMap).length} horas de dados`);

        // Manter rastreamento acumulado de produção por turno
        let accumulatedByShift = { 1: 0, 2: 0, 3: 0 };

        // Ordenar horas para processar sequencialmente
        const sortedHours = Object.keys(hourlyMap).map(h => parseInt(h, 10)).sort((a, b) => a - b);

        // Para cada hora, atualizar os campos de cavidades e número de embalagem
        sortedHours.forEach(hh => {
            const entries = hourlyMap[hh];
            
            // Calcular totais para essa hora
            const totalCycles = entries.reduce((sum, e) => sum + (Number(e.ciclo_real || 0)), 0);
            // A quantidade pode estar em: quantidade, produzido, ou precisar ser calculada de peso/cavidades
            let totalQuantity = entries.reduce((sum, e) => sum + (Number(e.quantidade || e.produzido || 0)), 0);
            
            // Se não houver quantidade direta, calcular a partir de ciclo_real * cavidades
            if (totalQuantity === 0) {
                totalQuantity = entries.reduce((sum, e) => {
                    const ciclos = Number(e.ciclo_real || 0);
                    const cavs = Number(e.cavidades || cavitiesStandard);
                    return sum + (ciclos * cavs);
                }, 0);
            }

            console.log(`  Hora ${hh}h: ${totalCycles} ciclos reais, ${totalQuantity} peças produzidas`);

            // Determinar turno baseado nos horários corretos:
            // 1º Turno: 7h - 14h
            // 2º Turno: 15h - 22h
            // 3º Turno: 23h - 6h
            let shift = 3; // Default para 3º Turno
            if (hh >= 7 && hh <= 14) {
                shift = 1;
            } else if (hh >= 15 && hh <= 22) {
                shift = 2;
            }

            // Determinar cavidades reais priorizando o painel de ciclo/cavidades
            let hourlyReportedCavities = null;
            for (const row of entries) {
                const candidates = [
                    row.cavidades,
                    row.cavidade,
                    row.cavidades_ativas,
                    row.cavidade_real,
                    row.active_cavities,
                    row.activeCavities
                ];
                for (const candidate of candidates) {
                    const parsed = parsePositiveInt(candidate);
                    if (parsed !== null) {
                        hourlyReportedCavities = parsed;
                        break;
                    }
                }
                if (hourlyReportedCavities !== null) {
                    break;
                }
            }

            const shiftActiveCavities = activeCavitiesByShift[shift];
            const resolvedCavities = hourlyReportedCavities ?? shiftActiveCavities ?? cavitiesStandard;
            const cavitiesSource = hourlyReportedCavities !== null
                ? 'apontamentos horários'
                : shiftActiveCavities !== null
                    ? 'painel de ciclo/cavidades'
                    : 'planejamento da OP';

            // Atualizar campo de cavidades reais
            const cavitiesInput = document.querySelector(`.quality-cavities-input.shift-${shift}.hour-${hh}`);
            if (cavitiesInput) {
                cavitiesInput.value = resolvedCavities ? String(resolvedCavities) : '';
                cavitiesInput.readOnly = true;
                cavitiesInput.classList.add('bg-gray-100');
                cavitiesInput.title = `Cavidades ativas: ${resolvedCavities} (${cavitiesSource})`;
            }

            // Calcular número de saco e atualizar (acumulado por turno)
            accumulatedByShift[shift] += totalQuantity;
            const bagsCompleted = Math.floor(accumulatedByShift[shift] / bagCapacity);
            const piecesInCurrentBag = accumulatedByShift[shift] % bagCapacity;
            const currentBag = bagsCompleted + 1;

            console.log(`    Turno ${shift} acumulado: ${accumulatedByShift[shift]} peças = ${bagsCompleted} sacos completos + ${piecesInCurrentBag} peças no saco ${currentBag}`);

            // Atualizar campo de embalagem (número do saco atual)
            const packagingSpan = document.querySelector(`.quality-packaging-shift-${shift}-${hh}`);
            if (packagingSpan) {
                packagingSpan.textContent = currentBag > 0 ? `Saco ${currentBag}` : '-';
                packagingSpan.title = `${accumulatedByShift[shift]} peças | ${piecesInCurrentBag}/${bagCapacity} no saco`;
                packagingSpan.classList.add('cursor-help');
            }
        });

        // Preparar observações salvas se existirem
        loadQualityObservations();
    }

    function loadQualityObservations() {
        // Esta função carregará observações salvas do Firestore quando implementado
        console.log('📝 Sistema de observações pronto');
    }


    async function loadQualityHistory(planId, dateValue) {
        if (!planId || !qualityHistoryList) return;

        try {
            const snapshot = await db.collection('process_control_checks').where('planId', '==', planId).get();
            const records = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const filtered = records.filter(record => (record.date || '').slice(0, 10) === dateValue);
            filtered.sort((a, b) => {
                const aTime = a.createdAt?.toMillis ? a.createdAt.toMillis() : 0;
                const bTime = b.createdAt?.toMillis ? b.createdAt.toMillis() : 0;
                return bTime - aTime;
            });

            renderQualityHistory(filtered.slice(0, 5));
        } catch (error) {
            console.error('Erro ao carregar histórico de qualidade:', error);
            if (qualityHistoryList) qualityHistoryList.innerHTML = '';
            if (qualityHistoryEmpty) {
                qualityHistoryEmpty.classList.remove('hidden');
                qualityHistoryEmpty.textContent = 'Erro ao carregar histórico. Tente novamente mais tarde.';
            }
        }
    }

    function renderQualityHistory(records) {
        if (!qualityHistoryList || !qualityHistoryEmpty) return;

        if (!Array.isArray(records) || records.length === 0) {
            qualityHistoryList.innerHTML = '';
            qualityHistoryEmpty.classList.remove('hidden');
            if (qualityHistoryChip) qualityHistoryChip.textContent = '';
            if (qualityChecklistStatus) {
                qualityChecklistStatus.textContent = 'Nenhum checklist salvo para esta data.';
            }
            return;
        }

        qualityHistoryEmpty.classList.add('hidden');
        if (qualityHistoryChip) {
            qualityHistoryChip.textContent = `${records.length} registro(s)`;
        }

        qualityHistoryList.innerHTML = records.map(record => {
            const createdAt = record.createdAt && typeof record.createdAt.toDate === 'function' ? record.createdAt.toDate() : null;
            const createdDateLabel = createdAt ? createdAt.toLocaleDateString('pt-BR') : 'Data não informada';
            const createdTimeLabel = createdAt ? createdAt.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : '--:--';
            const statusLabels = {
                em_execucao: 'Produção em execução',
                setup: 'Em setup',
                ajuste: 'Em ajuste',
                parada: 'Parada'
            };
            const statusLabel = statusLabels[record.status] || 'Status não informado';

            const checkChips = [
                { label: 'Setup', ok: record.checks?.setup },
                { label: 'Parmetros', ok: record.checks?.parameters },
                { label: 'Poka-yokes', ok: record.checks?.pokaYoke },
                { label: 'Organização', ok: record.checks?.clean }
            ].map(item => {
                const icon = item.ok ? 'check' : 'x';
                const classes = item.ok ? 'bg-emerald-100 text-emerald-700 border border-emerald-200' : 'bg-red-100 text-red-700 border border-red-200';
                return `<span class="inline-flex items-center gap-1 rounded-full px-2 py-1 text-xs font-semibold ${classes}"><i data-lucide="${icon}" class="w-3 h-3"></i>${item.label}</span>`;
            }).join(' ');

            const observations = record.observations ? `<p class="text-xs text-gray-600 mt-2"><strong>Observações:</strong> ${escapeHtml(record.observations)}</p>` : '';
            const actions = record.actions ? `<p class="text-xs text-gray-600 mt-1"><strong>Ações:</strong> ${escapeHtml(record.actions)}</p>` : '';

            return `
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
                    <div class="flex flex-col gap-2">
                        <div class="flex flex-col md:flex-row md:items-start md:justify-between gap-2">
                            <div class="flex-1">
                                <p class="text-sm font-semibold text-gray-800">${escapeHtml(statusLabel)}</p>
                                <p class="text-xs text-gray-500">${createdDateLabel} · ${createdTimeLabel} · Turno ${record.turno || '-'} · ${escapeHtml(record.createdByName || 'Responsável não identificado')}</p>
                            </div>
                            <button class="quality-delete-history-btn inline-flex items-center justify-center gap-1 rounded-lg bg-red-100 px-3 py-1 text-xs font-semibold text-red-600 hover:bg-red-200 transition" data-record-id="${record.id}" title="Excluir este lançamento">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                                Excluir
                            </button>
                        </div>
                        <div class="flex flex-wrap gap-2">${checkChips}</div>
                        ${observations}
                        ${actions}
                    </div>
                </div>
            `;
        }).join('');

        // Adicionar event listeners para botões de exclusão
        document.querySelectorAll('.quality-delete-history-btn').forEach(btn => {
            btn.addEventListener('click', deleteQualityHistoryRecord);
        });

        if (qualityChecklistStatus) {
            const latest = records[0];
            const createdAt = latest.createdAt && typeof latest.createdAt.toDate === 'function' ? latest.createdAt.toDate() : null;
            if (createdAt) {
                qualityChecklistStatus.textContent = `Último checklist salvo em ${createdAt.toLocaleDateString('pt-BR')} às ${createdAt.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`;
            }
        }

        lucide.createIcons();
    }

    async function deleteQualityHistoryRecord(event) {
        event.preventDefault();
        const recordId = event.currentTarget.getAttribute('data-record-id');
        
        if (!recordId) {
            showNotification('ID do registro não encontrado', 'error');
            return;
        }

        // Confirmar exclusão
        if (!confirm('Tem certeza que deseja excluir este lançamento? Esta ação não pode ser desfeita.')) {
            return;
        }

        try {
            await db.collection('process_control_checks').doc(recordId).delete();
            showNotification('Lançamento excluído com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE CHECKLIST QUALIDADE', 'qualidade', {
                recordId: recordId
            });
            
            // Recarregar histórico
            if (currentQualityContext && currentQualityContext.plan) {
                await loadQualityHistory(currentQualityContext.plan.id, currentQualityContext.date);
            }
        } catch (error) {
            console.error('Erro ao excluir lançamento:', error);
            showNotification('Erro ao excluir o lançamento. Tente novamente.', 'error');
        }
    }

    async function getPlansWithProductionDataForDate(dateValue) {
        try {
            // Buscar todos os planos para a data
            const plansSnapshot = await db.collection('planning')
                .where('date', '==', dateValue)
                .get();

            if (plansSnapshot.empty) {
                console.log('ℹ️ Nenhum plano para a data', dateValue);
                return [];
            }

            // Para cada plano, verificar se tem dados de produção
            const plansWithData = [];
            for (const planDoc of plansSnapshot.docs) {
                const planId = planDoc.id;
                const planData = planDoc.data();

                // Verificar se há apontamentos de produção
                const prodSnapshot = await db.collection('production_entries')
                    .where('planId', '==', planId)
                    .limit(1)
                    .get();

                if (!prodSnapshot.empty) {
                    plansWithData.push({
                        id: planId,
                        machine: planData.machine,
                        product: planData.product,
                        status: planData.status,
                        hasData: true
                    });
                }
            }

            return plansWithData;
        } catch (error) {
            console.error('Erro ao buscar planos com dados:', error);
            return [];
        }
    }

    
    function openSidebar() {
        if (sidebar && sidebarOverlay) {
            sidebar.classList.remove('-translate-x-full');
            sidebar.classList.add('sidebar-open');
            sidebarOverlay.classList.remove('hidden');
            sidebarOverlay.classList.add('active');
            sidebar.setAttribute('aria-hidden', 'false');
            sidebarOverlay.setAttribute('aria-hidden', 'false');
            document.body.style.overflow = 'hidden'; // Previne scroll do body
            if (sidebarOpenBtn) {
                sidebarOpenBtn.classList.add('is-active');
                sidebarOpenBtn.setAttribute('aria-expanded', 'true');
            }
        }
    }

    function closeSidebar() {
        if (sidebar && sidebarOverlay) {
            sidebar.classList.add('-translate-x-full');
            sidebar.classList.remove('sidebar-open');
            sidebarOverlay.classList.add('hidden');
            sidebarOverlay.classList.remove('active');
            sidebar.setAttribute('aria-hidden', 'true');
            sidebarOverlay.setAttribute('aria-hidden', 'true');
            document.body.style.overflow = ''; // Restaura scroll do body
            if (sidebarOpenBtn) {
                sidebarOpenBtn.classList.remove('is-active');
                sidebarOpenBtn.setAttribute('aria-expanded', 'false');
            }
        }
    }

    // Toggle collapse/expand sidebar (desktop only)
    function toggleSidebarCollapse() {
        if (!sidebar) return;
        
        const isCollapsed = sidebar.classList.contains('sidebar-collapsed');
        
        if (isCollapsed) {
            // Expandir
            sidebar.classList.remove('sidebar-collapsed');
            sidebar.classList.add('sidebar-expanded');
            localStorage.setItem('sidebar-state', 'expanded');
            console.log('[TRACE][toggleSidebarCollapse] Sidebar expandido');
        } else {
            // Retrair
            sidebar.classList.remove('sidebar-expanded');
            sidebar.classList.add('sidebar-collapsed');
            localStorage.setItem('sidebar-state', 'collapsed');
            console.log('[TRACE][toggleSidebarCollapse] Sidebar retraído');
        }
        
        // Atualizar ícone do toggle
        if (sidebarToggleBtn) {
            lucide.createIcons();
        }
    }

    // Restaurar estado do sidebar ao carregar página
    function restoreSidebarState() {
        if (!sidebar) return;
        
        const savedState = localStorage.getItem('sidebar-state') || 'expanded';
        
        if (savedState === 'collapsed') {
            sidebar.classList.remove('sidebar-expanded');
            sidebar.classList.add('sidebar-collapsed');
            console.log('[TRACE][restoreSidebarState] Sidebar restaurado como retraído');
        } else {
            sidebar.classList.add('sidebar-expanded');
            sidebar.classList.remove('sidebar-collapsed');
            console.log('[TRACE][restoreSidebarState] Sidebar restaurado como expandido');
        }
    }

    function handleAnalysisTabClick(e) {
        const view = e.currentTarget.dataset.view;
        if (view) {
            switchAnalysisView(view);
        }
    }

    function setDateRange(range) {
        const end = new Date();
        const start = new Date();
        
        switch(range) {
            case '7':
                start.setDate(start.getDate() - 7);
                break;
            case '30':
                start.setDate(start.getDate() - 30);
                break;
            case 'month':
                start.setDate(1);
                break;
            default:
                start.setDate(start.getDate() - 7);
        }
        
        if (startDateSelector) startDateSelector.value = start.toISOString().split('T')[0];
        if (endDateSelector) endDateSelector.value = end.toISOString().split('T')[0];
    }
    
    // --- ABA DE PLANEJAMENTO ---
    function setupPlanningTab() {
        if (!planningMachineSelect) return;
        
        const machineOptions = machineDatabase.map(m => {
            const mid = normalizeMachineId(m.id);
            return `<option value="${mid}">${mid} - ${m.model}</option>`;
        }).join('');
        planningMachineSelect.innerHTML = `<option value="">Selecione...</option>${machineOptions}`;

        // Configurar select de código do produto
        const productCodInput = document.getElementById('planning-product-cod');
        const productCodDatalist = document.getElementById('planning-product-cod-list');
        if (productCodInput && productCodDatalist) {
            const prodDatabase = (window.databaseModule && window.databaseModule.productDatabase) 
                ? window.databaseModule.productDatabase 
                : (typeof productDatabase !== 'undefined' ? productDatabase : []);
            const sortedProducts = [...prodDatabase].sort((a, b) => a.cod - b.cod);
            const escapeOptionLabel = (str = '') => String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            productCodDatalist.innerHTML = sortedProducts.map(p => {
                const label = `${p.cod} - ${p.name} (${p.client})`;
                const escapedLabel = escapeOptionLabel(label);
                return `<option value="${p.cod}" label="${escapedLabel}">${escapedLabel}</option>`;
            }).join('');
        }
    }

    // --- ABA DE ORDENS DE PRODUÇÃO ---
    function setupProductionOrdersTab() {
        if (!productionOrderCodeInput) return;

        // Popular lista de códigos disponíveis
        if (productionOrderCodeDatalist) {
            const sortedProducts = [...productDatabase].sort((a, b) => a.cod - b.cod);
            const escapeOptionLabel = (str = '') => String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');

            productionOrderCodeDatalist.innerHTML = sortedProducts.map(product => {
                const label = `${product.cod} - ${product.name} (${product.client})`;
                const escaped = escapeOptionLabel(label);
                return `<option value="${product.cod}" label="${escaped}">${escaped}</option>`;
            }).join('');
        }

        // Popular select de máquinas no formulário
        populateOrderMachineSelect();

        productionOrderCodeInput.addEventListener('input', handleProductionOrderCodeInput);
        productionOrderCodeInput.addEventListener('change', handleProductionOrderCodeSelection);

        initOrdersFilters();
        listenToProductionOrders();
    }

    function populatePlanningOrderSelect() {
        // Função mantida para compatibilidade - agora a busca usa o cache productionOrdersCache
        // Não é mais necessário popular um select com options
        if (!Array.isArray(productionOrdersCache)) return;
        
        console.log(`[Planejamento] Cache atualizado com ${productionOrdersCache.length} OPs`);
    }

    function handleProductionOrderCodeInput(e) {
        const rawCode = (e.target.value || '').trim();

        if (!rawCode) {
            clearProductionOrderAutoFields();
            setProductionOrderFeedback();
            return;
        }

        // Enquanto o usuário digita, ocultar mensagens para evitar falso negativo
        setProductionOrderFeedback();
    }

    function handleProductionOrderCodeSelection(e) {
        const rawCode = (e.target.value || '').trim();

        if (!rawCode) {
            clearProductionOrderAutoFields();
            setProductionOrderFeedback();
            return;
        }

        // Usar função helper com fallback seguro
        const product = getProductByCode(rawCode);

        if (product) {
            fillProductionOrderFields(product);
            const clientLabel = product.client ? ` – ${product.client}` : '';
            setProductionOrderFeedback(`Produto carregado: ${product.name}${clientLabel}`, 'success');
            return;
        }

        clearProductionOrderAutoFields();
        setProductionOrderFeedback('Produto não encontrado na base. Preencha manualmente.', 'error');
    }

    function fillProductionOrderFields(product) {
        if (!product) return;

        if (productionOrderProductInput) {
            productionOrderProductInput.value = product.name || '';
        }

        if (productionOrderCustomerInput) {
            productionOrderCustomerInput.value = product.client || '';
        }

        if (productionOrderRawMaterialInput) {
            productionOrderRawMaterialInput.value = product.mp || '';
        }
    }

    function clearProductionOrderAutoFields() {
        if (productionOrderProductInput) productionOrderProductInput.value = '';
        if (productionOrderCustomerInput) productionOrderCustomerInput.value = '';
        if (productionOrderRawMaterialInput) productionOrderRawMaterialInput.value = '';
    }

    function setProductionOrderFeedback(message = '', type = 'info') {
        if (!productionOrderFeedback) return;

        if (!message) {
            productionOrderFeedback.textContent = '';
            productionOrderFeedback.style.display = 'none';
            productionOrderFeedback.className = 'mt-2 text-sm font-medium text-primary-blue';
            return;
        }

        const baseClasses = 'mt-2 text-sm font-medium';
        const typeClass = type === 'success'
            ? 'text-emerald-600'
            : type === 'error'
                ? 'text-red-600'
                : 'text-primary-blue';

        productionOrderFeedback.textContent = message;
        productionOrderFeedback.style.display = 'block';
        productionOrderFeedback.className = `${baseClasses} ${typeClass}`;
    }

    function escapeHtml(str = '') {
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function normalizeNumericString(value) {
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        if (!trimmed) return null;

        const thousandPatternPtBr = /^\d{1,3}(\.\d{3})+(,\d+)?$/;
        const thousandPatternEn = /^\d{1,3}(,\d{3})+(\.\d+)?$/;

        const hasComma = trimmed.includes(',');
        const hasDot = trimmed.includes('.');

        // Se possuir apenas vírgula (formato típico pt-BR), tratar como decimal
        if (hasComma && !hasDot) {
            return trimmed.replace(/\s+/g, '').replace(',', '.');
        }

        if (thousandPatternPtBr.test(trimmed)) {
            return trimmed.replace(/\./g, '').replace(',', '.');
        }

        if (thousandPatternEn.test(trimmed)) {
            return trimmed.replace(/,/g, '');
        }

        // Caso geral: remover espaços e trocar vírgula por ponto
        return trimmed.replace(/\s+/g, '').replace(',', '.');
    }

    function parseOptionalNumber(value) {
        if (value === null || value === undefined || value === '') return null;

        if (typeof value === 'number') {
            return Number.isFinite(value) ? value : null;
        }

        if (typeof value === 'string') {
            const normalized = normalizeNumericString(value);
            if (normalized === null) return null;
            const parsed = Number(normalized);
            return Number.isFinite(parsed) ? parsed : null;
        }

        const fallback = Number(value);
        return Number.isFinite(fallback) ? fallback : null;
    }

    function coerceToNumber(value, fallback = 0) {
        const parsed = parseOptionalNumber(value);
        return parsed === null ? fallback : parsed;
    }

    function getProductionOrderStatusBadge(status = 'planejada') {
        const statusMap = {
            'planejada': { label: 'Planejada', className: 'bg-sky-100 text-sky-700' },
            'em_andamento': { label: 'Em andamento', className: 'bg-amber-100 text-amber-700' },
            'concluida': { label: 'Concluída', className: 'bg-emerald-100 text-emerald-700' },
            'cancelada': { label: 'Cancelada', className: 'bg-red-100 text-red-700' }
        };

        const safeStatus = statusMap[status] || statusMap['planejada'];
        return `<span class="px-2 py-1 rounded-full text-xs font-semibold ${safeStatus.className}">${safeStatus.label}</span>`;
    }

    function setProductionOrderStatus(message = '', type = 'info') {
        if (!productionOrderStatusMessage) return;

        if (!message) {
            productionOrderStatusMessage.textContent = '';
            productionOrderStatusMessage.className = 'text-sm font-semibold h-5 text-center';
            return;
        }

        const baseClasses = 'text-sm font-semibold h-5 text-center';
        const typeClass = type === 'success'
            ? 'text-status-success'
            : type === 'error'
                ? 'text-status-error'
                : 'text-gray-600';

        productionOrderStatusMessage.textContent = message;
        productionOrderStatusMessage.className = `${baseClasses} ${typeClass}`;
    }

    function populateOrdersFilterMachine() {
        if (!ordersFilterMachine) return;

        const machineSet = new Set();
        if (Array.isArray(productionOrdersCache)) {
            productionOrdersCache.forEach(order => {
                const machineId = (order.machine_id || order.machine || '').trim();
                if (machineId) machineSet.add(machineId);
            });
        }

        const currentValue = ordersFilterMachine.value;
        ordersFilterMachine.innerHTML = '<option value="">Todas as máquinas</option>';

        Array.from(machineSet).sort().forEach(machineId => {
            const option = document.createElement('option');
            option.value = machineId;
            option.textContent = machineId;
            ordersFilterMachine.appendChild(option);
        });

        if (currentValue && Array.from(ordersFilterMachine.options).some(opt => opt.value === currentValue)) {
            ordersFilterMachine.value = currentValue;
        }
    }

    function applyOrdersFilters() {
        if (!Array.isArray(productionOrdersCache)) {
            renderProductionOrdersTable([]);
            return;
        }

        const machineFilter = (ordersFilterMachine?.value || '').trim();
        const statusFilter = (ordersFilterStatus?.value || '').trim();
        const searchFilter = (ordersFilterSearch?.value || '').trim().toLowerCase();

        let result = [...productionOrdersCache];

        if (machineFilter) {
            result = result.filter(order => {
                const machineId = (order.machine_id || order.machine || '').trim();
                return machineId === machineFilter;
            });
        }

        if (statusFilter) {
            result = result.filter(order => (order.status || '').trim() === statusFilter);
        }

        if (searchFilter) {
            result = result.filter(order => {
                const parts = [
                    order.order_number || order.orderNumber || '',
                    order.product || order.product_name || '',
                    order.customer || order.client || '',
                    order.part_code || order.product_cod || ''
                ];
                return parts.some(p => String(p).toLowerCase().includes(searchFilter));
            });
        }

        filteredProductionOrders = result;
        populateOrdersFilterMachine();
        renderProductionOrdersTable(filteredProductionOrders);
    }

    function initOrdersFilters() {
        if (!ordersFilterMachine && !ordersFilterStatus && !ordersFilterSearch) return;

        if (ordersFilterMachine) {
            ordersFilterMachine.addEventListener('change', () => {
                applyOrdersFilters();
            });
        }

        if (ordersFilterStatus) {
            ordersFilterStatus.addEventListener('change', () => {
                applyOrdersFilters();
            });
        }

        if (ordersFilterSearch) {
            let searchTimeout;
            ordersFilterSearch.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyOrdersFilters();
                }, 250);
            });
        }

        applyOrdersFilters();
    }

    function renderProductionOrdersTable(orders = []) {
        if (!productionOrderTableBody) return;

        if (!Array.isArray(orders) || orders.length === 0) {
            productionOrderTableBody.innerHTML = '';
            if (productionOrderEmptyState) {
                productionOrderEmptyState.style.display = 'block';
            }
            return;
        }

        const rows = orders.map(order => {
            const orderNumber = escapeHtml(order.order_number || order.orderNumber || '-');
            const productName = escapeHtml(order.product || order.product_name || '-');
            const customer = escapeHtml(order.customer || order.client || '-');
            const productCode = escapeHtml(order.part_code || order.product_cod || '-');
            const lotSizeNumber = parseOptionalNumber(order.lot_size || order.lotSize);
            const lotSizeDisplay = Number.isFinite(lotSizeNumber) && lotSizeNumber > 0
                ? lotSizeNumber.toLocaleString('pt-BR')
                : '-';
            const statusBadge = getProductionOrderStatusBadge(order.status);
            const createdAt = order.createdAt?.toDate ? order.createdAt.toDate() : null;
            const createdAtLabel = createdAt ? createdAt.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' }) : '-';

            return `
                <tr class="odd:bg-white even:bg-gray-50" data-order-id="${escapeHtml(order.id || '')}">
                    <td class="px-3 py-2 text-sm border align-middle font-semibold text-gray-800">${orderNumber}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-gray-700">${productName}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-gray-700">${customer}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-gray-700">${productCode}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-center text-gray-700">${lotSizeDisplay}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-center">${statusBadge}</td>
                    <td class="px-3 py-2 text-sm border align-middle">
                        <div class="flex items-center justify-center gap-2 text-gray-400">
                            <i data-lucide="clock" class="w-4 h-4"></i>
                            <span class="text-xs font-medium">${createdAtLabel}</span>
                        </div>
                    </td>
                    <td class="px-3 py-2 text-sm border align-middle">
                        <div class="flex items-center justify-center gap-1 flex-wrap">
                            <button type="button" class="edit-production-order p-1.5 text-blue-600 hover:bg-blue-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Editar ordem">
                                <i data-lucide="edit-2" class="w-4 h-4"></i>
                            </button>
                            ${order.status === 'ativa' ? `
                                <button type="button" class="finish-production-order p-1.5 text-green-600 hover:bg-green-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Finalizar OP">
                                    <i data-lucide="check-circle" class="w-4 h-4"></i>
                                </button>
                            ` : order.status !== 'concluida' ? `
                                <button type="button" class="activate-production-order p-1.5 text-green-600 hover:bg-green-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" data-machine-id="${escapeHtml(order.machine_id || '')}" title="Ativar OP">
                                    <i data-lucide="play-circle" class="w-4 h-4"></i>
                                </button>
                            ` : ''}
                            <button type="button" class="adjust-quantity-order p-1.5 text-yellow-600 hover:bg-yellow-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Ajustar quantidade">
                                <i data-lucide="package-minus" class="w-4 h-4"></i>
                            </button>
                            ${order.status !== 'ativa' ? `
                                <button type="button" class="delete-production-order p-1.5 text-red-600 hover:bg-red-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Excluir ordem">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                            ` : ''}
                        </div>
                    </td>
                </tr>
            `;
        }).join('');

        productionOrderTableBody.innerHTML = rows;
        if (productionOrderEmptyState) {
            productionOrderEmptyState.style.display = 'none';
        }

        // Adicionar listeners para todos os botões da tabela
        document.querySelectorAll('.edit-production-order').forEach(btn => {
            btn.addEventListener('click', handleEditProductionOrder);
        });
        document.querySelectorAll('.activate-production-order').forEach(btn => {
            btn.addEventListener('click', handleActivateProductionOrder);
        });
        document.querySelectorAll('.finish-production-order').forEach(btn => {
            btn.addEventListener('click', handleFinishProductionOrder);
        });
        document.querySelectorAll('.adjust-quantity-order').forEach(btn => {
            btn.addEventListener('click', handleAdjustQuantityOrder);
        });
        document.querySelectorAll('.delete-production-order').forEach(btn => {
            btn.addEventListener('click', handleDeleteProductionOrder);
        });

        lucide.createIcons();
    }

    function handleEditProductionOrder(e) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar ordens
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('editar ordens de produção');
            return;
        }
        
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);
        if (!order) return;

        // Preencher form com dados da ordem para edição
        if (productionOrderForm) {
            document.getElementById('order-number').value = order.order_number || '';
            document.getElementById('order-product').value = order.product || '';
            document.getElementById('order-lot-size').value = order.lot_size || '';
            document.getElementById('order-batch').value = order.batch_number || '';
            document.getElementById('order-customer-order').value = order.customer_order || '';
            document.getElementById('order-customer').value = order.customer || '';
            document.getElementById('order-part-code').value = order.part_code || '';
            document.getElementById('order-packaging-qty').value = order.packaging_qty || '';
            document.getElementById('order-internal-packaging-qty').value = order.internal_packaging_qty || '';
            document.getElementById('order-raw-material').value = order.raw_material || '';

            // Salvar ID para update
            productionOrderForm.dataset.editingOrderId = orderId;

            // Mudar texto do botão
            const submitButton = productionOrderForm.querySelector('button[type="submit"]');
            if (submitButton) {
                submitButton.innerHTML = `<i data-lucide="save"></i><span>Salvar Alterações</span>`;
            }

            // Scroll para o formulário
            productionOrderForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
            lucide.createIcons();
        }
    }

    async function handleActivateProductionOrder(e) {
        e.preventDefault();
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);
        let machineId = e.currentTarget.dataset.machineId || order?.machine_id || selectedMachineData?.machine || '';

        if (!order) {
            alert('Dados da ordem não encontrados.');
            return;
        }

        if (!machineId) {
            const input = prompt('Informe a máquina para ativar esta OP (ex.: H-01):');
            if (!input) return;
            machineId = input.trim();
        }

        try {
            setProductionOrderStatus('Ativando ordem...', 'info');
            const success = await setOrderAsActive(orderId, machineId);
            
            if (success) {
                setProductionOrderStatus('Ordem ativada com sucesso!', 'success');
                
                // Registrar log
                registrarLogSistema('ATIVAÇÃO DE ORDEM', 'ordem', {
                    orderId: orderId,
                    orderNumber: order.order_number || order.codigoOP,
                    machine: machineId
                });
                
                // Atualizar listas e painel
                if (typeof loadProductionOrders === 'function') {
                    await loadProductionOrders();
                }
                await populateMachineSelector();
                if (selectedMachineData?.machine) {
                    await onMachineSelected(selectedMachineData.machine);
                }
                setTimeout(() => setProductionOrderStatus('', 'info'), 2000);
            } else {
                setProductionOrderStatus('Operação cancelada ou erro.', 'error');
            }
        } catch (error) {
            console.error('Erro ao ativar ordem:', error);
            setProductionOrderStatus('Erro ao ativar ordem. Tente novamente.', 'error');
        }
    }

    async function handleFinishProductionOrder(e) {
        e.preventDefault();
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);

        if (!order) {
            alert('Ordem não encontrada.');
            return;
        }

        try {
            setProductionOrderStatus('Finalizando ordem...', 'info');
            const success = await finishActiveOrder(orderId);
            
            if (success) {
                setProductionOrderStatus('Ordem finalizada com sucesso!', 'success');
                setTimeout(() => setProductionOrderStatus('', 'info'), 2000);
                
                // Registrar log
                registrarLogSistema('FINALIZAÇÃO DE ORDEM', 'ordem', {
                    orderId: orderId,
                    codigoOP: order.codigoOP || order.opNumber,
                    produto: order.produto || order.productName
                });
            } else {
                setProductionOrderStatus('Operação cancelada.', 'info');
            }
        } catch (error) {
            console.error('Erro ao finalizar ordem:', error);
            setProductionOrderStatus('Erro ao finalizar ordem. Tente novamente.', 'error');
        }
    }

    async function handleDeleteProductionOrder(e) {
        e.preventDefault();
        
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir ordens
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir ordens de produção');
            return;
        }
        
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);

        if (!order) return;

        if (order.status === 'ativa') {
            alert('Não é possível excluir uma OP ativa. Finalize a OP primeiro.');
            return;
        }

        if (!confirm(`Tem certeza que deseja excluir a OP "${order.order_number}"?`)) {
            return;
        }

        try {
            setProductionOrderStatus('Excluindo ordem...', 'info');
            await db.collection('production_orders').doc(orderId).delete();
            setProductionOrderStatus('Ordem excluída com sucesso!', 'success');
            setTimeout(() => setProductionOrderStatus('', 'info'), 2000);
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE ORDEM', 'ordem', {
                orderId: orderId,
                orderNumber: order.order_number,
                produto: order.produto || order.productName
            });
        } catch (error) {
            console.error('Erro ao excluir ordem:', error);
            setProductionOrderStatus('Erro ao excluir ordem. Tente novamente.', 'error');
        }
    }

    // =========================================================================
    // AJUSTE DE QUANTIDADE EXECUTADA DO PLANEJAMENTO
    // =========================================================================
    
    function openAdjustExecutedModal() {
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Verificar permissão
        if (!window.authSystem?.checkPermissionForAction('adjust_executed')) {
            showPermissionDeniedNotification('ajustar quantidade executada');
            return;
        }

        const modal = document.getElementById('adjust-executed-modal');
        if (!modal) return;

        const machineSpan = document.getElementById('adjust-exec-machine');
        const productSpan = document.getElementById('adjust-exec-product');
        const plannedSpan = document.getElementById('adjust-exec-planned');
        const currentSpan = document.getElementById('adjust-exec-current');
        const newQtyInput = document.getElementById('adjust-exec-new-qty');
        const diffDiv = document.getElementById('adjust-exec-diff');
        const reasonSelect = document.getElementById('adjust-exec-reason');
        const obsInput = document.getElementById('adjust-exec-obs');
        const statusDiv = document.getElementById('adjust-executed-status');

        // Calcular quantidade atual baseado nos entries (fonte única de verdade)
        const planId = selectedMachineData.id;
        const currentExecuted = Math.round(coerceToNumber(selectedMachineData.totalProduced, 0));
        // CORREÇÃO: Usar planned_quantity (meta diária) primeiro, não lot_size (tamanho total OP)
        const plannedQty = Math.round(coerceToNumber(
            selectedMachineData.planned_quantity ?? selectedMachineData.planned_qty ?? selectedMachineData.meta, 0
        ));

        // Preencher informações
        if (machineSpan) machineSpan.textContent = selectedMachineData.machine || '-';
        if (productSpan) productSpan.textContent = selectedMachineData.product || '-';
        if (plannedSpan) plannedSpan.textContent = plannedQty.toLocaleString('pt-BR');
        if (currentSpan) currentSpan.textContent = currentExecuted.toLocaleString('pt-BR');
        
        // Limpar campos
        if (newQtyInput) {
            newQtyInput.value = currentExecuted;
            newQtyInput.dataset.currentQty = currentExecuted.toString();
            newQtyInput.dataset.planId = planId;
        }
        if (diffDiv) diffDiv.textContent = '';
        if (reasonSelect) reasonSelect.value = '';
        if (obsInput) obsInput.value = '';
        if (statusDiv) statusDiv.textContent = '';

        // Listener para mostrar diferença em tempo real
        if (newQtyInput) {
            newQtyInput.removeEventListener('input', updateAdjustExecutedDiff);
            newQtyInput.addEventListener('input', updateAdjustExecutedDiff);
        }

        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    function updateAdjustExecutedDiff() {
        const newQtyInput = document.getElementById('adjust-exec-new-qty');
        const diffDiv = document.getElementById('adjust-exec-diff');
        
        if (!newQtyInput || !diffDiv) return;

        const currentQty = parseInt(newQtyInput.dataset.currentQty || '0');
        const newQty = parseInt(newQtyInput.value || '0');
        const diff = newQty - currentQty;

        if (diff === 0) {
            diffDiv.textContent = 'Sem alteração';
            diffDiv.className = 'mt-1 text-xs text-gray-500';
        } else if (diff > 0) {
            diffDiv.textContent = `+${diff.toLocaleString('pt-BR')} peças (aumento)`;
            diffDiv.className = 'mt-1 text-xs text-green-600 font-medium';
        } else {
            diffDiv.textContent = `${diff.toLocaleString('pt-BR')} peças (redução)`;
            diffDiv.className = 'mt-1 text-xs text-orange-600 font-medium';
        }
    }

    function closeAdjustExecutedModal() {
        const modal = document.getElementById('adjust-executed-modal');
        if (modal) modal.classList.add('hidden');
    }

    async function handleAdjustExecutedSubmit(e) {
        e.preventDefault();

        const newQtyInput = document.getElementById('adjust-exec-new-qty');
        const reasonSelect = document.getElementById('adjust-exec-reason');
        const obsInput = document.getElementById('adjust-exec-obs');
        const statusDiv = document.getElementById('adjust-executed-status');
        const submitBtn = document.getElementById('adjust-executed-save');

        const planId = newQtyInput?.dataset.planId;
        const currentQty = parseInt(newQtyInput?.dataset.currentQty || '0');
        const newQty = parseInt(newQtyInput?.value || '0');
        const reason = reasonSelect?.value;
        const observations = obsInput?.value?.trim() || '';

        if (!planId) {
            alert('Erro interno: planejamento não identificado.');
            return;
        }

        if (newQty < 0) {
            alert('A quantidade executada não pode ser negativa.');
            return;
        }

        if (!reason) {
            alert('Por favor, selecione o motivo do ajuste.');
            return;
        }

        const diff = newQty - currentQty;
        if (diff === 0) {
            alert('A quantidade informada é igual à atual. Nenhuma alteração necessária.');
            return;
        }

        // Confirmar alteração
        const confirmMsg = diff > 0
            ? `Confirma o AUMENTO de ${diff.toLocaleString('pt-BR')} peças?\n\nDe: ${currentQty.toLocaleString('pt-BR')}\nPara: ${newQty.toLocaleString('pt-BR')}`
            : `Confirma a REDUÇÃO de ${Math.abs(diff).toLocaleString('pt-BR')} peças?\n\nDe: ${currentQty.toLocaleString('pt-BR')}\nPara: ${newQty.toLocaleString('pt-BR')}`;
        
        if (!confirm(confirmMsg)) return;

        try {
            if (submitBtn) submitBtn.disabled = true;
            if (statusDiv) {
                statusDiv.textContent = 'Processando ajuste...';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-blue-600';
            }

            const currentUser = getActiveUser();
            const now = new Date();

            // Criar registro de ajuste como entry especial
            const adjustmentEntry = {
                type: 'adjustment',
                planId: planId,
                machine: selectedMachineData.machine,
                product: selectedMachineData.product || '',
                product_cod: selectedMachineData.product_cod || '',
                previousQuantity: currentQty,
                newQuantity: newQty,
                adjustmentQty: diff,
                reason: reason,
                observations: observations,
                turno: getCurrentShift(),
                data: now.toISOString().split('T')[0],
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                adjustedBy: currentUser?.username || 'desconhecido',
                adjustedByName: currentUser?.name || 'Desconhecido',
                isManualAdjustment: true
            };

            // Salvar registro do ajuste na collection de entries
            await db.collection('production_entries').add(adjustmentEntry);

            // Atualizar o planejamento com a nova quantidade
            await db.collection('planning').doc(planId).update({
                total_produzido: newQty,
                totalProduced: newQty,
                lastManualAdjustment: {
                    previousValue: currentQty,
                    newValue: newQty,
                    diff: diff,
                    reason: reason,
                    observations: observations,
                    adjustedBy: currentUser?.username || 'desconhecido',
                    adjustedByName: currentUser?.name || 'Desconhecido',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                },
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            console.log(`[AUDIT] ${currentUser?.name || 'Desconhecido'} ajustou quantidade executada do planejamento ${planId}: ${currentQty} → ${newQty} (${diff > 0 ? '+' : ''}${diff}) - Motivo: ${reason}`);

            // Registrar log do ajuste
            registrarLogSistema('AJUSTE DE QUANTIDADE EXECUTADA', 'planejamento', {
                planId: planId,
                machine: selectedMachineData?.machine,
                previousQty: currentQty,
                newQty: newQty,
                diff: diff,
                motivo: reason,
                observacoes: observations
            });

            if (statusDiv) {
                statusDiv.textContent = 'Ajuste aplicado com sucesso!';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-green-600';
            }

            showNotification(`Quantidade ajustada: ${currentQty.toLocaleString('pt-BR')} → ${newQty.toLocaleString('pt-BR')}`, 'success');

            // Fechar modal após 1.5 segundos
            setTimeout(() => {
                closeAdjustExecutedModal();
                // Forçar atualização do dashboard
                if (typeof updateDashboard === 'function') {
                    updateDashboard();
                }
            }, 1500);

        } catch (error) {
            console.error('Erro ao ajustar quantidade executada:', error);
            if (statusDiv) {
                statusDiv.textContent = 'Erro ao aplicar ajuste. Tente novamente.';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
            }
            showNotification('Erro ao aplicar ajuste', 'error');
        } finally {
            if (submitBtn) submitBtn.disabled = false;
        }
    }

    // Inicializar listeners do modal de ajuste de quantidade executada
    function initAdjustExecutedModal() {
        const closeBtn = document.getElementById('adjust-executed-close');
        const cancelBtn = document.getElementById('adjust-executed-cancel');
        const form = document.getElementById('adjust-executed-form');

        if (closeBtn) closeBtn.addEventListener('click', closeAdjustExecutedModal);
        if (cancelBtn) cancelBtn.addEventListener('click', closeAdjustExecutedModal);
        if (form) form.addEventListener('submit', handleAdjustExecutedSubmit);
    }

    function handleAdjustQuantityOrder(e) {
        e.preventDefault();
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);

        if (!order) {
            alert('Ordem de produção não encontrada.');
            return;
        }

        showAdjustQuantityModal(order);
    }

    function showAdjustQuantityModal(order) {
        const modal = document.getElementById('adjust-quantity-modal');
        const opNumberSpan = document.getElementById('adjust-op-number');
        const opProductSpan = document.getElementById('adjust-op-product');
        const opOriginalQtySpan = document.getElementById('adjust-op-original-qty');
        const reductionInput = document.getElementById('adjust-reduction-qty');
        const reasonSelect = document.getElementById('adjust-reason');
        const observationsInput = document.getElementById('adjust-observations');
        const finalQtySpan = document.getElementById('adjust-final-qty');
        const statusDiv = document.getElementById('adjust-quantity-status');

        if (!modal) return;

        // Preencher informações da OP
        if (opNumberSpan) opNumberSpan.textContent = order.order_number || '-';
        if (opProductSpan) opProductSpan.textContent = order.product || '-';
        
        const originalQty = parseOptionalNumber(order.lot_size || order.lotSize) || 0;
        if (opOriginalQtySpan) opOriginalQtySpan.textContent = originalQty.toLocaleString('pt-BR');

        // Limpar campos
        if (reductionInput) reductionInput.value = '';
        if (reasonSelect) reasonSelect.value = '';
        if (observationsInput) observationsInput.value = '';
        if (finalQtySpan) finalQtySpan.textContent = originalQty.toLocaleString('pt-BR');
        if (statusDiv) statusDiv.textContent = '';

        // Armazenar dados da ordem para uso posterior
        modal.dataset.orderId = order.id;
        modal.dataset.originalQty = originalQty.toString();

        // Listener para cálculo em tempo real da quantidade final
        if (reductionInput) {
            reductionInput.addEventListener('input', updateFinalQuantity);
        }

        modal.classList.remove('hidden');
    }

    function updateFinalQuantity() {
        const modal = document.getElementById('adjust-quantity-modal');
        const reductionInput = document.getElementById('adjust-reduction-qty');
        const finalQtySpan = document.getElementById('adjust-final-qty');

        if (!modal || !reductionInput || !finalQtySpan) return;

        const originalQty = parseInt(modal.dataset.originalQty || '0');
        const adjustmentQty = parseInt(reductionInput.value || '0');
        const newQty = originalQty + adjustmentQty;

        // Mostrar a nova quantidade após o ajuste
        if (adjustmentQty !== 0) {
            const sign = adjustmentQty > 0 ? '+' : '';
            finalQtySpan.textContent = `${newQty.toLocaleString('pt-BR')} (${sign}${adjustmentQty.toLocaleString('pt-BR')})`;
        } else {
            finalQtySpan.textContent = originalQty.toLocaleString('pt-BR');
        }
        
        // Validação visual - não permitir quantidade final negativa
        if (newQty < 0) {
            finalQtySpan.className = 'text-lg font-bold text-red-600';
            reductionInput.style.borderColor = '#DC2626';
        } else if (adjustmentQty > 0) {
            finalQtySpan.className = 'text-lg font-bold text-green-600';
            reductionInput.style.borderColor = '#10B981';
        } else if (adjustmentQty < 0) {
            finalQtySpan.className = 'text-lg font-bold text-orange-600';
            reductionInput.style.borderColor = '#F59E0B';
        } else {
            finalQtySpan.className = 'text-lg font-bold text-blue-800';
            reductionInput.style.borderColor = '#D1D5DB';
        }
    }

    function closeAdjustQuantityModal() {
        const modal = document.getElementById('adjust-quantity-modal');
        const reductionInput = document.getElementById('adjust-reduction-qty');
        
        if (modal) {
            modal.classList.add('hidden');
            modal.removeAttribute('data-order-id');
            modal.removeAttribute('data-original-qty');
        }
        
        // Remover listener temporário
        if (reductionInput) {
            reductionInput.removeEventListener('input', updateFinalQuantity);
        }
    }

    async function handleAdjustQuantitySubmit(e) {
        e.preventDefault();

        const modal = document.getElementById('adjust-quantity-modal');
        const orderId = modal?.dataset.orderId;
        const originalQty = parseInt(modal?.dataset.originalQty || '0');
        
        const reductionInput = document.getElementById('adjust-reduction-qty');
        const reasonSelect = document.getElementById('adjust-reason');
        const observationsInput = document.getElementById('adjust-observations');
        const statusDiv = document.getElementById('adjust-quantity-status');
        const submitButton = document.getElementById('adjust-quantity-save');

        if (!orderId) {
            alert('Erro interno: ID da ordem não encontrado.');
            return;
        }

        const adjustmentQty = parseInt(reductionInput?.value || '0');
        const reason = reasonSelect?.value || '';
        const observations = (observationsInput?.value || '').trim();

        // Validações
        if (!adjustmentQty || adjustmentQty === 0) {
            alert('Informe um valor válido para o ajuste (positivo para aumentar, negativo para reduzir).');
            if (reductionInput) reductionInput.focus();
            return;
        }

        const finalQty = originalQty + adjustmentQty;

        if (finalQty < 0) {
            alert('A quantidade final não pode ser negativa. Ajuste inválido.');
            if (reductionInput) reductionInput.focus();
            return;
        }

        if (!reason) {
            alert('Selecione o motivo do ajuste.');
            if (reasonSelect) reasonSelect.focus();
            return;
        }

        try {
            if (statusDiv) statusDiv.textContent = 'Aplicando ajuste...';
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.textContent = 'Aplicando...';
            }

            // Criar registro do ajuste (para o array, sem serverTimestamp)
            const adjustmentRecordForArray = {
                orderId: orderId,
                originalQuantity: originalQty,
                adjustmentQuantity: adjustmentQty,
                finalQuantity: finalQty,
                adjustmentType: adjustmentQty > 0 ? 'increase' : 'decrease',
                reason: reason,
                observations: observations,
                adjustedBy: getActiveUser()?.name || 'Sistema',
                adjustedAt: new Date().toISOString(),
                workDay: new Date().toISOString().split('T')[0]
            };

            // Criar registro do ajuste (para coleção separada, com serverTimestamp)
            const adjustmentRecordForCollection = {
                ...adjustmentRecordForArray,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            };

            // Salvar registro do ajuste na coleção
            await db.collection('quantity_adjustments').add(adjustmentRecordForCollection);

            // Atualizar a quantidade do lote (lot_size) da OP
            const currentOrder = await db.collection('production_orders').doc(orderId).get();
            const orderData = currentOrder.data();
            const currentAdjustments = orderData.quantity_adjustments || [];
            
            await db.collection('production_orders').doc(orderId).update({
                lot_size: finalQty,
                quantity_adjustments: [...currentAdjustments, adjustmentRecordForArray],
                total_adjustments: (orderData.total_adjustments || 0) + adjustmentQty,
                lastQuantityAdjustment: adjustmentRecordForArray,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            if (statusDiv) {
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-green-600';
                statusDiv.textContent = 'Ajuste aplicado com sucesso!';
            }
            
            // Após ajuste de quantidade, garantir que os cards de máquina e o painel de lançamento
            // reflitam o novo tamanho de lote da OP
            listenToProductionOrders();
            await populateMachineSelector();

            if (selectedMachineData && selectedMachineData.machine) {
                const machine = selectedMachineData.machine;
                // machineCardData agora é array - pegar primeiro plano para compatibilidade
                const machineDataArray = machineCardData[machine];
                const updatedMachineData = Array.isArray(machineDataArray) ? machineDataArray[0] : (machineDataArray || machineSelector?.machineData?.[machine]);
                if (updatedMachineData) {
                    selectedMachineData = updatedMachineData;
                    updateMachineInfo();
                }
            }
            
            setTimeout(() => {
                closeAdjustQuantityModal();
            }, 1500);

        } catch (error) {
            console.error('Erro ao aplicar ajuste de quantidade:', error);
            if (statusDiv) {
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                statusDiv.textContent = 'Erro ao aplicar ajuste. Tente novamente.';
            }
        } finally {
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Aplicar Ajuste';
            }
        }
    }

    // Funções para controle de OP ativa na máquina
    async function checkActiveOrderOnMachine(machineId) {
        try {
            if (!machineId) return null;

            const snapshot = await db.collection('production_orders')
                .where('machine_id', '==', machineId)
                .where('status', '==', 'ativa')
                .limit(1)
                .get();

            if (snapshot.empty) return null;

            const doc = snapshot.docs[0];
            const data = doc.data();

            return { id: doc.id, ...data };
        } catch (error) {
            console.error('Erro ao verificar OP ativa na máquina:', error);
            return null;
        }
    }

    // Sincronizar selectedMachineData com a OP ativa antes de atualizar o card
    async function syncSelectedMachineWithActiveOrder() {
        try {
            if (!selectedMachineData || !selectedMachineData.machine) return;

            const activeOrder = await checkActiveOrderOnMachine(selectedMachineData.machine);
            if (!activeOrder) {
                return;
            }
            // Carregar lançamentos desta OP para aplicar a mesma regra da análise
            const productionSnapshot = await db.collection('production_entries')
                .where('orderId', '==', activeOrder.id)
                .get();

            const productionTotalsByOrderId = new Map();
            let aggregate = 0;
            productionSnapshot.docs.forEach(doc => {
                const data = doc.data();
                const producedQty = coerceToNumber(data.produzido ?? data.quantity, 0);
                if (Number.isFinite(producedQty) && producedQty > 0) {
                    aggregate += producedQty;
                }
            });
            productionTotalsByOrderId.set(activeOrder.id, aggregate);

            const metrics = computeOrderExecutionMetrics(activeOrder, productionTotalsByOrderId);

            selectedMachineData = {
                ...selectedMachineData,
                order_id: activeOrder.id || activeOrder.order_id || selectedMachineData.order_id,
                orderId: activeOrder.id || activeOrder.orderId || selectedMachineData.orderId,
                order_lot_size: metrics.lotSize,
                lot_size: metrics.lotSize,
                total_produzido: metrics.totalProduced,
                totalProduced: metrics.totalProduced
            };

            console.log('[SYNC-ORDER] selectedMachineData sincronizado com OP ativa', {
                machine: selectedMachineData.machine,
                order_id: selectedMachineData.order_id,
                lot_size: selectedMachineData.order_lot_size,
                total_produzido: selectedMachineData.total_produzido
            });
        } catch (error) {
            console.error('Erro ao sincronizar máquina com OP ativa:', error);
        }
    }

    async function setOrderAsActive(orderId, machineId) {
        try {
            // Verificar se já existe OP ativa na máquina
            const activeOrder = await checkActiveOrderOnMachine(machineId);
            
            if (activeOrder && activeOrder.id !== orderId) {
                const confirmChange = confirm(
                    `A máquina ${machineId} já possui a OP "${activeOrder.order_number}" ativa.\n\n` +
                    `Deseja finalizar a OP atual e ativar a nova OP?\n\n` +
                    `⚠️ IMPORTANTE: Certifique-se de que todas as quantidades da OP atual estão corretas antes de continuar.`
                );
                
                if (!confirmChange) {
                    return false;
                }
                
                // Finalizar OP atual
                await db.collection('production_orders').doc(activeOrder.id).update({
                    status: 'concluida',
                    finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    finishedBy: getActiveUser()?.name || 'Sistema'
                });
            }
            
            // Ativar nova OP
            await db.collection('production_orders').doc(orderId).update({
                status: 'ativa',
                machine_id: machineId,
                startedAt: firebase.firestore.FieldValue.serverTimestamp(),
                startedBy: getActiveUser()?.name || 'Sistema'
            });
            
            return true;
        } catch (error) {
            console.error('Erro ao ativar OP na máquina:', error);
            return false;
        }
    }

    async function finishActiveOrder(orderId) {
        try {
            const confirmFinish = confirm(
                `Deseja finalizar esta Ordem de Produção?\n\n` +
                `⚠️ IMPORTANTE: Certifique-se de que todas as quantidades produzidas estão corretas.\n` +
                `Após finalizar, uma nova OP poderá ser ativada na máquina.`
            );
            
            if (!confirmFinish) {
                return false;
            }
            
            await db.collection('production_orders').doc(orderId).update({
                status: 'concluida',
                finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                finishedBy: getActiveUser()?.name || 'Sistema'
            });
            
            return true;
        } catch (error) {
            console.error('Erro ao finalizar OP:', error);
            return false;
        }
    }

    /**
     * Verifica e restaura paradas ativas do Firebase
     * Chamada ao selecionar uma máquina ou ao recarregar a página
     */
    async function checkActiveDowntimes() {
        if (!db || !selectedMachineData) {
            console.log('[DOWNTIME][CHECK] Nenhuma máquina selecionada ou DB indisponível');
            return;
        }
        
        try {
            const activeDowntimeDoc = await db.collection('active_downtimes').doc(selectedMachineData.machine).get();
            
            if (activeDowntimeDoc.exists) {
                const activeDowntime = activeDowntimeDoc.data();
                console.log('[DOWNTIME][CHECK] Parada ativa encontrada:', activeDowntime);
                
                // Validar dados mínimos
                if (!activeDowntime.machine || !activeDowntime.startDate || !activeDowntime.startTime) {
                    console.warn('[DOWNTIME][CHECK] Dados de parada ativa incompletos, removendo...');
                    const normalizedMachineForDelete = normalizeMachineId(selectedMachineData.machine);
                    await db.collection('active_downtimes').doc(normalizedMachineForDelete).delete();
                    return;
                }
                
                // Reconstruir timestamp de início
                let startTimestamp;
                if (activeDowntime.startTimestamp?.toDate) {
                    startTimestamp = activeDowntime.startTimestamp.toDate();
                } else if (activeDowntime.startTimestampLocal) {
                    startTimestamp = new Date(activeDowntime.startTimestampLocal);
                } else {
                    // Fallback: reconstruir a partir de date + time
                    startTimestamp = parseDateTime(activeDowntime.startDate, activeDowntime.startTime);
                }
                
                if (!startTimestamp || isNaN(startTimestamp.getTime())) {
                    console.warn('[DOWNTIME][CHECK] Timestamp de início inválido, removendo parada...');
                    const normalizedMachineForDelete = normalizeMachineId(selectedMachineData.machine);
                    await db.collection('active_downtimes').doc(normalizedMachineForDelete).delete();
                    return;
                }
                
                // Verificar se a parada é muito antiga (mais de 7 dias)
                const now = new Date();
                const elapsedMs = now.getTime() - startTimestamp.getTime();
                const elapsedDays = elapsedMs / (1000 * 60 * 60 * 24);
                
                if (elapsedDays > 7) {
                    console.warn(`[DOWNTIME][CHECK] Parada muito antiga (${elapsedDays.toFixed(1)} dias), requer atenção especial`);
                    // Mostrar alerta para o usuário
                    const confirmar = confirm(
                        `⚠️ Parada Muito Longa Detectada!\n\n` +
                        `Máquina: ${activeDowntime.machine}\n` +
                        `Iniciada em: ${activeDowntime.startDate} às ${activeDowntime.startTime}\n` +
                        `Duração: ${elapsedDays.toFixed(1)} dias\n\n` +
                        `Deseja restaurar esta parada? Se não, ela será removida.`
                    );
                    
                    if (!confirmar) {
                        const normalizedMachineForDelete = normalizeMachineId(selectedMachineData.machine);
                        await db.collection('active_downtimes').doc(normalizedMachineForDelete).delete();
                        console.log('[DOWNTIME][CHECK] Parada antiga removida pelo usuário');
                        return;
                    }
                }
                
                // Restaurar estado da parada
                currentDowntimeStart = {
                    machine: activeDowntime.machine,
                    date: activeDowntime.startDate,
                    startTime: activeDowntime.startTime,
                    startTimestamp: startTimestamp,
                    startTimestampLocal: startTimestamp.toISOString(),
                    startShift: activeDowntime.startShift || getShiftForDateTime(startTimestamp),
                    // Motivo e observações
                    reason: activeDowntime.reason || null,
                    observations: activeDowntime.observations || '',
                    // Dados do operador
                    userCod: activeDowntime.userCod ?? null,
                    nomeUsuario: activeDowntime.nomeUsuario || null,
                    // Contexto de produção
                    product: activeDowntime.product || null,
                    productCod: activeDowntime.productCod || null,
                    orderId: activeDowntime.orderId || null,
                    orderNumber: activeDowntime.orderNumber || null
                };
                
                machineStatus = 'stopped';
                updateMachineStatus();
                freezeProductionTimer();
                startDowntimeTimer();
                
                // Calcular tempo decorrido para exibição
                const elapsedHours = (elapsedMs / (1000 * 60 * 60)).toFixed(1);
                const elapsedMinutes = Math.floor((elapsedMs / 60000) % 60);
                
                let durationText;
                if (elapsedDays >= 1) {
                    durationText = `${Math.floor(elapsedDays)}d ${Math.floor((elapsedMs / 3600000) % 24)}h`;
                } else if (parseFloat(elapsedHours) >= 1) {
                    durationText = `${elapsedHours}h`;
                } else {
                    durationText = `${elapsedMinutes} min`;
                }
                
                showNotification(`⏱️ Parada ativa restaurada! Tempo decorrido: ${durationText}`, 'warning');
                
                console.log('[DOWNTIME][CHECK] Estado da parada restaurado:', {
                    machine: activeDowntime.machine,
                    duration: durationText,
                    startedAt: activeDowntime.startDate + ' ' + activeDowntime.startTime
                });
            } else {
                console.log('[DOWNTIME][CHECK] Nenhuma parada ativa para:', selectedMachineData.machine);
            }
        } catch (error) {
            console.error('[DOWNTIME][CHECK] Erro ao verificar paradas ativas:', error);
        }
    }

    function listenToProductionOrders() {
        if (!db || !productionOrderTableBody) return;

        try {
            const query = db.collection('production_orders').orderBy('createdAt', 'desc');
            listenerManager.subscribe('productionOrders', query,
                (snapshot) => {
                    productionOrdersCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    
                    // Alimentar DataStore para evitar leituras repetidas
                    if (window.DataStore) {
                        window.DataStore.set('productionOrders', productionOrdersCache);
                    }
                    
                    applyOrdersFilters();
                    populatePlanningOrderSelect();
                    if (productionOrderStatusMessage && productionOrderStatusMessage.className.includes('text-status-error')) {
                        setProductionOrderStatus('', 'info');
                    }
                },
                (error) => {
                    console.error('Erro ao carregar ordens de produção:', error);
                    renderProductionOrdersTable([]);
                    setProductionOrderStatus('Não foi possível carregar as ordens de produção.', 'error');
                }
            );
        } catch (error) {
            console.error('Erro ao inicializar listener de ordens de produção:', error);
            setProductionOrderStatus('Erro ao iniciar monitoramento das ordens.', 'error');
        }
    }

    async function handleProductionOrderFormSubmit(event) {
        event.preventDefault();

        if (!productionOrderForm) return;

        if (!window.authSystem.checkPermissionForAction('create_production_order')) {
            return;
        }

        const formData = new FormData(productionOrderForm);
        const rawData = Object.fromEntries(formData.entries());

        const orderNumber = (rawData.order_number || '').trim();
        if (!orderNumber) {
            setProductionOrderStatus('Informe o número da OP antes de salvar.', 'error');
            return;
        }

        const normalizedOrderNumber = orderNumber.toUpperCase();

        const partCode = (rawData.part_code || '').trim();
        // Usar função helper com fallback seguro
        const matchedProduct = partCode ? getProductByCode(partCode) : null;

        const submitButton = productionOrderForm.querySelector('button[type="submit"]');
        const originalButtonContent = submitButton ? submitButton.innerHTML : '';

        try {
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.innerHTML = `<i data-lucide="loader-2" class="animate-spin"></i><span>Salvando...</span>`;
                lucide.createIcons();
            }

            setProductionOrderStatus('Salvando ordem de produção...', 'info');

            // CORREÇÃO: Validação de ordem duplicada considera agora apenas ordens ATIVAS
            // Uma ordem pode ser reutilizada em datas diferentes ou após finalização
            const existingSnapshot = await db.collection('production_orders')
                .where('order_number', '==', normalizedOrderNumber)
                .where('status', 'in', ['planejada', 'ativa', 'em_andamento'])  // Apenas ordens ativas
                .limit(1)
                .get();

            const editingOrderId = productionOrderForm.dataset.editingOrderId;

            if (!existingSnapshot.empty && !editingOrderId) {
                setProductionOrderStatus('Já existe uma ordem ATIVA com este número. Finalize-a ou use outro número.', 'error');
                return;
            }

            // Se estamos editando, validar se outro documento já tem esse número
            if (editingOrderId && !existingSnapshot.empty && existingSnapshot.docs[0].id !== editingOrderId) {
                setProductionOrderStatus('Já existe uma ordem ATIVA com este número.', 'error');
                return;
            }

            const docData = {
                order_number: normalizedOrderNumber,
                order_number_original: orderNumber,
                customer_order: (rawData.customer_order || '').trim(),
                customer: (rawData.customer || matchedProduct?.client || '').trim(),
                client: (rawData.customer || matchedProduct?.client || '').trim(),
                product: (rawData.product || matchedProduct?.name || '').trim(),
                part_code: partCode,
                product_cod: partCode,
                lot_size: parseOptionalNumber(rawData.lot_size),
                batch_number: (rawData.batch_number || '').trim(),
                packaging_qty: parseOptionalNumber(rawData.packaging_qty),
                internal_packaging_qty: parseOptionalNumber(rawData.internal_packaging_qty),
                raw_material: (rawData.raw_material || matchedProduct?.mp || '').trim(),
                machine_id: (rawData.machine_id || '').trim() || null,
                status: 'planejada',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            if (!editingOrderId) {
                docData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
            }

            if (matchedProduct) {
                docData.product_snapshot = {
                    cod: matchedProduct.cod,
                    client: matchedProduct.client || '',
                    name: matchedProduct.name || '',
                    cavities: parseOptionalNumber(matchedProduct.cavities),
                    cycle: parseOptionalNumber(matchedProduct.cycle),
                    weight: parseOptionalNumber(matchedProduct.weight),
                    mp: matchedProduct.mp || ''
                };
            }

            if (editingOrderId) {
                await db.collection('production_orders').doc(editingOrderId).update(docData);
                setProductionOrderStatus('Ordem atualizada com sucesso!', 'success');
                
                // Registrar log de edição
                registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: editingOrderId,
                    orderNumber: normalizedOrderNumber,
                    product: docData.product,
                    lotSize: docData.lot_size
                });
            } else {
                const docRef = await db.collection('production_orders').add(docData);
                setProductionOrderStatus('Ordem cadastrada com sucesso!', 'success');
                
                // Registrar log de criação
                registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: docRef.id,
                    orderNumber: normalizedOrderNumber,
                    product: docData.product,
                    lotSize: docData.lot_size
                });
            }

            productionOrderForm.reset();
            delete productionOrderForm.dataset.editingOrderId;
            clearProductionOrderAutoFields();
            setProductionOrderFeedback();

            if (submitButton) {
                submitButton.innerHTML = `<i data-lucide="plus-circle"></i><span>Cadastrar OP</span>`;
            }

            setTimeout(() => setProductionOrderStatus('', 'info'), 3000);
        } catch (error) {
            console.error('Erro ao cadastrar ordem de produção:', error);
            setProductionOrderStatus('Erro ao cadastrar ordem. Tente novamente.', 'error');
        } finally {
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.innerHTML = originalButtonContent;
                lucide.createIcons();
            }
        }
    }

    function onPlanningProductCodChange(e) {
        const input = e?.target;
        if (!input) return;

        const rawCode = (input.value || '').trim();
        // Usar função helper com fallback seguro
        const product = getProductByCode(rawCode);

        const cycleInput = document.getElementById('budgeted-cycle');
        const cavitiesInput = document.getElementById('mold-cavities');
        const weightInput = document.getElementById('piece-weight');
        const plannedQtyInput = document.getElementById('planned-quantity');
        const productNameDisplay = document.getElementById('product-name-display');
        const mpInput = planningMpInput || document.getElementById('planning-mp');

        const resetFields = () => {
            if (cycleInput) cycleInput.value = '';
            if (cavitiesInput) cavitiesInput.value = '';
            if (weightInput) weightInput.value = '';
            if (plannedQtyInput) plannedQtyInput.value = '';
            if (mpInput) mpInput.value = '';
        };

        const hideDisplay = () => {
            if (productNameDisplay) {
                productNameDisplay.textContent = '';
                productNameDisplay.style.display = 'none';
                productNameDisplay.classList.remove('text-red-600', 'bg-red-50');
                productNameDisplay.classList.add('text-primary-blue', 'bg-gray-50');
            }
        };

        if (product) {
            if (cycleInput) cycleInput.value = product.cycle || '';
            if (cavitiesInput) cavitiesInput.value = product.cavities || '';
            if (weightInput) weightInput.value = typeof product.weight === 'number' ? product.weight : '';
            if (mpInput) mpInput.value = product.mp || '';

            const cycle = Number(product.cycle) || 0;
            const cavities = Number(product.cavities) || 0;
            const plannedQty = cycle > 0 ? Math.floor((86400 / cycle) * cavities * 0.85) : 0;
            if (plannedQtyInput) plannedQtyInput.value = plannedQty;

            if (productNameDisplay) {
                productNameDisplay.textContent = `${product.name} (${product.client})`;
                productNameDisplay.style.display = 'block';
                productNameDisplay.classList.remove('text-red-600', 'bg-red-50');
                productNameDisplay.classList.add('text-primary-blue', 'bg-gray-50');
            }
            return;
        }

        // Caso sem produto encontrado
        resetFields();

        if (!rawCode) {
            hideDisplay();
            return;
        }

        if (productNameDisplay && e.type !== 'input') {
            productNameDisplay.textContent = 'Produto não encontrado';
            productNameDisplay.style.display = 'block';
            productNameDisplay.classList.remove('text-primary-blue', 'bg-gray-50');
            productNameDisplay.classList.add('text-red-600', 'bg-red-50');
        } else if (productNameDisplay && e.type === 'input') {
            hideDisplay();
        }
    }

    async function handlePlanningFormSubmit(e) {
        e.preventDefault();
        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('create_planning')) {
            return;
        }
        
        const form = e.target;
    const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        const productionOrderId = (data.production_order_id || '').trim();
        
        // Validar data - usar data do input ou data atual
        if (!data.date) {
            const dateInput = document.getElementById('planning-date-selector');
            if (dateInput && dateInput.value) {
                data.date = dateInput.value;
            } else {
                // Fallback para data atual
                const hoje = new Date();
                data.date = hoje.getFullYear() + '-' + 
                           String(hoje.getMonth() + 1).padStart(2, '0') + '-' + 
                           String(hoje.getDate()).padStart(2, '0');
            }
        }
        
        // Validar máquina
        if (!data.machine) {
            alert('Por favor, selecione uma máquina!');
            return;
        }
        
        // Buscar dados completos do produto selecionado
        const productCod = data.product_cod;
        // Usar função helper com fallback seguro
        const product = getProductByCode(productCod);
        
        if (!product) {
            alert('Produto não encontrado!');
            return;
        }

        const statusMessage = document.getElementById('planning-status-message');
        const submitButton = document.getElementById('planning-submit-button');
        
        if (!submitButton) return;
        
        submitButton.disabled = true;
        submitButton.innerHTML = `<i data-lucide="loader-2" class="animate-spin"></i><span>A Adicionar...</span>`;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
        try {
            let linkedOrder = null;
            if (productionOrderId) {
                linkedOrder = Array.isArray(productionOrdersCache)
                    ? productionOrdersCache.find(order => order && order.id === productionOrderId)
                    : null;

                if (!linkedOrder) {
                    try {
                        const orderDoc = await db.collection('production_orders').doc(productionOrderId).get();
                        if (orderDoc.exists) {
                            linkedOrder = { id: orderDoc.id, ...orderDoc.data() };
                        }
                    } catch (orderError) {
                        console.warn('Falha ao carregar dados da OP vinculada:', orderError);
                    }
                }
            }

            const snapshot = linkedOrder?.product_snapshot || {};
            const resolvedProductName = linkedOrder?.product || product.name;
            const resolvedClient = linkedOrder?.customer || linkedOrder?.client || product.client || '';
            const resolvedMp = (data.mp || linkedOrder?.raw_material || snapshot.mp || product.mp || '').trim();
            const resolvedCycle = parseFloat(data.budgeted_cycle) || Number(product.cycle) || Number(snapshot.cycle) || 0;
            const resolvedCavities = parseFloat(data.mold_cavities) || Number(product.cavities) || Number(snapshot.cavities) || 0;
            
            // Converter peso da peça usando parser específico para peças (não converte kg->g)
            let resolvedWeight = 0;
            if (data.piece_weight) {
                resolvedWeight = parsePieceWeightInput(data.piece_weight);
                console.log('[PLANNING] piece_weight from input:', { raw: data.piece_weight, converted: resolvedWeight });
            }
            // Se não tiver peso, usar fallback do produto/snapshot
            if (!resolvedWeight && (snapshot.weight || product.weight)) {
                resolvedWeight = parsePieceWeightInput(snapshot.weight || product.weight);
                console.log('[PLANNING] piece_weight from fallback:', { snapshot: snapshot.weight, product: product.weight, resolved: resolvedWeight });
            }
            const resolvedQuantidadeEmbalagem = parseFloat(data.quantidade_da_embalagem) || null;
            const resolvedPlannedQuantity = (() => {
                const parsed = parseInt(data.planned_quantity, 10);
                return Number.isFinite(parsed) ? parsed : 0;
            })();

            product.mp = resolvedMp;

            const docData = {
                date: data.date,
                machine: data.machine,
                production_order_id: productionOrderId || null,
                product_cod: product.cod,
                client: resolvedClient,
                product: resolvedProductName,
                budgeted_cycle: resolvedCycle || null,
                mold_cavities: resolvedCavities || null,
                piece_weight: resolvedWeight || null,
                piece_weight_grams: resolvedWeight || null,
                quantidade_da_embalagem: resolvedQuantidadeEmbalagem,
                planned_quantity: resolvedPlannedQuantity,
                mp: resolvedMp,
                mp_type: data.mp_type || linkedOrder?.mp_type || '',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                // ✅ DISTRIBUIÇÃO POR TURNO (Opção 3 - Híbrido)
                shift_distribution: {
                    t1: {
                        planned_qty: parseInt(data.planned_qty_t1) || 0,
                        cycle: parseFloat(data.cycle_t1) || resolvedCycle || null,
                        cavities: parseInt(data.cavities_t1) || resolvedCavities || null,
                        customized: shiftDistributionData?.t1?.customized || false
                    },
                    t2: {
                        planned_qty: parseInt(data.planned_qty_t2) || 0,
                        cycle: parseFloat(data.cycle_t2) || resolvedCycle || null,
                        cavities: parseInt(data.cavities_t2) || resolvedCavities || null,
                        customized: shiftDistributionData?.t2?.customized || false
                    },
                    t3: {
                        planned_qty: parseInt(data.planned_qty_t3) || 0,
                        cycle: parseFloat(data.cycle_t3) || resolvedCycle || null,
                        cavities: parseInt(data.cavities_t3) || resolvedCavities || null,
                        customized: shiftDistributionData?.t3?.customized || false
                    }
                }
            };
            console.log('[PLANNING] docData to be saved:', { piece_weight: docData.piece_weight, piece_weight_grams: docData.piece_weight_grams, shift_distribution: docData.shift_distribution });

            if (linkedOrder) {
                docData.order_id = linkedOrder.id;
                docData.order_number = linkedOrder.order_number || linkedOrder.order_number_original || linkedOrder.id;
                docData.order_customer = resolvedClient;
                const linkedLotSize = parseOptionalNumber(linkedOrder.lot_size);
                if (typeof linkedLotSize === 'number' && Number.isFinite(linkedLotSize)) {
                    docData.order_lot_size = linkedLotSize;
                }
                const linkedPartCode = linkedOrder.part_code || linkedOrder.product_cod;
                if (linkedPartCode) {
                    docData.order_part_code = String(linkedPartCode);
                }
                // ✅ CORREÇÃO: Herdar total_produzido da ordem para manter consistência com aba Ordens
                const linkedTotalProduzido = parseOptionalNumber(linkedOrder.total_produzido);
                if (typeof linkedTotalProduzido === 'number' && linkedTotalProduzido > 0) {
                    docData.total_produzido = linkedTotalProduzido;
                    console.log('[PLANNING] Herdando total_produzido da ordem:', linkedTotalProduzido);
                }
            }
            
            // ✅ POKA-YOKE: Verificar se já existe planejamento ATIVO com mesma OP na mesma máquina e data
            // CORREÇÃO: Excluir planejamentos finalizados/cancelados da verificação
            if (docData.order_number) {
                const duplicateCheck = await db.collection('planning')
                    .where('date', '==', docData.date)
                    .where('machine', '==', docData.machine)
                    .where('order_number', '==', docData.order_number)
                    .get();
                
                // Filtrar apenas planejamentos ATIVOS (não finalizados/cancelados)
                const activeduplicates = duplicateCheck.docs.filter(doc => {
                    const planData = doc.data();
                    const status = (planData.status || '').toLowerCase();
                    // Se status não existe ou está vazio, considerar como ativo
                    // Se status é 'concluida', 'finalizada', 'cancelada', ignorar
                    return !['concluida', 'concluída', 'finalizada', 'cancelada', 'cancelado'].includes(status);
                });
                
                console.log('[PLANNING-DEBUG] Verificação de duplicata OP:', {
                    order_number: docData.order_number,
                    date: docData.date,
                    machine: docData.machine,
                    total_encontrados: duplicateCheck.docs.length,
                    ativos_encontrados: activeduplicates.length,
                    docs: duplicateCheck.docs.map(d => ({ id: d.id, status: d.data().status, product: d.data().product }))
                });
                
                if (activeduplicates.length > 0) {
                    const existingPlan = activeduplicates[0].data();
                    alert(`⚠️ DUPLICATA DETECTADA!\n\nJá existe um planejamento ATIVO para a OP ${docData.order_number} na máquina ${docData.machine} nesta data.\n\nProduto existente: ${existingPlan.product || '-'}\nStatus: ${existingPlan.status || 'ativo'}\n\nSe deseja adicionar outro produto do mesmo molde, use uma OP diferente.`);
                    submitButton.disabled = false;
                    submitButton.innerHTML = `<i data-lucide="plus"></i><span>Adicionar</span>`;
                    if (typeof lucide !== 'undefined') lucide.createIcons();
                    return;
                }
            }
            
            // Verificar também por product_cod na mesma máquina/data (mesmo produto sem OP)
            // CORREÇÃO: Excluir planejamentos finalizados/cancelados
            if (docData.product_cod) {
                const productDuplicateCheck = await db.collection('planning')
                    .where('date', '==', docData.date)
                    .where('machine', '==', docData.machine)
                    .where('product_cod', '==', docData.product_cod)
                    .get();
                
                // Filtrar apenas planejamentos ATIVOS
                const activeProductDuplicates = productDuplicateCheck.docs.filter(doc => {
                    const planData = doc.data();
                    const status = (planData.status || '').toLowerCase();
                    return !['concluida', 'concluída', 'finalizada', 'cancelada', 'cancelado'].includes(status);
                });
                
                console.log('[PLANNING-DEBUG] Verificação de duplicata Produto:', {
                    product_cod: docData.product_cod,
                    date: docData.date,
                    machine: docData.machine,
                    total_encontrados: productDuplicateCheck.docs.length,
                    ativos_encontrados: activeProductDuplicates.length,
                    docs: productDuplicateCheck.docs.map(d => ({ id: d.id, status: d.data().status, order_number: d.data().order_number }))
                });
                
                if (activeProductDuplicates.length > 0) {
                    const existingPlan = activeProductDuplicates[0].data();
                    const confirmAdd = confirm(`⚠️ ATENÇÃO: Produto possivelmente duplicado!\n\nJá existe um planejamento ATIVO para o produto ${docData.product_cod} na máquina ${docData.machine} nesta data.\n\nOP existente: ${existingPlan.order_number || 'Sem OP'}\nOP atual: ${docData.order_number || 'Sem OP'}\nStatus: ${existingPlan.status || 'ativo'}\n\nDeseja adicionar mesmo assim?`);
                    if (!confirmAdd) {
                        submitButton.disabled = false;
                        submitButton.innerHTML = `<i data-lucide="plus"></i><span>Adicionar</span>`;
                        if (typeof lucide !== 'undefined') lucide.createIcons();
                        return;
                    }
                }
            }
            
            await db.collection('planning').add(docData);
            
            // Registrar log
            registrarLogSistema('CRIAÇÃO DE PLANEJAMENTO', 'planejamento', {
                machine: data.machine,
                date: data.date,
                product: resolvedProductName,
                productCod: product.cod,
                plannedQuantity: resolvedPlannedQuantity,
                orderNumber: linkedOrder?.order_number || null
            });
            
            if (statusMessage) {
                statusMessage.textContent = 'Item adicionado com sucesso!';
                statusMessage.className = 'text-status-success text-sm font-semibold h-5 text-center';
            }
            form.reset();
            
            // Limpar campos com verificação de existência
            const budgetedCycleEl = document.getElementById('budgeted-cycle');
            const moldCavitiesEl = document.getElementById('mold-cavities');
            const pieceWeightEl = document.getElementById('piece-weight');
            const quantidadeEmbalagemEl = document.getElementById('quantidade-embalagem');
            const plannedQuantityEl = document.getElementById('planned-quantity');
            
            if (budgetedCycleEl) budgetedCycleEl.value = '';
            if (moldCavitiesEl) moldCavitiesEl.value = '';
            if (pieceWeightEl) pieceWeightEl.value = '';
            if (quantidadeEmbalagemEl) quantidadeEmbalagemEl.value = '';
            if (plannedQuantityEl) plannedQuantityEl.value = '';
            if (planningMpInput) planningMpInput.value = '';
            if (planningOrderSelect) {
                planningOrderSelect.value = '';
                planningOrderSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }
            const productNameDisplay = document.getElementById('product-name-display');
            if (productNameDisplay) {
                productNameDisplay.textContent = '';
                productNameDisplay.style.display = 'none';
            }
            const orderInfo = document.getElementById('planning-order-info');
            if (orderInfo) {
                orderInfo.style.display = 'none';
                orderInfo.textContent = '';
            }
            
            // Ocultar e limpar seção de distribuição por turno
            hideShiftDistribution();
        } catch (error) {
            console.error("Erro ao adicionar planejamento: ", error);
            if (statusMessage) {
                statusMessage.textContent = 'Erro ao adicionar. Tente novamente.';
                statusMessage.className = 'text-status-error text-sm font-semibold h-5 text-center';
            }
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = `<i data-lucide="plus-circle"></i><span>Adicionar ao Plano</span>`;
            if (typeof lucide !== 'undefined') lucide.createIcons();
            if (statusMessage) {
                setTimeout(() => statusMessage.textContent = '', 3000);
            }
        }
    }

    // Função para atualizar KPIs do Planejamento
    function updatePlanningKPIs(planningItems, combinedData) {
        const kpiItems = document.getElementById('planning-kpi-items');
        const kpiMachines = document.getElementById('planning-kpi-machines');
        const kpiProduced = document.getElementById('planning-kpi-produced');
        const kpiProducts = document.getElementById('planning-kpi-products');
        
        if (!kpiItems || !kpiMachines || !kpiProduced || !kpiProducts) return;
        
        // Total de itens planejados
        const totalItems = planningItems?.length || 0;
        kpiItems.textContent = totalItems.toLocaleString('pt-BR');
        
        // Máquinas únicas ativas
        const uniqueMachines = new Set((planningItems || []).map(p => p.machine).filter(Boolean));
        kpiMachines.textContent = uniqueMachines.size.toLocaleString('pt-BR');
        
        // Produção total do dia
        const totalProduced = (combinedData || []).reduce((sum, item) => {
            // CORREÇÃO: Usar producao_dia para KPIs da tabela de planejamento
            return sum + (Number(item.producao_dia) || Number(item.total_produzido) || 0);
        }, 0);
        kpiProduced.textContent = totalProduced.toLocaleString('pt-BR');
        
        // Produtos únicos
        const uniqueProducts = new Set((planningItems || []).map(p => p.product_cod || p.product).filter(Boolean));
        kpiProducts.textContent = uniqueProducts.size.toLocaleString('pt-BR');
    }

    // Função para atualizar dados do planejamento (botão refresh)
    window.refreshPlanningData = function() {
        const dateSelector = document.getElementById('planning-date-selector');
        if (dateSelector && dateSelector.value) {
            listenToPlanningChanges(dateSelector.value);
        }
    };

    // Função para imprimir relatório de planejamento
    window.printPlanningReport = function() {
        window.print();
    };

    // Função para exportar tabela de planejamento para Excel (XLS)
    window.exportPlanningTable = function() {
        const table = document.getElementById('planning-table-body');
        if (!table) {
            alert('Tabela não encontrada!');
            return;
        }
        
        const rows = table.querySelectorAll('tr');
        if (rows.length === 0) {
            alert('Nenhum dado para exportar.');
            return;
        }
        
        const date = document.getElementById('planning-date-selector')?.value || 'export';
        
        // Criar HTML com estilos para Excel
        let html = `
    <html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
    <head>
        <meta charset="UTF-8">
        <!--[if gte mso 9]>
        <xml>
            <x:ExcelWorkbook>
                <x:ExcelWorksheets>
                    <x:ExcelWorksheet>
                        <x:Name>Controle Ciclo Cavidade</x:Name>
                        <x:WorksheetOptions>
                            <x:DisplayGridlines/>
                        </x:WorksheetOptions>
                    </x:ExcelWorksheet>
                </x:ExcelWorksheets>
            </x:ExcelWorkbook>
        </xml>
        <![endif]-->
        <style>
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #333; padding: 6px; text-align: center; }
            th { background-color: #475569; color: white; font-weight: bold; }
            .title { font-size: 16px; font-weight: bold; background-color: #334155; color: white; }
            .header-plan { background-color: #f1f5f9; color: #374151; font-weight: bold; }
            .header-t1 { background-color: #DBEAFE; color: #1D4ED8; font-weight: bold; }
            .header-t2 { background-color: #FEF3C7; color: #B45309; font-weight: bold; }
            .header-t3 { background-color: #F3E8FF; color: #7E22CE; font-weight: bold; }
            .header-total { background-color: #D1FAE5; color: #065F46; font-weight: bold; }
            .text-left { text-align: left; }
            .text-red { color: #dc2626; font-weight: bold; }
            .text-green { color: #16a34a; font-weight: bold; }
            .text-amber { color: #d97706; font-weight: bold; }
            .total-cell { background-color: #ECFDF5; font-weight: bold; }
        </style>
    </head>
    <body>
        <table>
            <tr>
                <td colspan="16" class="title">Controle de Ciclo/Cavidade por Turno | Data: ${date}</td>
            </tr>
            <tr>
                <th rowspan="2">Máq.</th>
                <th rowspan="2">Produto</th>
                <th rowspan="2">MP</th>
                <th colspan="3" class="header-plan">Planejado</th>
                <th colspan="3" class="header-t1">1º Turno</th>
                <th colspan="3" class="header-t2">2º Turno</th>
                <th colspan="3" class="header-t3">3º Turno</th>
                <th rowspan="2" class="header-total">Total</th>
            </tr>
            <tr>
                <th class="header-plan">Ciclo</th>
                <th class="header-plan">Cav.</th>
                <th class="header-plan">Peso</th>
                <th class="header-t1">Ciclo</th>
                <th class="header-t1">Cav.</th>
                <th class="header-t1">Qtd.</th>
                <th class="header-t2">Ciclo</th>
                <th class="header-t2">Cav.</th>
                <th class="header-t2">Qtd.</th>
                <th class="header-t3">Ciclo</th>
                <th class="header-t3">Cav.</th>
                <th class="header-t3">Qtd.</th>
            </tr>`;
        
        // Dados da tabela
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 15) {
                const maquina = cells[0]?.textContent.trim() || '';
                const produto = cells[1]?.textContent.trim() || '';
                const mp = cells[2]?.textContent.trim() || '';
                const cicloPlan = cells[3]?.textContent.trim() || '';
                const cavPlan = cells[4]?.textContent.trim() || '';
                const peso = cells[5]?.textContent.trim() || '';
                const cicloT1 = cells[6]?.textContent.trim() || '';
                const cavT1 = cells[7]?.textContent.trim() || '';
                const qtdT1 = cells[8]?.textContent.trim() || '';
                const cicloT2 = cells[9]?.textContent.trim() || '';
                const cavT2 = cells[10]?.textContent.trim() || '';
                const qtdT2 = cells[11]?.textContent.trim() || '';
                const cicloT3 = cells[12]?.textContent.trim() || '';
                const cavT3 = cells[13]?.textContent.trim() || '';
                const qtdT3 = cells[14]?.textContent.trim() || '';
                const total = cells[15]?.textContent.trim() || '';
                
                html += `
            <tr>
                <td style="font-weight: bold;">${maquina}</td>
                <td class="text-left">${produto}</td>
                <td>${mp}</td>
                <td>${cicloPlan}</td>
                <td>${cavPlan}</td>
                <td>${peso}</td>
                <td>${cicloT1}</td>
                <td>${cavT1}</td>
                <td>${qtdT1}</td>
                <td>${cicloT2}</td>
                <td>${cavT2}</td>
                <td>${qtdT2}</td>
                <td>${cicloT3}</td>
                <td>${cavT3}</td>
                <td>${qtdT3}</td>
                <td class="total-cell">${total}</td>
            </tr>`;
            }
        });
        
        html += `
        </table>
    </body>
    </html>`;
        
        // Criar e baixar arquivo XLS
        const blob = new Blob([html], { type: 'application/vnd.ms-excel;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `controle_ciclo_cavidade_${date}.xls`;
        link.click();
        URL.revokeObjectURL(link.href);
    };

    // Função para imprimir tabela de Controle de Ciclo/Cavidade por Turno
    window.printPlanningTable = function() {
        const table = document.getElementById('planning-table-body');
        if (!table) {
            alert('Tabela não encontrada!');
            return;
        }
        
        const rows = table.querySelectorAll('tr');
        if (rows.length === 0) {
            alert('Nenhum dado para imprimir.');
            return;
        }
        
        const date = document.getElementById('planning-date-selector')?.value || new Date().toISOString().split('T')[0];
        
        // Criar HTML para impressão
        let html = `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Controle de Ciclo/Cavidade por Turno - ${date}</title>
    <style>
        @page { size: landscape; margin: 10mm; }
        * { box-sizing: border-box; }
        body { font-family: Arial, sans-serif; font-size: 10px; margin: 0; padding: 10px; }
        .header { text-align: center; margin-bottom: 15px; }
        .header h1 { font-size: 16px; margin: 0 0 5px 0; color: #334155; }
        .header p { font-size: 11px; color: #64748b; margin: 0; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #cbd5e1; padding: 4px 6px; text-align: center; }
        th { background-color: #475569; color: white; font-weight: bold; font-size: 9px; }
        .header-plan { background-color: #f1f5f9 !important; color: #374151 !important; }
        .header-t1 { background-color: #DBEAFE !important; color: #1D4ED8 !important; }
        .header-t2 { background-color: #FEF3C7 !important; color: #B45309 !important; }
        .header-t3 { background-color: #F3E8FF !important; color: #7E22CE !important; }
        .header-total { background-color: #D1FAE5 !important; color: #065F46 !important; }
        .text-left { text-align: left; }
        .total-cell { background-color: #ECFDF5; font-weight: bold; }
        .machine { font-weight: bold; }
        tr:nth-child(even) { background-color: #f8fafc; }
        .footer { text-align: center; margin-top: 15px; font-size: 9px; color: #94a3b8; }
        @media print {
            body { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Controle de Ciclo/Cavidade por Turno</h1>
        <p>Data: ${date} | Impresso em: ${new Date().toLocaleString('pt-BR')}</p>
    </div>
    <table>
        <thead>
            <tr>
                <th rowspan="2">Máq.</th>
                <th rowspan="2">Produto</th>
                <th rowspan="2">MP</th>
                <th colspan="3" class="header-plan">Planejado</th>
                <th colspan="3" class="header-t1">1º Turno</th>
                <th colspan="3" class="header-t2">2º Turno</th>
                <th colspan="3" class="header-t3">3º Turno</th>
                <th rowspan="2" class="header-total">Total</th>
            </tr>
            <tr>
                <th class="header-plan">Ciclo</th>
                <th class="header-plan">Cav.</th>
                <th class="header-plan">Peso</th>
                <th class="header-t1">Ciclo</th>
                <th class="header-t1">Cav.</th>
                <th class="header-t1">Qtd.</th>
                <th class="header-t2">Ciclo</th>
                <th class="header-t2">Cav.</th>
                <th class="header-t2">Qtd.</th>
                <th class="header-t3">Ciclo</th>
                <th class="header-t3">Cav.</th>
                <th class="header-t3">Qtd.</th>
            </tr>
        </thead>
        <tbody>`;
        
        // Dados da tabela
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 15) {
                const maquina = cells[0]?.textContent.trim() || '';
                const produto = cells[1]?.textContent.trim() || '';
                const mp = cells[2]?.textContent.trim() || '';
                const cicloPlan = cells[3]?.textContent.trim() || '';
                const cavPlan = cells[4]?.textContent.trim() || '';
                const peso = cells[5]?.textContent.trim() || '';
                const cicloT1 = cells[6]?.textContent.trim() || '';
                const cavT1 = cells[7]?.textContent.trim() || '';
                const qtdT1 = cells[8]?.textContent.trim() || '';
                const cicloT2 = cells[9]?.textContent.trim() || '';
                const cavT2 = cells[10]?.textContent.trim() || '';
                const qtdT2 = cells[11]?.textContent.trim() || '';
                const cicloT3 = cells[12]?.textContent.trim() || '';
                const cavT3 = cells[13]?.textContent.trim() || '';
                const qtdT3 = cells[14]?.textContent.trim() || '';
                const total = cells[15]?.textContent.trim() || '';
                
                html += `
            <tr>
                <td class="machine">${maquina}</td>
                <td class="text-left">${produto}</td>
                <td>${mp}</td>
                <td>${cicloPlan}</td>
                <td>${cavPlan}</td>
                <td>${peso}</td>
                <td>${cicloT1}</td>
                <td>${cavT1}</td>
                <td>${qtdT1}</td>
                <td>${cicloT2}</td>
                <td>${cavT2}</td>
                <td>${qtdT2}</td>
                <td>${cicloT3}</td>
                <td>${cavT3}</td>
                <td>${qtdT3}</td>
                <td class="total-cell">${total}</td>
            </tr>`;
            }
        });
        
        html += `
        </tbody>
    </table>
    <div class="footer">Hokkaido MES - Sistema de Gestão de Produção</div>
</body>
</html>`;
        
        // Abrir janela de impressão
        const printWindow = window.open('', '_blank', 'width=1200,height=800');
        if (printWindow) {
            printWindow.document.write(html);
            printWindow.document.close();
            printWindow.focus();
            setTimeout(() => {
                printWindow.print();
            }, 500);
        } else {
            alert('Não foi possível abrir a janela de impressão. Verifique se popups estão habilitados.');
        }
    };

    // Setup de busca na tabela de planejamento
    function setupPlanningTableSearch() {
        const searchInput = document.getElementById('planning-table-search');
        if (!searchInput) return;
        
        let debounceTimer;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                const searchTerm = e.target.value.toLowerCase().trim();
                const tableBody = document.getElementById('planning-table-body');
                if (!tableBody) return;
                
                const rows = tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const text = row.textContent.toLowerCase();
                    row.style.display = text.includes(searchTerm) ? '' : 'none';
                });
            }, 300);
        });
    }

    // Inicializar busca na tabela
    setTimeout(setupPlanningTableSearch, 1000);

    function listenToPlanningChanges(date) {
        if (!date) return;
        
        // AÇÃO 3: Salvar referência para Visibility API poder retomar
        window._currentListenerSetup = () => listenToPlanningChanges(date);
        
        detachActiveListener();
        showLoadingState('leader-panel', true);
        
        // Limpar cache de produção ao mudar de data (evita valores antigos)
        if (typeof machineCardProductionCache !== 'undefined' && machineCardProductionCache.clear) {
            machineCardProductionCache.clear();
        }
        
        let planningItems = [];
        let productionEntries = [];
        let downtimeEntries = [];
        let activeDowntimeSet = new Set();
        
        // Cache de total_produzido das OPs vinculadas (para consistência com aba Ordens)
        const orderTotalCache = new Map();

        const render = async () => {
            // CORREÇÃO CONSISTÊNCIA: Enriquecer plannings com total_produzido da OP vinculada
            // Isso garante que os cards das máquinas mostrem o MESMO valor que a aba Admin > Dados > Ordens
            // IMPORTANTE: Sempre usar o valor da OP como fonte de verdade
            for (const plan of planningItems) {
                const orderId = plan.production_order_id || plan.production_order || plan.order_id;
                if (orderId) {
                    try {
                        // Buscar sempre da OP (ignorar cache para garantir valor atualizado)
                        const orderDoc = await db.collection('production_orders').doc(orderId).get();
                        if (orderDoc.exists) {
                            const orderData = orderDoc.data() || {};
                            const orderTotal = coerceToNumber(orderData.total_produzido ?? orderData.totalProduced, 0);
                            orderTotalCache.set(orderId, orderTotal);
                            
                            const planTotal = coerceToNumber(plan.total_produzido, 0);
                            
                            // SEMPRE usar o valor da OP como fonte de verdade
                            // O Admin mostra o valor da OP, então os cards devem mostrar o mesmo
                            if (orderTotal !== planTotal) {
                                console.log(`[SYNC-CONSISTENCIA] Planning ${plan.id} tem total_produzido (${planTotal}) diferente da OP ${orderId} (${orderTotal}). Sincronizando...`);
                                // Atualizar cache local imediatamente com valor da OP
                                plan.total_produzido = orderTotal;
                                plan.totalProduced = orderTotal;
                                // Atualizar Firebase em background (não esperar)
                                db.collection('planning').doc(plan.id).update({
                                    total_produzido: orderTotal,
                                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                                }).catch(e => console.warn('[SYNC-CONSISTENCIA] Falha ao sincronizar planning:', e));
                            } else {
                                // Valores já estão sincronizados
                                plan.total_produzido = orderTotal;
                                plan.totalProduced = orderTotal;
                            }
                        } else {
                            orderTotalCache.set(orderId, 0);
                        }
                    } catch (e) {
                        console.warn('[SYNC-CONSISTENCIA] Erro ao buscar OP:', orderId, e);
                        orderTotalCache.set(orderId, 0);
                    }
                }
            }
            
            const combinedData = planningItems.map(plan => {
                const shifts = { T1: 0, T2: 0, T3: 0 };

                productionEntries.forEach(entry => {
                    if (!entry || entry.planId !== plan.id) return;
                    const shiftKey = normalizeShiftValue(entry.turno);
                    if (!shiftKey || !shifts.hasOwnProperty(shiftKey)) return;
                    const produced = Number(entry.produzido) || 0;
                    shifts[shiftKey] += produced;
                });

                // CORREÇÃO: Calcular produção do dia (para referência)
                const producao_dia = shifts.T1 + shifts.T2 + shifts.T3;
                
                // CORREÇÃO CONSISTÊNCIA COM ADMIN:
                // O Admin mostra o total_produzido da OP (production_orders)
                // Os cards devem mostrar o MESMO valor para evitar divergências
                // Prioridade: 1) valor da OP (orderTotal), 2) valor do planning (storedTotal), 3) produção do dia
                const storedTotal = coerceToNumber(plan.total_produzido, 0);
                const orderId = plan.production_order_id || plan.production_order || plan.order_id;
                const orderTotal = orderId ? (orderTotalCache.get(orderId) || 0) : 0;
                
                // Se existe OP vinculada, usar o valor dela (igual ao Admin)
                // Senão, usar o valor do planning ou produção do dia (o que for maior)
                let total_produzido_final;
                if (orderId && orderTotal > 0) {
                    // Tem OP vinculada - usar valor da OP (mesmo que Admin)
                    total_produzido_final = orderTotal;
                } else {
                    // Sem OP vinculada - usar maior entre planning e produção do dia
                    total_produzido_final = Math.max(storedTotal, producao_dia);
                }

                return {
                    ...plan,
                    T1: { produzido: shifts.T1 },
                    T2: { produzido: shifts.T2 },
                    T3: { produzido: shifts.T3 },
                    producao_dia: producao_dia,  // Produção apenas do dia (para tabela)
                    total_produzido: total_produzido_final  // Total acumulado da OP (maior valor)
                };
            });

            // Atualizar KPIs do Planejamento
            updatePlanningKPIs(planningItems, combinedData);
            
            renderPlanningTable(combinedData);
            renderLeaderPanel(planningItems);
            
            // CORREÇÃO: Usar combinedData ao invés de planningItems para garantir
            // que os cards das máquinas tenham o total_produzido correto (igual ao Admin)
            const activePlansEnriched = combinedData.filter(isPlanActive);
            
            // NOVO: Carregar paradas ativas para mostrar no painel de máquinas
            const machinesDowntime = await getAllMachinesDowntimeStatus();
            renderMachineCards(activePlansEnriched, productionEntries, downtimeEntries, activeDowntimeSet, machinesDowntime);
            showLoadingState('leader-panel', false, planningItems.length === 0);
            
            // Atualizar contagem no painel
            const panelCount = document.getElementById('planning-panel-count');
            if (panelCount) {
                panelCount.textContent = `${planningItems.length} ${planningItems.length === 1 ? 'item' : 'itens'}`;
            }
        };

        // AÇÃO 2: Debounce para consolidar renders de múltiplos listeners
        // Evita múltiplas chamadas render() quando vários listeners disparam quase simultaneamente
        let renderDebounceTimer = null;
        const scheduleRender = () => {
            if (renderDebounceTimer) {
                clearTimeout(renderDebounceTimer);
            }
            renderDebounceTimer = setTimeout(() => {
                requestAnimationFrame(() => render().catch(e => console.error('Erro em render:', e)));
            }, 200); // 200ms de debounce (aumentado para evitar oscilações)
        };

        // Limpar listeners anteriores se existirem
        listenerManager.unsubscribe('planning');
        listenerManager.unsubscribe('productionEntries');
        listenerManager.unsubscribe('downtime');
        // activeDowntimes agora usa polling (AÇÃO 4)

        // Filtrar planejamentos pela data selecionada (dia de trabalho inicia às 7h)
        // Busca planejamentos onde a data do planejamento é igual à data selecionada
        const planningQuery = db.collection('planning').where('date', '==', date);
        listenerManager.subscribe('planning', planningQuery,
            (snapshot) => {
                // Filtrar apenas planejamentos ativos (não concluídos/finalizados/cancelados)
                planningItems = snapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(isPlanActive);
                planningItems.sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                
                // Alimentar DataStore para evitar leituras repetidas
                if (window.DataStore) {
                    window.DataStore.set('planning', planningItems);
                }
                
                if (machineSelector) {
                    machineSelector.machineData = {};
                    planningItems.forEach(item => {
                        if (isPlanActive(item)) {
                            machineSelector.machineData[item.machine] = { id: item.id, ...item };
                        }
                    });
                }
                if (selectedMachineData) {
                    const updatedSelected = planningItems.find(item => item.id === selectedMachineData.id);
                    if (updatedSelected) {
                        selectedMachineData = { ...selectedMachineData, ...updatedSelected };
                        updateQuickProductionPieceWeightUI();
                        if (productName) {
                            productName.textContent = selectedMachineData.product || 'Produto não definido';
                        }
                        if (shiftTarget) {
                            // Usar lot_size (tamanho do lote OP), não planned_quantity/3
                            const totalPlanned = coerceToNumber(selectedMachineData.order_lot_size ?? selectedMachineData.lot_size, 0);
                            const totalExecuted = coerceToNumber(selectedMachineData.total_produzido, 0);
                            if (!totalPlanned) {
                                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / N/A`;
                            } else {
                                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / ${totalPlanned.toLocaleString('pt-BR')}`;
                            }
                        }
                        if (productMp) {
                            productMp.textContent = selectedMachineData.mp ? `MP: ${selectedMachineData.mp}` : 'Matéria-prima não definida';
                        }
                    }
                }
                scheduleRender();
            },
            (error) => {
                console.error("Erro ao carregar planejamentos:", error);
                if(leaderLaunchPanel) leaderLaunchPanel.innerHTML = `<div class="col-span-full text-center text-red-600">Erro ao carregar dados.</div>`;
                showLoadingState('leader-panel', false, true);
            }
        );

        const entriesQuery = db.collection('production_entries').where('data', '==', date);
        listenerManager.subscribe('productionEntries', entriesQuery,
            (snapshot) => {
                productionEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Alimentar DataStore para evitar leituras repetidas
                if (window.DataStore) {
                    window.DataStore.set('productionEntries', productionEntries);
                }
                
                scheduleRender();
            },
            (error) => console.error("Erro ao carregar lançamentos de produção:", error)
        );

        // Listener de paradas do dia selecionado e próximo dia (para cobrir T3 após 00:00)
        const base = new Date(`${date}T12:00:00`);
        const next = new Date(base);
        next.setDate(next.getDate() + 1);
        const nextStr = new Date(next.getTime() - next.getTimezoneOffset()*60000).toISOString().split('T')[0];
        
        const downtimeQuery = db.collection('downtime_entries')
            .where('date', 'in', [date, nextStr]);
        listenerManager.subscribe('downtime', downtimeQuery,
            (snapshot) => {
                downtimeEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                scheduleRender();
            },
            (error) => console.error('Erro ao carregar paradas:', error)
        );

        // AÇÃO 4: Polling para paradas ativas (cards vermelhos) - substituído listener por polling 5s
        // Função de polling para active_downtimes
        // IMPORTANTE: Filtrar apenas máquinas válidas do machineDatabase para evitar contagem incorreta
        const validMachineIdsSet = new Set(machineDatabase.map(m => normalizeMachineId(m.id)));
        const pollActiveDowntimes = async () => {
            try {
                const snapshot = await db.collection('active_downtimes').get();
                // Filtrar apenas máquinas que existem no machineDatabase
                const allDowntimeIds = snapshot.docs.map(doc => doc.id);
                const validDowntimeIds = allDowntimeIds.filter(id => {
                    const normalizedId = normalizeMachineId(id);
                    const isValid = validMachineIdsSet.has(normalizedId);
                    if (!isValid) {
                        console.warn(`[pollActiveDowntimes] Máquina "${id}" em active_downtimes não existe no machineDatabase`);
                    }
                    return isValid;
                });
                activeDowntimeSet = new Set(validDowntimeIds);
                scheduleRender();
            } catch (error) {
                console.error('Erro ao buscar paradas ativas:', error);
            }
        };
        
        // Executar imediatamente na primeira vez
        pollActiveDowntimes();
        
        // Configurar polling a cada 15 segundos (otimizado para reduzir custos - era 5s)
        window._startActiveDowntimesPolling = () => {
            if (window._activeDowntimesPolling) {
                clearInterval(window._activeDowntimesPolling);
            }
            window._activeDowntimesPolling = setInterval(pollActiveDowntimes, 15000);
        };
        window._startActiveDowntimesPolling();
    }

    function renderPlanningTable(items) {
        if (!planningTableBody) return;
        const orDash = (value) => value || '-';
        const orDashNum = (value) => {
            const parsed = parseOptionalNumber(value);
            return parsed !== null ? parsed.toLocaleString('pt-BR') : '-';
        };
        const cycleClass = (realCycle, budgetedCycle) => {
            if (!realCycle || !budgetedCycle) return '';
            return realCycle > budgetedCycle ? 'text-status-error font-bold' : '';
        };

        // Agrupar por Máquina + Produto (independente da OP)
        const grouped = new Map();
        (items || []).forEach(item => {
            const key = `${item.machine}||${item.product_cod || item.product || ''}`;
            if (!grouped.has(key)) {
                grouped.set(key, {
                    id: item.id, // Guardar ID do primeiro item do grupo
                    machine: item.machine,
                    product: item.product,
                    product_cod: item.product_cod,
                    mp: item.mp,
                    budgeted_cycle: item.budgeted_cycle,
                    mold_cavities: item.mold_cavities,
                    piece_weight: item.piece_weight,
                    // Ciclos/Cavidades reais por turno (pega o primeiro valor informado)
                    real_cycle_t1: item.real_cycle_t1 || null,
                    active_cavities_t1: item.active_cavities_t1 || null,
                    real_cycle_t2: item.real_cycle_t2 || null,
                    active_cavities_t2: item.active_cavities_t2 || null,
                    real_cycle_t3: item.real_cycle_t3 || null,
                    active_cavities_t3: item.active_cavities_t3 || null,
                    // Produção por turno acumulada
                    T1: { produzido: Number(item.T1?.produzido) || 0 },
                    T2: { produzido: Number(item.T2?.produzido) || 0 },
                    T3: { produzido: Number(item.T3?.produzido) || 0 },
                    // CORREÇÃO: Na tabela usar produção do dia (T1+T2+T3), não total acumulado da OP
                    producao_dia: coerceToNumber(item.producao_dia, 0) || (Number(item.T1?.produzido) || 0) + (Number(item.T2?.produzido) || 0) + (Number(item.T3?.produzido) || 0),
                    total_produzido: coerceToNumber(item.total_produzido, 0)
                });
            } else {
                const agg = grouped.get(key);
                // Manter primeiro valor de ciclo/cavidades reais informado; se vazio, assumir do item atual
                if (!agg.real_cycle_t1 && item.real_cycle_t1) agg.real_cycle_t1 = item.real_cycle_t1;
                if (!agg.active_cavities_t1 && item.active_cavities_t1) agg.active_cavities_t1 = item.active_cavities_t1;
                if (!agg.real_cycle_t2 && item.real_cycle_t2) agg.real_cycle_t2 = item.real_cycle_t2;
                if (!agg.active_cavities_t2 && item.active_cavities_t2) agg.active_cavities_t2 = item.active_cavities_t2;
                if (!agg.real_cycle_t3 && item.real_cycle_t3) agg.real_cycle_t3 = item.real_cycle_t3;
                if (!agg.active_cavities_t3 && item.active_cavities_t3) agg.active_cavities_t3 = item.active_cavities_t3;
                // Atualizar campos básicos se estiverem vazios
                if (!agg.mp && item.mp) agg.mp = item.mp;
                if (!agg.budgeted_cycle && item.budgeted_cycle) agg.budgeted_cycle = item.budgeted_cycle;
                if (!agg.mold_cavities && item.mold_cavities) agg.mold_cavities = item.mold_cavities;
                if (!agg.piece_weight && item.piece_weight) agg.piece_weight = item.piece_weight;
                // Somar produção por turno e total
                agg.T1.produzido += Number(item.T1?.produzido) || 0;
                agg.T2.produzido += Number(item.T2?.produzido) || 0;
                agg.T3.produzido += Number(item.T3?.produzido) || 0;
                // CORREÇÃO: Somar produção do dia separadamente
                agg.producao_dia += coerceToNumber(item.producao_dia, 0) || (Number(item.T1?.produzido) || 0) + (Number(item.T2?.produzido) || 0) + (Number(item.T3?.produzido) || 0);
                agg.total_produzido += coerceToNumber(item.total_produzido, 0);
            }
        });

        // Ordenar por máquina em ordem crescente (numérica se possível)
        const sortedItems = Array.from(grouped.values()).sort((a, b) => {
            const machineA = a.machine || '';
            const machineB = b.machine || '';
            // Tentar extrair número da máquina para ordenação numérica
            const numA = parseInt(machineA.replace(/\D/g, ''), 10);
            const numB = parseInt(machineB.replace(/\D/g, ''), 10);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return machineA.localeCompare(machineB, 'pt-BR', { numeric: true });
        });

        const rows = sortedItems.map(item => `
            <tr class="hover:bg-gray-50 text-center text-sm">
                <td class="px-2 py-2 whitespace-nowrap border text-left">${item.machine}</td>
                <td class="px-2 py-2 whitespace-nowrap border text-left">${item.product}</td>
                <td class="px-2 py-2 whitespace-nowrap border text-left">${orDash(item.mp)}</td>
                <td class="px-2 py-2 whitespace-nowrap border">${orDash(item.budgeted_cycle)}</td>
                <td class="px-2 py-2 whitespace-nowrap border">${orDash(item.mold_cavities)}</td>
                <td class="px-2 py-2 whitespace-nowrap border">${orDash(item.piece_weight)}</td>
                
                <td class="px-2 py-2 whitespace-nowrap border bg-blue-50 ${cycleClass(item.real_cycle_t1, item.budgeted_cycle)}">${orDash(item.real_cycle_t1)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-blue-50">${orDash(item.active_cavities_t1)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-blue-50">${orDashNum(item.T1?.produzido)}</td>

                <td class="px-2 py-2 whitespace-nowrap border bg-yellow-50 ${cycleClass(item.real_cycle_t2, item.budgeted_cycle)}">${orDash(item.real_cycle_t2)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-yellow-50">${orDash(item.active_cavities_t2)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-yellow-50">${orDashNum(item.T2?.produzido)}</td>

                <td class="px-2 py-2 whitespace-nowrap border bg-purple-50 ${cycleClass(item.real_cycle_t3, item.budgeted_cycle)}">${orDash(item.real_cycle_t3)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-purple-50">${orDash(item.active_cavities_t3)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-purple-50">${orDashNum(item.T3?.produzido)}</td>

                <td class="px-3 py-2 whitespace-nowrap bg-emerald-50 font-bold text-emerald-700 text-base">${orDashNum(item.producao_dia)}</td>
                <td class="px-2 py-2 whitespace-nowrap no-print text-center">
                    <button class="delete-plan-btn bg-red-100 hover:bg-red-200 text-red-600 hover:text-red-700 p-1.5 rounded-lg transition-all" data-id="${item.id}" title="Deletar planejamento">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </td>
            </tr>
        `).join('');

        planningTableBody.innerHTML = rows;
        
        // Mostrar/ocultar estado vazio
        const emptyState = document.getElementById('planning-table-empty');
        if (emptyState) {
            emptyState.classList.toggle('hidden', sortedItems.length > 0);
        }
        
        lucide.createIcons();
    }

    function handlePlanningTableClick(e) {
        const deleteButton = e.target.closest('.delete-plan-btn');
        if (deleteButton) {
            const docId = deleteButton.dataset.id;
            showConfirmModal(docId, 'planning');
        }
    }
    
    // --- PAINEL DO LÍDER ---
    function renderLeaderPanel(planItems) {
        if (!leaderLaunchPanel) return;

        // Agrupar por Máquina + Produto (consolidar itens de OPs diferentes do mesmo produto)
        const groups = new Map();
        (planItems || []).forEach(item => {
            const key = `${item.machine}||${item.product_cod || item.product || ''}`;
            if (!groups.has(key)) {
                groups.set(key, {
                    ids: [item.id],
                    machine: item.machine,
                    product: item.product,
                    product_cod: item.product_cod,
                    mp: item.mp || '',
                    real_cycle_t1: item.real_cycle_t1 || null,
                    active_cavities_t1: item.active_cavities_t1 || null,
                    real_cycle_t2: item.real_cycle_t2 || null,
                    active_cavities_t2: item.active_cavities_t2 || null,
                    real_cycle_t3: item.real_cycle_t3 || null,
                    active_cavities_t3: item.active_cavities_t3 || null
                });
            } else {
                const g = groups.get(key);
                g.ids.push(item.id);
                // Manter o primeiro valor informado para ciclo/cavidades de cada turno
                if (!g.real_cycle_t1 && item.real_cycle_t1) g.real_cycle_t1 = item.real_cycle_t1;
                if (!g.active_cavities_t1 && item.active_cavities_t1) g.active_cavities_t1 = item.active_cavities_t1;
                if (!g.real_cycle_t2 && item.real_cycle_t2) g.real_cycle_t2 = item.real_cycle_t2;
                if (!g.active_cavities_t2 && item.active_cavities_t2) g.active_cavities_t2 = item.active_cavities_t2;
                if (!g.real_cycle_t3 && item.real_cycle_t3) g.real_cycle_t3 = item.real_cycle_t3;
                if (!g.active_cavities_t3 && item.active_cavities_t3) g.active_cavities_t3 = item.active_cavities_t3;
                if (!g.mp && item.mp) g.mp = item.mp;
            }
        });

        leaderLaunchPanel.innerHTML = Array.from(groups.values()).map(group => {
            const turnos = ['T1', 'T2', 'T3'];
            const statusHtml = turnos.map(turno => {
                const rc = group[`real_cycle_${turno.toLowerCase()}`];
                const cav = group[`active_cavities_${turno.toLowerCase()}`];
                const isComplete = rc && cav;
                const statusClass = isComplete ? 'bg-green-100 text-status-success' : 'bg-yellow-100 text-status-warning';
                const statusIcon = isComplete ? `<i data-lucide="check-circle-2" class="w-4 h-4"></i>` : `<i data-lucide="alert-circle" class="w-4 h-4"></i>`;
                return `<div class="flex items-center justify-center gap-2 p-1 rounded-md text-xs font-semibold ${statusClass}">${statusIcon} ${turno}</div>`;
            }).join('');

            const btnClasses = turnos.map(turno => {
                const rc = group[`real_cycle_${turno.toLowerCase()}`];
                const cav = group[`active_cavities_${turno.toLowerCase()}`];
                const isComplete = rc && cav;
                return isComplete ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            });
            const mpLabel = group.mp ? `<p class="text-xs text-gray-500 mt-1">MP: ${group.mp}</p>` : '';
            const idsCsv = group.ids.join(',');

            return `
                <div class="border rounded-lg p-4 shadow-md flex flex-col justify-between bg-white">
                    <div>
                        <h3 class="font-bold text-lg">${group.machine}</h3>
                        <p class="text-sm text-gray-600">${group.product}</p>
                        ${mpLabel}
                        <div class="grid grid-cols-3 gap-2 mt-2">
                           ${statusHtml}
                        </div>
                    </div>
                    <div class="grid grid-cols-3 gap-2 mt-4">
                        <button data-id="${idsCsv}" data-turno="T1" class="setup-btn ${btnClasses[0]} text-white font-bold py-2 px-3 rounded-lg text-sm">1º Turno</button>
                        <button data-id="${idsCsv}" data-turno="T2" class="setup-btn ${btnClasses[1]} text-white font-bold py-2 px-3 rounded-lg text-sm">2º Turno</button>
                        <button data-id="${idsCsv}" data-turno="T3" class="setup-btn ${btnClasses[2]} text-white font-bold py-2 px-3 rounded-lg text-sm">3º Turno</button>
                    </div>
                </div>
            `;
        }).join('');
        lucide.createIcons();
    }
    
    function handleLeaderPanelClick(e) {
        const setupButton = e.target.closest('.setup-btn');
        if (setupButton) {
            const docId = setupButton.dataset.id;
            const turno = setupButton.dataset.turno;
            showLeaderModal(docId, turno);
        }
    }

    async function showLeaderModal(docId, turno) {
        if (!leaderModalForm || !leaderModalTitle) return;
        
        console.log('[TRACE][showLeaderModal] opening', { docId, turno });

        leaderModalForm.querySelector('#leader-modal-cancel-btn')?.remove();
        
        leaderModalForm.innerHTML = `
            <input type="hidden" id="leader-entry-doc-id" name="docId">
            <input type="hidden" id="leader-entry-turno" name="turno">
            <div>
                <label for="leader-entry-real-cycle" class="block text-sm font-medium">Ciclo Real (${turno})</label>
                <input type="number" id="leader-entry-real-cycle" name="real_cycle" step="0.1" class="mt-1 w-full p-2 border-gray-300 rounded-md">
            </div>
            <div>
                <label for="leader-entry-active-cavities" class="block text-sm font-medium">Cavidades Ativas (${turno})</label>
                <input type="number" id="leader-entry-active-cavities" name="active_cavities" step="1" class="mt-1 w-full p-2 border-gray-300 rounded-md">
            </div>
            <div class="mt-6 flex justify-end gap-3 pt-4 border-t">
                <button type="button" id="leader-modal-cancel-btn" class="bg-gray-200 hover:bg-gray-300 font-bold py-2 px-6 rounded-lg">Cancelar</button>
                <button type="submit" class="bg-primary-blue hover:bg-blue-800 text-white font-bold py-2 px-6 rounded-lg">Salvar</button>
            </div>`;
        
        leaderModal.querySelector('#leader-modal-cancel-btn').addEventListener('click', hideLeaderModal);
        
        document.getElementById('leader-entry-doc-id').value = docId;
        document.getElementById('leader-entry-turno').value = turno;

        try {
            // Suporta múltiplos IDs (csv) vindos do painel consolidado
            const ids = String(docId).split(',').map(s => s.trim()).filter(Boolean);
            let headerMachine = '';
            let prefillReal = '';
            let prefillCav = '';
            for (const id of ids) {
                try {
                    const ref = db.collection('planning').doc(id);
                    const snap = await ref.get();
                    if (snap.exists) {
                        const data = snap.data();
                        if (!headerMachine) headerMachine = data.machine || '';
                        const rc = data[`real_cycle_${turno.toLowerCase()}`];
                        const cav = data[`active_cavities_${turno.toLowerCase()}`];
                        if (!prefillReal && rc) prefillReal = rc;
                        if (!prefillCav && cav) prefillCav = cav;
                        if (prefillReal && prefillCav) break; // já temos valores para preencher
                    }
                } catch (innerErr) {
                    console.warn('[TRACE][showLeaderModal] falha ao recuperar doc para prefill', id, innerErr);
                }
            }
            leaderModalTitle.textContent = `Lançamento: ${headerMachine || 'Máquina'} - ${turno}`;
            document.getElementById('leader-entry-real-cycle').value = prefillReal || '';
            document.getElementById('leader-entry-active-cavities').value = prefillCav || '';
            
        } catch (error) {
            console.error("Erro ao buscar dados do setup: ", error);
        }
        
        leaderModal.classList.remove('hidden');
        console.log('[TRACE][showLeaderModal] modal displayed');
    }
    
    function hideLeaderModal() {
        if (leaderModal) leaderModal.classList.add('hidden');
    }

    async function handleLeaderEntrySubmit(e) {
        e.preventDefault();
        const formData = new FormData(e.target);
        const docId = formData.get('docId');
        const turno = formData.get('turno');
        const realCycle = parseFloat(formData.get('real_cycle')) || null;
        const activeCavities = parseInt(formData.get('active_cavities')) || null;

        console.log('[TRACE][handleLeaderEntrySubmit] submission data', {
            docId,
            turno,
            realCycle,
            activeCavities
        });

        const planDataToUpdate = {
            [`real_cycle_${turno.toLowerCase()}`]: realCycle,
            [`active_cavities_${turno.toLowerCase()}`]: activeCavities,
        };

        console.log('[TRACE][handleLeaderEntrySubmit] updating planning document', planDataToUpdate);

        try {
            // Suporta múltiplos IDs (csv) para manter OPs sincronizadas para o mesmo produto
            const ids = String(docId).split(',').map(s => s.trim()).filter(Boolean);
            const batchSize = 20; // segurança para não estourar limites
            for (let i = 0; i < ids.length; i += batchSize) {
                const slice = ids.slice(i, i + batchSize);
                const batch = db.batch();
                slice.forEach(id => {
                    const ref = db.collection('planning').doc(id);
                    batch.update(ref, planDataToUpdate);
                });
                await batch.commit();
            }

            hideLeaderModal();
            console.log('[TRACE][handleLeaderEntrySubmit] completed successfully for ids', ids);
        } catch (error) {
            console.error("Erro ao salvar dados do líder: ", error);
            alert("Não foi possível salvar os dados. Tente novamente.");
        }
    }

    // --- PAINEL DO OPERADOR ---
    function listenToCurrentProductionPlan() {
        detachActiveListener();
        const date = getProductionDateString();
        showLoadingState('launch-panel', true);

        let planningItems = [];
        let launchedEntries = new Set();
        let productionEntries = [];

        const render = () => {
            renderLaunchPanel(planningItems, launchedEntries, productionEntries);
            showLoadingState('launch-panel', false, planningItems.length === 0);
        };

        // Limpar listeners anteriores se existirem
        listenerManager.unsubscribe('launchPlanning');
        listenerManager.unsubscribe('launchProductions');

        // OTIMIZADO: Filtrar planejamentos dos últimos 30 dias (redução de custo Firebase)
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        const thirtyDaysAgoStr = thirtyDaysAgo.toISOString().split('T')[0];
        const planningQuery = db.collection('planning').where('date', '>=', thirtyDaysAgoStr);
        listenerManager.subscribe('launchPlanning', planningQuery,
            (snapshot) => {
                // Filtrar apenas planejamentos ativos (não concluídos/finalizados/cancelados)
                planningItems = snapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(isPlanActive);
                planningItems.sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                render();
            },
            (error) => {
                console.error("Erro ao carregar plano de produção: ", error);
                if (launchPanelContainer) {
                    launchPanelContainer.innerHTML = `<div class="col-span-full text-center text-red-600 bg-red-50 p-4 rounded-lg"><p class="font-bold">Falha ao carregar dados.</p></div>`;
                }
            }
        );
        
        const entriesQuery = db.collection('production_entries').where('data', '==', date);
        listenerManager.subscribe('launchProductions', entriesQuery,
            (snapshot) => {
                launchedEntries = new Set();
                productionEntries = snapshot.docs.map(doc => doc.data());
                snapshot.forEach(doc => {
                    const entry = doc.data();
                    if(entry.produzido > 0 || entry.refugo_kg > 0) {
                        launchedEntries.add(`${entry.planId}-${entry.turno}`);
                    }
                });
                render();
            },
            (error) => {
                console.error("Erro ao carregar lançamentos de produção: ", error);
            }
        );
    }

    function renderLaunchPanel(planItems, launchedEntries, productionEntries) {
        if (!launchPanelContainer) return;
        launchPanelContainer.innerHTML = planItems.map(item => {
            const t1Launched = launchedEntries.has(`${item.id}-T1`);
            const t2Launched = launchedEntries.has(`${item.id}-T2`);
            const t3Launched = launchedEntries.has(`${item.id}-T3`);

            const t1Class = t1Launched ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            const t2Class = t2Launched ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            const t3Class = t3Launched ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            
            const totalProduzido = productionEntries
                .filter(p => p.planId === item.id)
                .reduce((sum, p) => sum + (p.produzido || 0), 0);
            
            const meta = item.planned_quantity || 0;
            const progresso = meta > 0 ? (totalProduzido / meta) * 100 : 0;
            const progressoCor = progresso < 50 ? 'bg-status-error' : progresso < 90 ? 'bg-status-warning' : 'bg-status-success';

            const linkedOrderId = item.order_id || item.production_order_id || item.production_order || null;
            const linkedOrder = linkedOrderId && Array.isArray(productionOrdersCache)
                ? productionOrdersCache.find(order => order && order.id === linkedOrderId)
                : null;
            const orderNumberRaw = linkedOrder?.order_number
                || item.order_number
                || linkedOrder?.order_number_original
                || item.order_number_original
                || linkedOrder?.id
                || '';
            const orderNumberLabel = orderNumberRaw
                ? `OP ${escapeHtml(orderNumberRaw)}`
                : 'OP não vinculada';

            return `
            <div class="bg-gray-50 border rounded-lg p-4 shadow-sm flex flex-col justify-between">
                <div>
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="font-bold text-lg">${item.machine}</h3>
                            <p class="text-sm text-gray-600">${item.product}</p>
                            <p class="text-xs text-gray-500">${orderNumberLabel}</p>
                            <p class="text-xs text-gray-500 mt-1">${item.mp ? `MP: ${item.mp}` : 'MP não definida'}</p>
                        </div>
                        <span class="text-xs font-bold text-gray-500">${totalProduzido.toLocaleString('pt-BR')} / ${meta.toLocaleString('pt-BR')}</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                        <div class="${progressoCor} h-2.5 rounded-full" style="width: ${Math.min(progresso, 100)}%"></div>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-2 mt-4">
                    <button data-id="${item.id}" data-turno="T1" class="launch-btn ${t1Class} text-white font-bold py-2 rounded-md">Turno 1</button>
                    <button data-id="${item.id}" data-turno="T2" class="launch-btn ${t2Class} text-white font-bold py-2 rounded-md">Turno 2</button>
                    <button data-id="${item.id}" data-turno="T3" class="launch-btn ${t3Class} text-white font-bold py-2 rounded-md">Turno 3</button>
                </div>
            </div>
        `}).join('');
        lucide.createIcons();
    }
    
    async function handleLaunchPanelClick(e) {
        const launchButton = e.target.closest('.launch-btn');
        if (launchButton) {
            const planId = launchButton.dataset.id;
            const turno = launchButton.dataset.turno;
            showProductionModal(planId, turno);
        }
    }

    async function showProductionModal(planId, turno) {
        if (!productionModalForm || !productionModalTitle) return;
        
        productionModalForm.reset();
        document.getElementById('production-entry-plan-id').value = planId;
        document.getElementById('production-entry-turno').value = turno;

        try {
            const planDoc = await db.collection('planning').doc(planId).get();
            if (planDoc.exists) {
                const planData = planDoc.data();
                productionModalTitle.textContent = `Lançamento: ${planData.machine} - ${turno}`;
                // Preencher contexto do modal com dados do plano (máquina/produto)
                try {
                    fillModalContext(productionModal, {
                        machine: planData.machine,
                        product: planData.product,
                        product_cod: planData.product_cod
                    });
                } catch (e) { /* noop */ }
                
                // Configurar informações do produto
                const productWeightInfo = document.getElementById('product-weight-info');
                if (productWeightInfo) {
                    const pieceWeightGrams = resolvePieceWeightGrams(
                        planData.piece_weight_grams,
                        planData.piece_weight,
                        planData.weight
                    );
                    const infoParts = [
                        pieceWeightGrams > 0
                            ? `Peso da peça: ${pieceWeightGrams.toFixed(3)}g`
                            : 'Peso da peça: -'
                    ];
                    if (planData.mp) infoParts.push(`MP: ${planData.mp}`);
                    productWeightInfo.textContent = infoParts.join(' – ');
                }
                
                // Configurar caixa de tara
                const taraCheckbox = document.getElementById('use-tara-box');
                const taraWeightInput = document.getElementById('tara-box-weight');
                const taraInfo = document.getElementById('tara-box-info');
                
                const taraData = taraBoxesDatabase[planData.machine];
                if (taraData) {
                    taraWeightInput.value = taraData.peso;
                    taraInfo.textContent = taraData.descricao;
                }
            } else { throw new Error("Plano não encontrado."); }
            
            // Carregar lançamentos existentes
            await loadHourlyEntries(planId, turno);
            
            productionModal.classList.remove('hidden');

        } catch(error) {
            console.error("Erro ao abrir modal de produção:", error);
            alert("Não foi possível carregar os dados. Tente novamente.");
        }
    }

    function hideProductionModal() {
        if (productionModal) productionModal.classList.add('hidden');
    }

    async function handleProductionEntrySubmit(e) {
        e.preventDefault();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }

        // ✅ POKA-YOKE: Bloquear lançamento se ciclo/cavidades não foram informados
        if (!validateCycleCavityLaunched()) {
            return;
        }
        
        const statusMessage = document.getElementById('production-modal-status');
        const saveButton = document.getElementById('production-modal-save-btn');
        
        if (!saveButton) return;
        
        saveButton.disabled = true;
        saveButton.textContent = 'Salvando...';

        const formData = new FormData(productionModalForm);
        const planId = formData.get('planId');
        const turno = formData.get('turno');
        
        console.log('[TRACE][handleProductionEntrySubmit] submission started', { planId, turno });

        const produzido = parseInt(formData.get('produzido')) || 0;
        const refugoKg = parseFloat(formData.get('refugo')) || 0;
        const borrasKg = parseFloat(formData.get('borras')) || 0;
        const motivoRefugo = formData.get('perdas');

        console.log('[TRACE][handleProductionEntrySubmit] parsed form values', {
            produzido,
            refugoKg,
            borrasKg,
            motivoRefugo
        });

        try {
            // Salvar lançamentos por hora
            await saveHourlyEntries(planId, turno);
            console.log('[TRACE][handleProductionEntrySubmit] hourly entries saved');

            // Salvar registro principal de produção
            const entriesRef = db.collection('production_entries');
            const q = entriesRef.where('planId', '==', planId).where('turno', '==', turno).limit(1);
            const querySnapshot = await q.get();
            const planDoc = await db.collection('planning').doc(planId).get();
            const planData = planDoc.exists ? planDoc.data() : {};
            const linkedOrderId = planData.order_id || planData.production_order_id || planData.production_order || null;
            const linkedOrderNumber = planData.order_number || planData.orderNumber || null;
            const planMachine = planData.machine || selectedMachineData?.machine || null;
            const planDate = planData.date || getProductionDateString();
            const planMp = planData.mp || '';
            const planMpType = planData.mp_type || '';

            console.log('[TRACE][handleProductionEntrySubmit] resolved plan info', {
                planMachine,
                planDate,
                planMp,
                planMpType,
                linkedOrderId
            });

            const entryPayload = {
                produzido,
                duracao_min: 0,
                refugo_kg: refugoKg,
                borras_kg: borrasKg,
                motivo_refugo: motivoRefugo,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                machine: planMachine, // FIX: vincula a máquina correta para análise e filtros
                mp: planMp,
                mp_type: planMpType,
                orderId: linkedOrderId || null,
                order_id: linkedOrderId || null,
                production_order_id: linkedOrderId || null,
                order_number: linkedOrderNumber || null
            };

            console.log('[TRACE][handleProductionEntrySubmit] entry payload', entryPayload);
            
            if(querySnapshot.empty){
                console.log('[TRACE][handleProductionEntrySubmit] creating production entry');
                await entriesRef.add({
                    ...entryPayload,
                    planId,
                    turno,
                    data: planDate,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                }); // FIX: inclui data/createdAt para uso futuro
            } else {
                console.log('[TRACE][handleProductionEntrySubmit] updating existing production entry');
                await querySnapshot.docs[0].ref.update({
                    ...entryPayload,
                    data: planDate
                });
            }

            // =====================================================
            // INTEGRAÇÃO FERRAMENTARIA - Atualizar batidas do molde
            // =====================================================
            if (produzido > 0 && typeof window.atualizarBatidasPorProducao === 'function') {
                try {
                    // Já temos planData disponível aqui, então usar diretamente
                    const productCod = planData?.product_cod || planData?.productCod || planData?.part_code || 
                                       selectedMachineData?.product_cod || selectedMachineData?.productCod;
                    
                    console.log('[SYNC-FERRAMENTARIA] Modal - Dados para integração:', { productCod, produzido, planId });
                    
                    if (productCod) {
                        const resultadoBatidas = await window.atualizarBatidasPorProducao(productCod, produzido);
                        if (resultadoBatidas.success) {
                            console.log(`[SYNC-FERRAMENTARIA] ✅ Modal Produção - Batidas atualizadas: molde "${resultadoBatidas.molde}", +${resultadoBatidas.batidasAdicionadas} batidas`);
                        } else {
                            console.log(`[SYNC-FERRAMENTARIA] ⚠️ Modal - Batidas não atualizadas:`, resultadoBatidas.reason);
                        }
                    } else {
                        console.log('[SYNC-FERRAMENTARIA] ⚠️ Modal - product_cod não encontrado');
                    }
                } catch (ferramentariaErr) {
                    console.warn('[SYNC-FERRAMENTARIA] Falha ao atualizar batidas (modal):', ferramentariaErr);
                }
            }

            if (statusMessage) {
                statusMessage.textContent = 'Lançamentos salvos com sucesso!';
                statusMessage.className = 'text-green-600 text-sm font-semibold h-5 text-center';
            }
            // Atualizar aba de análise se estiver aberta
            await refreshAnalysisIfActive();
            setTimeout(() => {
                hideProductionModal();
                if (statusMessage) statusMessage.textContent = '';
            }, 1500);
        } catch (error) {
            console.error("Erro ao salvar lançamentos: ", error);
            if (statusMessage) {
                statusMessage.textContent = 'Erro ao salvar. Tente novamente.';
                statusMessage.className = 'text-red-600 text-sm font-semibold h-5 text-center';
            }
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Salvar Lançamentos';
        }
    }
    // --- ABA DE LANÇAMENTO INTERATIVO ---
    
    function setupLaunchTab() {
        populateMachineSelector();

        if (machineCardGrid && !machineCardGrid.dataset.listenerAttached) {
            machineCardGrid.addEventListener('click', async (event) => {
                // Ações de botões dentro do card
                const finalizeBtn = event.target.closest('.card-finalize-btn');
                if (finalizeBtn) {
                    event.preventDefault();
                    event.stopPropagation();
                    await handleCardFinalizeClick(finalizeBtn);
                    return;
                }
                const activateNextBtn = event.target.closest('.card-activate-next-btn');
                if (activateNextBtn) {
                    event.preventDefault();
                    event.stopPropagation();
                    await handleCardActivateNextClick(activateNextBtn);
                    return;
                }

                // Seleção do card da máquina
                const card = event.target.closest('.machine-card');
                if (!card) return;
                const machine = card.dataset.machine;
                if (!machine) return;
                // Scroll automático apenas quando usuário clica diretamente no card
                await onMachineSelected(machine, { scrollToPanel: true });
            });
            machineCardGrid.dataset.listenerAttached = 'true';
        }

        setupActionButtons();
        updateCurrentShift();
        setInterval(updateCurrentShift, 60000);

        // Toggle modo do gráfico (Por hora / OP)
        if (launchChartModeHourlyBtn && !launchChartModeHourlyBtn.dataset.listenerAttached) {
            launchChartModeHourlyBtn.addEventListener('click', async () => {
                if (launchChartMode === 'hourly') return;
                launchChartMode = 'hourly';
                launchChartModeHourlyBtn.classList.add('bg-white','text-blue-600','shadow-sm');
                launchChartModeOpBtn?.classList.remove('bg-white','text-blue-600','shadow-sm');
                if (opProductionChart) opProductionChart.classList.add('hidden');
                if (hourlyProductionChart) hourlyProductionChart.classList.remove('hidden');
                await refreshLaunchCharts();
            });
            launchChartModeHourlyBtn.dataset.listenerAttached = 'true';
        }
        if (launchChartModeOpBtn && !launchChartModeOpBtn.dataset.listenerAttached) {
            launchChartModeOpBtn.addEventListener('click', async () => {
                if (launchChartMode === 'op') return;
                launchChartMode = 'op';
                launchChartModeOpBtn.classList.add('bg-white','text-blue-600','shadow-sm');
                launchChartModeHourlyBtn?.classList.remove('bg-white','text-blue-600','shadow-sm');
                if (hourlyProductionChart) hourlyProductionChart.classList.add('hidden');
                if (opProductionChart) opProductionChart.classList.remove('hidden');
                await refreshLaunchCharts();
            });
            launchChartModeOpBtn.dataset.listenerAttached = 'true';
        }
    }

    function updateCurrentShift() {
        const now = new Date();
        const hour = now.getHours();
        const minute = now.getMinutes();
        let currentShift;
        
        // T1: 06:30-14:59, T2: 15:00-23:19, T3: 23:20-06:29
        if ((hour === 6 && minute >= 30) || (hour >= 7 && hour < 15)) {
            currentShift = 'T1';
        } else if (hour >= 15 && (hour < 23 || (hour === 23 && minute < 20))) {
            currentShift = 'T2';
        } else {
            currentShift = 'T3';
        }
        
        if (currentShiftDisplay) {
            currentShiftDisplay.textContent = currentShift;
        }
    }
    
    function updateMachineInfo() {
        if (!selectedMachineData) return;
        
        if (machineIcon) machineIcon.textContent = selectedMachineData.machine;
        if (machineName) machineName.textContent = `Máquina ${selectedMachineData.machine}`;
        if (productName) productName.textContent = selectedMachineData.product || 'Produto não definido';
        if (shiftTarget) {
            // Usar APENAS lot_size, não planned_quantity (meta diária)
            const totalPlanned = selectedMachineData.order_lot_size || selectedMachineData.lot_size || 0;
            const totalExecuted = coerceToNumber(selectedMachineData.total_produzido, 0);
            
            if (!totalPlanned) {
                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / N/A`;
            } else {
                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / ${totalPlanned.toLocaleString('pt-BR')}`;
            }
        }
    }
    
    
    
    // Carregar gráfico da OP (acumulado por DIA ao longo da ordem)
    async function loadOpProductionChart() {
        if (!selectedMachineData || !opProductionChart) return;
        try {
            const orderId = selectedMachineData.order_id || selectedMachineData.orderId || null;
            const planId = selectedMachineData.id;
            let query = db.collection('production_entries');
            if (orderId) {
                query = query.where('orderId', '==', orderId);
            } else {
                query = query.where('planId', '==', planId);
            }
            const snap = await query.get();
            const entries = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            if (entries.length === 0) {
                if (opChartInstance) { opChartInstance.destroy(); opChartInstance = null; }
                const ctx = opProductionChart.getContext('2d');
                ctx.clearRect(0,0,opProductionChart.width, opProductionChart.height);
                return;
            }
            const parseDate = (e) => {
                try {
                    if (e.timestamp?.toDate) return e.timestamp.toDate();
                } catch (_) {}
                if (e.dataHoraInformada) return new Date(e.dataHoraInformada);
                if (e.data && e.horaInformada) return new Date(`${e.data}T${e.horaInformada}:00`);
                if (e.data) return new Date(`${e.data}T12:00:00`);
                return new Date();
            };
            // Agrupar por DIA de produção
            const toDateKey = (e) => {
                if (e.data) return e.data; // já deve estar em YYYY-MM-DD
                const d = parseDate(e);
                const y = d.getFullYear();
                const m = String(d.getMonth()+1).padStart(2,'0');
                const day = String(d.getDate()).padStart(2,'0');
                return `${y}-${m}-${day}`;
            };
            const dailyTotals = {};
            entries.forEach(e => {
                const key = toDateKey(e);
                const qty = Number(e.produzido || e.quantity || 0) || 0;
                dailyTotals[key] = (dailyTotals[key] || 0) + qty;
            });
            const dayKeys = Object.keys(dailyTotals).sort(); // YYYY-MM-DD ordena lexicograficamente por data
            let cumulative = 0;
            const labels = [];
            const values = [];
            const fmtDay = (k) => {
                // k: YYYY-MM-DD -> DD/MM
                const [yy, mm, dd] = k.split('-');
                return `${dd}/${mm}`;
            };
            dayKeys.forEach(k => {
                cumulative += dailyTotals[k];
                labels.push(fmtDay(k));
                values.push(cumulative);
            });
            if (opChartInstance) { opChartInstance.destroy(); opChartInstance = null; }
            opChartInstance = new Chart(opProductionChart.getContext('2d'), {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Acumulado da OP (por dia)',
                            data: values,
                            borderColor: '#10B981',
                            backgroundColor: 'rgba(16,185,129,0.15)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { grid: { display: false } },
                        y: { beginAtZero: true, grid: { color: 'rgba(0,0,0,0.05)' } }
                    },
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => ` ${ctx.parsed.y?.toLocaleString('pt-BR')} peças`
                            }
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Erro ao carregar gráfico da OP:', error);
        }
    }

    async function refreshLaunchCharts() {
        // Guard para evitar atualizações concorrentes sobrescrevendo o gráfico
        if (isRefreshingLaunchCharts) return;
        isRefreshingLaunchCharts = true;
        try {
            if (launchChartMode === 'op') {
                await loadOpProductionChart();
            } else {
                await loadHourlyProductionChart();
            }
        } finally {
            isRefreshingLaunchCharts = false;
        }
    }
    
    async function loadTodayStats() {
        if (!selectedMachineData) return;
        
        try {
            const today = getProductionDateString();
            // Calcular janela do dia de produção atual [07:00 de hoje, 07:00 de amanhã)
            const windowStart = combineDateAndTime(today, '07:00');
            const nextDay = new Date(windowStart);
            nextDay.setDate(nextDay.getDate() + 1);
            const tomorrow = nextDay.toISOString().split('T')[0];
            const windowEnd = combineDateAndTime(tomorrow, '07:00');
            
            // Carregar produção do dia para a MÁQUINA (somando todas as OPs do dia)
            const prodSnapshot = await db.collection('production_entries')
                .where('data', '==', today)
                .where('machine', '==', selectedMachineData.machine)
                .get();
            const prodDocs = prodSnapshot.docs;
            let totalProduced = 0;
            let totalLosses = 0;
            
            // Produção por turno
            let producedT1 = 0;
            let producedT2 = 0;
            let producedT3 = 0;
            
            prodDocs.forEach(doc => {
                const data = doc.data();
                const quantidade = Number(data.produzido || data.quantity || 0) || 0;
                const turno = Number(data.turno || data.shift || 0);
                
                totalProduced += quantidade;
                totalLosses += Number(data.refugo_kg || 0) || 0;
                
                // Separar por turno
                if (turno === 1) {
                    producedT1 += quantidade;
                } else if (turno === 2) {
                    producedT2 += quantidade;
                } else if (turno === 3) {
                    producedT3 += quantidade;
                }
            });
            
            // Carregar paradas (duas consultas por data para evitar índice composto)
            const [dtSnapToday, dtSnapTomorrow] = await Promise.all([
                db.collection('downtime_entries')
                  .where('machine', '==', selectedMachineData.machine)
                  .where('date', '==', today)
                  .get(),
                db.collection('downtime_entries')
                  .where('machine', '==', selectedMachineData.machine)
                  .where('date', '==', tomorrow)
                  .get()
            ]);
            const dtDocs = [...dtSnapToday.docs, ...dtSnapTomorrow.docs];
            let totalDowntime = 0;
            dtDocs.forEach(doc => {
                const data = doc.data();
                const start = combineDateAndTime(data.date, data.startTime);
                const end = combineDateAndTime(data.date, data.endTime);
                if (!(start instanceof Date) || Number.isNaN(start.getTime())) return;
                if (!(end instanceof Date) || Number.isNaN(end.getTime())) return;
                const overlapStart = start > windowStart ? start : windowStart;
                const overlapEnd = end < windowEnd ? end : windowEnd;
                if (overlapEnd > overlapStart) {
                    totalDowntime += Math.round((overlapEnd - overlapStart) / 60000);
                }
            });
            
            // Calcular eficiência baseado na meta diária (com fallback para planned_quantity)
            const dailyTarget = Number(selectedMachineData.daily_target || selectedMachineData.planned_quantity || 0);
            const efficiency = dailyTarget > 0 ? (totalProduced / dailyTarget * 100) : 0;
            
            // Atualizar display - produção por turno
            const producedT1El = document.getElementById('produced-t1');
            const producedT2El = document.getElementById('produced-t2');
            const producedT3El = document.getElementById('produced-t3');
            if (producedT1El) producedT1El.textContent = producedT1.toLocaleString('pt-BR');
            if (producedT2El) producedT2El.textContent = producedT2.toLocaleString('pt-BR');
            if (producedT3El) producedT3El.textContent = producedT3.toLocaleString('pt-BR');
            
            // Atualizar display - totais
            if (producedToday) producedToday.textContent = totalProduced.toLocaleString('pt-BR');
            if (efficiencyToday) efficiencyToday.textContent = efficiency.toFixed(1) + '%';
            if (lossesToday) lossesToday.textContent = totalLosses.toFixed(2);
            if (downtimeToday) downtimeToday.textContent = totalDowntime;
            
        } catch (error) {
            console.error("Erro ao carregar estatísticas: ", error);
        }
    }
    
    function setupActionButtons() {
        // Botão de produção
        const btnProduction = document.getElementById('btn-production');
        if (btnProduction && !btnProduction.dataset.listenerAttached) {
            btnProduction.addEventListener('click', openProductionModal);
            btnProduction.dataset.listenerAttached = 'true';
        }

        // Botão de perdas
        const btnLosses = document.getElementById('btn-losses');
        if (btnLosses && !btnLosses.dataset.listenerAttached) {
            btnLosses.addEventListener('click', openLossesModal);
            btnLosses.dataset.listenerAttached = 'true';
        }
        
        // Botão de parada
        const btnDowntime = document.getElementById('btn-downtime');
        if (btnDowntime && !btnDowntime.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-downtime');
            btnDowntime.addEventListener('click', toggleDowntime);
            btnDowntime.dataset.listenerAttached = 'true';
        } else if (btnDowntime) {
            console.log('[TRACE][setupEventListeners] btn-downtime listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-downtime não encontrado no DOM');
        }
        
        // Botão de produção manual
        const btnManualProduction = document.getElementById('btn-manual-production');
        if (btnManualProduction && !btnManualProduction.dataset.listenerAttached) {
            btnManualProduction.addEventListener('click', openManualProductionModal);
            btnManualProduction.dataset.listenerAttached = 'true';
        }

        const btnManualLosses = document.getElementById('btn-manual-losses');
        if (btnManualLosses && !btnManualLosses.dataset.listenerAttached) {
            btnManualLosses.addEventListener('click', openManualLossesModal);
            btnManualLosses.dataset.listenerAttached = 'true';
        }

        // Botão de lançamento manual de parada
        const btnManualDowntime = document.getElementById('btn-manual-downtime');
        if (btnManualDowntime && !btnManualDowntime.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-manual-downtime');
            btnManualDowntime.addEventListener('click', openManualDowntimeModal);
            btnManualDowntime.dataset.listenerAttached = 'true';
        } else if (btnManualDowntime) {
            console.log('[TRACE][setupEventListeners] btn-manual-downtime listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-manual-downtime não encontrado no DOM');
        }
        
        // Botão de retrabalho
        const btnRework = document.getElementById('btn-rework');
        if (btnRework && !btnRework.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-rework');
            btnRework.addEventListener('click', openReworkModal);
            btnRework.dataset.listenerAttached = 'true';
        } else if (btnRework) {
            console.log('[TRACE][setupEventListeners] btn-rework listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-rework não encontrado no DOM');
        }
        
        // Botão de borra
        const btnManualBorra = document.getElementById('btn-manual-borra');
        if (btnManualBorra && !btnManualBorra.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-manual-borra');
            btnManualBorra.addEventListener('click', openManualBorraModal);
            btnManualBorra.dataset.listenerAttached = 'true';
        } else if (btnManualBorra) {
            console.log('[TRACE][setupEventListeners] btn-manual-borra listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-manual-borra não encontrado no DOM');
        }

        // Botão de ajuste de quantidade executada
        const btnAdjustExecuted = document.getElementById('btn-adjust-executed');
        if (btnAdjustExecuted && !btnAdjustExecuted.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-adjust-executed');
            btnAdjustExecuted.addEventListener('click', openAdjustExecutedModal);
            btnAdjustExecuted.dataset.listenerAttached = 'true';
        } else if (btnAdjustExecuted) {
            console.log('[TRACE][setupEventListeners] btn-adjust-executed listener já anexado');
        }

        // Botão de paradas longas
        const btnExtendedDowntime = document.getElementById('btn-extended-downtime');
        if (btnExtendedDowntime && !btnExtendedDowntime.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-extended-downtime');
            btnExtendedDowntime.addEventListener('click', openExtendedDowntimeModal);
            btnExtendedDowntime.dataset.listenerAttached = 'true';
        } else if (btnExtendedDowntime) {
            console.log('[TRACE][setupEventListeners] btn-extended-downtime listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-extended-downtime não encontrado no DOM');
        }

        // Nota: O submit de paradas longas da ABA é tratado pelo setupExtendedDowntimeTab()
        // Não anexar listener duplicado aqui
        
        // Setup modals
        try {
            setupModals();
            console.log('[TRACE][setupEventListeners] setupModals completed successfully');
        } catch (err) {
            console.error('[ERROR][setupEventListeners] setupModals failed:', err);
        }
        
        // Setup tare controls
        try {
            setupTareControls();
            console.log('[TRACE][setupEventListeners] setupTareControls completed successfully');
        } catch (err) {
            console.error('[ERROR][setupEventListeners] setupTareControls failed:', err);
        }
    }

    async function handleFinalizeOrderClick(event) {
        event?.preventDefault?.();

        if (!selectedMachineData) {
            alert('Selecione uma máquina antes de finalizar a ordem.');
            return;
        }

        if (typeof window.authSystem?.checkPermissionForAction === 'function') {
            const hasPermission = window.authSystem.checkPermissionForAction('close_production_order');
            if (hasPermission === false) {
                return;
            }
        }

        // ⚠️ MULTI-PRODUTO: Verificar se há múltiplos planos elegíveis para finalização
        const machinePlans = machineCardData[selectedMachineData.machine] || [];
        const eligiblePlans = machinePlans.filter(p => {
            const status = String(p.status || '').toLowerCase();
            // Planos que podem ser finalizados: ativa, em_andamento, ou planejado (não concluída/cancelada)
            return !['concluida', 'cancelada', 'finalizada', 'encerrada'].includes(status);
        });

        if (eligiblePlans.length === 0) {
            showNotification('Nenhuma ordem elegível para finalização nesta máquina.', 'warning');
            return;
        }

        // Se houver múltiplos planos elegíveis, mostrar modal de seleção
        if (eligiblePlans.length > 1) {
            openFinalizeOrderSelectorModal(eligiblePlans);
            return;
        }

        // Se houver apenas 1 plano elegível, finalizar diretamente
        const targetPlan = eligiblePlans[0];
        await executeFinalizeOrder(targetPlan);
    }

    // Modal de seleção de OP para finalização (Multi-Produto)
    function openFinalizeOrderSelectorModal(plans) {
        const modal = document.getElementById('finalize-order-selector-modal');
        const listContainer = document.getElementById('finalize-order-list');
        const closeBtn = document.getElementById('finalize-order-selector-close');
        const cancelBtn = document.getElementById('finalize-order-selector-cancel');

        if (!modal || !listContainer) {
            console.error('Modal de seleção de OP não encontrado');
            // Fallback: usar o primeiro plano
            if (plans.length > 0) {
                executeFinalizeOrder(plans[0]);
            }
            return;
        }

        // Limpar lista anterior
        listContainer.innerHTML = '';

        // Gerar cards para cada plano
        plans.forEach((plan, idx) => {
            const productName = plan.product || plan.product_name || getProductByCode(plan.product_cod)?.name || `Produto ${idx + 1}`;
            const orderNum = plan.order_number || plan.order_number_original || '-';
            const turno = plan.turno || plan.shift || '-';
            const status = plan.status || 'planejado';
            const statusColor = status === 'ativa' ? 'bg-green-100 text-green-700' : 'bg-blue-100 text-blue-700';
            const progress = plan.progress || plan.last_progress || {};
            const executed = progress.executed || 0;
            const planned = progress.planned || plan.quantidade || 0;
            const percentComplete = planned > 0 ? Math.round((executed / planned) * 100) : 0;

            const card = document.createElement('div');
            card.className = 'bg-gray-50 hover:bg-gray-100 border border-gray-200 rounded-xl p-4 cursor-pointer transition-all hover:shadow-md hover:border-emerald-300';
            card.innerHTML = `
                <div class="flex items-start justify-between gap-3">
                    <div class="flex-1 min-w-0">
                        <div class="flex items-center gap-2 mb-2">
                            <span class="text-xs font-bold ${statusColor} px-2 py-0.5 rounded-full">${status.toUpperCase()}</span>
                            <span class="text-xs bg-purple-100 text-purple-700 px-2 py-0.5 rounded-full">T${turno}</span>
                        </div>
                        <p class="font-semibold text-gray-800 text-sm truncate" title="${productName}">${productName}</p>
                        <p class="text-xs text-gray-500 mt-1">OP: <span class="font-medium">${orderNum}</span></p>
                        <div class="mt-2">
                            <div class="flex items-center justify-between text-xs text-gray-500 mb-1">
                                <span>Progresso</span>
                                <span class="font-medium">${executed.toLocaleString()} / ${planned.toLocaleString()} (${percentComplete}%)</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-1.5 overflow-hidden">
                                <div class="h-full rounded-full transition-all ${percentComplete >= 100 ? 'bg-emerald-500' : 'bg-blue-500'}" style="width: ${Math.min(percentComplete, 100)}%"></div>
                            </div>
                        </div>
                    </div>
                    <button type="button" class="finalize-plan-btn flex-shrink-0 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-2 px-3 rounded-lg text-xs transition-colors flex items-center gap-1.5">
                        <i data-lucide="check-circle" class="w-4 h-4"></i>
                        Finalizar
                    </button>
                </div>
            `;

            // Evento de clique no botão de finalizar
            const finalizeBtn = card.querySelector('.finalize-plan-btn');
            finalizeBtn.addEventListener('click', async (e) => {
                e.stopPropagation();
                closeModal('finalize-order-selector-modal');
                await executeFinalizeOrder(plan);
            });

            listContainer.appendChild(card);
        });

        // Eventos de fechar modal
        const closeModal_ = () => closeModal('finalize-order-selector-modal');
        closeBtn?.addEventListener('click', closeModal_);
        cancelBtn?.addEventListener('click', closeModal_);

        // Abrir modal
        modal.classList.remove('hidden');
        lucide.createIcons();
    }

    // Executa a finalização de uma ordem específica
    async function executeFinalizeOrder(plan) {
        // Buscar a OP correspondente ao plano
        let targetOrder = null;
        
        if (plan.order_id) {
            try {
                const orderDoc = await db.collection('production_orders').doc(plan.order_id).get();
                if (orderDoc.exists) {
                    targetOrder = { id: orderDoc.id, ...orderDoc.data() };
                }
            } catch (err) {
                console.warn('Erro ao buscar OP por order_id:', err);
            }
        }

        // Se não encontrou por order_id, buscar por part_code
        if (!targetOrder && plan.product_cod) {
            try {
                const ordersSnapshot = await db.collection('production_orders')
                    .where('part_code', '==', String(plan.product_cod))
                    .get();
                
                if (!ordersSnapshot.empty) {
                    const orders = ordersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    const isOpen = (o) => !['concluida','cancelada','finalizada','encerrada'].includes(String(o.status||'').toLowerCase());
                    targetOrder = orders.find(o => ['ativa','em_andamento'].includes(String(o.status||'').toLowerCase()))
                        || orders.filter(isOpen)[0]
                        || orders[0];
                }
            } catch (err) {
                console.warn('Erro ao buscar OP por part_code:', err);
            }
        }

        if (!targetOrder) {
            // Se não encontrar OP, finalizar apenas o planejamento
            console.log('OP não encontrada, finalizando apenas planejamento:', plan.id);
        }

        const orderLabel = targetOrder?.order_number || targetOrder?.order_number_original || plan.order_number || plan.id;
        const confirmMessage = `Confirma a finalização da OP ${orderLabel || ''}? Esta ação marcará o lote como concluído.`;
        if (!window.confirm(confirmMessage)) {
            return;
        }

        const button = finalizeOrderBtn;
        const originalContent = button ? button.innerHTML : '';

        try {
            if (button) {
                button.disabled = true;
                button.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Finalizando...</span>`;
                lucide.createIcons();
            }

            const currentUser = getActiveUser();
            const progressSnapshot = {
                executed: Number(plan.progress?.executed || currentOrderProgress?.executed) || 0,
                planned: Number(plan.progress?.planned || currentOrderProgress?.planned || plan.quantidade) || 0,
                expected: Number(plan.progress?.expected || currentOrderProgress?.expected) || 0
            };

            // Atualizar OP se existir
            if (targetOrder?.id) {
                const updatePayload = {
                    status: 'concluida',
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    completedBy: currentUser.username || null,
                    completedByName: currentUser.name || null,
                    last_progress: {
                        ...progressSnapshot,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                    }
                };

                await db.collection('production_orders').doc(targetOrder.id).update(updatePayload);
            }

            // Atualizar planejamento
            if (plan.id) {
                const planUpdate = {
                    status: 'concluida',
                    finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    finishedBy: currentUser.name || currentUser.username || null
                };

                try {
                    await db.collection('planning').doc(plan.id).update(planUpdate);
                } catch (planError) {
                    console.warn('Não foi possível atualizar status do planejamento:', planError);
                }
            }

            showNotification(`OP ${orderLabel} finalizada com sucesso!`, 'success');

            // Verificar se ainda há outras OPs ativas na máquina
            const machinePlans = machineCardData[selectedMachineData?.machine] || [];
            const remainingActive = machinePlans.filter(p => 
                p.id !== plan.id && 
                !['concluida', 'cancelada', 'finalizada', 'encerrada'].includes(String(p.status || '').toLowerCase())
            );

            if (remainingActive.length > 0) {
                // Ainda há OPs ativas, manter painel visível e selecionar a próxima
                selectedMachineData = remainingActive[0];
                showNotification(`Ainda há ${remainingActive.length} OP(s) ativa(s) nesta máquina.`, 'info');
                await loadRecentEntriesForMachine(selectedMachineData.machine, selectedMachineData.product_cod);
            } else {
                // Não há mais OPs ativas
                if (button) {
                    button.classList.add('hidden');
                }

                currentActiveOrder = null;
                selectedMachineData = null;
                setActiveMachineCard(null);
                resetProductionTimer();
                if (productionControlPanel) {
                    productionControlPanel.classList.add('hidden');
                }
                if (recentEntriesList) {
                    recentEntriesList.innerHTML = '';
                }
                updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
                setRecentEntriesState({ loading: false, empty: true });
            }

            await Promise.allSettled([
                loadTodayStats(),
                refreshAnalysisIfActive(),
                populateMachineSelector()
            ]);

        } catch (error) {
            console.error('Erro ao finalizar ordem de produção:', error);
            alert('Não foi possível finalizar a ordem. Tente novamente.');
        } finally {
            if (button) {
                button.disabled = false;
                button.innerHTML = originalContent;
                lucide.createIcons();
            }
        }
    }
    
    function setupModals() {
    // ================================
    // VALIDAÇÃO EM TEMPO REAL (POKA-YOKE)
    // ================================
    
    // Validar campos de lançamento de produção em tempo real
    function setupProductionFormValidation() {
        const qtyInput = document.getElementById('quick-production-qty');
        const weightInput = document.getElementById('quick-production-weight');
        const useTareCheckbox = document.getElementById('quick-production-use-tare');
        const submitBtn = document.getElementById('quick-production-submit');
        const measuredFeedback = document.getElementById('quick-production-piece-weight-feedback');
        const measuredVariation = document.getElementById('quick-production-piece-weight-variation');
        
        if (!qtyInput || !weightInput) return;
        
        // Função para atualizar feedback
        const updateFeedback = () => {
            const qty = qtyInput.value ? parseInt(qtyInput.value, 10) : 0;
            const weightInput_value = weightInput.value || '';
            const weightGrams = parseWeightInputToGrams(weightInput_value);
            // Usar getActivePieceWeightGrams que faz fallback para o catálogo
            const activePieceWeight = getActivePieceWeightGrams();
            
            // Atualizar display de conversão
            const convertedDisplay = document.getElementById('quick-production-weight-converted');
            if (weightGrams > 0) {
                let conversionText = '';
                
                // Mostrar conversão de unidade
                if (parseFloat(weightInput_value) > 0 && parseFloat(weightInput_value) < 100) {
                    conversionText = `= ${weightGrams}g`;
                } else {
                    conversionText = `= ${(weightGrams/1000).toFixed(3)}kg`;
                }
                
                // Calcular peso líquido se tara estiver ativa
                let netWeightGrams = weightGrams;
                if (useTareCheckbox && useTareCheckbox.checked) {
                    const tareGrams = getTareWeightForMachine(selectedMachineData?.machine);
                    if (tareGrams > 0) {
                        netWeightGrams = Math.max(0, weightGrams - tareGrams);
                        conversionText += ` → ${(netWeightGrams/1000).toFixed(3)}kg (líquido)`;
                    }
                }
                
                // ✅ NOVO: Mostrar conversão para peças
                if (activePieceWeight > 0 && netWeightGrams > 0) {
                    const estimatedPieces = Math.floor(netWeightGrams / activePieceWeight);
                    conversionText += ` ≈ ${estimatedPieces.toLocaleString('pt-BR')} peças`;
                }
                
                convertedDisplay.textContent = conversionText;
                convertedDisplay.classList.remove('hidden');
            } else {
                convertedDisplay.textContent = '';
            }
            
            if (measuredVariation) {
                measuredVariation.textContent = '';
                measuredVariation.classList.add('hidden');
            }
            
            // Validar consistência se ambos preenchidos
            const consistencyAlert = document.getElementById('quick-production-consistency-alert');
            const consistencyMsg = document.getElementById('quick-production-consistency-message');
            
            if (qty > 0 && weightGrams > 0 && selectedMachineData) {
                if (activePieceWeight > 0) {
                    const consistency = validateWeightQuantityConsistency(weightGrams, qty, activePieceWeight, PIECE_WEIGHT_TOLERANCE_PERCENT);
                    if (!consistency.valid) {
                        consistencyAlert.classList.remove('hidden');
                        consistencyMsg.textContent = consistency.message;
                        submitBtn.classList.add('opacity-75');
                    } else {
                        consistencyAlert.classList.add('hidden');
                        submitBtn.classList.remove('opacity-75');
                    }
                }
            } else {
                consistencyAlert.classList.add('hidden');
                submitBtn.classList.remove('opacity-75');
            }
            
            // Validar que pelo menos um campo está preenchido
            if ((qty === 0 || !qtyInput.value) && (weightGrams === 0 || !weightInput.value)) {
                submitBtn.disabled = true;
                submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                submitBtn.disabled = false;
                submitBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        };

        quickProductionUpdateFeedback = updateFeedback;
        
        // Event listeners
        qtyInput.addEventListener('input', updateFeedback);
        qtyInput.addEventListener('blur', updateFeedback);
        qtyInput.addEventListener('change', updateFeedback);

        weightInput.addEventListener('input', updateFeedback);
        weightInput.addEventListener('blur', updateFeedback);
        weightInput.addEventListener('change', updateFeedback);
        
        if (measuredInput) {
            measuredInput.addEventListener('input', () => {
                if (measuredInput.value && measuredFeedback) {
                    measuredFeedback.textContent = '';
                }
                updateFeedback();
            });
            measuredInput.addEventListener('blur', () => {
                const val = measuredInput.value;
                if (val && (isNaN(parseFloat(val)) || parseFloat(val) <= 0)) {
                    measuredInput.classList.add('border-red-500', 'border-2');
                    if (measuredFeedback) {
                        measuredFeedback.textContent = '❌ Informe um peso válido em gramas';
                        measuredFeedback.classList.add('text-red-600');
                    }
                } else {
                    measuredInput.classList.remove('border-red-500', 'border-2');
                    if (measuredFeedback) {
                        measuredFeedback.textContent = 'Se vazio, será usado o peso padrão do planejamento.';
                        measuredFeedback.classList.remove('text-red-600');
                    }
                }
            });
        }
        
        if (useTareCheckbox) {
            useTareCheckbox.addEventListener('change', updateFeedback);
        }
        
        // Validar que quantidade é inteiro positivo
        qtyInput.addEventListener('blur', function() {
            const val = this.value;
            if (val && (isNaN(parseInt(val, 10)) || parseInt(val, 10) < 0)) {
                this.classList.add('border-red-500', 'border-2');
                document.getElementById('quick-production-qty-feedback').textContent = '❌ Deve ser um número inteiro positivo';
                document.getElementById('quick-production-qty-feedback').classList.add('text-red-600');
            } else {
                this.classList.remove('border-red-500', 'border-2');
                document.getElementById('quick-production-qty-feedback').textContent = '';
                document.getElementById('quick-production-qty-feedback').classList.remove('text-red-600');
            }
        });
        
        // Validar que peso é número positivo
        weightInput.addEventListener('blur', function() {
            const val = this.value;
            if (val && (isNaN(parseFloat(val)) || parseFloat(val) < 0)) {
                this.classList.add('border-red-500', 'border-2');
                document.getElementById('quick-production-weight-feedback').textContent = '❌ Deve ser um número positivo';
                document.getElementById('quick-production-weight-feedback').classList.add('text-red-600');
            } else {
                this.classList.remove('border-red-500', 'border-2');
                document.getElementById('quick-production-weight-feedback').textContent = 'Digite o peso em gramas (Ex: 1500g = 1,5kg)';
                document.getElementById('quick-production-weight-feedback').classList.remove('text-red-600');
            }
        });
        
        // Primeiro update
        updateFeedback();
    }

        // Modal de produção
        const quickProductionModal = document.getElementById('quick-production-modal');
        const quickProductionClose = document.getElementById('quick-production-close');
        const quickProductionCancel = document.getElementById('quick-production-cancel');
        const quickProductionForm = document.getElementById('quick-production-form');
        
        if (quickProductionClose) quickProductionClose.addEventListener('click', () => closeModal('quick-production-modal'));
        if (quickProductionCancel) quickProductionCancel.addEventListener('click', () => closeModal('quick-production-modal'));
        // Listeners serão adicionados em openProductionModal() quando o modal abre
        
        // Modal de perdas
        const quickLossesClose = document.getElementById('quick-losses-close');
        const quickLossesCancel = document.getElementById('quick-losses-cancel');
        const quickLossesForm = document.getElementById('quick-losses-form');
        const quickLossesDeleteBtn = document.getElementById('quick-losses-delete-btn');
        
        if (quickLossesClose) quickLossesClose.addEventListener('click', () => closeModal('quick-losses-modal'));
        if (quickLossesCancel) quickLossesCancel.addEventListener('click', () => closeModal('quick-losses-modal'));
        if (quickLossesForm) quickLossesForm.addEventListener('submit', handleLossesSubmit);
        if (quickLossesDeleteBtn) {
            quickLossesDeleteBtn.addEventListener('click', () => {
                if (currentEditContext && currentEditContext.type === 'loss' && currentEditContext.id) {
                    const targetCollection = currentEditContext.collection || 'production_entries';
                    showConfirmModal(currentEditContext.id, targetCollection);
                } else {
                    alert('Abra um lançamento existente para excluir.');
                }
            });
        }
        
        // Modal de parada
        const quickDowntimeClose = document.getElementById('quick-downtime-close');
        const quickDowntimeCancel = document.getElementById('quick-downtime-cancel');
        const quickDowntimeForm = document.getElementById('quick-downtime-form');
        
        if (quickDowntimeClose) quickDowntimeClose.addEventListener('click', () => closeModal('quick-downtime-modal'));
        if (quickDowntimeCancel) quickDowntimeCancel.addEventListener('click', () => closeModal('quick-downtime-modal'));
        if (quickDowntimeForm) quickDowntimeForm.addEventListener('submit', handleDowntimeSubmit);
        
        // Modal de produção manual
        const manualProductionClose = document.getElementById('manual-production-close');
        const manualProductionCancel = document.getElementById('manual-production-cancel');
        const manualProductionForm = document.getElementById('manual-production-form');
        const manualProductionSubmitBtn = document.getElementById('manual-production-submit');

        if (manualProductionClose) manualProductionClose.addEventListener('click', () => closeModal('manual-production-modal'));
        if (manualProductionCancel) manualProductionCancel.addEventListener('click', () => closeModal('manual-production-modal'));
        
        // Modal de perdas manual
        const manualLossesClose = document.getElementById('manual-losses-close');
        const manualLossesCancel = document.getElementById('manual-losses-cancel');

        if (manualLossesClose) manualLossesClose.addEventListener('click', () => closeModal('manual-losses-modal'));
        if (manualLossesCancel) manualLossesCancel.addEventListener('click', () => closeModal('manual-losses-modal'));

        // Modal de parada manual
        const manualDowntimeClose = document.getElementById('manual-downtime-close');
        const manualDowntimeCancel = document.getElementById('manual-downtime-cancel');
        
        if (manualDowntimeClose) manualDowntimeClose.addEventListener('click', () => closeModal('manual-downtime-modal'));
        if (manualDowntimeCancel) manualDowntimeCancel.addEventListener('click', () => closeModal('manual-downtime-modal'));

        // Modal de retrabalho
        const quickReworkClose = document.getElementById('quick-rework-close');
        const quickReworkCancel = document.getElementById('quick-rework-cancel');
        const quickReworkForm = document.getElementById('quick-rework-form');

        if (quickReworkClose) quickReworkClose.addEventListener('click', () => closeModal('quick-rework-modal'));
        if (quickReworkCancel) quickReworkCancel.addEventListener('click', () => closeModal('quick-rework-modal'));
        if (quickReworkForm) quickReworkForm.addEventListener('submit', handleReworkSubmit);

        // Modal de borra
        const manualBorraClose = document.getElementById('manual-borra-close');
        const manualBorraCancel = document.getElementById('manual-borra-cancel');
        const manualBorraForm = document.getElementById('manual-borra-form');

        if (manualBorraClose) manualBorraClose.addEventListener('click', () => closeModal('manual-borra-modal'));
        if (manualBorraCancel) manualBorraCancel.addEventListener('click', () => closeModal('manual-borra-modal'));
        if (manualBorraForm) manualBorraForm.addEventListener('submit', handleManualBorraSubmit);

        // Modal de ajuste de quantidade
        const adjustQuantityClose = document.getElementById('adjust-quantity-close');
        const adjustQuantityCancel = document.getElementById('adjust-quantity-cancel');
        const adjustQuantityForm = document.getElementById('adjust-quantity-form');

        if (adjustQuantityClose) adjustQuantityClose.addEventListener('click', closeAdjustQuantityModal);
        if (adjustQuantityCancel) adjustQuantityCancel.addEventListener('click', closeAdjustQuantityModal);
        if (adjustQuantityForm) adjustQuantityForm.addEventListener('submit', handleAdjustQuantitySubmit);

        // Modal de ajuste de quantidade executada (planejamento)
        initAdjustExecutedModal();
    }
    
    // Funções para abrir/fechar modais
    function openProductionModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }
        updateQuickProductionPieceWeightUI({ forceUpdateInput: true });
        
        // ⚠️ MULTI-PRODUTO: Popular seletor se houver múltiplos planos na máquina
        const planSelectorContainer = document.getElementById('quick-production-plan-selector-container');
        const planSelector = document.getElementById('quick-production-plan-selector');
        if (planSelectorContainer && planSelector && selectedMachineData?.machine) {
            const machinePlans = machineCardData[selectedMachineData.machine];
            if (Array.isArray(machinePlans) && machinePlans.length > 1) {
                // Mostrar seletor e popular com os planos
                planSelectorContainer.classList.remove('hidden');
                planSelector.innerHTML = '<option value="">Selecione o produto para lançar...</option>';
                machinePlans.forEach((p, idx) => {
                    const productName = p.product || p.product_name || getProductByCode(p.product_cod)?.name || `Produto ${idx + 1}`;
                    const orderNum = p.order_number || p.order_number_original || '-';
                    planSelector.innerHTML += `<option value="${p.id}" ${p.id === selectedMachineData.id ? 'selected' : ''}>${productName} (OP: ${orderNum})</option>`;
                });
                
                // Listener para trocar o plano selecionado
                planSelector.onchange = function() {
                    const selectedPlanId = this.value;
                    if (selectedPlanId && Array.isArray(machinePlans)) {
                        const newPlan = machinePlans.find(p => p.id === selectedPlanId);
                        if (newPlan) {
                            selectedMachineData = newPlan;
                            updateQuickProductionPieceWeightUI({ forceUpdateInput: true });
                            // Atualizar contexto do modal
                            const contextProduct = document.querySelector('#quick-production-modal .context-product');
                            const contextOrder = document.querySelector('#quick-production-modal .context-op');
                            if (contextProduct) contextProduct.textContent = newPlan.product || getProductByCode(newPlan.product_cod)?.name || '-';
                            if (contextOrder) contextOrder.textContent = newPlan.order_number || '-';
                        }
                    }
                };
            } else {
                planSelectorContainer.classList.add('hidden');
            }
        }
        
        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('quick-production-form');
        const submitBtn = document.getElementById('quick-production-submit');
        
        if (form) {
            form.removeEventListener('submit', handleQuickProductionSubmit);
            form.addEventListener('submit', handleQuickProductionSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleQuickProductionSubmit);
            submitBtn.addEventListener('click', handleQuickProductionSubmit);
        }
        
        // ✅ Configurar campo de código do operador
        setupUserCodeInput('quick-production-user');
        const userInput = document.getElementById('quick-production-user');
        if (userInput) {
            userInput.value = '';
            updateUserNameDisplay('quick-production-user', '');
        }
        
        openModal('quick-production-modal');
    }
    
    function openLossesModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }
        // Ocultar botão de exclusão em novo lançamento
        const quickLossesDeleteBtn = document.getElementById('quick-losses-delete-btn');
        if (quickLossesDeleteBtn) quickLossesDeleteBtn.classList.add('hidden');
        
        // Configurar poka yoke para entrada de peso
        const weightInput = document.getElementById('quick-losses-weight');
        if (weightInput) {
            // Criar helper de validação se não existir
            if (!document.getElementById('weight-feedback-helper')) {
                const helper = document.createElement('div');
                helper.id = 'weight-feedback-helper';
                helper.className = 'mt-1 text-sm font-medium';
                weightInput.parentElement.appendChild(helper);
            }
            
            // Limpar valor anterior
            weightInput.value = '';
            
            // Adicionar listener para feedback real-time
            weightInput.removeEventListener('input', updateWeightFeedback);
            weightInput.addEventListener('input', updateWeightFeedback);
            
            // Adicionar listener para validação ao sair
            weightInput.removeEventListener('blur', validateWeightInput);
            weightInput.addEventListener('blur', validateWeightInput);
        }

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('quick-losses-form');
        const submitBtn = document.getElementById('quick-losses-submit');
        const closeBtn = document.getElementById('quick-losses-close');
        const cancelBtn = document.getElementById('quick-losses-cancel');
        
        if (form) {
            form.removeEventListener('submit', handleLossesSubmit);
            form.addEventListener('submit', handleLossesSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleLossesSubmit);
            submitBtn.addEventListener('click', handleLossesSubmit);
        }

        if (closeBtn) {
            closeBtn.removeEventListener('click', () => closeModal('quick-losses-modal'));
            closeBtn.addEventListener('click', () => closeModal('quick-losses-modal'));
        }

        if (cancelBtn) {
            cancelBtn.removeEventListener('click', () => closeModal('quick-losses-modal'));
            cancelBtn.addEventListener('click', () => closeModal('quick-losses-modal'));
        }
        
        // ✅ Configurar campo de código do operador
        setupUserCodeInput('quick-losses-user');
        const userInputQuickLosses = document.getElementById('quick-losses-user');
        if (userInputQuickLosses) {
            userInputQuickLosses.value = '';
            updateUserNameDisplay('quick-losses-user', '');
        }
        
        openModal('quick-losses-modal');
    }
    
    // Atualizar feedback em tempo real do input de peso
    function updateWeightFeedback() {
        const weightInput = document.getElementById('quick-losses-weight');
        const helper = document.getElementById('weight-feedback-helper');
        
        if (!helper || !weightInput.value) {
            if (helper) {
                helper.innerHTML = '';
                helper.className = 'mt-1 text-sm';
            }
            return;
        }
        
        const rawValue = weightInput.value;
        const weightGrams = parseInt(rawValue, 10) || 0;
        
        let feedbackHTML = '';
        let feedbackClass = 'text-gray-600';
        
        // Obter peso da peça para conversão (usa catálogo como fallback)
        const pieceWeightGrams = getActivePieceWeightGrams();
        
        if (weightGrams > 0) {
            // Entrada em gramas - mostrar conversão para kg
            const weightKg = (weightGrams / 1000).toFixed(3);
            feedbackHTML = `✔ ${weightGrams}g = <strong>${weightKg} kg</strong>`;
            
            // Calcular e mostrar quantidade de peças
            if (pieceWeightGrams > 0) {
                const estimatedPieces = Math.floor(weightGrams / pieceWeightGrams);
                feedbackHTML += ` ≈ <strong class="text-blue-600">${estimatedPieces.toLocaleString('pt-BR')} peças</strong>`;
            }
            
            feedbackClass = 'text-green-700';
        } else if (rawValue && weightGrams === 0) {
            // Entrada não-vazia mas não foi convertida
            feedbackHTML = `❌ <strong>Erro:</strong> Não foi possível interpretar "${rawValue}" como número`;
            feedbackClass = 'text-red-700 bg-red-50 p-2 rounded border border-red-200';
        }
        
        if (helper) {
            helper.innerHTML = feedbackHTML;
            helper.className = `mt-1 text-sm font-medium ${feedbackClass}`;
        }
    }
    
    // Validar e corrigir entrada de peso ao sair do campo
    function validateWeightInput() {
        const weightInput = document.getElementById('quick-losses-weight');
        if (!weightInput || !weightInput.value) return;
        
        const rawValue = weightInput.value;
        const weightGrams = parseInt(rawValue, 10) || 0;
        
        if (weightGrams === 0 && rawValue.trim()) {
            // Campo tem texto mas não foi interpretado como número
            const confirmation = window.confirm(
                `Não consegui interpretar "${rawValue}" como peso em gramas.\n\n` +
                `Digite apenas números inteiros (ex: 1500 para 1,5kg)\n\n` +
                `Deseja limpar o campo e tentar novamente?`
            );
            if (confirmation) {
                weightInput.value = '';
                updateWeightFeedback();
                weightInput.focus();
            }
        } else if (weightGrams > 50000) {
            // Alerta se peso muito alto (mais de 50kg em gramas)
            const weightKg = (weightGrams / 1000).toFixed(3);
            const confirmation = window.confirm(
                `⚠️ Peso muito alto: ${weightGrams}g (${weightKg}kg)\n\n` +
                `Confirma este peso ou quer corrigir?`
            );
            if (!confirmation) {
                weightInput.value = '';
                updateWeightFeedback();
                weightInput.focus();
            }
        }
    }
    
    function openReworkModal() {
        console.log('[TRACE][openReworkModal] called, selectedMachineData:', selectedMachineData);
        
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][openReworkModal] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }
        
        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('quick-rework-form');
        const submitBtn = document.getElementById('quick-rework-submit');
        
        if (form) {
            form.removeEventListener('submit', handleReworkSubmit);
            form.addEventListener('submit', handleReworkSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleReworkSubmit);
            submitBtn.addEventListener('click', handleReworkSubmit);
        }
        
        const reworkModal = document.getElementById('quick-rework-modal');
        if (reworkModal) {
            console.log('[DEBUG] Portalizando quick-rework-modal antes da abertura');
            modalManager.portalize(reworkModal);
        }

        setTimeout(() => {
            console.log('[TRACE][openReworkModal] abrindo modal quick-rework-modal');
            openModal('quick-rework-modal');
        }, 0);
    }
    
    function openManualProductionModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina e produto)
        const contextMachine = document.querySelector('#manual-production-modal .context-machine');
        const contextProduct = document.querySelector('#manual-production-modal .context-product');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        if (contextProduct) contextProduct.textContent = selectedMachineData.product || '-';

        const dateInput = document.getElementById('manual-production-date');
        if (dateInput) {
            dateInput.value = getProductionDateString();
        }

        const shiftSelect = document.getElementById('manual-production-shift');
        if (shiftSelect) {
            shiftSelect.value = String(getCurrentShift());
        }

        const hourInput = document.getElementById('manual-production-hour');
        if (hourInput) {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            hourInput.value = `${hours}:${minutes}`;
        }
        
        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-production-form');
        const submitBtn = document.getElementById('manual-production-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualProductionSubmit);
            form.addEventListener('submit', handleManualProductionSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualProductionSubmit);
            submitBtn.addEventListener('click', handleManualProductionSubmit);
        }
        
        // ✅ Configurar campo de código do operador
        setupUserCodeInput('manual-production-user');
        const userInput = document.getElementById('manual-production-user');
        if (userInput) {
            userInput.value = '';
            updateUserNameDisplay('manual-production-user', '');
        }

        openModal('manual-production-modal');
    }

    function openManualLossesModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina e produto)
        const contextMachine = document.querySelector('#manual-losses-modal .context-machine');
        const contextProduct = document.querySelector('#manual-losses-modal .context-product');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        if (contextProduct) contextProduct.textContent = selectedMachineData.product || '-';

        const dateInput = document.getElementById('manual-losses-date');
        if (dateInput) {
            dateInput.value = getProductionDateString();
        }

        const shiftSelect = document.getElementById('manual-losses-shift');
        if (shiftSelect) {
            shiftSelect.value = String(getCurrentShift());
        }

        const hourInput = document.getElementById('manual-losses-hour');
        if (hourInput) {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            hourInput.value = `${hours}:${minutes}`;
        }

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-losses-form');
        const submitBtn = document.getElementById('manual-losses-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualLossesSubmit);
            form.addEventListener('submit', handleManualLossesSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualLossesSubmit);
            submitBtn.addEventListener('click', handleManualLossesSubmit);
        }
        
        // ✅ Configurar campo de código do operador
        setupUserCodeInput('manual-losses-user');
        const userInputLosses = document.getElementById('manual-losses-user');
        if (userInputLosses) {
            userInputLosses.value = '';
            updateUserNameDisplay('manual-losses-user', '');
        }

        openModal('manual-losses-modal');
    }

    function openManualBorraModal() {
        console.log('[TRACE][openManualBorraModal] called, selectedMachineData:', selectedMachineData);
        
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][openManualBorraModal] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina e produto)
        const contextMachine = document.querySelector('#manual-borra-modal .context-machine');
        const contextProduct = document.querySelector('#manual-borra-modal .context-product');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        if (contextProduct) contextProduct.textContent = selectedMachineData.product || '-';

        // Popular os selects do modal com máquinas e motivos do database.js
        populateBorraModal();

        const dateInput = document.getElementById('manual-borra-date');
        if (dateInput) {
            dateInput.value = getProductionDateString();
        }

        const shiftSelect = document.getElementById('manual-borra-shift');
        if (shiftSelect) {
            shiftSelect.value = String(getCurrentShift());
        }

        const machineSelect = document.getElementById('manual-borra-machine');
        if (machineSelect && selectedMachineData) {
            machineSelect.value = normalizeMachineId(selectedMachineData.machine);
        }

        const hourInput = document.getElementById('manual-borra-hour');
        if (hourInput) {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            hourInput.value = `${hours}:${minutes}`;
        }

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-borra-form');
        const submitBtn = document.getElementById('manual-borra-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualBorraSubmit);
            form.addEventListener('submit', handleManualBorraSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualBorraSubmit);
            submitBtn.addEventListener('click', handleManualBorraSubmit);
        }

        const borraModal = document.getElementById('manual-borra-modal');
        if (borraModal) {
            console.log('[DEBUG] Portalizando manual-borra-modal antes da abertura');
            modalManager.portalize(borraModal);
        }

        setTimeout(() => {
            console.log('[TRACE][openManualBorraModal] abrindo modal manual-borra-modal');
            openModal('manual-borra-modal');
        }, 0);
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;

        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
        modal.removeAttribute('data-modal-open');

        modalManager.clearStyles(modal);
        const modalContent = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
        if (modalContent) {
            modalManager.clearContentStyles(modalContent);
        }

        // Limpar formulários associados ao modal fechado
        const form = modal.querySelector('form');
        if (form) form.reset();
        if (['quick-production-modal', 'quick-losses-modal', 'quick-downtime-modal', 'quick-rework-modal', 'manual-borra-modal'].includes(modalId)) {
            currentEditContext = null;
        }
    }
    
    // Expor closeModal globalmente para uso em onclick
    window.closeModal = closeModal;

    // Preenche o contexto (máquina/produto) em um modal, se existir o bloco .modal-context
    function fillModalContext(modalEl, context = null) {
        if (!modalEl) return;
        const ctx = modalEl.querySelector('.modal-context');
        if (!ctx) return;
        const machineEl = ctx.querySelector('.context-machine');
        const productEl = ctx.querySelector('.context-product');
        const src = context || selectedMachineData || {};
        const machine = src.machine || src.machine_id || '-';
        let product = src.product || src.product_name || '';
        const code = src.product_cod || src.product_code || src.part_code || '';
        if (!product && code) product = `Cod ${code}`;
        if (machineEl) machineEl.textContent = machine || '-';
        if (productEl) productEl.textContent = product || 'Produto não definido';
    }

    function openModal(modalId) {
        if (modalId === 'quick-downtime-modal') {
            // Forçar re-vinculação do submit do formulário de parada
            const quickDowntimeForm = document.getElementById('quick-downtime-form');
            if (quickDowntimeForm) {
                quickDowntimeForm.onsubmit = null;
                quickDowntimeForm.removeEventListener('submit', handleDowntimeSubmit);
                quickDowntimeForm.addEventListener('submit', handleDowntimeSubmit);
                console.log('[DEBUG] Evento de submit vinculado ao quick-downtime-form (openModal)');
            }
        }
        
        // Popular selects de usuários quando modal abre
        if (['quick-production-modal', 'quick-losses-modal', 'quick-downtime-modal', 'manual-production-modal', 'manual-losses-modal', 'manual-downtime-modal'].includes(modalId)) {
            populateAllUserSelects();
        }
        
        console.error('🔴🔴🔴 OPENMODAL START, modalId=' + modalId + ' 🔴🔴🔴');

        const modal = document.getElementById(modalId);
        console.error('🔴 modal found:', !!modal, 'typeof:', typeof modal);

        if (!modal) {
            console.error('🔴 EARLY RETURN: Modal not found');
            return;
        }

        modalManager.portalize(modal);
        console.error('🔴 calling fillModalContext');

        // Atualizar faixa de contexto do modal, quando aplicável
        try {
            fillModalContext(modal);
            console.error('🔴 fillModalContext OK');
        } catch (e) {
            console.error('🔴 fillModalContext ERROR:', e.message);
        }

        modal.setAttribute('data-modal-open', 'true');
        modal.setAttribute('aria-hidden', 'false');
        modal.classList.remove('hidden');
        modalManager.applyStyles(modal);

        const modalContent = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
        if (modalContent) {
            modalManager.applyContentStyles(modalContent);
        } else {
            console.warn('🔴 Nenhum container interno padrão (.bg-white/.modal-content) encontrado para', modalId);
        }

        const initialComputed = window.getComputedStyle(modal);
        console.error('🔴 after force -> hidden:', modal.classList.contains('hidden'),
            'display:', initialComputed.display,
            'opacity:', initialComputed.opacity,
            'visibility:', initialComputed.visibility,
            'z-index:', initialComputed.zIndex);

        const logState = (label) => {
            if (!modal || !modal.isConnected) {
                console.error(`🔴 ${label} modal desconectado do DOM`, { modalId });
                return;
            }
            const style = window.getComputedStyle(modal);
            const rect = modal.getBoundingClientRect();
            console.error(`🔴 ${label} hidden=${modal.classList.contains('hidden')} display=${style.display} opacity=${style.opacity} visibility=${style.visibility} z-index=${style.zIndex} rect=${Math.round(rect.width)}x${Math.round(rect.height)} top=${Math.round(rect.top)} left=${Math.round(rect.left)}`);
        };

        requestAnimationFrame(() => {
            modalManager.verify(modal);
            logState('RAF check');
        });

        setTimeout(() => logState('100ms later'), 100);
        setTimeout(() => logState('300ms later'), 300);
        setTimeout(() => logState('500ms later'), 500);

        console.error('🔴🔴🔴 OPENMODAL END 🔴🔴🔴');
    }

    // Função para toggle de parada (stop/start)
    function toggleDowntime() {
        console.log('[TRACE][toggleDowntime] called, selectedMachineData:', selectedMachineData, 'machineStatus:', machineStatus);
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][toggleDowntime] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }
        
        if (machineStatus === 'running') {
            console.log('[TRACE][toggleDowntime] Status running -> abrindo modal para selecionar motivo da parada');
            // Parar máquina - solicitar motivo ANTES de iniciar a parada
            openDowntimeReasonModal();
        } else {
            console.log('[TRACE][toggleDowntime] Status stopped -> finalizando parada');
            // Retomar máquina - finalizar parada (motivo já foi informado no início)
            finalizeMachineDowntime();
        }
    }
    
    // Função para abrir modal de lançamento manual de parada passada
    function openManualDowntimeModal() {
        console.log('[TRACE][openManualDowntimeModal] called, selectedMachineData:', selectedMachineData);
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][openManualDowntimeModal] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina)
        const contextMachine = document.querySelector('#manual-downtime-modal .context-machine');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        
        // Preencher datas padrão
        const today = getProductionDateString();
        const ds = document.getElementById('manual-downtime-date-start');
        const de = document.getElementById('manual-downtime-date-end');
        
        if (ds && !ds.value) ds.value = today;
        if (de && !de.value) de.value = today;

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-downtime-form');
        const submitBtn = document.getElementById('manual-downtime-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualDowntimeSubmit);
            form.addEventListener('submit', handleManualDowntimeSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualDowntimeSubmit);
            submitBtn.addEventListener('click', handleManualDowntimeSubmit);
        }
        
        // ✅ Configurar campo de código do operador
        setupUserCodeInput('manual-downtime-user');
        const userInputDowntime = document.getElementById('manual-downtime-user');
        if (userInputDowntime) {
            userInputDowntime.value = '';
            updateUserNameDisplay('manual-downtime-user', '');
        }

        openModal('manual-downtime-modal');
        console.log('[TRACE][openManualDowntimeModal] completed');
    }
    
    // ========================================
    // SISTEMA ROBUSTO DE PARADAS - FUNÇÕES PRINCIPAIS
    // ========================================
    
    /**
     * Inicia uma parada de máquina com persistência robusta
     * @param {string} reason - Motivo da parada (informado no modal)
     * @param {string} observations - Observações adicionais
     * @param {number} userCod - Código do operador responsável
     * @param {string} nomeUsuario - Nome do operador responsável
     */
    async function startMachineDowntime(reason, observations = '', userCod = null, nomeUsuario = null) {
        if (!selectedMachineData) {
            console.error('[DOWNTIME] Tentativa de iniciar parada sem máquina selecionada');
            showNotification('Selecione uma máquina primeiro.', 'error');
            return;
        }

        if (!reason) {
            console.error('[DOWNTIME] Tentativa de iniciar parada sem motivo');
            showNotification('Informe o motivo da parada.', 'error');
            return;
        }

        const now = new Date();
        const currentShift = getShiftForDateTime(now);
        const workday = getWorkdayForDateTime(now);
        
        // Estrutura de dados robusta para a parada (inclui motivo desde o início)
        currentDowntimeStart = {
            machine: selectedMachineData.machine,
            date: workday,
            startTime: formatTimeHM(now),
            startTimestamp: now,
            startShift: currentShift,
            // Motivo e observações (informados no início)
            reason: reason,
            observations: observations,
            // Dados do operador
            userCod: userCod,
            nomeUsuario: nomeUsuario,
            // Dados adicionais para rastreabilidade
            product: selectedMachineData.product || null,
            productCod: selectedMachineData.product_cod || null,
            orderId: selectedMachineData.order_id || null,
            orderNumber: selectedMachineData.order_number || null
        };
        
        console.log('[DOWNTIME][START] Parada iniciada:', currentDowntimeStart);
        
        // Salvar parada ativa no Firebase para persistência (sobrevive a refresh/troca de máquina)
        try {
            const activeDowntimeData = {
                // Identificação
                machine: selectedMachineData.machine,
                
                // Timestamps (múltiplos formatos para robustez)
                startDate: workday,
                startTime: formatTimeHM(now),
                startTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                startTimestampLocal: now.toISOString(),
                startShift: currentShift,
                
                // Motivo e observações (informados no início)
                reason: reason,
                observations: observations,
                
                // Dados do operador responsável
                userCod: userCod,
                nomeUsuario: nomeUsuario,
                
                // Contexto de produção
                product: selectedMachineData.product || null,
                productCod: selectedMachineData.product_cod || null,
                orderId: selectedMachineData.order_id || null,
                orderNumber: selectedMachineData.order_number || null,
                
                // Metadados
                startedBy: getActiveUser()?.name || 'Sistema',
                startedByUsername: getActiveUser()?.username || null,
                isActive: true,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                
                // Versão do sistema para compatibilidade futura
                systemVersion: '2.1'
            };
            
            // Usar merge para não perder dados em caso de erro parcial
            // IMPORTANTE: Normalizar ID da máquina para garantir consistência
            const normalizedMachineIdForDowntime = normalizeMachineId(selectedMachineData.machine);
            await db.collection('active_downtimes').doc(normalizedMachineIdForDowntime).set(activeDowntimeData, { merge: true });
            
            console.log('[DOWNTIME][START] Parada ativa persistida no Firebase:', activeDowntimeData);
        } catch (error) {
            console.error('[DOWNTIME][START] Erro ao persistir parada no Firebase:', error);
            // Mesmo com erro no Firebase, continuamos com a parada local
            showNotification('Parada iniciada localmente. Pode haver erro de sincronização.', 'warning');
        }
        
        machineStatus = 'stopped';
        updateMachineStatus();
        freezeProductionTimer();
        startDowntimeTimer();
        
        // Notificação com informações contextuais
        const shiftLabel = currentShift === 1 ? '1º Turno' : currentShift === 2 ? '2º Turno' : '3º Turno';
        showNotification(`Máquina parada às ${formatTimeHM(now)} (${shiftLabel}) - Motivo: ${reason}. Clique em START quando retomar.`, 'warning');
    }
    
    // Função para abrir modal solicitando motivo da parada ao INICIAR (nova dinâmica)
    function openDowntimeReasonModal() {
        console.log('[TRACE][openDowntimeReasonModal] called - Solicitando motivo para INICIAR parada');
        
        // Limpar formulário
        const reasonSelect = document.getElementById('quick-downtime-reason');
        const obsField = document.getElementById('quick-downtime-obs');
        if (reasonSelect) reasonSelect.value = '';
        if (obsField) obsField.value = '';
        
        // Atualizar título e botão do modal para refletir a nova dinâmica
        const modalTitle = document.getElementById('downtime-modal-title');
        const actionBtn = document.getElementById('downtime-action-btn');
        if (modalTitle) modalTitle.textContent = 'Iniciar Parada - Informe o Motivo';
        if (actionBtn) actionBtn.textContent = 'Iniciar Parada';
        
        // ✅ Configurar campo de código do operador
        setupUserCodeInput('quick-downtime-user');
        const userInputQuickDowntime = document.getElementById('quick-downtime-user');
        if (userInputQuickDowntime) {
            userInputQuickDowntime.value = '';
            updateUserNameDisplay('quick-downtime-user', '');
        }
        
        console.log('[TRACE][openDowntimeReasonModal] abrindo modal quick-downtime-modal');
        openModal('quick-downtime-modal');
    }
    
    /**
     * Finaliza uma parada de máquina (quando usuário clica START para retomar)
     * O motivo já foi informado no início da parada
     */
    async function finalizeMachineDowntime() {
        console.log('[DOWNTIME][FINALIZE] Finalizando parada', {
            selectedMachineData,
            currentDowntimeStart,
            machineStatus,
            timestamp: new Date().toISOString()
        });

        if (!currentDowntimeStart) {
            console.warn('[DOWNTIME][FINALIZE] Nenhuma parada ativa encontrada');
            // Garante que o status da máquina volte para running e a UI seja atualizada
            machineStatus = 'running';
            updateMachineStatus();
            resumeProductionTimer();
            stopDowntimeTimer();
            await loadTodayStats();
            await loadRecentEntries(false);
            await refreshAnalysisIfActive();
            return;
        }
        
        // Bloquear múltiplos cliques
        if (finalizeMachineDowntime._processing) {
            console.warn('[DOWNTIME][FINALIZE] Já está processando, ignorando clique duplicado');
            return;
        }
        finalizeMachineDowntime._processing = true;
        
        let erroFinal = null;
        let savedSegments = 0;
        
        try {
            const now = new Date();
            const endShift = getShiftForDateTime(now);
            const endWorkday = getWorkdayForDateTime(now);
            
            // Reconstruir data de início a partir dos dados salvos
            let startDateTime;
            if (currentDowntimeStart.startTimestamp instanceof Date) {
                startDateTime = currentDowntimeStart.startTimestamp;
            } else if (currentDowntimeStart.startTimestampLocal) {
                startDateTime = new Date(currentDowntimeStart.startTimestampLocal);
            } else {
                // Fallback: reconstruir a partir de date + startTime
                startDateTime = parseDateTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            }
            
            if (!startDateTime || isNaN(startDateTime.getTime())) {
                console.error('[DOWNTIME][FINALIZE] Data de início inválida:', currentDowntimeStart);
                alert('Erro: Data de início da parada inválida. Registre manualmente.');
                return;
            }
            
            // Verificar se a data de início é futura (erro de dados)
            if (startDateTime > now) {
                console.error('[DOWNTIME][FINALIZE] Data de início é futura! Corrigindo para agora menos 1 minuto.', {
                    startDateTime: startDateTime.toISOString(),
                    now: now.toISOString()
                });
                // Corrigir para 1 minuto antes de agora
                startDateTime = new Date(now.getTime() - 60000);
            }
            
            // Se a diferença for muito pequena (< 5 segundos), garantir pelo menos 1 minuto de duração
            const diffMs = now.getTime() - startDateTime.getTime();
            if (diffMs < 5000) {
                console.warn('[DOWNTIME][FINALIZE] Parada muito curta (' + diffMs + 'ms), ajustando para 1 minuto');
                startDateTime = new Date(now.getTime() - 60000);
            }
            
            const startDateStr = formatDateYMD(startDateTime);
            const startTimeStr = formatTimeHM(startDateTime);
            const endDateStr = formatDateYMD(now);
            const endTimeStr = formatTimeHM(now);
            
            // Calcular duração total para log
            const totalDurationMs = now.getTime() - startDateTime.getTime();
            const totalDurationMin = Math.max(1, Math.round(totalDurationMs / 60000));
            const totalDurationHours = (totalDurationMs / 3600000).toFixed(2);
            
            console.log('[DOWNTIME][FINALIZE] Calculando segmentos:', {
                startDateTime: startDateTime.toISOString(),
                now: now.toISOString(),
                startDate: startDateStr,
                startTime: startTimeStr,
                endDate: endDateStr,
                endTime: endTimeStr,
                totalDurationMs,
                totalDurationMin,
                totalDurationHours: `${totalDurationHours}h`
            });
            
            // Segmentar a parada por turno
            const segments = splitDowntimeIntoShiftSegments(startDateStr, startTimeStr, endDateStr, endTimeStr);
            
            if (!segments.length) {
                console.error('[DOWNTIME][FINALIZE] Nenhum segmento gerado');
                alert('Intervalo de parada inválido. Verifique os horários ou registre manualmente.');
                return;
            }
            
            console.log('[DOWNTIME][FINALIZE] Segmentos a salvar:', segments.length, segments);
            
            const currentUser = getActiveUser();
            const batch = db.batch();
            
            // Usar o motivo que foi informado no início da parada
            const reason = currentDowntimeStart.reason;
            const obs = currentDowntimeStart.observations || '';
            
            // Validação: motivo é obrigatório
            if (!reason || reason.trim() === '') {
                console.error('[DOWNTIME][FINALIZE] Motivo não informado');
                alert('⚠️ Erro: Motivo da parada não foi informado.\n\nEsta parada não pode ser finalizada sem um motivo válido.\nPor favor, registre a parada manualmente com o motivo correto.');
                return;
            }
            
            for (const seg of segments) {
                const downtimeData = {
                    // Identificação
                    machine: currentDowntimeStart.machine,
                    
                    // Período
                    date: seg.date,
                    startTime: seg.startTime,
                    endTime: seg.endTime,
                    duration: seg.duration,
                    shift: seg.shift,
                    
                    // Motivo e observações (informados no início da parada)
                    reason: reason,
                    observations: obs,
                    
                    // Dados do operador que registrou a parada
                    userCod: currentDowntimeStart.userCod ?? null,
                    nomeUsuario: currentDowntimeStart.nomeUsuario || null,
                    
                    // Contexto de produção (se disponível)
                    product: currentDowntimeStart.product || null,
                    productCod: currentDowntimeStart.productCod || null,
                    orderId: currentDowntimeStart.orderId || null,
                    orderNumber: currentDowntimeStart.orderNumber || null,
                    
                    // Metadados de registro
                    registradoPor: currentUser?.username || null,
                    registradoPorNome: getCurrentUserName(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    
                    // Metadados adicionais para auditoria
                    originalStartTimestamp: startDateTime.toISOString(),
                    originalEndTimestamp: now.toISOString(),
                    totalParentDuration: totalDurationMin,
                    segmentIndex: segments.indexOf(seg),
                    totalSegments: segments.length,
                    systemVersion: '2.0'
                };
                
                const docRef = db.collection('downtime_entries').doc();
                batch.set(docRef, downtimeData);
                savedSegments++;
                
                console.log(`[DOWNTIME][FINALIZE] Segmento ${savedSegments}/${segments.length} preparado:`, {
                    date: seg.date,
                    shift: seg.shift,
                    duration: seg.duration,
                    startTime: seg.startTime,
                    endTime: seg.endTime
                });
            }
            
            // Executar batch de salvamento
            await batch.commit();
            console.log(`[DOWNTIME][FINALIZE] ${savedSegments} segmentos salvos com sucesso`);
            
        } catch (error) {
            erroFinal = error;
            console.error('[DOWNTIME][FINALIZE] Erro ao registrar parada:', error);
            alert('Erro ao registrar parada. Tente novamente.');
        } finally {
            // Remover parada ativa dessa máquina (evita restauração automática na troca de máquina/reload)
            const machineToClean = currentDowntimeStart?.machine;
            const reasonForLog = currentDowntimeStart?.reason;
            
            // Calcular duração para log
            let durationForLog = '-';
            if (currentDowntimeStart) {
                let startDt;
                if (currentDowntimeStart.startTimestamp instanceof Date) {
                    startDt = currentDowntimeStart.startTimestamp;
                } else if (currentDowntimeStart.startTimestampLocal) {
                    startDt = new Date(currentDowntimeStart.startTimestampLocal);
                }
                if (startDt && !isNaN(startDt.getTime())) {
                    const elapsedMin = Math.round((Date.now() - startDt.getTime()) / 60000);
                    durationForLog = elapsedMin + ' min';
                }
            }
            
            try {
                if (machineToClean) {
                    const normalizedMachineForDelete = normalizeMachineId(machineToClean);
                    await db.collection('active_downtimes').doc(normalizedMachineForDelete).delete();
                    console.log('[DOWNTIME][FINALIZE] active_downtime removed for machine', normalizedMachineForDelete);
                }
            } catch (err) {
                console.warn('[DOWNTIME][FINALIZE] failed to delete active_downtime doc', err);
            }
            
            // Resetar status e timers (sempre)
            currentDowntimeStart = null;
            machineStatus = 'running';
            updateMachineStatus();
            stopDowntimeTimer();
            resumeProductionTimer();
            await loadTodayStats();
            await loadRecentEntries(false);
            await refreshAnalysisIfActive();
            
            if (!erroFinal) {
                showNotification('Parada finalizada e registrada com sucesso!', 'success');
                console.log('[DOWNTIME][FINALIZE] success path completed');
                
                // Registrar log de parada
                registrarLogSistema('REGISTRO DE PARADA', 'parada', {
                    machine: machineToClean || selectedMachineData?.machine,
                    motivo: reasonForLog || '-',
                    duracao: durationForLog
                });
            }
            
            // Liberar flag de processamento
            finalizeMachineDowntime._processing = false;
        }
    }

    // ======== PARADAS LONGAS (Fim de Semana, Manutenção, etc.) ========
    
    // Função para popular motivos de parada - ATIVA
    // extended-downtime-reason agora é um SELECT com optgroups
    function populateExtendedDowntimeReasons() {
        const reasonSelect = document.getElementById('extended-downtime-reason');
        if (!reasonSelect) return;

        const groupedReasons = getGroupedDowntimeReasons();
        let options = '<option value="">Selecione o motivo...</option>';

        Object.entries(groupedReasons).forEach(([group, reasons]) => {
            options += `<optgroup label="${group}">`;
            reasons.forEach(reason => {
                options += `<option value="${reason}">${reason}</option>`;
            });
            options += '</optgroup>';
        });

        reasonSelect.innerHTML = options;
        console.log('[PARADAS-LONGAS] Motivos carregados:', Object.keys(groupedReasons).length, 'grupos');
    }

    function populateExtendedDowntimeMachines() {
        const machineSelect = document.getElementById('extended-downtime-machine');
        if (!machineSelect) {
            console.warn('[PARADAS-LONGAS] Select de máquina não encontrado');
            return;
        }

        if (window.databaseModule && window.databaseModule.machineDatabase) {
            const machines = window.databaseModule.machineDatabase;
            let options = '<option value="">Selecione uma ou mais máquinas...</option>';
            
            machines.forEach(m => {
                const machineId = normalizeMachineId(m.id);
                options += `<option value="${machineId}">${machineId}</option>`;
            });
            
            machineSelect.innerHTML = options;
            console.log('[PARADAS-LONGAS] Máquinas carregadas:', machines.length);
        } else {
            console.warn('[PARADAS-LONGAS] machineDatabase não disponível');
        }
    }

    function setupExtendedDowntimeTab() {
        populateExtendedDowntimeReasons();
        populateExtendedDowntimeMachines();
        
        // Inicializar modal de edição completa
        initEditExtendedDowntimeModal();

        // Elementos do formulário
        const startDateInput = document.getElementById('extended-downtime-start-date');
        const customTimeInput = document.getElementById('extended-downtime-custom-time');
        const useNowBtn = document.getElementById('extended-downtime-use-now');
        const startTimeElement = document.getElementById('extended-downtime-start-time');
        
        // Função para preencher com data/hora atual
        function setCurrentDateTime() {
            const now = new Date();
            const dateString = now.toISOString().split('T')[0];  // YYYY-MM-DD
            const timeString = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            if (startDateInput) startDateInput.value = dateString;
            if (customTimeInput) customTimeInput.value = timeString;
            if (startTimeElement) startTimeElement.textContent = `Definido: ${dateString} às ${timeString}`;
        }
        
        // Preencher com data/hora atual ao carregar
        setCurrentDateTime();
        
        // Botão para usar data/hora atual
        if (useNowBtn) {
            useNowBtn.addEventListener('click', function(e) {
                e.preventDefault();
                setCurrentDateTime();
                showNotification('✅ Data e hora atualizados para agora', 'success');
            });
        }
        
        // Atualizar display quando campos mudarem
        function updateDisplay() {
            if (startDateInput && customTimeInput && startTimeElement) {
                const date = startDateInput.value || '--';
                const time = customTimeInput.value || '--:--';
                startTimeElement.textContent = `Selecionado: ${date} às ${time}`;
            }
        }
        
        if (startDateInput) startDateInput.addEventListener('change', updateDisplay);
        if (customTimeInput) customTimeInput.addEventListener('change', updateDisplay);

        const form = document.getElementById('extended-downtime-form');
        if (form && !form.dataset.listenerAttached) {
            form.addEventListener('submit', handleExtendedDowntimeFormSubmit);
            form.dataset.listenerAttached = 'true';
        }
        
        // Inicializar parada em lote
        setupParadaEmLote();
    }

    // ==================== PARADA EM LOTE ====================
    
    /**
     * Configura a funcionalidade de parada em lote
     * Permite registrar a mesma parada para múltiplas máquinas simultaneamente
     */
    function setupParadaEmLote() {
        // Aguardar um pouco para garantir que o DOM está pronto
        setTimeout(() => {
            const btnAbrir = document.getElementById('btn-parada-em-lote');
            const btnFechar = document.getElementById('btn-fechar-parada-lote');
            const container = document.getElementById('parada-lote-container');
            const gridMaquinas = document.getElementById('maquinas-lote-grid');
            const countEl = document.getElementById('maquinas-selecionadas-count');
            const btnSelecionarTodas = document.getElementById('btn-selecionar-todas');
            const btnLimparSelecao = document.getElementById('btn-limpar-selecao');
            const categoriaSelect = document.getElementById('parada-lote-categoria');
            const motivoSelect = document.getElementById('parada-lote-motivo');
            const dataInput = document.getElementById('parada-lote-data');
            const horaInput = document.getElementById('parada-lote-hora');
            const btnUsarAgora = document.getElementById('parada-lote-usar-agora');
            const form = document.getElementById('parada-lote-form');
            
            if (!btnAbrir) {
                console.error('[PARADA-LOTE] btn-parada-em-lote não encontrado');
                return;
            }
            if (!container) {
                console.error('[PARADA-LOTE] parada-lote-container não encontrado');
                return;
            }
            
            console.log('[PARADA-LOTE] Inicializando - Elementos encontrados:', {
                btnAbrir: !!btnAbrir,
                container: !!container,
                gridMaquinas: !!gridMaquinas,
                form: !!form
            });
            
            // Lista de máquinas válidas (26 máquinas)
            const validMachines = ['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                   'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                   'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32'];
        
        // Motivos por categoria (para uso em lote - eventos que afetam múltiplas máquinas)
        const motivosPorCategoria = {
            'ADMINISTRATIVO': ['FALTA DE ENERGIA', 'FALTA DE ÁGUA', 'QUEDA DE ENERGIA', 'FERIADO', 'FIM DE SEMANA'],
            'MANUTENÇÃO': ['MANUTENÇÃO PREVENTIVA GERAL', 'PARADA PROGRAMADA', 'MANUTENÇÃO DE INFRAESTRUTURA'],
            'COMPRAS': ['FALTA DE MATÉRIA PRIMA GERAL', 'ATRASO NO FORNECEDOR'],
            'PCP': ['SEM PROGRAMAÇÃO', 'SEM PROGRAMAÇÃO-FIM DE SEMANA', 'ESTRATÉGIA PCP'],
            'COMERCIAL': ['SEM PEDIDO', 'BAIXA DEMANDA'],
            'HOKKAIDO': ['HOKKAIDO']
        };
        
        // Preencher grid de máquinas
        function renderMaquinasGrid() {
            if (!gridMaquinas) return;
            gridMaquinas.innerHTML = validMachines.map(m => `
                <label class="flex items-center justify-center p-2 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-orange-50 hover:border-orange-300 transition-all maquina-lote-item" data-machine="${m}">
                    <input type="checkbox" name="maquinas-lote" value="${m}" class="sr-only maquina-lote-checkbox">
                    <span class="text-sm font-bold text-gray-700">${m}</span>
                </label>
            `).join('');
            
            // Adicionar event listeners aos checkboxes
            gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                item.addEventListener('click', () => {
                    const checkbox = item.querySelector('.maquina-lote-checkbox');
                    checkbox.checked = !checkbox.checked;
                    if (checkbox.checked) {
                        item.classList.add('bg-orange-100', 'border-orange-500');
                        item.querySelector('span').classList.add('text-orange-700');
                    } else {
                        item.classList.remove('bg-orange-100', 'border-orange-500');
                        item.querySelector('span').classList.remove('text-orange-700');
                    }
                    updateCount();
                });
            });
        }
        
        // Atualizar contagem
        function updateCount() {
            const count = gridMaquinas.querySelectorAll('.maquina-lote-checkbox:checked').length;
            if (countEl) countEl.textContent = `${count} máquina${count !== 1 ? 's' : ''} selecionada${count !== 1 ? 's' : ''}`;
        }
        
        // Preencher motivos baseado na categoria
        function updateMotivos() {
            if (!motivoSelect || !categoriaSelect) return;
            const categoria = categoriaSelect.value;
            const motivos = motivosPorCategoria[categoria] || [];
            
            motivoSelect.innerHTML = '<option value="">Selecione o motivo...</option>' + 
                motivos.map(m => `<option value="${m}">${m}</option>`).join('');
        }
        
        // Definir data/hora atual
        function setCurrentDateTime() {
            const now = new Date();
            if (dataInput) dataInput.value = now.toISOString().split('T')[0];
            if (horaInput) horaInput.value = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        }
        
        // Abrir/fechar container
        btnAbrir.addEventListener('click', () => {
            console.log('[PARADA-LOTE] Botão clicado, container hidden antes:', container.classList.contains('hidden'));
            container.classList.toggle('hidden');
            if (!container.classList.contains('hidden')) {
                console.log('[PARADA-LOTE] Abrindo container, renderizando grid...');
                renderMaquinasGrid();
                setCurrentDateTime();
                updateMotivos();
                setTimeout(() => lucide.createIcons(), 100);
            } else {
                console.log('[PARADA-LOTE] Fechando container');
            }
        });
        
        if (btnFechar) {
            btnFechar.addEventListener('click', () => {
                container.classList.add('hidden');
            });
        }
        
        // Selecionar todas
        if (btnSelecionarTodas) {
            btnSelecionarTodas.addEventListener('click', () => {
                gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                    const checkbox = item.querySelector('.maquina-lote-checkbox');
                    checkbox.checked = true;
                    item.classList.add('bg-orange-100', 'border-orange-500');
                    item.querySelector('span').classList.add('text-orange-700');
                });
                updateCount();
            });
        }
        
        // Limpar seleção
        if (btnLimparSelecao) {
            btnLimparSelecao.addEventListener('click', () => {
                gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                    const checkbox = item.querySelector('.maquina-lote-checkbox');
                    checkbox.checked = false;
                    item.classList.remove('bg-orange-100', 'border-orange-500');
                    item.querySelector('span').classList.remove('text-orange-700');
                });
                updateCount();
            });
        }
        
        // Atualizar motivos quando categoria mudar
        if (categoriaSelect) {
            categoriaSelect.addEventListener('change', updateMotivos);
            // Inicializar com a primeira categoria
            updateMotivos();
        }
        
        // Usar data/hora atual
        if (btnUsarAgora) {
            btnUsarAgora.addEventListener('click', () => {
                setCurrentDateTime();
                showNotification('✅ Data e hora atualizados', 'success');
            });
        }
        
        // Submit do formulário
        if (form && !form.dataset.listenerAttached) {
            form.dataset.listenerAttached = 'true';
            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const statusDiv = document.getElementById('parada-lote-status');
                const submitBtn = document.getElementById('parada-lote-submit');
                
                // Coletar máquinas selecionadas
                const maquinasSelecionadas = Array.from(gridMaquinas.querySelectorAll('.maquina-lote-checkbox:checked'))
                    .map(cb => cb.value);
                
                const categoria = categoriaSelect?.value;
                const motivo = motivoSelect?.value;
                const data = dataInput?.value;
                const hora = horaInput?.value;
                
                // Validação
                if (maquinasSelecionadas.length === 0) {
                    if (statusDiv) {
                        statusDiv.textContent = '❌ Selecione pelo menos uma máquina';
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
                    }
                    return;
                }
                
                if (!categoria || !motivo || !data || !hora) {
                    if (statusDiv) {
                        statusDiv.textContent = '❌ Preencha todos os campos obrigatórios';
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
                    }
                    return;
                }
                
                try {
                    if (submitBtn) submitBtn.disabled = true;
                    if (statusDiv) {
                        statusDiv.textContent = `Registrando paradas para ${maquinasSelecionadas.length} máquinas...`;
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-blue-600';
                    }
                    
                    const startDateTime = new Date(`${data}T${hora}:00`);
                    const userName = getActiveUser()?.name || 'Sistema';
                    const batch = db.batch();
                    
                    // Criar documento para cada máquina
                    maquinasSelecionadas.forEach(machineId => {
                        const docRef = db.collection('extended_downtime_logs').doc();
                        batch.set(docRef, {
                            machine_id: machineId,
                            category: categoria,
                            type: motivo,
                            reason: motivo,
                            start_date: data,
                            start_time: hora,
                            start_datetime: firebase.firestore.Timestamp.fromDate(startDateTime),
                            end_date: null,
                            end_time: null,
                            end_datetime: null,
                            status: 'active',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            createdBy: userName,
                            shift: getCurrentShift(startDateTime),
                            date: data,
                            batch_id: Date.now().toString() // ID para identificar paradas do mesmo lote
                        });
                    });
                    
                    await batch.commit();
                    
                    console.log('[PARADA-LOTE] ✅ Paradas registradas:', maquinasSelecionadas.length, 'máquinas');
                    
                    if (statusDiv) {
                        statusDiv.textContent = `✅ Parada registrada para ${maquinasSelecionadas.length} máquinas!`;
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-green-600';
                    }
                    
                    // Limpar formulário
                    gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                        const checkbox = item.querySelector('.maquina-lote-checkbox');
                        checkbox.checked = false;
                        item.classList.remove('bg-orange-100', 'border-orange-500');
                        item.querySelector('span').classList.remove('text-orange-700');
                    });
                    updateCount();
                    if (categoriaSelect) categoriaSelect.value = '';
                    if (motivoSelect) motivoSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
                    
                    // Recarregar lista de paradas
                    if (typeof loadExtendedDowntimeList === 'function') {
                        await loadExtendedDowntimeList();
                    }
                    
                    // Recarregar painel de máquinas
                    const machinesDowntime = await getAllMachinesDowntimeStatus();
                    await renderMachineCards([], [], [], new Set(), machinesDowntime);
                    
                    if (submitBtn) submitBtn.disabled = false;
                    
                    setTimeout(() => {
                        if (statusDiv) {
                            statusDiv.textContent = '';
                            statusDiv.className = 'text-sm font-semibold h-5 text-center';
                        }
                    }, 5000);
                    
                } catch (error) {
                    console.error('[PARADA-LOTE] Erro:', error);
                    if (statusDiv) {
                        statusDiv.textContent = `❌ Erro: ${error.message}`;
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
                    }
                    if (submitBtn) submitBtn.disabled = false;
                }
            });
        }
        
        console.log('[PARADA-LOTE] ✅ Funcionalidade de parada em lote inicializada');
        }, 500); // Aguardar 500ms para garantir que o DOM está pronto
    }

    // ==================== ACOMPANHAMENTO DE TURNO ====================
    let acompanhamentoInitialized = false;

    function setupAcompanhamentoTurno() {
        if (acompanhamentoInitialized) return;
        acompanhamentoInitialized = true;

        console.log('[ACOMPANHAMENTO] Inicializando aba de acompanhamento de turno...');

        // Setup das tabs de acompanhamento (Produção vs Perdas vs Paradas)
        document.querySelectorAll('.acompanhamento-tab-btn').forEach(btn => {
            if (btn.dataset.tabListenerAttached) return;
            btn.dataset.tabListenerAttached = 'true';
            
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const tab = e.currentTarget.dataset.acompanhamentoTab;
                console.log('[ACOMPANHAMENTO] Alternando para aba:', tab);
                
                // Atualizar visual das tabs
                document.querySelectorAll('.acompanhamento-tab-btn').forEach(b => {
                    b.classList.remove('border-blue-600', 'border-red-600', 'border-amber-600', 'bg-blue-50', 'bg-red-50', 'bg-amber-50', 'text-blue-700', 'text-red-700', 'text-amber-700');
                    b.classList.add('border-transparent', 'text-gray-500');
                });
                
                if (tab === 'producao') {
                    e.currentTarget.classList.add('border-blue-600', 'bg-blue-50', 'text-blue-700');
                } else if (tab === 'perdas') {
                    e.currentTarget.classList.add('border-red-600', 'bg-red-50', 'text-red-700');
                } else if (tab === 'paradas') {
                    e.currentTarget.classList.add('border-amber-600', 'bg-amber-50', 'text-amber-700');
                }
                e.currentTarget.classList.remove('border-transparent', 'text-gray-500');
                
                // Mostrar/esconder conteúdo
                document.querySelectorAll('.acompanhamento-tab-content').forEach(content => {
                    content.classList.add('hidden');
                });
                const tabContent = document.getElementById(`acompanhamento-tab-${tab}`);
                if (tabContent) {
                    tabContent.classList.remove('hidden');
                }
                
                if (typeof lucide !== 'undefined') lucide.createIcons();
            });
        });

        // Definir data padrão = hoje
        const dataInput = document.getElementById('acompanhamento-data');
        if (dataInput && !dataInput.value) {
            dataInput.value = getProductionDateString();
        }

        // Atualizar status de conexão
        const statusEl = document.getElementById('acompanhamento-status');
        if (statusEl && db) {
            statusEl.textContent = '✅ Conectado';
            statusEl.classList.remove('text-blue-600', 'bg-blue-100');
            statusEl.classList.add('text-green-600', 'bg-green-100');
        }

        // Event listeners
        const btnCarregar = document.getElementById('acompanhamento-carregar');
        const btnLimpar = document.getElementById('acompanhamento-limpar');
        const btnImprimir = document.getElementById('acompanhamento-imprimir');

        if (btnCarregar && !btnCarregar.dataset.listenerAttached) {
            btnCarregar.addEventListener('click', carregarDadosAcompanhamento);
            btnCarregar.dataset.listenerAttached = 'true';
        }

        if (btnLimpar && !btnLimpar.dataset.listenerAttached) {
            btnLimpar.addEventListener('click', limparCedocAcompanhamento);
            btnLimpar.dataset.listenerAttached = 'true';
        }

        if (btnImprimir && !btnImprimir.dataset.listenerAttached) {
            btnImprimir.addEventListener('click', () => window.print());
            btnImprimir.dataset.listenerAttached = 'true';
        }

        const btnSalvar = document.getElementById('acompanhamento-salvar');
        if (btnSalvar && !btnSalvar.dataset.listenerAttached) {
            btnSalvar.addEventListener('click', salvarDadosAcompanhamento);
            btnSalvar.dataset.listenerAttached = 'true';
        }

        // Renderizar ícones Lucide
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    async function carregarDadosAcompanhamento() {
        const data = document.getElementById('acompanhamento-data')?.value;

        if (!data) {
            showNotification('⚠️ Selecione a data!', 'warning');
            return;
        }

        const tbody = document.getElementById('acompanhamento-tbody');
        if (!tbody) return;

        tbody.innerHTML = `
            <tr>
                <td colspan="10" class="px-4 py-10 text-center text-gray-400">
                    <i data-lucide="loader-2" class="w-10 h-10 mx-auto mb-3 animate-spin opacity-50"></i>
                    <p>Carregando dados do Hokkaido Mes...</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        try {
            // Estrutura: { maquina: { t1: hokkaido, t2: hokkaido, t3: hokkaido } }
            const producaoPorMaquina = new Map();
            
            // Usar um Set para evitar duplicatas por docId
            const docsProcessados = new Set();

            // Buscar registros com campo 'data' (português)
            const snapshotData = await db.collection('production_entries')
                .where('data', '==', data)
                .get();
                
            console.log('[ACOMPANHAMENTO] Documentos encontrados com campo "data":', snapshotData.size);
            
            // Buscar também com campo 'date' (inglês) para cobrir registros antigos
            const snapshotDate = await db.collection('production_entries')
                .where('date', '==', data)
                .get();
                
            console.log('[ACOMPANHAMENTO] Documentos encontrados com campo "date":', snapshotDate.size);

            // Função para processar um documento
            const processarDoc = (doc) => {
                // Evitar processar o mesmo doc duas vezes
                if (docsProcessados.has(doc.id)) return;
                docsProcessados.add(doc.id);
                
                const d = doc.data();
                const machine = normalizeMachineId(d.machine || d.machine_id || d.maquina || '');
                if (!machine || machine === 'N/A') return;
                
                // CORREÇÃO: Pegar APENAS quantidade produzida (peças), NÃO peso
                // O campo correto é 'produzido' ou 'quantity' - ambos são peças
                // 'peso_liquido' e 'peso_bruto' são KG e não devem ser somados aqui
                const quantidade = parseInt(d.produzido || d.quantity || 0, 10);
                
                // Pegar turno - pode estar em 'turno' ou 'shift'
                const turno = parseInt(d.turno || d.shift || 0, 10);
                
                // Ignorar registros sem turno válido ou que são apenas perdas
                if (turno < 1 || turno > 3) return;
                
                // Ignorar registros que são apenas perdas (sem produção)
                if (quantidade <= 0) return;

                if (!producaoPorMaquina.has(machine)) {
                    producaoPorMaquina.set(machine, { t1: 0, t2: 0, t3: 0 });
                }
                producaoPorMaquina.get(machine)[`t${turno}`] += quantidade;
            };

            // Processar todos os documentos
            snapshotData.docs.forEach(processarDoc);
            snapshotDate.docs.forEach(processarDoc);
            
            console.log('[ACOMPANHAMENTO] Total de docs processados (sem duplicatas):', docsProcessados.size);
            console.log('[ACOMPANHAMENTO] Máquinas com produção:', producaoPorMaquina.size);

            // Renderizar tabela
            tbody.innerHTML = '';

            if (producaoPorMaquina.size === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" class="px-4 py-10 text-center text-gray-400">
                            <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                            <p>Nenhum lançamento encontrado para esta data</p>
                        </td>
                    </tr>
                `;
                document.getElementById('acompanhamento-resumo')?.classList.add('hidden');
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            // Ordenar por máquina
            const maquinasOrdenadas = Array.from(producaoPorMaquina.entries()).sort((a, b) => a[0].localeCompare(b[0]));

            // Carregar dados salvos dos 3 turnos
            let dadosSalvos = {};
            try {
                for (const t of ['1', '2', '3']) {
                    const docId = `${data}_T${t}`;
                    const docSalvo = await db.collection('acompanhamento_turno').doc(docId).get();
                    if (docSalvo.exists) {
                        const saved = docSalvo.data();
                        if (saved.registros) {
                            saved.registros.forEach(r => {
                                const key = `${r.maquina}_T${t}`;
                                dadosSalvos[key] = { cedoc: r.cedoc };
                            });
                        }
                    }
                }
                console.log('[ACOMPANHAMENTO] Dados salvos carregados:', Object.keys(dadosSalvos).length, 'registros');
            } catch (e) {
                console.warn('[ACOMPANHAMENTO] Não foi possível carregar dados salvos:', e);
            }

            maquinasOrdenadas.forEach(([maquina, hokkaidos]) => {
                const salvoT1 = dadosSalvos[`${maquina}_T1`] || {};
                const salvoT2 = dadosSalvos[`${maquina}_T2`] || {};
                const salvoT3 = dadosSalvos[`${maquina}_T3`] || {};
                
                const linha = document.createElement('tr');
                linha.className = 'hover:bg-gray-50 transition-colors';
                linha.innerHTML = `
                    <td class="px-3 py-2 border-r border-gray-200"><strong class="text-blue-600 text-sm">${maquina}</strong></td>
                    
                    <!-- T1 -->
                    <td class="px-1 py-2 text-center bg-blue-50/30">
                        <input type="number" class="acompanhamento-cedoc w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-blue-500" 
                               data-maquina="${maquina}" data-turno="1" placeholder="0" value="${salvoT1.cedoc || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-blue-50/30">
                        <span class="text-xs font-semibold acompanhamento-hokkaido" data-turno="1">${hokkaidos.t1}</span>
                    </td>
                    <td class="px-1 py-2 text-center border-r border-gray-200 bg-blue-50/30">
                        <span class="acompanhamento-diferenca text-xs font-bold" data-maquina="${maquina}" data-turno="1">0</span>
                    </td>
                    
                    <!-- T2 -->
                    <td class="px-1 py-2 text-center bg-purple-50/30">
                        <input type="number" class="acompanhamento-cedoc w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-purple-500" 
                               data-maquina="${maquina}" data-turno="2" placeholder="0" value="${salvoT2.cedoc || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-purple-50/30">
                        <span class="text-xs font-semibold acompanhamento-hokkaido" data-turno="2">${hokkaidos.t2}</span>
                    </td>
                    <td class="px-1 py-2 text-center border-r border-gray-200 bg-purple-50/30">
                        <span class="acompanhamento-diferenca text-xs font-bold" data-maquina="${maquina}" data-turno="2">0</span>
                    </td>
                    
                    <!-- T3 -->
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <input type="number" class="acompanhamento-cedoc w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-orange-500" 
                               data-maquina="${maquina}" data-turno="3" placeholder="0" value="${salvoT3.cedoc || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <span class="text-xs font-semibold acompanhamento-hokkaido" data-turno="3">${hokkaidos.t3}</span>
                    </td>
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <span class="acompanhamento-diferenca text-xs font-bold" data-maquina="${maquina}" data-turno="3">0</span>
                    </td>
                `;

                // Adicionar listeners para calcular diferenças
                linha.querySelectorAll('.acompanhamento-cedoc').forEach(input => {
                    input.addEventListener('input', calcularDiferencasAcompanhamento);
                });

                tbody.appendChild(linha);
            });

            document.getElementById('acompanhamento-resumo')?.classList.remove('hidden');
            calcularDiferencasAcompanhamento();
            if (typeof lucide !== 'undefined') lucide.createIcons();

            console.log('[ACOMPANHAMENTO] Dados carregados:', producaoPorMaquina.size, 'máquinas');

        } catch (error) {
            console.error('[ACOMPANHAMENTO] Erro ao carregar dados:', error);
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="px-4 py-10 text-center text-red-400">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                        <p>Erro ao carregar: ${error.message}</p>
                    </td>
                </tr>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    function calcularDiferencasAcompanhamento() {
        let celulasComDiferenca = 0;

        document.querySelectorAll('#acompanhamento-tbody tr').forEach(row => {
            // Para cada linha, processar os 3 turnos
            row.querySelectorAll('.acompanhamento-cedoc').forEach(cedocInput => {
                const turno = cedocInput.dataset.turno;
                const maquina = cedocInput.dataset.maquina;
                
                // Encontrar o hokkaido e diferença correspondentes na mesma linha
                const hokaidoSpan = row.querySelector(`.acompanhamento-hokkaido[data-turno="${turno}"]`);
                const diferencaCell = row.querySelector(`.acompanhamento-diferenca[data-turno="${turno}"]`);

                if (cedocInput && hokaidoSpan && diferencaCell) {
                    const cedoc = parseFloat(cedocInput.value) || 0;
                    const hokkaido = parseFloat(hokaidoSpan.textContent) || 0;
                    const diferenca = cedoc - hokkaido;

                    diferencaCell.textContent = Math.round(diferenca);

                    // Resetar classes
                    diferencaCell.classList.remove('text-red-600', 'bg-red-100', 'text-yellow-600', 'bg-yellow-100', 'text-green-600', 'bg-green-100', 'rounded', 'px-1');

                    if (diferenca > 0) {
                        diferencaCell.classList.add('text-red-600', 'bg-red-100', 'rounded', 'px-1');
                        celulasComDiferenca++;
                    } else if (diferenca < 0) {
                        diferencaCell.classList.add('text-yellow-600', 'bg-yellow-100', 'rounded', 'px-1');
                        celulasComDiferenca++;
                    } else if (cedoc > 0) {
                        diferencaCell.classList.add('text-green-600', 'bg-green-100', 'rounded', 'px-1');
                    }
                }
            });
        });

        // Atualizar resumo
        const maquinasDiffEl = document.getElementById('acompanhamento-maquinas-diff');
        if (maquinasDiffEl) {
            maquinasDiffEl.textContent = celulasComDiferenca;
        }
    }

    function limparCedocAcompanhamento() {
        if (!confirm('⚠️ Limpar todos os valores CEDOC?')) return;

        document.querySelectorAll('.acompanhamento-cedoc').forEach(input => {
            input.value = '';
        });
        calcularDiferencasAcompanhamento();
        showNotification('✅ Campos limpos!', 'success');
    }

    async function salvarDadosAcompanhamento() {
        const data = document.getElementById('acompanhamento-data')?.value;

        if (!data) {
            showNotification('⚠️ Selecione a data primeiro!', 'warning');
            return;
        }

        // Agrupar registros por turno
        const registrosPorTurno = { 1: [], 2: [], 3: [] };
        let temDados = false;

        document.querySelectorAll('#acompanhamento-tbody tr').forEach(row => {
            // Processar cada input CEDOC da linha (3 turnos)
            row.querySelectorAll('.acompanhamento-cedoc').forEach(cedocInput => {
                const maquina = cedocInput.dataset.maquina;
                const turnoLinha = parseInt(cedocInput.dataset.turno);
                const synchroSpan = row.querySelector(`.acompanhamento-synchro[data-turno="${turnoLinha}"]`);
                const diferencaCell = row.querySelector(`.acompanhamento-diferenca[data-turno="${turnoLinha}"]`);

                const cedoc = parseFloat(cedocInput.value) || 0;
                const synchro = parseFloat(synchroSpan?.textContent) || 0;
                const diferenca = parseFloat(diferencaCell?.textContent) || 0;

                if (cedoc > 0) {
                    temDados = true;
                }

                registrosPorTurno[turnoLinha].push({
                    maquina: maquina,
                    cedoc: cedoc,
                    synchro: synchro,
                    diferenca: diferenca
                });
            });
        });

        if (!temDados) {
            showNotification('⚠️ Preencha ao menos um valor CEDOC!', 'warning');
            return;
        }

        try {
            const usuario = window.authSystem?.getCurrentUser()?.name || 'Desconhecido';

            // Salvar cada turno separadamente
            for (const t of [1, 2, 3]) {
                if (registrosPorTurno[t].length > 0) {
                    const docId = `${data}_T${t}`;
                    await db.collection('acompanhamento_turno').doc(docId).set({
                        data: data,
                        turno: t,
                        registros: registrosPorTurno[t],
                        salvoEm: firebase.firestore.FieldValue.serverTimestamp(),
                        salvoEmLocal: new Date().toLocaleString('pt-BR'),
                        usuario: usuario
                    }, { merge: true });
                }
            }
            showNotification('✅ Acompanhamento salvo com sucesso!', 'success');
            console.log('[ACOMPANHAMENTO] Dados salvos para todos os turnos');
            
            // Registrar log
            registrarLogSistema('SALVAMENTO DE ACOMPANHAMENTO', 'acompanhamento', {
                data: data,
                turnosRegistrados: Object.keys(registrosPorTurno).filter(t => registrosPorTurno[t].length > 0).length,
                totalRegistros: registrosPorTurno[1].length + registrosPorTurno[2].length + registrosPorTurno[3].length
            });

        } catch (error) {
            console.error('[ACOMPANHAMENTO] Erro ao salvar:', error);
            showNotification('❌ Erro ao salvar: ' + error.message, 'error');
        }
    }
    // ==================== FIM ACOMPANHAMENTO DE TURNO ====================

    // ==================== ACOMPANHAMENTO DE PERDAS (PERDAS/OP) ====================
    let acompanhamentoPerdasSetupDone = false;
    let acompanhamentoPerdasDataAtual = {};

    function setupAcompanhamentoPerdas() {
        if (acompanhamentoPerdasSetupDone) {
            if (typeof lucide !== 'undefined') lucide.createIcons();
            return;
        }
        acompanhamentoPerdasSetupDone = true;

        console.log('[ACOMPANHAMENTO-PERDAS] Inicializando módulo de perdas...');

        // Data padrão = hoje
        const today = new Date().toISOString().split('T')[0];
        const dataInput = document.getElementById('acompanhamento-perdas-data');
        if (dataInput) {
            dataInput.value = today;
        }

        // Eventos dos botões
        const btnCarregar = document.getElementById('acompanhamento-perdas-carregar');
        const btnLimpar = document.getElementById('acompanhamento-perdas-limpar');
        const btnSalvar = document.getElementById('acompanhamento-perdas-salvar');
        const btnImprimir = document.getElementById('acompanhamento-perdas-imprimir');

        if (btnCarregar) {
            btnCarregar.addEventListener('click', carregarDadosAcompanhamentoPerdas);
        }

        if (btnLimpar) {
            btnLimpar.addEventListener('click', limparOpAcompanhamentoPerdas);
        }

        if (btnSalvar) {
            btnSalvar.addEventListener('click', salvarDadosAcompanhamentoPerdas);
        }

        if (btnImprimir) {
            btnImprimir.addEventListener('click', imprimirAcompanhamentoPerdas);
        }

        // Atualizar status
        const status = document.getElementById('acompanhamento-perdas-status');
        if (status) {
            status.textContent = '✅ Pronto';
            status.classList.remove('text-red-600', 'bg-red-100');
            status.classList.add('text-green-600', 'bg-green-100');
        }

        if (typeof lucide !== 'undefined') lucide.createIcons();
        console.log('[ACOMPANHAMENTO-PERDAS] Setup concluído!');
    }

    async function carregarDadosAcompanhamentoPerdas() {
        const data = document.getElementById('acompanhamento-perdas-data')?.value;

        if (!data) {
            showNotification('⚠️ Selecione a data!', 'warning');
            return;
        }

        const tbody = document.getElementById('acompanhamento-perdas-tbody');
        if (!tbody) return;

        tbody.innerHTML = `
            <tr>
                <td colspan="10" class="px-4 py-10 text-center text-gray-400">
                    <i data-lucide="loader-2" class="w-10 h-10 mx-auto mb-3 animate-spin opacity-50"></i>
                    <p>Carregando dados de perdas do Hokkaido Mes...</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        try {
            // Buscar todos os 3 turnos - igual ao acompanhamento de produção
            const turnosParaBuscar = [1, 2, 3];
            
            // Estrutura: { maquina: { t1: perdasMes, t2: perdasMes, t3: perdasMes } }
            const perdasPorMaquina = new Map();

            for (const t of turnosParaBuscar) {
                // Buscar por 'turno'
                const snapshot = await db.collection('production_entries')
                    .where('data', '==', data)
                    .where('turno', '==', t)
                    .get();

                snapshot.docs.forEach(doc => {
                    const d = doc.data();
                    const machine = d.machine || d.machine_id || d.maquina || 'N/A';
                    const refugo = parseFloat(d.refugo_kg || d.refugo || 0);

                    if (refugo <= 0) return; // Ignorar se não tiver perda

                    if (!perdasPorMaquina.has(machine)) {
                        perdasPorMaquina.set(machine, { t1: 0, t2: 0, t3: 0 });
                    }
                    perdasPorMaquina.get(machine)[`t${t}`] += refugo;
                });

                // Buscar por 'shift' também
                const snapshotShift = await db.collection('production_entries')
                    .where('data', '==', data)
                    .where('shift', '==', t)
                    .get();

                snapshotShift.docs.forEach(doc => {
                    const d = doc.data();
                    const machine = d.machine || d.machine_id || d.maquina || 'N/A';
                    const refugo = parseFloat(d.refugo_kg || d.refugo || 0);

                    if (refugo <= 0) return; // Ignorar se não tiver perda

                    if (!perdasPorMaquina.has(machine)) {
                        perdasPorMaquina.set(machine, { t1: 0, t2: 0, t3: 0 });
                    }
                    perdasPorMaquina.get(machine)[`t${t}`] += refugo;
                });
            }

            // Renderizar tabela
            tbody.innerHTML = '';

            if (perdasPorMaquina.size === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" class="px-4 py-10 text-center text-gray-400">
                            <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                            <p>Nenhum lançamento de perdas encontrado para esta data</p>
                        </td>
                    </tr>
                `;
                document.getElementById('acompanhamento-perdas-resumo')?.classList.add('hidden');
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            // Ordenar por máquina (igual ao acompanhamento de produção)
            const maquinasOrdenadas = Array.from(perdasPorMaquina.entries()).sort((a, b) => a[0].localeCompare(b[0]));

            // Carregar dados salvos dos 3 turnos (OP manual)
            let dadosSalvos = {};
            try {
                for (const t of ['1', '2', '3']) {
                    const docId = `${data}_T${t}`;
                    const docSalvo = await db.collection('acompanhamento_perdas').doc(docId).get();
                    if (docSalvo.exists) {
                        const saved = docSalvo.data();
                        if (saved.registros) {
                            saved.registros.forEach(r => {
                                const key = `${r.maquina}_T${t}`;
                                dadosSalvos[key] = { op: r.op };
                            });
                        }
                    }
                }
                console.log('[ACOMPANHAMENTO-PERDAS] Dados salvos carregados:', Object.keys(dadosSalvos).length, 'registros');
            } catch (e) {
                console.warn('[ACOMPANHAMENTO-PERDAS] Não foi possível carregar dados salvos:', e);
            }

            // Armazenar dados atuais
            acompanhamentoPerdasDataAtual = { data: data, maquinas: {} };

            maquinasOrdenadas.forEach(([maquina, perdasMes]) => {
                const salvoT1 = dadosSalvos[`${maquina}_T1`] || {};
                const salvoT2 = dadosSalvos[`${maquina}_T2`] || {};
                const salvoT3 = dadosSalvos[`${maquina}_T3`] || {};

                // Armazenar dados para calcular diferenças
                acompanhamentoPerdasDataAtual.maquinas[maquina] = {
                    mes: perdasMes,
                    op: { t1: salvoT1.op || 0, t2: salvoT2.op || 0, t3: salvoT3.op || 0 }
                };
                
                const linha = document.createElement('tr');
                linha.className = 'hover:bg-gray-50 transition-colors';
                linha.dataset.maquina = maquina;
                linha.innerHTML = `
                    <td class="px-3 py-2 border-r border-gray-200"><strong class="text-red-600 text-sm">${maquina}</strong></td>
                    
                    <!-- T1 -->
                    <td class="px-1 py-2 text-center bg-red-50/30">
                        <input type="number" step="0.01" class="acompanhamento-op-perdas w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-red-500" 
                               data-maquina="${maquina}" data-turno="1" placeholder="0" value="${salvoT1.op || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-red-50/30">
                        <span class="text-xs font-semibold acompanhamento-mes-perdas" data-turno="1">${perdasMes.t1.toFixed(2)}</span>
                    </td>
                    <td class="px-1 py-2 text-center border-r border-gray-200 bg-red-50/30">
                        <span class="acompanhamento-diferenca-perdas text-xs font-bold" data-maquina="${maquina}" data-turno="1">0</span>
                    </td>
                    
                    <!-- T2 -->
                    <td class="px-1 py-2 text-center bg-purple-50/30">
                        <input type="number" step="0.01" class="acompanhamento-op-perdas w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-purple-500" 
                               data-maquina="${maquina}" data-turno="2" placeholder="0" value="${salvoT2.op || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-purple-50/30">
                        <span class="text-xs font-semibold acompanhamento-mes-perdas" data-turno="2">${perdasMes.t2.toFixed(2)}</span>
                    </td>
                    <td class="px-1 py-2 text-center border-r border-gray-200 bg-purple-50/30">
                        <span class="acompanhamento-diferenca-perdas text-xs font-bold" data-maquina="${maquina}" data-turno="2">0</span>
                    </td>
                    
                    <!-- T3 -->
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <input type="number" step="0.01" class="acompanhamento-op-perdas w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-orange-500" 
                               data-maquina="${maquina}" data-turno="3" placeholder="0" value="${salvoT3.op || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <span class="text-xs font-semibold acompanhamento-mes-perdas" data-turno="3">${perdasMes.t3.toFixed(2)}</span>
                    </td>
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <span class="acompanhamento-diferenca-perdas text-xs font-bold" data-maquina="${maquina}" data-turno="3">0</span>
                    </td>
                `;

                // Adicionar listeners para calcular diferenças
                linha.querySelectorAll('.acompanhamento-op-perdas').forEach(input => {
                    input.addEventListener('input', calcularDiferencasPerdas);
                });

                tbody.appendChild(linha);
            });

            // Calcular diferenças iniciais
            calcularDiferencasPerdas();

            // Mostrar resumo
            document.getElementById('acompanhamento-perdas-resumo')?.classList.remove('hidden');

            showNotification(`✅ Dados de perdas carregados: ${maquinasOrdenadas.length} máquinas`, 'success');

            if (typeof lucide !== 'undefined') lucide.createIcons();

        } catch (error) {
            console.error('[ACOMPANHAMENTO-PERDAS] Erro ao carregar:', error);
            showNotification('❌ Erro ao carregar dados de perdas: ' + error.message, 'error');
            tbody.innerHTML = `
                <tr>
                    <td colspan="10" class="px-4 py-10 text-center text-red-500">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                        <p>Erro ao carregar dados. Tente novamente.</p>
                    </td>
                </tr>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    function calcularDiferencasPerdas() {
        const tbody = document.getElementById('acompanhamento-perdas-tbody');
        if (!tbody) return;

        let totalOp = 0;
        let totalMes = 0;
        let maquinasComDiferenca = 0;

        tbody.querySelectorAll('tr[data-maquina]').forEach(row => {
            const maquina = row.dataset.maquina;
            const dados = acompanhamentoPerdasDataAtual.maquinas?.[maquina];
            if (!dados) return;

            const mes = dados.mes;

            // Pegar valores dos inputs
            const inputs = row.querySelectorAll('.acompanhamento-op-perdas');
            const diferencas = row.querySelectorAll('.acompanhamento-diferenca-perdas');

            let temDiferenca = false;

            inputs.forEach((input, idx) => {
                const turno = input.dataset.turno;
                const opValue = parseFloat(input.value) || 0;
                const mesValue = mes[`t${turno}`] || 0;
                const diff = opValue - mesValue;

                // Atualizar diferença visual
                const diffSpan = diferencas[idx];
                if (diffSpan) {
                    if (Math.abs(diff) < 0.01) {
                        diffSpan.innerHTML = '<span class="text-green-600">0</span>';
                    } else if (diff > 0) {
                        diffSpan.innerHTML = `<span class="text-orange-600">+${diff.toFixed(2)}</span>`;
                        temDiferenca = true;
                    } else {
                        diffSpan.innerHTML = `<span class="text-red-600">${diff.toFixed(2)}</span>`;
                        temDiferenca = true;
                    }
                }

                // Acumular totais
                totalOp += opValue;
                totalMes += mesValue;

                // Atualizar dados armazenados
                dados.op[`t${turno}`] = opValue;
            });

            // Destacar linha com diferença
            if (temDiferenca) {
                row.classList.add('bg-red-50');
                maquinasComDiferenca++;
            } else {
                row.classList.remove('bg-red-50');
            }
        });

        // Atualizar resumo
        const maqDiffEl = document.getElementById('acompanhamento-perdas-maquinas-diff');
        const totalOpEl = document.getElementById('acompanhamento-perdas-total-op');
        const totalMesEl = document.getElementById('acompanhamento-perdas-total-mes');

        if (maqDiffEl) maqDiffEl.textContent = maquinasComDiferenca;
        if (totalOpEl) totalOpEl.textContent = totalOp.toFixed(2);
        if (totalMesEl) totalMesEl.textContent = totalMes.toFixed(2);
    }

    function limparOpAcompanhamentoPerdas() {
        if (!confirm('Limpar todos os valores de OP? Esta ação não pode ser desfeita.')) return;

        document.querySelectorAll('.acompanhamento-op-perdas').forEach(input => {
            input.value = '';
        });

        // Resetar dados armazenados
        if (acompanhamentoPerdasDataAtual.maquinas) {
            Object.keys(acompanhamentoPerdasDataAtual.maquinas).forEach(maquina => {
                acompanhamentoPerdasDataAtual.maquinas[maquina].op = { t1: 0, t2: 0, t3: 0 };
            });
        }

        calcularDiferencasPerdas();
        showNotification('🗑️ Valores de OP limpos', 'info');
    }

    async function salvarDadosAcompanhamentoPerdas() {
        if (!acompanhamentoPerdasDataAtual.data) {
            showNotification('⚠️ Carregue os dados primeiro', 'warning');
            return;
        }

        try {
            const data = acompanhamentoPerdasDataAtual.data;
            const usuario = window.authSystem?.getCurrentUser();
            
            // Salvar por turno (igual ao acompanhamento de produção)
            for (const t of ['1', '2', '3']) {
                const registros = [];
                
                document.querySelectorAll(`.acompanhamento-op-perdas[data-turno="${t}"]`).forEach(input => {
                    const maquina = input.dataset.maquina;
                    const opValue = parseFloat(input.value) || 0;
                    const mesValue = acompanhamentoPerdasDataAtual.maquinas?.[maquina]?.mes?.[`t${t}`] || 0;
                    
                    registros.push({
                        maquina: maquina,
                        op: opValue,
                        mes: mesValue,
                        diferenca: opValue - mesValue
                    });
                });

                const docId = `${data}_T${t}`;
                await db.collection('acompanhamento_perdas').doc(docId).set({
                    data: data,
                    turno: parseInt(t),
                    registros: registros,
                    atualizadoEm: firebase.firestore.FieldValue.serverTimestamp(),
                    atualizadoPor: usuario?.name || 'Desconhecido'
                });
            }

            showNotification('✅ Dados de perdas salvos com sucesso!', 'success');
            console.log('[ACOMPANHAMENTO-PERDAS] Dados salvos:', data);

        } catch (error) {
            console.error('[ACOMPANHAMENTO-PERDAS] Erro ao salvar:', error);
            showNotification('❌ Erro ao salvar: ' + error.message, 'error');
        }
    }

    function imprimirAcompanhamentoPerdas() {
        const tabela = document.getElementById('acompanhamento-perdas-tabela');
        const data = acompanhamentoPerdasDataAtual.data || 'Não selecionada';
        const totalOp = document.getElementById('acompanhamento-perdas-total-op')?.textContent || '0';
        const totalMes = document.getElementById('acompanhamento-perdas-total-mes')?.textContent || '0';
        const maquinasDiff = document.getElementById('acompanhamento-perdas-maquinas-diff')?.textContent || '0';

        const printWindow = window.open('', '_blank');
        printWindow.document.write(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Acompanhamento de Perdas - ${data}</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; }
                    h1 { text-align: center; color: #dc2626; margin-bottom: 5px; }
                    .subtitle { text-align: center; color: #666; margin-bottom: 20px; }
                    .resumo { display: flex; justify-content: space-around; margin-bottom: 20px; padding: 15px; background: #fef2f2; border-radius: 8px; }
                    .resumo-item { text-align: center; }
                    .resumo-item label { display: block; font-size: 12px; color: #666; }
                    .resumo-item span { font-size: 24px; font-weight: bold; color: #dc2626; }
                    table { width: 100%; border-collapse: collapse; font-size: 11px; }
                    th { background: #dc2626; color: white; padding: 8px 4px; border: 1px solid #b91c1c; }
                    td { padding: 6px 4px; border: 1px solid #ddd; text-align: center; }
                    tr:nth-child(even) { background: #f9f9f9; }
                    .diff-positive { color: #ea580c; font-weight: bold; }
                    .diff-negative { color: #dc2626; font-weight: bold; }
                    .diff-zero { color: #16a34a; }
                    @media print { body { padding: 0; } }
                </style>
            </head>
            <body>
                <h1>📊 Acompanhamento de Perdas</h1>
                <p class="subtitle">Data: ${data} | Validação Perdas vs OP</p>
                <div class="resumo">
                    <div class="resumo-item">
                        <label>Máquinas c/ Diferença</label>
                        <span>${maquinasDiff}</span>
                    </div>
                    <div class="resumo-item">
                        <label>Total OP (kg)</label>
                        <span>${totalOp}</span>
                    </div>
                    <div class="resumo-item">
                        <label>Total MES (kg)</label>
                        <span>${totalMes}</span>
                    </div>
                </div>
                ${tabela.outerHTML.replace(/class="[^"]*"/g, '').replace(/<input[^>]*value="([^"]*)"[^>]*>/g, '$1').replace(/<input[^>]*>/g, '0')}
                <p style="text-align: center; margin-top: 20px; color: #888; font-size: 11px;">
                    Impresso em: ${new Date().toLocaleString('pt-BR')} | Hokkaido MES
                </p>
            </body>
            </html>
        `);
        printWindow.document.close();
        printWindow.print();
    }
    // ==================== FIM ACOMPANHAMENTO DE PERDAS ====================

    // ==================== ACOMPANHAMENTO DE PARADAS (TIMELINE) ====================
    let acompanhamentoParadasSetupDone = false;
    let acompanhamentoParadasDataAtual = {};

    function setupAcompanhamentoParadas() {
        if (acompanhamentoParadasSetupDone) {
            if (typeof lucide !== 'undefined') lucide.createIcons();
            return;
        }
        acompanhamentoParadasSetupDone = true;

        console.log('[ACOMPANHAMENTO-PARADAS] Inicializando módulo de paradas...');

        // Data padrão = hoje
        const today = new Date().toISOString().split('T')[0];
        const dataInput = document.getElementById('acompanhamento-paradas-data');
        if (dataInput) {
            dataInput.value = today;
        }

        // Eventos dos botões
        const btnCarregar = document.getElementById('acompanhamento-paradas-carregar');
        const btnImprimir = document.getElementById('acompanhamento-paradas-imprimir');
        const btnExportar = document.getElementById('acompanhamento-paradas-exportar');

        if (btnCarregar) {
            btnCarregar.addEventListener('click', carregarTimelineParadas);
        }

        if (btnImprimir) {
            btnImprimir.addEventListener('click', imprimirTimelineParadas);
        }

        if (btnExportar) {
            btnExportar.addEventListener('click', exportarTimelineParadas);
        }

        // Atualizar status
        const status = document.getElementById('acompanhamento-paradas-status');
        if (status) {
            status.textContent = '✅ Pronto';
            status.classList.remove('text-amber-600', 'bg-amber-100');
            status.classList.add('text-green-600', 'bg-green-100');
        }

        if (typeof lucide !== 'undefined') lucide.createIcons();
        console.log('[ACOMPANHAMENTO-PARADAS] Setup concluído!');
    }

    async function carregarTimelineParadas() {
        const data = document.getElementById('acompanhamento-paradas-data')?.value;
        const turnoFiltro = document.getElementById('acompanhamento-paradas-turno')?.value || 'all';
        const container = document.getElementById('acompanhamento-paradas-timeline');
        const escalaEl = document.getElementById('paradas-escala-tempo');

        if (!data) {
            showNotification('⚠️ Selecione uma data!', 'warning');
            return;
        }

        container.innerHTML = `
            <div class="text-center py-10 text-gray-400">
                <div class="animate-spin w-10 h-10 border-4 border-amber-500 border-t-transparent rounded-full mx-auto mb-3"></div>
                <p>Carregando timeline de paradas...</p>
            </div>
        `;

        try {
            // Definir horários do turno
            let horaInicio, horaFim, escalaMarcas;
            if (turnoFiltro === '1') {
                horaInicio = 7; horaFim = 15;
                escalaMarcas = ['07:00', '08:00', '09:00', '10:00', '11:00', '12:00', '13:00', '14:00', '15:00'];
            } else if (turnoFiltro === '2') {
                horaInicio = 15; horaFim = 23;
                escalaMarcas = ['15:00', '16:00', '17:00', '18:00', '19:00', '20:00', '21:00', '22:00', '23:00'];
            } else if (turnoFiltro === '3') {
                horaInicio = 23; horaFim = 31; // 31 = 07:00 do dia seguinte
                escalaMarcas = ['23:00', '00:00', '01:00', '02:00', '03:00', '04:00', '05:00', '06:00', '07:00'];
            } else {
                horaInicio = 7; horaFim = 31; // Dia completo (07h às 07h)
                escalaMarcas = ['07:00', '10:00', '13:00', '16:00', '19:00', '22:00', '01:00', '04:00', '07:00'];
            }

            // Renderizar escala de tempo
            escalaEl.innerHTML = escalaMarcas.map(h => `<span>${h}</span>`).join('');

            // Buscar máquinas do planejamento para a data
            const maquinasPlanejamento = new Set();
            
            // Primeiro, buscar do planejamento
            const planejamentoSnapshot = await db.collection('planejamento')
                .where('data', '==', data)
                .get();
            
            planejamentoSnapshot.forEach(doc => {
                const d = doc.data();
                if (d.maquina || d.machine) {
                    maquinasPlanejamento.add(d.maquina || d.machine);
                }
            });

            // Se não houver planejamento, buscar máquinas da produção
            if (maquinasPlanejamento.size === 0) {
                const producaoSnapshot = await db.collection('production_entries')
                    .where('data', '==', data)
                    .get();
                
                producaoSnapshot.forEach(doc => {
                    const d = doc.data();
                    if (d.machine) {
                        maquinasPlanejamento.add(d.machine);
                    }
                });
            }

            // Se ainda não houver máquinas, usar lista padrão
            if (maquinasPlanejamento.size === 0) {
                ['H31', 'H32', 'H33', 'H34', 'H35', 'H36', 'H37', 'H38', 'H39', 'H40'].forEach(m => maquinasPlanejamento.add(m));
            }

            // Ordenar máquinas
            const maquinasOrdenadas = Array.from(maquinasPlanejamento).sort((a, b) => {
                const numA = parseInt(a.replace(/\D/g, '')) || 0;
                const numB = parseInt(b.replace(/\D/g, '')) || 0;
                return numA - numB;
            });

            // Buscar paradas para todas as máquinas
            const paradasPorMaquina = new Map();
            
            const paradasSnapshot = await db.collection('downtime_entries')
                .where('data', '==', data)
                .get();

            paradasSnapshot.forEach(doc => {
                const d = doc.data();
                const machine = d.machine || d.maquina;
                if (!machine || !maquinasPlanejamento.has(machine)) return;

                // Filtrar por turno se necessário
                if (turnoFiltro !== 'all') {
                    const turnoParada = d.turno || d.shift;
                    if (String(turnoParada) !== turnoFiltro) return;
                }

                if (!paradasPorMaquina.has(machine)) {
                    paradasPorMaquina.set(machine, []);
                }

                const inicio = d.horaInicio || d.startTime || d.hora_inicio;
                const fim = d.horaFim || d.endTime || d.hora_fim;
                const duracao = parseFloat(d.duracao || d.duration || 0);
                const motivo = d.motivo || d.reason || d.observacao || 'Não informado';
                const tipo = (d.tipo || d.type || '').toLowerCase();

                paradasPorMaquina.get(machine).push({
                    inicio: inicio,
                    fim: fim,
                    duracao: duracao,
                    motivo: motivo,
                    tipo: tipo
                });
            });

            // Calcular estatísticas
            let tempoTotalParado = 0;
            let totalParadas = 0;

            paradasPorMaquina.forEach(paradas => {
                paradas.forEach(p => {
                    tempoTotalParado += p.duracao;
                    totalParadas++;
                });
            });

            const tempoTurno = turnoFiltro === 'all' ? 24 * maquinasOrdenadas.length : 8 * maquinasOrdenadas.length;
            const tempoProducao = tempoTurno - tempoTotalParado;
            const disponibilidade = tempoTurno > 0 ? ((tempoProducao / tempoTurno) * 100) : 0;

            // Atualizar resumo
            const resumoEl = document.getElementById('acompanhamento-paradas-resumo');
            if (resumoEl) {
                resumoEl.classList.remove('hidden');
                document.getElementById('acompanhamento-paradas-tempo-prod').textContent = `${tempoProducao.toFixed(1)}h`;
                document.getElementById('acompanhamento-paradas-tempo-parado').textContent = `${tempoTotalParado.toFixed(1)}h`;
                document.getElementById('acompanhamento-paradas-total').textContent = totalParadas;
                document.getElementById('acompanhamento-paradas-disponibilidade').textContent = `${disponibilidade.toFixed(1)}%`;
            }

            // Armazenar dados
            acompanhamentoParadasDataAtual = {
                data: data,
                turno: turnoFiltro,
                maquinas: maquinasOrdenadas,
                paradas: paradasPorMaquina,
                horaInicio: horaInicio,
                horaFim: horaFim
            };

            // Renderizar timeline
            container.innerHTML = '';
            
            maquinasOrdenadas.forEach(maquina => {
                const paradas = paradasPorMaquina.get(maquina) || [];
                const row = criarLinhaTimelineParadas(maquina, paradas, horaInicio, horaFim);
                container.appendChild(row);
            });

            showNotification(`✅ Timeline carregada: ${maquinasOrdenadas.length} máquinas, ${totalParadas} paradas`, 'success');

            if (typeof lucide !== 'undefined') lucide.createIcons();

        } catch (error) {
            console.error('[ACOMPANHAMENTO-PARADAS] Erro:', error);
            showNotification('❌ Erro ao carregar timeline: ' + error.message, 'error');
            container.innerHTML = `
                <div class="text-center py-10 text-red-500">
                    <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                    <p>Erro ao carregar dados. Tente novamente.</p>
                </div>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    function criarLinhaTimelineParadas(maquina, paradas, horaInicio, horaFim) {
        const row = document.createElement('div');
        row.className = 'flex items-center gap-2 py-2 border-b border-gray-100 hover:bg-gray-50 transition-colors';

        // Nome da máquina
        const labelDiv = document.createElement('div');
        labelDiv.className = 'w-24 flex-shrink-0 font-bold text-sm text-gray-700';
        labelDiv.textContent = maquina;
        row.appendChild(labelDiv);

        // Container da timeline
        const timelineDiv = document.createElement('div');
        timelineDiv.className = 'flex-1 h-8 bg-green-400 rounded-lg relative overflow-hidden';
        timelineDiv.title = `${maquina} - Clique para ver detalhes`;

        // Calcular duração total do período
        const duracaoTotal = horaFim - horaInicio; // em horas

        // Renderizar paradas como blocos vermelhos/amarelos
        paradas.forEach((parada, idx) => {
            // Converter hora de início para posição
            let horaInicioParada = 0;
            if (parada.inicio) {
                const parts = parada.inicio.split(':');
                horaInicioParada = parseInt(parts[0]) + (parseInt(parts[1] || 0) / 60);
                // Ajustar para T3 (atravessa meia-noite)
                if (horaInicioParada < 7 && horaInicio >= 23) {
                    horaInicioParada += 24;
                }
            }

            const duracao = parada.duracao || 1; // duração em horas
            
            // Calcular posição e largura percentual
            const posicaoInicio = ((horaInicioParada - horaInicio) / duracaoTotal) * 100;
            const largura = (duracao / duracaoTotal) * 100;

            // Criar bloco de parada
            const blocoParada = document.createElement('div');
            const isSetup = parada.tipo && (parada.tipo.includes('setup') || parada.tipo.includes('troca'));
            blocoParada.className = `absolute top-0 h-full ${isSetup ? 'bg-yellow-500' : 'bg-red-500'} cursor-pointer hover:opacity-80 transition-opacity`;
            blocoParada.style.left = `${Math.max(0, Math.min(posicaoInicio, 100))}%`;
            blocoParada.style.width = `${Math.max(0.5, Math.min(largura, 100 - posicaoInicio))}%`;
            blocoParada.title = `${parada.inicio || '?'} - ${parada.fim || '?'}\n${parada.motivo}\nDuração: ${duracao.toFixed(1)}h`;

            // Adicionar texto se o bloco for grande o suficiente
            if (largura > 8) {
                blocoParada.innerHTML = `<span class="text-white text-xs font-semibold truncate px-1 leading-8">${parada.motivo.substring(0, 15)}</span>`;
            }

            timelineDiv.appendChild(blocoParada);
        });

        // Se não houver paradas, mostrar como totalmente verde
        if (paradas.length === 0) {
            timelineDiv.title = `${maquina} - Sem paradas registradas`;
        }

        row.appendChild(timelineDiv);

        // Estatísticas rápidas
        const statsDiv = document.createElement('div');
        statsDiv.className = 'w-20 flex-shrink-0 text-right';
        const tempoParado = paradas.reduce((acc, p) => acc + (p.duracao || 0), 0);
        statsDiv.innerHTML = `<span class="text-xs font-semibold ${tempoParado > 0 ? 'text-red-600' : 'text-green-600'}">${tempoParado.toFixed(1)}h</span>`;
        row.appendChild(statsDiv);

        return row;
    }

    function imprimirTimelineParadas() {
        const data = acompanhamentoParadasDataAtual.data || 'Não selecionada';
        const turno = acompanhamentoParadasDataAtual.turno || 'all';
        const turnoLabel = turno === 'all' ? 'Todos' : `T${turno}`;

        const tempoProd = document.getElementById('acompanhamento-paradas-tempo-prod')?.textContent || '0h';
        const tempoParado = document.getElementById('acompanhamento-paradas-tempo-parado')?.textContent || '0h';
        const totalParadas = document.getElementById('acompanhamento-paradas-total')?.textContent || '0';
        const disponibilidade = document.getElementById('acompanhamento-paradas-disponibilidade')?.textContent || '0%';

        // Gerar HTML das linhas
        let linhasHtml = '';
        acompanhamentoParadasDataAtual.maquinas?.forEach(maquina => {
            const paradas = acompanhamentoParadasDataAtual.paradas?.get(maquina) || [];
            const tempoParadoMaq = paradas.reduce((acc, p) => acc + (p.duracao || 0), 0);
            
            linhasHtml += `
                <tr>
                    <td style="padding: 8px; border: 1px solid #ddd; font-weight: bold;">${maquina}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center;">${paradas.length}</td>
                    <td style="padding: 8px; border: 1px solid #ddd; text-align: center; color: ${tempoParadoMaq > 0 ? '#dc2626' : '#16a34a'};">${tempoParadoMaq.toFixed(1)}h</td>
                    <td style="padding: 8px; border: 1px solid #ddd; font-size: 11px;">${paradas.map(p => p.motivo).join(', ') || '-'}</td>
                </tr>
            `;
        });

        const printWindow = window.open('', '_blank');
        printWindow.document.write(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Timeline de Paradas - ${data}</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 20px; }
                    h1 { text-align: center; color: #d97706; margin-bottom: 5px; }
                    .subtitle { text-align: center; color: #666; margin-bottom: 20px; }
                    .resumo { display: flex; justify-content: space-around; margin-bottom: 20px; padding: 15px; background: #fffbeb; border-radius: 8px; }
                    .resumo-item { text-align: center; }
                    .resumo-item label { display: block; font-size: 12px; color: #666; }
                    .resumo-item span { font-size: 20px; font-weight: bold; }
                    .resumo-item.green span { color: #16a34a; }
                    .resumo-item.red span { color: #dc2626; }
                    .resumo-item.amber span { color: #d97706; }
                    .resumo-item.blue span { color: #2563eb; }
                    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                    th { background: #d97706; color: white; padding: 10px; border: 1px solid #b45309; }
                    td { padding: 8px; border: 1px solid #ddd; }
                    tr:nth-child(even) { background: #f9f9f9; }
                    @media print { body { padding: 0; } }
                </style>
            </head>
            <body>
                <h1>⏱️ Timeline de Paradas</h1>
                <p class="subtitle">Data: ${data} | Turno: ${turnoLabel}</p>
                <div class="resumo">
                    <div class="resumo-item green">
                        <label>Tempo Produzindo</label>
                        <span>${tempoProd}</span>
                    </div>
                    <div class="resumo-item red">
                        <label>Tempo Parado</label>
                        <span>${tempoParado}</span>
                    </div>
                    <div class="resumo-item amber">
                        <label>Total Paradas</label>
                        <span>${totalParadas}</span>
                    </div>
                    <div class="resumo-item blue">
                        <label>Disponibilidade</label>
                        <span>${disponibilidade}</span>
                    </div>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Máquina</th>
                            <th>Qtd Paradas</th>
                            <th>Tempo Parado</th>
                            <th>Motivos</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${linhasHtml}
                    </tbody>
                </table>
                <p style="text-align: center; margin-top: 20px; color: #888; font-size: 11px;">
                    Impresso em: ${new Date().toLocaleString('pt-BR')} | Hokkaido MES
                </p>
            </body>
            </html>
        `);
        printWindow.document.close();
        printWindow.print();
    }

    function exportarTimelineParadas() {
        if (!acompanhamentoParadasDataAtual.maquinas) {
            showNotification('⚠️ Carregue os dados primeiro', 'warning');
            return;
        }

        let csv = 'Máquina;Qtd Paradas;Tempo Parado (h);Motivos\n';
        
        acompanhamentoParadasDataAtual.maquinas.forEach(maquina => {
            const paradas = acompanhamentoParadasDataAtual.paradas?.get(maquina) || [];
            const tempoParado = paradas.reduce((acc, p) => acc + (p.duracao || 0), 0);
            const motivos = paradas.map(p => p.motivo).join(' | ');
            
            csv += `${maquina};${paradas.length};${tempoParado.toFixed(2)};"${motivos}"\n`;
        });

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `timeline-paradas-${acompanhamentoParadasDataAtual.data}.csv`;
        link.click();

        showNotification('✅ Arquivo CSV exportado!', 'success');
    }
    // ==================== FIM ACOMPANHAMENTO DE PARADAS ====================

    // ==================== HISTÓRICO DO SISTEMA ====================
    
    // Função global para registrar ações no sistema
    window.logSystemAction = async function(tipo, descricao, detalhes = {}) {
        try {
            const usuario = window.authSystem?.getCurrentUser();
            const now = new Date();
            
            await db.collection('system_logs').add({
                tipo: tipo,
                descricao: descricao,
                maquina: detalhes.maquina || selectedMachineData?.machine || null,
                usuario: usuario?.name || 'Desconhecido',
                userId: usuario?.id || null,
                detalhes: detalhes,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                timestampLocal: now.toISOString(),
                data: now.toISOString().split('T')[0],
                hora: now.toTimeString().split(' ')[0]
            });
            
            console.log('[SYSTEM_LOG]', tipo, descricao);
        } catch (error) {
            console.error('[SYSTEM_LOG] Erro ao registrar ação:', error);
        }
    };
    
    // Função interna para registrar logs (usada em diversos pontos do sistema)
    async function registrarLogSistema(acao, tipo, detalhes = {}) {
        try {
            const usuario = window.authSystem?.getCurrentUser();
            const now = new Date();
            
            await db.collection('system_logs').add({
                acao: acao,
                tipo: tipo,
                descricao: acao,
                maquina: detalhes.machine || detalhes.maquina || selectedMachineData?.machine || null,
                usuario: usuario?.name || 'Desconhecido',
                userId: usuario?.id || null,
                detalhes: detalhes,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                timestampLocal: now.toISOString(),
                data: now.toISOString().split('T')[0],
                hora: now.toTimeString().split(' ')[0]
            });
            
            console.log('[SYSTEM_LOG]', acao, tipo, detalhes);
        } catch (error) {
            console.error('[SYSTEM_LOG] Erro ao registrar log:', error);
        }
    }

    // ==================== ADMINISTRAÇÃO DE DADOS ====================
    let adminDadosSetupDone = false;
    let adminCurrentOrderDoc = null;
    let adminCurrentProductionDoc = null;
    let adminCurrentPlanningDoc = null;
    
    function setupAdminDadosPage() {
        // Verificar permissão - apenas gestores e admins
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('acessar a administração de dados');
            navigateTo('lancamento');
            return;
        }
        
        if (adminDadosSetupDone) {
            if (typeof lucide !== 'undefined') lucide.createIcons();
            return;
        }
        adminDadosSetupDone = true;
        
        console.log('[ADMIN-DADOS] Inicializando página de administração...');
        
        // Setup das abas internas
        document.querySelectorAll('.admin-tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tab = e.currentTarget.dataset.adminTab;
                switchAdminTab(tab);
            });
        });
        
        // Aba Paradas - botões
        const btnAnalyze = document.getElementById('admin-btn-analyze');
        const btnFix = document.getElementById('admin-btn-fix');
        const btnClearLog = document.getElementById('admin-btn-clear-log');
        
        if (btnAnalyze) btnAnalyze.addEventListener('click', adminAnalyzeDowntimeProblems);
        if (btnFix) btnFix.addEventListener('click', adminFixDowntimeRecords);
        if (btnClearLog) btnClearLog.addEventListener('click', () => {
            const logContainer = document.getElementById('admin-log-container');
            if (logContainer) logContainer.innerHTML = '';
        });
        
        // Aba Ordens - nova estrutura simplificada
        const btnBuscarOP = document.getElementById('admin-btn-buscar-op');
        const btnSalvarOP = document.getElementById('admin-btn-salvar-op');
        const inputBuscaOP = document.getElementById('admin-ordem-busca');
        const inputNovaQtd = document.getElementById('admin-op-nova-qtd');
        
        if (btnBuscarOP) btnBuscarOP.addEventListener('click', adminBuscarOrdemSimplificado);
        if (btnSalvarOP) btnSalvarOP.addEventListener('click', adminSalvarOrdemSimplificado);
        
        // Busca ao pressionar Enter
        if (inputBuscaOP) {
            inputBuscaOP.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') adminBuscarOrdemSimplificado();
            });
        }
        
        // Preview ao digitar nova quantidade
        if (inputNovaQtd) {
            inputNovaQtd.addEventListener('input', adminPreviewAlteracao);
        }
        
        // Aba Produção - setup
        const dataProducao = document.getElementById('admin-producao-data');
        if (dataProducao) dataProducao.value = getProductionDateString();
        
        // Popular select de máquinas (Produção)
        const selectMaquina = document.getElementById('admin-producao-maquina');
        if (selectMaquina && window.databaseModule?.machineDatabase) {
            let options = '<option value="">Todas</option>';
            window.databaseModule.machineDatabase.forEach(m => {
                const id = normalizeMachineId(m.id);
                options += `<option value="${id}">${id}</option>`;
            });
            selectMaquina.innerHTML = options;
        }
        
        const btnBuscarProducao = document.getElementById('admin-btn-buscar-producao');
        if (btnBuscarProducao) btnBuscarProducao.addEventListener('click', adminBuscarProducao);

        // ===== Aba Perdas - setup =====
        const dataPerdas = document.getElementById('admin-perdas-data');
        if (dataPerdas) dataPerdas.value = getProductionDateString();
        
        // Popular select de máquinas (Perdas)
        const selectMaquinaPerdas = document.getElementById('admin-perdas-maquina');
        if (selectMaquinaPerdas && window.databaseModule?.machineDatabase) {
            let options = '<option value="">Todas</option>';
            window.databaseModule.machineDatabase.forEach(m => {
                const id = normalizeMachineId(m.id);
                options += `<option value="${id}">${id}</option>`;
            });
            selectMaquinaPerdas.innerHTML = options;
        }
        
        const btnBuscarPerdas = document.getElementById('admin-btn-buscar-perdas');
        if (btnBuscarPerdas) btnBuscarPerdas.addEventListener('click', adminBuscarPerdas);

        // Aba Planejamento - setup
        const dataPlanejamento = document.getElementById('admin-planejamento-data');
        if (dataPlanejamento) dataPlanejamento.value = getProductionDateString();
        
        // Popular select de máquinas (Planejamento)
        const selectMaquinaPlan = document.getElementById('admin-planejamento-maquina');
        if (selectMaquinaPlan && window.databaseModule?.machineDatabase) {
            let options = '<option value="">Todas</option>';
            window.databaseModule.machineDatabase.forEach(m => {
                const id = normalizeMachineId(m.id);
                options += `<option value="${id}">${id}</option>`;
            });
            selectMaquinaPlan.innerHTML = options;
        }
        
        const btnBuscarPlanejamento = document.getElementById('admin-btn-buscar-planejamento');
        if (btnBuscarPlanejamento) btnBuscarPlanejamento.addEventListener('click', adminBuscarPlanejamento);
        
        // ===== Aba Ajustes em Lote - setup =====
        const dataAjuste = document.getElementById('admin-ajuste-data');
        if (dataAjuste) dataAjuste.value = getProductionDateString();
        
        // Popular select de máquinas (Ajustes)
        const selectMaquinaAjuste = document.getElementById('admin-ajuste-maquina');
        if (selectMaquinaAjuste && window.databaseModule?.machineDatabase) {
            let options = '<option value="">Todas</option>';
            window.databaseModule.machineDatabase.forEach(m => {
                const id = normalizeMachineId(m.id);
                options += `<option value="${id}">${id}</option>`;
            });
            selectMaquinaAjuste.innerHTML = options;
        }
        
        const btnCarregarAjustes = document.getElementById('admin-btn-carregar-ajustes');
        if (btnCarregarAjustes) btnCarregarAjustes.addEventListener('click', adminCarregarAjustesLote);
        
        const btnSalvarAjustes = document.getElementById('admin-btn-salvar-ajustes');
        if (btnSalvarAjustes) btnSalvarAjustes.addEventListener('click', adminSalvarAjustesLote);
        
        const btnDescartarAjustes = document.getElementById('admin-btn-descartar-ajustes');
        if (btnDescartarAjustes) btnDescartarAjustes.addEventListener('click', adminDescartarAjustes);
        
        const btnSyncTotais = document.getElementById('admin-btn-sync-totais');
        if (btnSyncTotais) btnSyncTotais.addEventListener('click', adminSincronizarTotais);
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function switchAdminTab(tabName) {
        // Atualizar botões
        document.querySelectorAll('.admin-tab-btn').forEach(btn => {
            if (btn.dataset.adminTab === tabName) {
                btn.className = 'admin-tab-btn active px-4 py-2 text-sm font-semibold rounded-t-lg transition bg-blue-500 text-white whitespace-nowrap';
            } else {
                btn.className = 'admin-tab-btn px-4 py-2 text-sm font-semibold rounded-t-lg transition bg-gray-100 text-gray-600 hover:bg-gray-200 whitespace-nowrap';
            }
        });
        
        // Mostrar/ocultar conteúdo
        document.querySelectorAll('.admin-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        const activeContent = document.getElementById(`admin-tab-${tabName}`);
        if (activeContent) activeContent.classList.remove('hidden');
    }
    
    function adminLog(message, type = 'info') {
        const container = document.getElementById('admin-log-container');
        if (!container) return;
        
        const colors = {
            info: 'text-blue-400',
            warn: 'text-yellow-400',
            error: 'text-red-400',
            success: 'text-green-400'
        };
        
        const entry = document.createElement('div');
        entry.className = `${colors[type] || colors.info} py-0.5`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        container.appendChild(entry);
        container.scrollTop = container.scrollHeight;
    }
    
    async function adminAnalyzeDowntimeProblems() {
        adminLog('Iniciando análise de registros de paradas...', 'info');
        
        const stats = { total: 0, problems: 0, fixed: 0, deleted: 0 };
        
        try {
            const snapshot = await db.collection('downtime_entries').limit(1000).get();
            stats.total = snapshot.size;
            
            adminLog(`Total de registros: ${stats.total}`, 'info');
            
            let problemCount = 0;
            snapshot.forEach(doc => {
                const data = doc.data();
                const problems = [];
                
                // Verificar problemas comuns
                if (!data.end_timestamp && !data.endTimestamp && data.status !== 'active') {
                    problems.push('Sem timestamp de fim (não ativo)');
                }
                if (!data.start_timestamp && !data.startTimestamp && !data.originalStartTimestamp) {
                    problems.push('Sem timestamp de início');
                }
                if (!data.machine_id && !data.machine) {
                    problems.push('Sem ID de máquina');
                }
                if (data.duration_minutes > 1440) {
                    problems.push(`Duração muito alta: ${data.duration_minutes}min`);
                }
                
                if (problems.length > 0) {
                    problemCount++;
                    adminLog(`⚠️ ${doc.id}: ${problems.join(', ')}`, 'warn');
                }
            });
            
            stats.problems = problemCount;
            
            // Atualizar estatísticas na UI
            document.getElementById('admin-stat-total').textContent = stats.total;
            document.getElementById('admin-stat-problems').textContent = stats.problems;
            document.getElementById('admin-stat-fixed').textContent = stats.fixed;
            document.getElementById('admin-stat-deleted').textContent = stats.deleted;
            
            adminLog(`✅ Análise completa: ${stats.problems} registros com problemas de ${stats.total}`, 'success');
            
            // Habilitar botão de correção se houver problemas
            const btnFix = document.getElementById('admin-btn-fix');
            if (btnFix) btnFix.disabled = stats.problems === 0;
            
        } catch (error) {
            adminLog(`❌ Erro na análise: ${error.message}`, 'error');
        }
    }
    
    async function adminFixDowntimeRecords() {
        const isDryRun = document.getElementById('admin-chk-dry-run')?.checked ?? true;
        const deleteInvalid = document.getElementById('admin-chk-delete-invalid')?.checked ?? false;
        
        adminLog(`🔧 Iniciando correção (Simulação: ${isDryRun ? 'SIM' : 'NÃO'})...`, 'info');
        
        const stats = { fixed: 0, deleted: 0 };
        
        try {
            const snapshot = await db.collection('downtime_entries').limit(500).get();
            const batch = db.batch();
            let batchCount = 0;
            
            for (const doc of snapshot.docs) {
                const data = doc.data();
                const updates = {};
                let shouldDelete = false;
                
                // Tentar corrigir timestamp de início
                if (!data.start_timestamp && !data.startTimestamp) {
                    if (data.originalStartTimestamp) {
                        updates.start_timestamp = data.originalStartTimestamp;
                        adminLog(`Corrigindo início de ${doc.id} usando originalStartTimestamp`, 'info');
                    } else if (data.date && data.start_time) {
                        try {
                            const startDate = new Date(`${data.date}T${data.start_time}:00`);
                            if (!isNaN(startDate.getTime())) {
                                updates.start_timestamp = firebase.firestore.Timestamp.fromDate(startDate);
                                adminLog(`Corrigindo início de ${doc.id} usando date+start_time`, 'info');
                            }
                        } catch (e) {}
                    } else {
                        adminLog(`⚠️ ${doc.id}: Não foi possível recuperar timestamp de início`, 'warn');
                        if (deleteInvalid) shouldDelete = true;
                    }
                }
                
                // Tentar corrigir timestamp de fim
                if (!data.end_timestamp && !data.endTimestamp && data.status !== 'active') {
                    if (data.originalEndTimestamp) {
                        updates.end_timestamp = data.originalEndTimestamp;
                        adminLog(`Corrigindo fim de ${doc.id} usando originalEndTimestamp`, 'info');
                    } else if (data.date && data.end_time) {
                        try {
                            const endDate = new Date(`${data.date}T${data.end_time}:00`);
                            if (!isNaN(endDate.getTime())) {
                                updates.end_timestamp = firebase.firestore.Timestamp.fromDate(endDate);
                                adminLog(`Corrigindo fim de ${doc.id} usando date+end_time`, 'info');
                            }
                        } catch (e) {}
                    }
                }
                
                // Aplicar correções ou deletar
                if (!isDryRun) {
                    if (shouldDelete) {
                        batch.delete(doc.ref);
                        stats.deleted++;
                        batchCount++;
                    } else if (Object.keys(updates).length > 0) {
                        batch.update(doc.ref, updates);
                        stats.fixed++;
                        batchCount++;
                    }
                } else {
                    if (shouldDelete) {
                        adminLog(`[SIMULAÇÃO] Deletaria: ${doc.id}`, 'warn');
                        stats.deleted++;
                    } else if (Object.keys(updates).length > 0) {
                        adminLog(`[SIMULAÇÃO] Corrigiria: ${doc.id} - ${JSON.stringify(updates)}`, 'info');
                        stats.fixed++;
                    }
                }
                
                // Commit batch a cada 400 operações
                if (batchCount >= 400) {
                    if (!isDryRun) await batch.commit();
                    batchCount = 0;
                }
            }
            
            // Commit final
            if (!isDryRun && batchCount > 0) {
                await batch.commit();
            }
            
            // Atualizar UI
            document.getElementById('admin-stat-fixed').textContent = stats.fixed;
            document.getElementById('admin-stat-deleted').textContent = stats.deleted;
            
            adminLog(`✅ Correção ${isDryRun ? '(simulação)' : ''} completa: ${stats.fixed} corrigidos, ${stats.deleted} excluídos`, 'success');
            
        } catch (error) {
            adminLog(`❌ Erro na correção: ${error.message}`, 'error');
        }
    }
    
    // ===== Funções de Ajuste de Ordens - NOVA ESTRUTURA SIMPLIFICADA =====
    // Variável para armazenar a ordem atual sendo editada
    let adminOrdemAtual = null;
    
    function adminOrdemLog(message, type = 'info') {
        const logDiv = document.getElementById('admin-ordem-log');
        if (!logDiv) return;
        
        const colors = {
            info: 'text-blue-400',
            success: 'text-green-400',
            warn: 'text-yellow-400',
            error: 'text-red-400'
        };
        
        const entry = document.createElement('div');
        entry.className = `${colors[type] || colors.info} py-0.5`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    async function adminBuscarOrdemSimplificado() {
        const numeroOP = document.getElementById('admin-ordem-busca')?.value?.trim();
        const cardOrdem = document.getElementById('admin-ordem-card');
        const emptyState = document.getElementById('admin-ordem-empty');
        
        if (!numeroOP) {
            alert('Digite o número da OP para buscar');
            return;
        }
        
        try {
            adminOrdemAtual = null;
            
            // Buscar ordem - tentar vários formatos
            let foundDoc = null;
            
            // Busca exata string
            const snapshot1 = await db.collection('production_orders')
                .where('order_number', '==', numeroOP)
                .limit(1)
                .get();
            
            if (!snapshot1.empty) {
                foundDoc = snapshot1.docs[0];
            }
            
            // Tentar busca numérica
            if (!foundDoc) {
                const numerico = parseInt(numeroOP);
                if (!isNaN(numerico)) {
                    const snapshot2 = await db.collection('production_orders')
                        .where('order_number', '==', numerico)
                        .limit(1)
                        .get();
                    
                    if (!snapshot2.empty) {
                        foundDoc = snapshot2.docs[0];
                    }
                }
            }
            
            if (!foundDoc) {
                alert(`OP ${numeroOP} não encontrada`);
                adminOrdemLog(`❌ OP ${numeroOP} não encontrada`, 'error');
                return;
            }
            
            adminOrdemAtual = { id: foundDoc.id, ...foundDoc.data() };
            const data = adminOrdemAtual;
            
            // IMPORTANTE: Usar os MESMOS campos que os cards de máquina usam
            // Cards usam: order_lot_size || lot_size para planejado
            // Cards usam: total_produzido para executado
            const planejado = Number(data.order_lot_size ?? data.lot_size ?? data.planned_quantity) || 0;
            const executado = Number(data.total_produzido ?? data.totalProduced ?? data.total_produced) || 0;
            const faltante = Math.max(0, planejado - executado);
            const progresso = planejado > 0 ? (executado / planejado * 100) : 0;
            
            // Resolver nome do produto (igual ao card de máquina)
            let productName = data.product || data.product_name || data.part_code || data.product_code || 'Produto não definido';
            
            // Preencher card
            document.getElementById('admin-op-numero').textContent = data.order_number || '-';
            document.getElementById('admin-op-produto').textContent = productName;
            document.getElementById('admin-op-maquina').textContent = data.machine_id ? `Máquina: ${data.machine_id}` : '';
            document.getElementById('admin-op-status').textContent = (data.status || 'planejada').toUpperCase();
            
            // Indicadores (mesmos valores dos cards)
            document.getElementById('admin-op-planejado').textContent = planejado.toLocaleString('pt-BR');
            document.getElementById('admin-op-executado').textContent = executado.toLocaleString('pt-BR');
            document.getElementById('admin-op-faltante').textContent = faltante.toLocaleString('pt-BR');
            
            // Progresso
            document.getElementById('admin-op-progresso-pct').textContent = progresso.toFixed(1) + '%';
            document.getElementById('admin-op-progresso-bar').style.width = Math.min(progresso, 100) + '%';
            
            // Cor da barra de progresso
            const barEl = document.getElementById('admin-op-progresso-bar');
            if (progresso >= 100) {
                barEl.className = 'h-4 rounded-full bg-gradient-to-r from-green-500 to-emerald-500 transition-all duration-500';
            } else if (progresso >= 50) {
                barEl.className = 'h-4 rounded-full bg-gradient-to-r from-blue-500 to-indigo-500 transition-all duration-500';
            } else {
                barEl.className = 'h-4 rounded-full bg-gradient-to-r from-amber-500 to-orange-500 transition-all duration-500';
            }
            
            // Pré-preencher campo de edição
            document.getElementById('admin-op-nova-qtd').value = executado;
            document.getElementById('admin-op-preview').classList.add('hidden');
            
            // Mostrar card, esconder empty state
            if (cardOrdem) cardOrdem.classList.remove('hidden');
            if (emptyState) emptyState.classList.add('hidden');
            
            // Recriar ícones
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            adminOrdemLog(`✅ OP ${data.order_number} carregada - Exec: ${executado.toLocaleString('pt-BR')} / Plan: ${planejado.toLocaleString('pt-BR')}`, 'success');
            
        } catch (error) {
            console.error('[ADMIN] Erro ao buscar ordem:', error);
            alert('Erro ao buscar ordem: ' + error.message);
            adminOrdemLog(`❌ Erro: ${error.message}`, 'error');
        }
    }
    
    function adminPreviewAlteracao() {
        if (!adminOrdemAtual) return;
        
        const novaQtd = parseInt(document.getElementById('admin-op-nova-qtd')?.value) || 0;
        const executadoAtual = Number(adminOrdemAtual.total_produzido ?? adminOrdemAtual.totalProduced ?? adminOrdemAtual.total_produced) || 0;
        const previewDiv = document.getElementById('admin-op-preview');
        
        if (novaQtd !== executadoAtual) {
            previewDiv.classList.remove('hidden');
            document.getElementById('admin-op-preview-atual').textContent = executadoAtual.toLocaleString('pt-BR');
            document.getElementById('admin-op-preview-novo').textContent = novaQtd.toLocaleString('pt-BR');
            
            const diff = novaQtd - executadoAtual;
            const diffEl = document.getElementById('admin-op-preview-diff');
            diffEl.textContent = (diff > 0 ? '+' : '') + diff.toLocaleString('pt-BR');
            diffEl.className = diff > 0 ? 'text-lg font-bold text-green-600' : diff < 0 ? 'text-lg font-bold text-red-600' : 'text-lg font-bold text-gray-600';
        } else {
            previewDiv.classList.add('hidden');
        }
    }
    
    async function adminSalvarOrdemSimplificado() {
        if (!adminOrdemAtual) {
            alert('Nenhuma ordem selecionada. Busque uma OP primeiro.');
            return;
        }
        
        const novaQtd = parseInt(document.getElementById('admin-op-nova-qtd')?.value);
        
        if (isNaN(novaQtd) || novaQtd < 0) {
            alert('Digite uma quantidade válida');
            return;
        }
        
        const executadoAtual = Number(adminOrdemAtual.total_produzido ?? adminOrdemAtual.totalProduced ?? adminOrdemAtual.total_produced) || 0;
        const planejado = Number(adminOrdemAtual.order_lot_size ?? adminOrdemAtual.lot_size ?? adminOrdemAtual.planned_quantity) || 0;
        
        if (novaQtd === executadoAtual) {
            alert('A quantidade não foi alterada.');
            return;
        }
        
        const diff = novaQtd - executadoAtual;
        const diffTexto = diff > 0 ? `+${diff.toLocaleString('pt-BR')}` : diff.toLocaleString('pt-BR');
        
        if (!confirm(`Confirma alteração?\n\nOP: ${adminOrdemAtual.order_number}\n\nExecutado atual: ${executadoAtual.toLocaleString('pt-BR')}\nNovo valor: ${novaQtd.toLocaleString('pt-BR')}\nDiferença: ${diffTexto}`)) {
            return;
        }
        
        try {
            // Atualizar ordem - usando os MESMOS campos que o sistema usa
            await db.collection('production_orders').doc(adminOrdemAtual.id).update({
                total_produzido: novaQtd,
                totalProduced: novaQtd,
                last_manual_adjustment: firebase.firestore.FieldValue.serverTimestamp(),
                adjusted_by: getActiveUser()?.name || 'Admin'
            });
            
            // CORREÇÃO: Os cards de máquina usam a collection 'planning', não 'daily_planning'
            // Atualizar planejamentos na collection PLANNING (usada pelos cards de máquina)
            let planningsAtualizados = 0;
            try {
                // Buscar por order_id
                let planningDocs = await db.collection('planning')
                    .where('order_id', '==', adminOrdemAtual.id)
                    .get();
                
                // Se não encontrar, tentar por production_order_id
                if (planningDocs.empty) {
                    planningDocs = await db.collection('planning')
                        .where('production_order_id', '==', adminOrdemAtual.id)
                        .get();
                }
                
                // Se não encontrar, tentar pelo order_number
                if (planningDocs.empty && adminOrdemAtual.order_number) {
                    planningDocs = await db.collection('planning')
                        .where('order_number', '==', adminOrdemAtual.order_number)
                        .get();
                }
                
                if (!planningDocs.empty) {
                    const batch = db.batch();
                    planningDocs.forEach(doc => {
                        batch.update(doc.ref, {
                            total_produzido: novaQtd,
                            totalProduced: novaQtd,
                            lastSyncedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    });
                    await batch.commit();
                    planningsAtualizados = planningDocs.size;
                    adminOrdemLog(`📋 ${planningDocs.size} planning(s) atualizado(s)`, 'info');
                    
                    // Limpar cache dos cards
                    if (typeof machineCardProductionCache !== 'undefined' && machineCardProductionCache instanceof Map) {
                        planningDocs.forEach(doc => {
                            machineCardProductionCache.delete(doc.id);
                        });
                    }
                } else {
                    adminOrdemLog(`⚠️ Nenhum planning encontrado para a OP`, 'warn');
                }
            } catch (e) {
                console.warn('Erro ao sincronizar planning:', e);
                adminOrdemLog(`⚠️ Erro ao sincronizar planning: ${e.message}`, 'warn');
            }
            
            // Também atualizar daily_planning (para consistência)
            try {
                const dailyPlannings = await db.collection('daily_planning')
                    .where('order_id', '==', adminOrdemAtual.id)
                    .get();
                
                if (!dailyPlannings.empty) {
                    const batch = db.batch();
                    dailyPlannings.forEach(doc => {
                        batch.update(doc.ref, {
                            total_produzido: novaQtd,
                            lastSyncedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    });
                    await batch.commit();
                }
            } catch (e) {
                console.warn('Erro ao sincronizar daily_planning:', e);
            }
            
            // Registrar log
            if (typeof registrarLogSistema === 'function') {
                await registrarLogSistema(
                    `AJUSTE MANUAL: OP ${adminOrdemAtual.order_number} - ${executadoAtual} → ${novaQtd}`,
                    'admin_adjustment',
                    {
                        order_id: adminOrdemAtual.id,
                        order_number: adminOrdemAtual.order_number,
                        previous: executadoAtual,
                        new_value: novaQtd,
                        difference: diff
                    }
                );
            }
            
            // Atualizar UI
            adminOrdemAtual.total_produzido = novaQtd;
            adminOrdemAtual.totalProduced = novaQtd;
            
            const faltante = Math.max(0, planejado - novaQtd);
            const progresso = planejado > 0 ? (novaQtd / planejado * 100) : 0;
            
            document.getElementById('admin-op-executado').textContent = novaQtd.toLocaleString('pt-BR');
            document.getElementById('admin-op-faltante').textContent = faltante.toLocaleString('pt-BR');
            document.getElementById('admin-op-progresso-pct').textContent = progresso.toFixed(1) + '%';
            document.getElementById('admin-op-progresso-bar').style.width = Math.min(progresso, 100) + '%';
            document.getElementById('admin-op-preview').classList.add('hidden');
            
            adminOrdemLog(`✅ OP ${adminOrdemAtual.order_number} atualizada: ${executadoAtual.toLocaleString('pt-BR')} → ${novaQtd.toLocaleString('pt-BR')} (${diffTexto})`, 'success');
            
            showNotification('Quantidade atualizada com sucesso!', 'success');
            
            // Informar que os cards serão atualizados pelos listeners
            adminOrdemLog(`🔄 Cards de máquina serão atualizados automaticamente`, 'info');
            
        } catch (error) {
            console.error('[ADMIN] Erro ao salvar:', error);
            alert('Erro ao salvar: ' + error.message);
            adminOrdemLog(`❌ Erro: ${error.message}`, 'error');
        }
    }

    // ===== Funções de Produção (CORRIGIDAS E MELHORADAS) =====
    async function adminBuscarProducao() {
        const dataFiltro = document.getElementById('admin-producao-data')?.value;
        const maquina = document.getElementById('admin-producao-maquina')?.value;
        const turno = document.getElementById('admin-producao-turno')?.value;
        const listaDiv = document.getElementById('admin-producao-lista');
        
        if (!dataFiltro) {
            alert('Selecione uma data');
            return;
        }
        
        console.log('[ADMIN-PRODUCAO] Buscando registros:', { dataFiltro, maquina, turno });
        
        try {
            listaDiv.innerHTML = '<div class="text-center py-4 text-gray-500"><div class="animate-spin inline-block w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full mb-2"></div><p>Carregando registros...</p></div>';
            
            // CORREÇÃO: Os registros podem usar campo "date" OU "data" (português)
            // Fazer duas queries paralelas para cobrir ambos os casos
            const [snapshotDate, snapshotData] = await Promise.all([
                db.collection('production_entries').where('date', '==', dataFiltro).limit(500).get(),
                db.collection('production_entries').where('data', '==', dataFiltro).limit(500).get()
            ]);
            
            console.log('[ADMIN-PRODUCAO] Documentos com field "date":', snapshotDate.size);
            console.log('[ADMIN-PRODUCAO] Documentos com field "data":', snapshotData.size);
            
            // Combinar resultados e remover duplicatas
            const allDocs = new Map();
            
            snapshotDate.docs.forEach(doc => {
                allDocs.set(doc.id, { id: doc.id, ...doc.data() });
            });
            
            snapshotData.docs.forEach(doc => {
                if (!allDocs.has(doc.id)) {
                    allDocs.set(doc.id, { id: doc.id, ...doc.data() });
                }
            });
            
            console.log('[ADMIN-PRODUCAO] Total combinado (sem duplicatas):', allDocs.size);
            
            // ===== CORREÇÃO: Buscar dados de produto e OP das coleções vinculadas =====
            // Coletar todos os orderIds e planIds únicos
            const orderIds = new Set();
            const planIds = new Set();
            
            allDocs.forEach(d => {
                const orderId = d.orderId || d.order_id || d.production_order_id;
                const planId = d.planId || d.plan_id;
                if (orderId) orderIds.add(orderId);
                if (planId) planIds.add(planId);
            });
            
            console.log('[ADMIN-PRODUCAO] Order IDs únicos:', orderIds.size, 'Plan IDs únicos:', planIds.size);
            
            // Buscar dados das OPs em lote
            const ordersCache = new Map();
            if (orderIds.size > 0) {
                const orderIdsArray = Array.from(orderIds);
                // Firestore limita "in" a 10 itens, então dividir em chunks
                const chunks = [];
                for (let i = 0; i < orderIdsArray.length; i += 10) {
                    chunks.push(orderIdsArray.slice(i, i + 10));
                }
                
                for (const chunk of chunks) {
                    try {
                        const ordersSnap = await db.collection('production_orders').where(firebase.firestore.FieldPath.documentId(), 'in', chunk).get();
                        ordersSnap.docs.forEach(doc => {
                            ordersCache.set(doc.id, doc.data());
                        });
                    } catch (err) {
                        console.warn('[ADMIN-PRODUCAO] Erro ao buscar OPs:', err);
                    }
                }
            }
            console.log('[ADMIN-PRODUCAO] OPs carregadas no cache:', ordersCache.size);
            
            // Buscar dados dos planejamentos em lote
            const plansCache = new Map();
            if (planIds.size > 0) {
                const planIdsArray = Array.from(planIds);
                const chunks = [];
                for (let i = 0; i < planIdsArray.length; i += 10) {
                    chunks.push(planIdsArray.slice(i, i + 10));
                }
                
                for (const chunk of chunks) {
                    try {
                        const plansSnap = await db.collection('planning').where(firebase.firestore.FieldPath.documentId(), 'in', chunk).get();
                        plansSnap.docs.forEach(doc => {
                            plansCache.set(doc.id, doc.data());
                        });
                    } catch (err) {
                        console.warn('[ADMIN-PRODUCAO] Erro ao buscar planejamentos:', err);
                    }
                }
            }
            console.log('[ADMIN-PRODUCAO] Planejamentos carregados no cache:', plansCache.size);
            
            // Enriquecer os documentos com dados de produto e OP
            allDocs.forEach((d, docId) => {
                const orderId = d.orderId || d.order_id || d.production_order_id;
                const planId = d.planId || d.plan_id;
                
                // Tentar obter dados da OP
                if (orderId && ordersCache.has(orderId)) {
                    const orderData = ordersCache.get(orderId);
                    d._order_number = orderData.op || orderData.order_number || orderData.op_number || '';
                    d._product_name = orderData.product_name || orderData.productName || orderData.descricao || '';
                    d._product_code = orderData.product_code || orderData.productCode || orderData.codigo || orderData.part_code || '';
                }
                
                // Se não encontrou na OP, tentar no planejamento
                if (planId && plansCache.has(planId)) {
                    const planData = plansCache.get(planId);
                    if (!d._order_number) d._order_number = planData.op || planData.order_number || '';
                    if (!d._product_name) d._product_name = planData.product_name || planData.productName || planData.description || planData.descricao || '';
                    if (!d._product_code) d._product_code = planData.product_code || planData.productCode || planData.part_code || planData.codigo || '';
                }
                
                allDocs.set(docId, d);
            });
            
            if (allDocs.size === 0) {
                listaDiv.innerHTML = `
                    <div class="text-center py-8 text-gray-400">
                        <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                        <p class="font-semibold">Nenhum registro encontrado</p>
                        <p class="text-sm">Data: ${dataFiltro}</p>
                    </div>`;
                document.getElementById('admin-prod-total').textContent = '0';
                document.getElementById('admin-prod-pecas').textContent = '0';
                document.getElementById('admin-prod-peso').textContent = '0';
                document.getElementById('admin-prod-refugo').textContent = '0';
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Converter Map para array
            let docs = Array.from(allDocs.values());
            
            // Filtrar por máquina se especificado (normalizado)
            if (maquina) {
                const maquinaNorm = normalizeMachineId(maquina);
                docs = docs.filter(d => {
                    const docMachine = normalizeMachineId(d.machine_id || d.machine || '');
                    return docMachine === maquinaNorm;
                });
            }
            
            // Filtrar por turno se especificado (campo pode ser 'shift' ou 'turno')
            if (turno) {
                docs = docs.filter(d => {
                    const docTurno = String(d.shift || d.turno || '');
                    return docTurno === turno;
                });
            }
            
            // Ordenar por timestamp decrescente (mais recente primeiro)
            docs.sort((a, b) => {
                const tsA = a.timestamp?.toMillis ? a.timestamp.toMillis() : (a.timestamp?.seconds || 0) * 1000;
                const tsB = b.timestamp?.toMillis ? b.timestamp.toMillis() : (b.timestamp?.seconds || 0) * 1000;
                return tsB - tsA;
            });
            
            // Limitar a 100 registros
            docs = docs.slice(0, 100);
            
            console.log('[ADMIN-PRODUCAO] Registros após filtros:', docs.length);
            
            if (docs.length === 0) {
                listaDiv.innerHTML = `
                    <div class="text-center py-8 text-gray-400">
                        <i data-lucide="filter-x" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                        <p class="font-semibold">Nenhum registro para os filtros selecionados</p>
                        <p class="text-sm">Data: ${dataFiltro}${maquina ? `, Máquina: ${maquina}` : ''}${turno ? `, Turno: ${turno}` : ''}</p>
                    </div>`;
                document.getElementById('admin-prod-total').textContent = '0';
                document.getElementById('admin-prod-pecas').textContent = '0';
                document.getElementById('admin-prod-peso').textContent = '0';
                document.getElementById('admin-prod-refugo').textContent = '0';
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            let html = '';
            let totalPecas = 0;
            let totalPeso = 0;
            let totalRefugo = 0;
            
            // Usar o array docs já filtrado e ordenado
            docs.forEach(d => {
                const hora = d.timestamp?.toDate ? d.timestamp.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : (d.horaInformada || d.hora || '-');
                const qtd = d.quantity || d.produzido || 0;
                const peso = (d.peso_kg || d.peso_bruto || d.weight_kg || 0);
                const refugo = (d.refugo_kg || d.refugo || 0);
                const orderId = d.order_id || d.orderId || d.production_order_id || '';
                // CORREÇÃO: Usar campos enriquecidos do cache (_order_number, _product_name, _product_code)
                const orderNumber = d._order_number || d.order_number || d.op || '';
                const productName = d._product_name || d.product_name || d.product || '';
                const productCode = d._product_code || d.product_code || d.codigo || '';
                const turnoDoc = d.shift || d.turno || '-';
                const operador = d.operador || d.user_name || d.registradoPorNome || d.nomeUsuario || '-';
                const maquinaDoc = d.machine_id || d.machine || '-';
                
                totalPecas += Number(qtd) || 0;
                totalPeso += Number(peso) || 0;
                totalRefugo += Number(refugo) || 0;

                html += `
                    <div class="bg-white rounded-lg border border-gray-200 p-3 hover:shadow-md transition" data-doc-id="${d.id}">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-2 flex-wrap">
                                <span class="font-bold text-blue-600 bg-blue-50 px-2 py-1 rounded text-sm">${maquinaDoc}</span>
                                ${orderNumber ? `<span class="text-xs px-2 py-0.5 rounded bg-purple-100 text-purple-700 font-semibold">OP ${orderNumber}</span>` : ''}
                                <span class="text-xs px-2 py-0.5 rounded bg-gray-100 text-gray-600">T${turnoDoc}</span>
                                <span class="text-xs text-gray-400">${hora}</span>
                            </div>
                            <div class="flex items-center gap-1">
                                <button class="admin-btn-view-producao text-gray-500 hover:text-gray-700 p-1.5 rounded hover:bg-gray-100 transition" data-id="${d.id}" title="Ver detalhes">
                                    <i data-lucide="eye" class="w-4 h-4"></i>
                                </button>
                                <button class="admin-btn-edit-producao text-blue-500 hover:text-blue-700 p-1.5 rounded hover:bg-blue-50 transition" data-id="${d.id}" title="Editar">
                                    <i data-lucide="edit-2" class="w-4 h-4"></i>
                                </button>
                                <button class="admin-btn-delete-producao text-red-500 hover:text-red-700 p-1.5 rounded hover:bg-red-50 transition" 
                                    data-id="${d.id}" 
                                    data-machine="${maquinaDoc}" 
                                    data-qty="${qtd}"
                                    data-order-id="${orderId}"
                                    title="Excluir">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        <div class="text-sm text-gray-600 mb-2 truncate" title="${productName || productCode || '-'}">
                            <span class="font-medium">${productName || productCode || 'Produto não definido'}</span>
                            ${productCode && productName ? `<span class="text-xs text-gray-400 ml-1">(${productCode})</span>` : ''}
                        </div>
                        <div class="grid grid-cols-4 gap-2 text-xs">
                            <div class="bg-green-50 rounded p-2 text-center">
                                <div class="font-bold text-green-600">${Number(qtd).toLocaleString('pt-BR')}</div>
                                <div class="text-green-700">Peças</div>
                            </div>
                            <div class="bg-amber-50 rounded p-2 text-center">
                                <div class="font-bold text-amber-600">${Number(peso).toFixed(2)}</div>
                                <div class="text-amber-700">Peso (kg)</div>
                            </div>
                            <div class="bg-red-50 rounded p-2 text-center">
                                <div class="font-bold text-red-600">${Number(refugo).toFixed(2)}</div>
                                <div class="text-red-700">Refugo (kg)</div>
                            </div>
                            <div class="bg-gray-50 rounded p-2 text-center">
                                <div class="font-bold text-gray-600 truncate" title="${operador}">${operador}</div>
                                <div class="text-gray-500">Operador</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            listaDiv.innerHTML = html;
            
            // Atualizar estatísticas
            document.getElementById('admin-prod-total').textContent = docs.length;
            document.getElementById('admin-prod-pecas').textContent = totalPecas.toLocaleString('pt-BR');
            document.getElementById('admin-prod-peso').textContent = totalPeso.toFixed(2);
            document.getElementById('admin-prod-refugo').textContent = totalRefugo.toFixed(2);
            
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Attach handlers de visualização
            listaDiv.querySelectorAll('.admin-btn-view-producao').forEach(btn => {
                btn.addEventListener('click', () => adminVisualizarProducao(btn.dataset.id));
            });
            
            // Attach handlers de edição
            listaDiv.querySelectorAll('.admin-btn-edit-producao').forEach(btn => {
                btn.addEventListener('click', () => adminEditarProducao(btn.dataset.id));
            });
            
            // Attach handlers de exclusão
            listaDiv.querySelectorAll('.admin-btn-delete-producao').forEach(btn => {
                btn.addEventListener('click', () => adminExcluirProducao(btn));
            });
            
        } catch (error) {
            console.error('[ADMIN-PRODUCAO] Erro ao buscar:', error);
            listaDiv.innerHTML = `
                <div class="text-center py-8 text-red-500">
                    <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-2 opacity-70"></i>
                    <p class="font-semibold">Erro ao carregar registros</p>
                    <p class="text-sm">${error.message}</p>
                </div>`;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    // Função para visualizar detalhes completos de um registro
    async function adminVisualizarProducao(docId) {
        try {
            const docRef = db.collection('production_entries').doc(docId);
            const docSnap = await docRef.get();
            
            if (!docSnap.exists) {
                alert('Registro não encontrado');
                return;
            }
            
            const d = docSnap.data();
            
            // ===== CORREÇÃO: Buscar dados de produto e OP das coleções vinculadas =====
            const orderId = d.orderId || d.order_id || d.production_order_id;
            const planId = d.planId || d.plan_id;
            
            let orderNumber = d.order_number || d.op || '';
            let produtoDoc = d.product_name || d.product || '';
            let codigoDoc = d.product_code || d.codigo || '';
            
            // Buscar dados da OP se existe orderId
            if (orderId) {
                try {
                    const orderSnap = await db.collection('production_orders').doc(orderId).get();
                    if (orderSnap.exists) {
                        const orderData = orderSnap.data();
                        if (!orderNumber) orderNumber = orderData.op || orderData.order_number || orderData.op_number || '';
                        if (!produtoDoc || produtoDoc === '-') produtoDoc = orderData.product_name || orderData.productName || orderData.descricao || '';
                        if (!codigoDoc || codigoDoc === '-') codigoDoc = orderData.product_code || orderData.productCode || orderData.codigo || orderData.part_code || '';
                    }
                } catch (err) {
                    console.warn('[ADMIN-PRODUCAO] Erro ao buscar OP:', err);
                }
            }
            
            // Se ainda não encontrou, buscar do planejamento
            if (planId && (!produtoDoc || produtoDoc === '-')) {
                try {
                    const planSnap = await db.collection('planning').doc(planId).get();
                    if (planSnap.exists) {
                        const planData = planSnap.data();
                        if (!orderNumber) orderNumber = planData.op || planData.order_number || '';
                        if (!produtoDoc || produtoDoc === '-') produtoDoc = planData.product_name || planData.productName || planData.description || planData.descricao || '';
                        if (!codigoDoc || codigoDoc === '-') codigoDoc = planData.product_code || planData.productCode || planData.part_code || planData.codigo || '';
                    }
                } catch (err) {
                    console.warn('[ADMIN-PRODUCAO] Erro ao buscar planejamento:', err);
                }
            }
            
            // Extrair campos com fallbacks para português/inglês
            const maquinaDoc = d.machine_id || d.machine || '-';
            const dataDoc = d.date || d.data || '-';
            const turnoDoc = d.shift || d.turno || '-';
            const qtdDoc = Number(d.quantity || d.produzido || 0);
            const pesoDoc = Number(d.peso_kg || d.peso_bruto || d.weight_kg || 0);
            const refugoDoc = Number(d.refugo_kg || d.refugo || 0);
            const operadorDoc = d.operador || d.user_name || d.registradoPorNome || d.nomeUsuario || '-';
            produtoDoc = produtoDoc || '-';
            codigoDoc = codigoDoc || '-';
            const obsDoc = d.observations || d.observacoes || d.obs || '';
            
            // Criar modal de visualização
            const modal = document.createElement('div');
            modal.id = 'admin-view-producao-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
            
            // Formatar timestamp
            let timestampStr = '-';
            if (d.timestamp?.toDate) {
                timestampStr = d.timestamp.toDate().toLocaleString('pt-BR');
            } else if (d.createdAt?.toDate) {
                timestampStr = d.createdAt.toDate().toLocaleString('pt-BR');
            }
            
            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden max-h-[90vh] flex flex-col">
                    <div class="bg-gradient-to-r from-gray-700 to-gray-800 px-5 py-4 flex-shrink-0">
                        <h3 class="text-lg font-bold text-white flex items-center gap-2">
                            <i data-lucide="eye" class="w-5 h-5"></i>
                            Detalhes do Registro
                        </h3>
                        <p class="text-gray-300 text-sm">ID: ${docId.substring(0, 20)}...</p>
                    </div>
                    <div class="p-5 overflow-y-auto flex-1">
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Máquina</div>
                                <div class="font-bold text-gray-800">${maquinaDoc}</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Data</div>
                                <div class="font-bold text-gray-800">${dataDoc}</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Turno</div>
                                <div class="font-bold text-gray-800">${turnoDoc}º Turno</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Timestamp</div>
                                <div class="font-bold text-gray-800 text-xs">${timestampStr}</div>
                            </div>
                            <div class="bg-green-50 p-3 rounded-lg">
                                <div class="text-xs text-green-600 uppercase font-semibold">Quantidade</div>
                                <div class="font-bold text-green-700">${qtdDoc.toLocaleString('pt-BR')} pç</div>
                            </div>
                            <div class="bg-amber-50 p-3 rounded-lg">
                                <div class="text-xs text-amber-600 uppercase font-semibold">Peso</div>
                                <div class="font-bold text-amber-700">${pesoDoc.toFixed(2)} kg</div>
                            </div>
                            <div class="bg-red-50 p-3 rounded-lg">
                                <div class="text-xs text-red-600 uppercase font-semibold">Refugo</div>
                                <div class="font-bold text-red-700">${refugoDoc.toFixed(2)} kg</div>
                            </div>
                            <div class="bg-blue-50 p-3 rounded-lg">
                                <div class="text-xs text-blue-600 uppercase font-semibold">Operador</div>
                                <div class="font-bold text-blue-700">${operadorDoc}</div>
                            </div>
                            <div class="col-span-2 bg-purple-50 p-3 rounded-lg">
                                <div class="text-xs text-purple-600 uppercase font-semibold">Produto</div>
                                <div class="font-bold text-purple-700">${produtoDoc}</div>
                                <div class="text-xs text-purple-500">Código: ${codigoDoc}</div>
                            </div>
                            ${orderNumber || orderId ? `
                            <div class="col-span-2 bg-indigo-50 p-3 rounded-lg">
                                <div class="text-xs text-indigo-600 uppercase font-semibold">Ordem de Produção</div>
                                <div class="font-bold text-indigo-700">${orderNumber ? `OP ${orderNumber}` : 'N/A'}</div>
                                <div class="text-xs text-indigo-500">ID: ${orderId || '-'}</div>
                            </div>
                            ` : ''}
                            ${obsDoc ? `
                            <div class="col-span-2 bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Observações</div>
                                <div class="text-gray-700">${obsDoc}</div>
                            </div>
                            ` : ''}
                            ${d.last_edited_at ? `
                            <div class="col-span-2 bg-yellow-50 p-3 rounded-lg">
                                <div class="text-xs text-yellow-600 uppercase font-semibold">Última Edição</div>
                                <div class="text-yellow-700 text-sm">${d.last_edited_at?.toDate ? d.last_edited_at.toDate().toLocaleString('pt-BR') : '-'}</div>
                                <div class="text-xs text-yellow-600">Por: ${d.edited_by || '-'}</div>
                            </div>
                            ` : ''}
                            ${d.manual ? `
                            <div class="col-span-2 bg-cyan-50 p-3 rounded-lg">
                                <div class="text-xs text-cyan-600 uppercase font-semibold">Tipo de Lançamento</div>
                                <div class="font-bold text-cyan-700">Manual</div>
                                <div class="text-xs text-cyan-500">Registrado por: ${d.registradoPorNome || d.registradoPor || '-'}</div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    <div class="flex gap-3 p-4 border-t bg-gray-50 flex-shrink-0">
                        <button type="button" class="admin-view-close flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2.5 rounded-lg transition">
                            Fechar
                        </button>
                        <button type="button" class="admin-view-edit flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 rounded-lg transition">
                            <i data-lucide="edit-2" class="w-4 h-4 inline mr-1"></i>
                            Editar
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Fechar modal
            modal.querySelector('.admin-view-close').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            // Editar
            modal.querySelector('.admin-view-edit').addEventListener('click', () => {
                modal.remove();
                adminEditarProducao(docId);
            });
            
        } catch (error) {
            console.error('[ADMIN-PRODUCAO] Erro ao visualizar:', error);
            alert('Erro ao carregar detalhes: ' + error.message);
        }
    }

    // Função para excluir registro com atualização de OP
    async function adminExcluirProducao(btn) {
        const docId = btn.dataset.id;
        const machine = btn.dataset.machine;
        const qty = parseInt(btn.dataset.qty) || 0;
        const orderId = btn.dataset.orderId;
        
        // Buscar dados completos do registro antes de excluir
        let entryData = null;
        try {
            const docSnap = await db.collection('production_entries').doc(docId).get();
            if (docSnap.exists) {
                entryData = docSnap.data();
            }
        } catch (e) {
            console.warn('[ADMIN-PRODUCAO] Erro ao buscar dados para exclusão:', e);
        }
        
        const confirmMsg = `⚠️ EXCLUIR REGISTRO DE PRODUÇÃO?\n\nMáquina: ${machine}\nQuantidade: ${qty} peças\n${orderId ? `OP vinculada: ${entryData?.order_number || orderId}\n` : ''}\n⚠️ Esta ação não pode ser desfeita!`;
        
        if (!confirm(confirmMsg)) return;
        
        try {
            // Se houver OP vinculada, atualizar o total
            const linkedOrderId = entryData?.order_id || entryData?.orderId || orderId;
            if (linkedOrderId && qty > 0) {
                try {
                    // Decrementar total da OP
                    const orderRef = db.collection('production_orders').doc(linkedOrderId);
                    const orderSnap = await orderRef.get();
                    
                    if (orderSnap.exists) {
                        const orderData = orderSnap.data();
                        const currentTotal = Number(orderData.total_produzido || orderData.totalProduced || 0);
                        const newTotal = Math.max(0, currentTotal - qty);
                        
                        await orderRef.update({
                            total_produzido: newTotal,
                            totalProduced: newTotal,
                            last_adjustment: firebase.firestore.FieldValue.serverTimestamp(),
                            adjustment_reason: `Exclusão de registro de produção (${qty} peças) via Admin`
                        });
                        
                        console.log('[ADMIN-PRODUCAO] OP atualizada:', linkedOrderId, currentTotal, '→', newTotal);
                    }
                } catch (orderError) {
                    console.warn('[ADMIN-PRODUCAO] Erro ao atualizar OP:', orderError);
                    // Continua com a exclusão mesmo se falhar a atualização da OP
                }
            }
            
            // Excluir o registro
            await db.collection('production_entries').doc(docId).delete();
            
            // Registrar log
            if (typeof registrarLogSistema === 'function') {
                await registrarLogSistema(
                    `EXCLUSÃO ADMIN: Registro de produção excluído - Máquina: ${machine}, Qtd: ${qty}`,
                    'admin_delete',
                    {
                        doc_id: docId,
                        machine: machine,
                        quantity: qty,
                        order_id: linkedOrderId || null,
                        deleted_by: getActiveUser()?.name || 'Admin'
                    }
                );
            }
            
            // Remover card da lista
            const cardElement = btn.closest('[data-doc-id]');
            if (cardElement) {
                cardElement.style.transition = 'all 0.3s ease';
                cardElement.style.opacity = '0';
                cardElement.style.transform = 'translateX(-100%)';
                setTimeout(() => cardElement.remove(), 300);
            }
            
            showNotification('Registro excluído com sucesso', 'success');
            
            // Recarregar lista após um pequeno delay para atualizar estatísticas
            setTimeout(() => adminBuscarProducao(), 500);
            
        } catch (err) {
            console.error('[ADMIN-PRODUCAO] Erro ao excluir:', err);
            alert('Erro ao excluir: ' + err.message);
        }
    }

    async function adminEditarProducao(docId) {
        try {
            const docRef = db.collection('production_entries').doc(docId);
            const docSnap = await docRef.get();
            
            if (!docSnap.exists) {
                alert('Registro não encontrado');
                return;
            }
            
            const data = docSnap.data();
            const oldQty = Number(data.quantity || data.produzido || 0);
            
            // ===== CORREÇÃO: Buscar dados de produto e OP das coleções vinculadas =====
            const orderId = data.orderId || data.order_id || data.production_order_id || '';
            const planId = data.planId || data.plan_id || '';
            
            let orderNumber = data.order_number || data.op || '';
            let produtoEdit = data.product_name || data.product || '';
            let codigoEdit = data.product_code || data.codigo || '';
            
            // Buscar dados da OP se existe orderId
            if (orderId) {
                try {
                    const orderSnap = await db.collection('production_orders').doc(orderId).get();
                    if (orderSnap.exists) {
                        const orderData = orderSnap.data();
                        if (!orderNumber) orderNumber = orderData.op || orderData.order_number || orderData.op_number || '';
                        if (!produtoEdit) produtoEdit = orderData.product_name || orderData.productName || orderData.descricao || '';
                        if (!codigoEdit) codigoEdit = orderData.product_code || orderData.productCode || orderData.codigo || orderData.part_code || '';
                    }
                } catch (err) {
                    console.warn('[ADMIN-PRODUCAO] Erro ao buscar OP:', err);
                }
            }
            
            // Se ainda não encontrou, buscar do planejamento
            if (planId && !produtoEdit) {
                try {
                    const planSnap = await db.collection('planning').doc(planId).get();
                    if (planSnap.exists) {
                        const planData = planSnap.data();
                        if (!orderNumber) orderNumber = planData.op || planData.order_number || '';
                        if (!produtoEdit) produtoEdit = planData.product_name || planData.productName || planData.description || planData.descricao || '';
                        if (!codigoEdit) codigoEdit = planData.product_code || planData.productCode || planData.part_code || planData.codigo || '';
                    }
                } catch (err) {
                    console.warn('[ADMIN-PRODUCAO] Erro ao buscar planejamento:', err);
                }
            }
            
            // Gerar opções de máquinas
            let machineOptions = '';
            if (window.databaseModule?.machineDatabase) {
                window.databaseModule.machineDatabase.forEach(m => {
                    const id = normalizeMachineId(m.id);
                    const currentMachine = normalizeMachineId(data.machine_id || data.machine || '');
                    const selected = id === currentMachine ? 'selected' : '';
                    machineOptions += `<option value="${id}" ${selected}>${id}</option>`;
                });
            }
            
            // Criar modal de edição
            const modal = document.createElement('div');
            modal.id = 'admin-edit-producao-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
            
            // Extrair campos com fallbacks
            const maquinaEdit = data.machine_id || data.machine || '';
            const dataEdit = data.date || data.data || '';
            const turnoEdit = String(data.shift || data.turno || '1');
            const qtdEdit = data.quantity || data.produzido || 0;
            const pesoEdit = data.peso_kg || data.peso_bruto || data.weight_kg || 0;
            const refugoEdit = data.refugo_kg || data.refugo || 0;
            const obsEdit = data.observations || data.observacoes || data.obs || '';
            
            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden max-h-[90vh] flex flex-col">
                    <div class="bg-gradient-to-r from-blue-600 to-blue-700 px-5 py-4 flex-shrink-0">
                        <h3 class="text-lg font-bold text-white flex items-center gap-2">
                            <i data-lucide="edit-3" class="w-5 h-5"></i>
                            Editar Lançamento de Produção
                        </h3>
                        <p class="text-blue-200 text-sm">${maquinaEdit || '-'} - ${dataEdit || '-'} - T${turnoEdit}</p>
                    </div>
                    <form id="admin-edit-producao-form" class="p-5 space-y-4 overflow-y-auto flex-1">
                        <input type="hidden" id="admin-edit-prod-id" value="${docId}">
                        <input type="hidden" id="admin-edit-prod-old-qty" value="${oldQty}">
                        <input type="hidden" id="admin-edit-prod-order-id" value="${orderId}">
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Máquina</label>
                                <select id="admin-edit-prod-machine" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                                    ${machineOptions || `<option value="${maquinaEdit}">${maquinaEdit || '-'}</option>`}
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Turno</label>
                                <select id="admin-edit-prod-turno" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                                    <option value="1" ${turnoEdit === '1' ? 'selected' : ''}>1º Turno</option>
                                    <option value="2" ${turnoEdit === '2' ? 'selected' : ''}>2º Turno</option>
                                    <option value="3" ${turnoEdit === '3' ? 'selected' : ''}>3º Turno</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Quantidade (peças)</label>
                                <input type="number" id="admin-edit-prod-qty" value="${qtdEdit}" min="0"
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 text-lg font-semibold">
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Peso (kg)</label>
                                <input type="number" step="0.01" id="admin-edit-prod-peso" value="${pesoEdit}" min="0"
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Refugo (kg)</label>
                                <input type="number" step="0.01" id="admin-edit-prod-refugo" value="${refugoEdit}" min="0"
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Data</label>
                                <input type="date" id="admin-edit-prod-date" value="${dataEdit}"
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500">
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Produto</label>
                            <input type="text" id="admin-edit-prod-product" value="${produtoEdit}" 
                                class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="Nome do produto">
                            ${codigoEdit ? `<p class="text-xs text-gray-500 mt-1">Código: ${codigoEdit}</p>` : ''}
                        </div>
                        
                        <div>
                            <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Observações</label>
                            <textarea id="admin-edit-prod-obs" rows="2" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="Observações sobre a edição...">${obsEdit}</textarea>
                        </div>
                        
                        ${orderId || orderNumber ? `
                        <div class="bg-purple-50 border border-purple-200 rounded-lg p-3">
                            <div class="flex items-center gap-2 text-purple-700 text-sm">
                                <i data-lucide="link" class="w-4 h-4"></i>
                                <span class="font-semibold">OP Vinculada: ${orderNumber || orderId}</span>
                            </div>
                            <p class="text-xs text-purple-600 mt-1">O total da OP será ajustado automaticamente se a quantidade for alterada.</p>
                        </div>
                        ` : ''}
                    </form>
                    <div class="flex gap-3 p-4 border-t bg-gray-50 flex-shrink-0">
                        <button type="button" id="admin-edit-prod-cancel" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2.5 rounded-lg transition">
                            Cancelar
                        </button>
                        <button type="button" id="admin-edit-prod-save" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 rounded-lg transition flex items-center justify-center gap-2">
                            <i data-lucide="save" class="w-4 h-4"></i>
                            Salvar Alterações
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Fechar modal
            document.getElementById('admin-edit-prod-cancel').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            // Salvar alterações
            document.getElementById('admin-edit-prod-save').addEventListener('click', async () => {
                const novaQtd = parseInt(document.getElementById('admin-edit-prod-qty').value) || 0;
                const novoPeso = parseFloat(document.getElementById('admin-edit-prod-peso').value) || 0;
                const novoRefugo = parseFloat(document.getElementById('admin-edit-prod-refugo').value) || 0;
                const novoTurno = document.getElementById('admin-edit-prod-turno').value;
                const novaMaquina = document.getElementById('admin-edit-prod-machine').value;
                const novaData = document.getElementById('admin-edit-prod-date').value;
                const novoProduto = document.getElementById('admin-edit-prod-product').value.trim();
                const novaObs = document.getElementById('admin-edit-prod-obs').value.trim();
                const oldQtyValue = parseInt(document.getElementById('admin-edit-prod-old-qty').value) || 0;
                const orderIdSave = document.getElementById('admin-edit-prod-order-id').value;
                
                try {
                    // Preparar dados para atualização (mantendo tanto campos em inglês quanto português)
                    const updateData = {
                        // Campos em inglês
                        quantity: novaQtd,
                        peso_kg: novoPeso,
                        weight_kg: novoPeso,
                        refugo_kg: novoRefugo,
                        shift: parseInt(novoTurno),
                        machine_id: novaMaquina,
                        machine: novaMaquina,
                        observations: novaObs,
                        // Campos em português (mantidos para compatibilidade)
                        produzido: novaQtd,
                        turno: parseInt(novoTurno),
                        peso_bruto: novoPeso,
                        refugo: novoRefugo,
                        observacoes: novaObs,
                        // Metadados
                        last_edited_at: firebase.firestore.FieldValue.serverTimestamp(),
                        edited_by: getActiveUser()?.name || 'Admin'
                    };
                    
                    if (novaData) {
                        updateData.date = novaData;
                        updateData.data = novaData;  // Campo em português também
                    }
                    if (novoProduto) {
                        updateData.product_name = novoProduto;
                        updateData.product = novoProduto;
                    }
                    
                    await docRef.update(updateData);
                    
                    // Se a quantidade mudou e há OP vinculada, atualizar
                    if (orderIdSave && novaQtd !== oldQtyValue) {
                        try {
                            const diff = novaQtd - oldQtyValue;
                            const orderRef = db.collection('production_orders').doc(orderId);
                            const orderSnap = await orderRef.get();
                            
                            if (orderSnap.exists) {
                                const orderData = orderSnap.data();
                                const currentTotal = Number(orderData.total_produzido || orderData.totalProduced || 0);
                                const newTotal = Math.max(0, currentTotal + diff);
                                
                                await orderRef.update({
                                    total_produzido: newTotal,
                                    totalProduced: newTotal,
                                    last_adjustment: firebase.firestore.FieldValue.serverTimestamp()
                                });
                                
                                console.log('[ADMIN-PRODUCAO] OP atualizada após edição:', orderId, currentTotal, '→', newTotal);
                            }
                        } catch (orderError) {
                            console.warn('[ADMIN-PRODUCAO] Erro ao atualizar OP após edição:', orderError);
                        }
                    }
                    
                    modal.remove();
                    showNotification('Registro atualizado com sucesso!', 'success');
                    adminBuscarProducao();
                    
                } catch (err) {
                    console.error('[ADMIN-PRODUCAO] Erro ao atualizar:', err);
                    alert('Erro ao atualizar: ' + err.message);
                }
            });
            
        } catch (error) {
            console.error('[ADMIN-PRODUCAO] Erro ao carregar registro:', error);
            alert('Erro ao carregar registro: ' + error.message);
        }
    }

    // ===== Funções de Perdas (Lançamentos de usuários) =====
    async function adminBuscarPerdas() {
        const dataFiltro = document.getElementById('admin-perdas-data')?.value;
        const maquina = document.getElementById('admin-perdas-maquina')?.value;
        const turno = document.getElementById('admin-perdas-turno')?.value;
        const tipo = document.getElementById('admin-perdas-tipo')?.value;
        const listaDiv = document.getElementById('admin-perdas-lista');
        
        if (!dataFiltro) {
            alert('Selecione uma data');
            return;
        }
        
        console.log('[ADMIN-PERDAS] Buscando registros:', { dataFiltro, maquina, turno, tipo });
        
        try {
            listaDiv.innerHTML = '<div class="text-center py-4 text-gray-500"><div class="animate-spin inline-block w-6 h-6 border-2 border-red-500 border-t-transparent rounded-full mb-2"></div><p>Carregando perdas...</p></div>';
            
            // Buscar APENAS registros de produção com refugo/perdas (lançados via aba Lançamento)
            // Registros de perdas têm refugo_kg > 0 ou refugo_qty > 0
            const [snapshotDate, snapshotData] = await Promise.all([
                db.collection('production_entries').where('date', '==', dataFiltro).limit(500).get(),
                db.collection('production_entries').where('data', '==', dataFiltro).limit(500).get()
            ]);
            
            console.log('[ADMIN-PERDAS] Documentos com field "date":', snapshotDate.size);
            console.log('[ADMIN-PERDAS] Documentos com field "data":', snapshotData.size);
            
            // Combinar resultados e filtrar apenas os que têm perdas
            const allDocs = new Map();
            
            const addIfHasLosses = (doc) => {
                const d = doc.data();
                const refugoKg = Number(d.refugo_kg || 0);
                const refugoQty = Number(d.refugo_qty || 0);
                const motivoPerda = d.perdas || '';
                
                // Considerar como perda se tem refugo_kg > 0 OU refugo_qty > 0 E tem motivo
                if ((refugoKg > 0 || refugoQty > 0) && motivoPerda) {
                    allDocs.set(doc.id, { id: doc.id, ...d });
                }
            };
            
            snapshotDate.docs.forEach(addIfHasLosses);
            snapshotData.docs.forEach(doc => {
                if (!allDocs.has(doc.id)) {
                    addIfHasLosses(doc);
                }
            });
            
            console.log('[ADMIN-PERDAS] Total com perdas (sem duplicatas):', allDocs.size);
            
            if (allDocs.size === 0) {
                listaDiv.innerHTML = `
                    <div class="text-center py-8 text-gray-400">
                        <i data-lucide="trash-2" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                        <p class="font-semibold">Nenhuma perda encontrada</p>
                        <p class="text-sm">Data: ${dataFiltro}</p>
                    </div>`;
                adminAtualizarEstatisticasPerdas([]);
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            // Converter Map para array
            let docs = Array.from(allDocs.values());
            
            // Filtrar por máquina se especificado
            if (maquina) {
                const maquinaNorm = normalizeMachineId(maquina);
                docs = docs.filter(d => {
                    const docMachine = normalizeMachineId(d.machine_id || d.machine || '');
                    return docMachine === maquinaNorm;
                });
            }
            
            // Filtrar por turno se especificado
            if (turno) {
                docs = docs.filter(d => {
                    const docTurno = String(d.shift || d.turno || '');
                    return docTurno === turno;
                });
            }
            
            // Filtrar por tipo se especificado
            if (tipo) {
                docs = docs.filter(d => {
                    const motivo = (d.perdas || '').toLowerCase();
                    if (tipo === 'borra') return motivo.includes('borra');
                    if (tipo === 'refugo') return motivo.includes('refugo') || motivo.includes('setup') || motivo.includes('ajuste') || motivo.includes('qualidade');
                    if (tipo === 'sucata') return motivo.includes('sucata') || motivo.includes('descarte');
                    return true;
                });
            }
            
            // Ordenar por timestamp decrescente
            docs.sort((a, b) => {
                const tsA = a.timestamp?.toMillis ? a.timestamp.toMillis() : (a.timestamp?.seconds || 0) * 1000;
                const tsB = b.timestamp?.toMillis ? b.timestamp.toMillis() : (b.timestamp?.seconds || 0) * 1000;
                return tsB - tsA;
            });
            
            // Limitar a 100 registros
            docs = docs.slice(0, 100);
            
            console.log('[ADMIN-PERDAS] Registros após filtros:', docs.length);
            
            if (docs.length === 0) {
                listaDiv.innerHTML = `
                    <div class="text-center py-8 text-gray-400">
                        <i data-lucide="filter-x" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                        <p class="font-semibold">Nenhuma perda para os filtros selecionados</p>
                        <p class="text-sm">Data: ${dataFiltro}${maquina ? `, Máquina: ${maquina}` : ''}${turno ? `, Turno: ${turno}` : ''}${tipo ? `, Tipo: ${tipo}` : ''}</p>
                    </div>`;
                adminAtualizarEstatisticasPerdas([]);
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }
            
            let html = '';
            
            docs.forEach(d => {
                const hora = d.timestamp?.toDate ? d.timestamp.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : (d.horaInformada || d.hora || '-');
                const pesoKg = Number(d.refugo_kg || 0);
                const qtdPecas = Number(d.refugo_qty || 0);
                const motivo = d.perdas || 'Não informado';
                const turnoDoc = d.shift || d.turno || '-';
                const operador = d.nomeUsuario || d.operador || d.user_name || '-';
                const maquinaDoc = d.machine_id || d.machine || '-';
                const obs = d.observacoes || d.observations || '';
                const mp = d.mp || '';
                const tipoMP = d.tipoMateriaPrima || '';
                
                // Determinar cor do tipo de perda
                const motivoLower = motivo.toLowerCase();
                let tipoBadge = '';
                if (motivoLower.includes('borra')) {
                    tipoBadge = '<span class="text-xs px-2 py-0.5 rounded bg-amber-100 text-amber-700 font-semibold">Borra</span>';
                } else if (motivoLower.includes('sucata') || motivoLower.includes('descarte')) {
                    tipoBadge = '<span class="text-xs px-2 py-0.5 rounded bg-purple-100 text-purple-700 font-semibold">Sucata</span>';
                } else {
                    tipoBadge = '<span class="text-xs px-2 py-0.5 rounded bg-orange-100 text-orange-700 font-semibold">Refugo</span>';
                }

                html += `
                    <div class="bg-white rounded-lg border border-gray-200 p-3 hover:shadow-md transition" data-doc-id="${d.id}">
                        <div class="flex items-center justify-between mb-2">
                            <div class="flex items-center gap-2 flex-wrap">
                                <span class="font-bold text-red-600 bg-red-50 px-2 py-1 rounded text-sm">${maquinaDoc}</span>
                                ${tipoBadge}
                                <span class="text-xs px-2 py-0.5 rounded bg-gray-100 text-gray-600">T${turnoDoc}</span>
                                <span class="text-xs text-gray-400">${hora}</span>
                            </div>
                            <div class="flex items-center gap-1">
                                <button class="admin-btn-view-perda text-gray-500 hover:text-gray-700 p-1.5 rounded hover:bg-gray-100 transition" data-id="${d.id}" title="Ver detalhes">
                                    <i data-lucide="eye" class="w-4 h-4"></i>
                                </button>
                                <button class="admin-btn-edit-perda text-blue-500 hover:text-blue-700 p-1.5 rounded hover:bg-blue-50 transition" data-id="${d.id}" title="Editar">
                                    <i data-lucide="edit-2" class="w-4 h-4"></i>
                                </button>
                                <button class="admin-btn-delete-perda text-red-500 hover:text-red-700 p-1.5 rounded hover:bg-red-50 transition" 
                                    data-id="${d.id}" 
                                    data-machine="${maquinaDoc}" 
                                    data-peso="${pesoKg}"
                                    data-motivo="${motivo}"
                                    title="Excluir">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                        <div class="text-sm text-gray-700 mb-2">
                            <span class="font-medium">Motivo: ${motivo}</span>
                        </div>
                        ${obs ? `<div class="text-xs text-gray-500 mb-2 truncate" title="${obs}">📝 ${obs}</div>` : ''}
                        <div class="grid grid-cols-4 gap-2 text-xs">
                            <div class="bg-red-50 rounded p-2 text-center">
                                <div class="font-bold text-red-600">${pesoKg.toFixed(3)}</div>
                                <div class="text-red-700">Peso (kg)</div>
                            </div>
                            <div class="bg-orange-50 rounded p-2 text-center">
                                <div class="font-bold text-orange-600">${qtdPecas.toLocaleString('pt-BR')}</div>
                                <div class="text-orange-700">Qtd (pç)</div>
                            </div>
                            <div class="bg-amber-50 rounded p-2 text-center">
                                <div class="font-bold text-amber-600 truncate" title="${tipoMP || mp || '-'}">${tipoMP || mp || '-'}</div>
                                <div class="text-amber-700">MP</div>
                            </div>
                            <div class="bg-gray-50 rounded p-2 text-center">
                                <div class="font-bold text-gray-600 truncate" title="${operador}">${operador}</div>
                                <div class="text-gray-500">Operador</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            listaDiv.innerHTML = html;
            
            // Atualizar estatísticas
            adminAtualizarEstatisticasPerdas(docs);
            
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Attach handlers
            listaDiv.querySelectorAll('.admin-btn-view-perda').forEach(btn => {
                btn.addEventListener('click', () => adminVisualizarPerda(btn.dataset.id));
            });
            
            listaDiv.querySelectorAll('.admin-btn-edit-perda').forEach(btn => {
                btn.addEventListener('click', () => adminEditarPerda(btn.dataset.id));
            });
            
            listaDiv.querySelectorAll('.admin-btn-delete-perda').forEach(btn => {
                btn.addEventListener('click', () => adminExcluirPerda(btn));
            });
            
        } catch (error) {
            console.error('[ADMIN-PERDAS] Erro ao buscar:', error);
            listaDiv.innerHTML = `
                <div class="text-center py-8 text-red-500">
                    <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-2 opacity-70"></i>
                    <p class="font-semibold">Erro ao carregar perdas</p>
                    <p class="text-sm">${error.message}</p>
                </div>`;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }
    
    function adminAtualizarEstatisticasPerdas(docs) {
        let totalPeso = 0;
        let pesoBorra = 0;
        let pesoRefugo = 0;
        let pesoSucata = 0;
        
        docs.forEach(d => {
            const peso = Number(d.refugo_kg || 0);
            const motivo = (d.perdas || '').toLowerCase();
            
            totalPeso += peso;
            
            if (motivo.includes('borra')) {
                pesoBorra += peso;
            } else if (motivo.includes('sucata') || motivo.includes('descarte')) {
                pesoSucata += peso;
            } else {
                pesoRefugo += peso;
            }
        });
        
        document.getElementById('admin-perdas-total').textContent = docs.length;
        document.getElementById('admin-perdas-peso').textContent = totalPeso.toFixed(2);
        document.getElementById('admin-perdas-borra').textContent = pesoBorra.toFixed(2);
        document.getElementById('admin-perdas-refugo').textContent = pesoRefugo.toFixed(2);
        document.getElementById('admin-perdas-sucata').textContent = pesoSucata.toFixed(2);
    }
    
    async function adminVisualizarPerda(docId) {
        try {
            const docRef = db.collection('production_entries').doc(docId);
            const docSnap = await docRef.get();
            
            if (!docSnap.exists) {
                alert('Registro não encontrado');
                return;
            }
            
            const d = docSnap.data();
            
            // Extrair campos
            const maquinaDoc = d.machine_id || d.machine || '-';
            const dataDoc = d.date || d.data || '-';
            const turnoDoc = d.shift || d.turno || '-';
            const pesoKg = Number(d.refugo_kg || 0);
            const qtdPecas = Number(d.refugo_qty || 0);
            const motivo = d.perdas || 'Não informado';
            const operadorDoc = d.nomeUsuario || d.operador || d.user_name || '-';
            const obsDoc = d.observacoes || d.observations || '';
            const mpDoc = d.mp || '-';
            const tipoMPDoc = d.tipoMateriaPrima || '-';
            const orderNumber = d.orderNumber || d.order_number || '';
            
            // Formatar timestamp
            let timestampStr = '-';
            if (d.timestamp?.toDate) {
                timestampStr = d.timestamp.toDate().toLocaleString('pt-BR');
            } else if (d.createdAt?.toDate) {
                timestampStr = d.createdAt.toDate().toLocaleString('pt-BR');
            }
            
            // Criar modal de visualização
            const modal = document.createElement('div');
            modal.id = 'admin-view-perda-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
            
            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden max-h-[90vh] flex flex-col">
                    <div class="bg-gradient-to-r from-red-600 to-red-700 px-5 py-4 flex-shrink-0">
                        <h3 class="text-lg font-bold text-white flex items-center gap-2">
                            <i data-lucide="eye" class="w-5 h-5"></i>
                            Detalhes da Perda
                        </h3>
                        <p class="text-red-200 text-sm">ID: ${docId.substring(0, 20)}...</p>
                    </div>
                    <div class="p-5 overflow-y-auto flex-1">
                        <div class="grid grid-cols-2 gap-4 text-sm">
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Máquina</div>
                                <div class="font-bold text-gray-800">${maquinaDoc}</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Data</div>
                                <div class="font-bold text-gray-800">${dataDoc}</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Turno</div>
                                <div class="font-bold text-gray-800">${turnoDoc}º Turno</div>
                            </div>
                            <div class="bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Timestamp</div>
                                <div class="font-bold text-gray-800 text-xs">${timestampStr}</div>
                            </div>
                            <div class="col-span-2 bg-red-50 p-3 rounded-lg">
                                <div class="text-xs text-red-600 uppercase font-semibold">Motivo da Perda</div>
                                <div class="font-bold text-red-700">${motivo}</div>
                            </div>
                            <div class="bg-red-50 p-3 rounded-lg">
                                <div class="text-xs text-red-600 uppercase font-semibold">Peso</div>
                                <div class="font-bold text-red-700">${pesoKg.toFixed(3)} kg</div>
                            </div>
                            <div class="bg-orange-50 p-3 rounded-lg">
                                <div class="text-xs text-orange-600 uppercase font-semibold">Quantidade</div>
                                <div class="font-bold text-orange-700">${qtdPecas.toLocaleString('pt-BR')} pç</div>
                            </div>
                            <div class="bg-amber-50 p-3 rounded-lg">
                                <div class="text-xs text-amber-600 uppercase font-semibold">Cód. MP</div>
                                <div class="font-bold text-amber-700">${mpDoc}</div>
                            </div>
                            <div class="bg-amber-50 p-3 rounded-lg">
                                <div class="text-xs text-amber-600 uppercase font-semibold">Tipo MP</div>
                                <div class="font-bold text-amber-700">${tipoMPDoc}</div>
                            </div>
                            <div class="col-span-2 bg-blue-50 p-3 rounded-lg">
                                <div class="text-xs text-blue-600 uppercase font-semibold">Operador</div>
                                <div class="font-bold text-blue-700">${operadorDoc}</div>
                            </div>
                            ${orderNumber ? `
                            <div class="col-span-2 bg-purple-50 p-3 rounded-lg">
                                <div class="text-xs text-purple-600 uppercase font-semibold">Ordem de Produção</div>
                                <div class="font-bold text-purple-700">OP ${orderNumber}</div>
                            </div>
                            ` : ''}
                            ${obsDoc ? `
                            <div class="col-span-2 bg-gray-50 p-3 rounded-lg">
                                <div class="text-xs text-gray-500 uppercase font-semibold">Observações</div>
                                <div class="text-gray-700">${obsDoc}</div>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                    <div class="flex gap-3 p-4 border-t bg-gray-50 flex-shrink-0">
                        <button type="button" class="admin-view-close flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2.5 rounded-lg transition">
                            Fechar
                        </button>
                        <button type="button" class="admin-view-edit flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2.5 rounded-lg transition">
                            <i data-lucide="edit-2" class="w-4 h-4 inline mr-1"></i>
                            Editar
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Fechar modal
            modal.querySelector('.admin-view-close').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            // Editar
            modal.querySelector('.admin-view-edit').addEventListener('click', () => {
                modal.remove();
                adminEditarPerda(docId);
            });
            
        } catch (error) {
            console.error('[ADMIN-PERDAS] Erro ao visualizar:', error);
            alert('Erro ao carregar detalhes: ' + error.message);
        }
    }
    
    async function adminEditarPerda(docId) {
        try {
            const docRef = db.collection('production_entries').doc(docId);
            const docSnap = await docRef.get();
            
            if (!docSnap.exists) {
                alert('Registro não encontrado');
                return;
            }
            
            const data = docSnap.data();
            
            // Gerar opções de máquinas
            let machineOptions = '';
            if (window.databaseModule?.machineDatabase) {
                window.databaseModule.machineDatabase.forEach(m => {
                    const id = normalizeMachineId(m.id);
                    const currentMachine = normalizeMachineId(data.machine_id || data.machine || '');
                    const selected = id === currentMachine ? 'selected' : '';
                    machineOptions += `<option value="${id}" ${selected}>${id}</option>`;
                });
            }
            
            // Extrair campos
            const maquinaEdit = data.machine_id || data.machine || '';
            const dataEdit = data.date || data.data || '';
            const turnoEdit = String(data.shift || data.turno || '1');
            const pesoKgEdit = data.refugo_kg || 0;
            const qtdEdit = data.refugo_qty || 0;
            const motivoEdit = data.perdas || '';
            const obsEdit = data.observacoes || data.observations || '';
            
            // Lista de motivos comuns
            const motivosComuns = [
                'Borra',
                'Setup',
                'Ajuste de Processo',
                'Qualidade/Visual',
                'Dimensional',
                'Contaminação',
                'Sucata',
                'Descarte',
                'Manutenção',
                'Outros'
            ];
            
            let motivoOptions = '';
            motivosComuns.forEach(m => {
                const selected = motivoEdit.toLowerCase().includes(m.toLowerCase()) ? 'selected' : '';
                motivoOptions += `<option value="${m}" ${selected}>${m}</option>`;
            });
            if (!motivosComuns.some(m => motivoEdit.toLowerCase().includes(m.toLowerCase()))) {
                motivoOptions += `<option value="${motivoEdit}" selected>${motivoEdit}</option>`;
            }
            
            // Criar modal de edição
            const modal = document.createElement('div');
            modal.id = 'admin-edit-perda-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
            
            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-lg overflow-hidden max-h-[90vh] flex flex-col">
                    <div class="bg-gradient-to-r from-red-600 to-red-700 px-5 py-4 flex-shrink-0">
                        <h3 class="text-lg font-bold text-white flex items-center gap-2">
                            <i data-lucide="edit-3" class="w-5 h-5"></i>
                            Editar Lançamento de Perda
                        </h3>
                        <p class="text-red-200 text-sm">${maquinaEdit || '-'} - ${dataEdit || '-'} - T${turnoEdit}</p>
                    </div>
                    <form id="admin-edit-perda-form" class="p-5 space-y-4 overflow-y-auto flex-1">
                        <input type="hidden" id="admin-edit-perda-id" value="${docId}">
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Máquina</label>
                                <select id="admin-edit-perda-machine" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500">
                                    ${machineOptions || `<option value="${maquinaEdit}">${maquinaEdit || '-'}</option>`}
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Turno</label>
                                <select id="admin-edit-perda-turno" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500">
                                    <option value="1" ${turnoEdit === '1' ? 'selected' : ''}>1º Turno</option>
                                    <option value="2" ${turnoEdit === '2' ? 'selected' : ''}>2º Turno</option>
                                    <option value="3" ${turnoEdit === '3' ? 'selected' : ''}>3º Turno</option>
                                </select>
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Motivo da Perda</label>
                            <select id="admin-edit-perda-motivo" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500">
                                ${motivoOptions}
                            </select>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Peso (kg)</label>
                                <input type="number" step="0.001" id="admin-edit-perda-peso" value="${pesoKgEdit}" min="0"
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500 text-lg font-semibold">
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Quantidade (peças)</label>
                                <input type="number" id="admin-edit-perda-qty" value="${qtdEdit}" min="0"
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500">
                            </div>
                        </div>
                        
                        <div>
                            <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Data</label>
                            <input type="date" id="admin-edit-perda-date" value="${dataEdit}"
                                class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500">
                        </div>
                        
                        <div>
                            <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Observações</label>
                            <textarea id="admin-edit-perda-obs" rows="2" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-red-500" placeholder="Observações sobre a edição...">${obsEdit}</textarea>
                        </div>
                    </form>
                    <div class="flex gap-3 p-4 border-t bg-gray-50 flex-shrink-0">
                        <button type="button" id="admin-edit-perda-cancel" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold py-2.5 rounded-lg transition">
                            Cancelar
                        </button>
                        <button type="button" id="admin-edit-perda-save" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-semibold py-2.5 rounded-lg transition flex items-center justify-center gap-2">
                            <i data-lucide="save" class="w-4 h-4"></i>
                            Salvar Alterações
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Fechar modal
            document.getElementById('admin-edit-perda-cancel').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            // Salvar alterações
            document.getElementById('admin-edit-perda-save').addEventListener('click', async () => {
                const novoPeso = parseFloat(document.getElementById('admin-edit-perda-peso').value) || 0;
                const novaQtd = parseInt(document.getElementById('admin-edit-perda-qty').value) || 0;
                const novoTurno = document.getElementById('admin-edit-perda-turno').value;
                const novaMaquina = document.getElementById('admin-edit-perda-machine').value;
                const novaData = document.getElementById('admin-edit-perda-date').value;
                const novoMotivo = document.getElementById('admin-edit-perda-motivo').value;
                const novaObs = document.getElementById('admin-edit-perda-obs').value.trim();
                
                if (novoPeso <= 0 && novaQtd <= 0) {
                    alert('Informe peso ou quantidade da perda');
                    return;
                }
                
                if (!novoMotivo) {
                    alert('Selecione o motivo da perda');
                    return;
                }
                
                try {
                    const updateData = {
                        refugo_kg: novoPeso,
                        refugo_qty: novaQtd,
                        perdas: novoMotivo,
                        shift: parseInt(novoTurno),
                        turno: parseInt(novoTurno),
                        machine_id: novaMaquina,
                        machine: novaMaquina,
                        observations: novaObs,
                        observacoes: novaObs,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        edited_by: getActiveUser()?.name || 'Admin'
                    };
                    
                    if (novaData) {
                        updateData.date = novaData;
                        updateData.data = novaData;
                    }
                    
                    await docRef.update(updateData);
                    
                    modal.remove();
                    showNotification('Perda atualizada com sucesso!', 'success');
                    adminBuscarPerdas();
                    
                    // Registrar log
                    if (typeof registrarLogSistema === 'function') {
                        await registrarLogSistema(
                            `EDIÇÃO ADMIN: Perda editada - Máquina: ${novaMaquina}, Motivo: ${novoMotivo}`,
                            'admin_edit',
                            { doc_id: docId, machine: novaMaquina, motivo: novoMotivo, peso: novoPeso }
                        );
                    }
                    
                } catch (err) {
                    console.error('[ADMIN-PERDAS] Erro ao atualizar:', err);
                    alert('Erro ao atualizar: ' + err.message);
                }
            });
            
        } catch (error) {
            console.error('[ADMIN-PERDAS] Erro ao carregar registro:', error);
            alert('Erro ao carregar registro: ' + error.message);
        }
    }
    
    async function adminExcluirPerda(btn) {
        const docId = btn.dataset.id;
        const machine = btn.dataset.machine;
        const peso = btn.dataset.peso;
        const motivo = btn.dataset.motivo;
        
        const confirmMsg = `⚠️ EXCLUIR REGISTRO DE PERDA?\n\nMáquina: ${machine}\nPeso: ${peso} kg\nMotivo: ${motivo}\n\n⚠️ Esta ação não pode ser desfeita!`;
        
        if (!confirm(confirmMsg)) return;
        
        try {
            await db.collection('production_entries').doc(docId).delete();
            
            // Registrar log
            if (typeof registrarLogSistema === 'function') {
                await registrarLogSistema(
                    `EXCLUSÃO ADMIN: Perda excluída - Máquina: ${machine}, Peso: ${peso}kg, Motivo: ${motivo}`,
                    'admin_delete',
                    { doc_id: docId, machine, peso, motivo, deleted_by: getActiveUser()?.name || 'Admin' }
                );
            }
            
            // Remover card da lista
            const cardElement = btn.closest('[data-doc-id]');
            if (cardElement) {
                cardElement.style.transition = 'all 0.3s ease';
                cardElement.style.opacity = '0';
                cardElement.style.transform = 'translateX(-100%)';
                setTimeout(() => cardElement.remove(), 300);
            }
            
            showNotification('Perda excluída com sucesso', 'success');
            
            // Recarregar lista após um pequeno delay para atualizar estatísticas
            setTimeout(() => adminBuscarPerdas(), 500);
            
        } catch (err) {
            console.error('[ADMIN-PERDAS] Erro ao excluir:', err);
            alert('Erro ao excluir: ' + err.message);
        }
    }

    // ===== Funções de Planejamento (NOVAS) =====
    async function adminBuscarPlanejamento() {
        const data = document.getElementById('admin-planejamento-data')?.value;
        const maquina = document.getElementById('admin-planejamento-maquina')?.value;
        const listaDiv = document.getElementById('admin-planejamento-lista');
        
        if (!data) {
            alert('Selecione uma data');
            return;
        }
        
        try {
            listaDiv.innerHTML = '<div class="text-center py-4 text-gray-500"><i class="animate-spin">⏳</i> Carregando...</div>';
            
            let query = db.collection('planning').where('date', '==', data);
            if (maquina) {
                query = query.where('machine', '==', maquina);
            }
            
            const snapshot = await query.get();
            
            if (snapshot.empty) {
                listaDiv.innerHTML = '<div class="text-center py-8 text-gray-400">Nenhum planejamento encontrado para esta data.</div>';
                return;
            }
            
            let html = '';
            
            snapshot.forEach(doc => {
                const d = doc.data();
                const cicloT1 = d.real_cycle_t1 || '-';
                const cavT1 = d.active_cavities_t1 || '-';
                const cicloT2 = d.real_cycle_t2 || '-';
                const cavT2 = d.active_cavities_t2 || '-';
                const cicloT3 = d.real_cycle_t3 || '-';
                const cavT3 = d.active_cavities_t3 || '-';

                html += `
                    <div class="bg-white rounded-xl border border-gray-200 p-4 hover:shadow-md transition">
                        <div class="flex items-center justify-between mb-3">
                            <div class="flex items-center gap-3">
                                <span class="font-bold text-emerald-600 bg-emerald-50 px-3 py-1.5 rounded-lg text-lg">${d.machine || '-'}</span>
                                <div>
                                    <p class="font-semibold text-gray-800">${d.product || d.product_name || '-'}</p>
                                    <p class="text-xs text-gray-500">MP: ${d.mp || '-'} | Código: ${d.product_cod || '-'}</p>
                                </div>
                            </div>
                            <button class="admin-btn-edit-planejamento bg-emerald-500 hover:bg-emerald-600 text-white px-4 py-2 rounded-lg font-semibold transition flex items-center gap-2" data-id="${doc.id}">
                                <i data-lucide="edit-2" class="w-4 h-4"></i>
                                Editar
                            </button>
                        </div>
                        
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-3 mb-3">
                            <div class="bg-blue-50 rounded-lg p-2 text-center">
                                <div class="font-bold text-blue-600">${d.planned_quantity || d.daily_target || 0}</div>
                                <div class="text-xs text-blue-700">Meta Planejada</div>
                            </div>
                            <div class="bg-gray-50 rounded-lg p-2 text-center">
                                <div class="font-bold text-gray-600">${d.budgeted_cycle || '-'}</div>
                                <div class="text-xs text-gray-500">Ciclo Orçado</div>
                            </div>
                            <div class="bg-gray-50 rounded-lg p-2 text-center">
                                <div class="font-bold text-gray-600">${d.mold_cavities || '-'}</div>
                                <div class="text-xs text-gray-500">Cavidades Molde</div>
                            </div>
                            <div class="bg-gray-50 rounded-lg p-2 text-center">
                                <div class="font-bold text-gray-600">${d.piece_weight || '-'}</div>
                                <div class="text-xs text-gray-500">Peso Peça (g)</div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-3 gap-2 text-center text-xs">
                            <div class="bg-blue-50 rounded-lg p-2 border border-blue-100">
                                <div class="font-semibold text-blue-800">1º Turno</div>
                                <div class="text-blue-600">Ciclo: <strong>${cicloT1}</strong> | Cav: <strong>${cavT1}</strong></div>
                            </div>
                            <div class="bg-amber-50 rounded-lg p-2 border border-amber-100">
                                <div class="font-semibold text-amber-800">2º Turno</div>
                                <div class="text-amber-600">Ciclo: <strong>${cicloT2}</strong> | Cav: <strong>${cavT2}</strong></div>
                            </div>
                            <div class="bg-purple-50 rounded-lg p-2 border border-purple-100">
                                <div class="font-semibold text-purple-800">3º Turno</div>
                                <div class="text-purple-600">Ciclo: <strong>${cicloT3}</strong> | Cav: <strong>${cavT3}</strong></div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            listaDiv.innerHTML = html;
            lucide.createIcons();
            
            // Attach handlers de edição
            listaDiv.querySelectorAll('.admin-btn-edit-planejamento').forEach(btn => {
                btn.addEventListener('click', () => adminEditarPlanejamento(btn.dataset.id));
            });
            
        } catch (error) {
            console.error('[ADMIN] Erro ao buscar planejamento:', error);
            listaDiv.innerHTML = `<div class="text-center py-4 text-red-500">Erro: ${error.message}</div>`;
        }
    }

    async function adminEditarPlanejamento(docId) {
        try {
            const docRef = db.collection('planning').doc(docId);
            const docSnap = await docRef.get();
            
            if (!docSnap.exists) {
                alert('Planejamento não encontrado');
                return;
            }
            
            const data = docSnap.data();
            
            // Criar modal de edição
            const modal = document.createElement('div');
            modal.id = 'admin-edit-planejamento-modal';
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl overflow-hidden max-h-[90vh] overflow-y-auto">
                    <div class="bg-gradient-to-r from-emerald-600 to-teal-600 px-5 py-4 sticky top-0">
                        <h3 class="text-lg font-bold text-white flex items-center gap-2">
                            <i data-lucide="calendar-check" class="w-5 h-5"></i>
                            Editar Planejamento
                        </h3>
                        <p class="text-emerald-200 text-sm">${data.machine || '-'} - ${data.product || '-'} (${data.date || '-'})</p>
                    </div>
                    <form id="admin-edit-planejamento-form" class="p-5 space-y-4">
                        <input type="hidden" id="admin-edit-plan-id" value="${docId}">
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Meta Planejada (peças)</label>
                                <input type="number" id="admin-edit-plan-meta" value="${data.planned_quantity || data.daily_target || 0}" 
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500">
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Ciclo Orçado (s)</label>
                                <input type="number" step="0.1" id="admin-edit-plan-ciclo-orc" value="${data.budgeted_cycle || ''}" 
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500">
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Cavidades do Molde</label>
                                <input type="number" id="admin-edit-plan-cav-molde" value="${data.mold_cavities || ''}" 
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500">
                            </div>
                            <div>
                                <label class="block text-xs font-semibold text-gray-500 uppercase mb-1">Peso da Peça (g)</label>
                                <input type="number" step="0.01" id="admin-edit-plan-peso" value="${data.piece_weight || ''}" 
                                    class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-emerald-500">
                            </div>
                        </div>
                        
                        <div class="border-t pt-4 mt-4">
                            <h4 class="font-semibold text-gray-700 mb-3">Ciclo Real e Cavidades Ativas por Turno</h4>
                            <div class="grid grid-cols-3 gap-4">
                                <div class="bg-blue-50 rounded-lg p-3 border border-blue-200">
                                    <div class="font-semibold text-blue-800 text-center mb-2">1º Turno</div>
                                    <div class="space-y-2">
                                        <div>
                                            <label class="block text-xs text-blue-600 mb-1">Ciclo Real (s)</label>
                                            <input type="number" step="0.1" id="admin-edit-plan-ciclo-t1" value="${data.real_cycle_t1 || ''}" 
                                                class="w-full p-2 border border-blue-200 rounded focus:ring-2 focus:ring-blue-500 text-sm">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-blue-600 mb-1">Cavidades Ativas</label>
                                            <input type="number" id="admin-edit-plan-cav-t1" value="${data.active_cavities_t1 || ''}" 
                                                class="w-full p-2 border border-blue-200 rounded focus:ring-2 focus:ring-blue-500 text-sm">
                                        </div>
                                    </div>
                                </div>
                                <div class="bg-amber-50 rounded-lg p-3 border border-amber-200">
                                    <div class="font-semibold text-amber-800 text-center mb-2">2º Turno</div>
                                    <div class="space-y-2">
                                        <div>
                                            <label class="block text-xs text-amber-600 mb-1">Ciclo Real (s)</label>
                                            <input type="number" step="0.1" id="admin-edit-plan-ciclo-t2" value="${data.real_cycle_t2 || ''}" 
                                                class="w-full p-2 border border-amber-200 rounded focus:ring-2 focus:ring-amber-500 text-sm">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-amber-600 mb-1">Cavidades Ativas</label>
                                            <input type="number" id="admin-edit-plan-cav-t2" value="${data.active_cavities_t2 || ''}" 
                                                class="w-full p-2 border border-amber-200 rounded focus:ring-2 focus:ring-amber-500 text-sm">
                                        </div>
                                    </div>
                                </div>
                                <div class="bg-purple-50 rounded-lg p-3 border border-purple-200">
                                    <div class="font-semibold text-purple-800 text-center mb-2">3º Turno</div>
                                    <div class="space-y-2">
                                        <div>
                                            <label class="block text-xs text-purple-600 mb-1">Ciclo Real (s)</label>
                                            <input type="number" step="0.1" id="admin-edit-plan-ciclo-t3" value="${data.real_cycle_t3 || ''}" 
                                                class="w-full p-2 border border-purple-200 rounded focus:ring-2 focus:ring-purple-500 text-sm">
                                        </div>
                                        <div>
                                            <label class="block text-xs text-purple-600 mb-1">Cavidades Ativas</label>
                                            <input type="number" id="admin-edit-plan-cav-t3" value="${data.active_cavities_t3 || ''}" 
                                                class="w-full p-2 border border-purple-200 rounded focus:ring-2 focus:ring-purple-500 text-sm">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex gap-3 pt-4 border-t">
                            <button type="button" id="admin-edit-plan-cancel" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-semibold py-2.5 rounded-lg transition">
                                Cancelar
                            </button>
                            <button type="submit" class="flex-1 bg-emerald-600 hover:bg-emerald-700 text-white font-semibold py-2.5 rounded-lg transition">
                                Salvar Alterações
                            </button>
                        </div>
                    </form>
                </div>
            `;
            
            document.body.appendChild(modal);
            lucide.createIcons();
            
            // Fechar modal
            document.getElementById('admin-edit-plan-cancel').addEventListener('click', () => modal.remove());
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
            // Salvar alterações
            document.getElementById('admin-edit-planejamento-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const updates = {
                    planned_quantity: parseInt(document.getElementById('admin-edit-plan-meta').value) || 0,
                    daily_target: parseInt(document.getElementById('admin-edit-plan-meta').value) || 0,
                    budgeted_cycle: parseFloat(document.getElementById('admin-edit-plan-ciclo-orc').value) || null,
                    mold_cavities: parseInt(document.getElementById('admin-edit-plan-cav-molde').value) || null,
                    piece_weight: parseFloat(document.getElementById('admin-edit-plan-peso').value) || null,
                    real_cycle_t1: parseFloat(document.getElementById('admin-edit-plan-ciclo-t1').value) || null,
                    active_cavities_t1: parseInt(document.getElementById('admin-edit-plan-cav-t1').value) || null,
                    real_cycle_t2: parseFloat(document.getElementById('admin-edit-plan-ciclo-t2').value) || null,
                    active_cavities_t2: parseInt(document.getElementById('admin-edit-plan-cav-t2').value) || null,
                    real_cycle_t3: parseFloat(document.getElementById('admin-edit-plan-ciclo-t3').value) || null,
                    active_cavities_t3: parseInt(document.getElementById('admin-edit-plan-cav-t3').value) || null,
                    last_edited_at: firebase.firestore.FieldValue.serverTimestamp(),
                    edited_by: getActiveUser()?.name || 'Admin'
                };
                
                try {
                    await docRef.update(updates);
                    
                    modal.remove();
                    showNotification('Planejamento atualizado com sucesso!', 'success');
                    adminBuscarPlanejamento();
                    
                } catch (err) {
                    alert('Erro ao atualizar: ' + err.message);
                }
            });
            
        } catch (error) {
            alert('Erro ao carregar planejamento: ' + error.message);
        }
    }

    // ===== AJUSTES EM LOTE - FUNÇÕES =====
    let ajustesLoteData = [];
    let ajustesLotePendentes = new Map(); // Armazena alterações pendentes
    
    async function adminCarregarAjustesLote() {
        const data = document.getElementById('admin-ajuste-data')?.value;
        const maquina = document.getElementById('admin-ajuste-maquina')?.value;
        const tipo = document.getElementById('admin-ajuste-tipo')?.value || 'resumo';
        const tbody = document.getElementById('admin-ajustes-body');
        const thead = document.getElementById('admin-ajustes-header');
        
        if (!data) {
            alert('Selecione uma data');
            return;
        }
        
        // Limpar alterações pendentes
        ajustesLotePendentes.clear();
        atualizarContadorAjustes();
        
        try {
            tbody.innerHTML = '<tr><td colspan="8" class="px-4 py-8 text-center text-gray-500"><i class="animate-spin inline-block">⏳</i> Carregando dados...</td></tr>';
            
            if (tipo === 'resumo') {
                await carregarResumoMaquinas(data, maquina, tbody, thead);
            } else if (tipo === 'lancamentos') {
                await carregarLancamentosIndividuais(data, maquina, tbody, thead);
            } else if (tipo === 'ordens') {
                await carregarOrdensDia(data, maquina, tbody, thead);
            }
            
            lucide.createIcons();
            
        } catch (error) {
            console.error('[ADMIN] Erro ao carregar ajustes:', error);
            tbody.innerHTML = `<tr><td colspan="8" class="px-4 py-8 text-center text-red-500">Erro: ${error.message}</td></tr>`;
        }
    }
    
    async function carregarResumoMaquinas(data, maquinaFiltro, tbody, thead) {
        // Ajustar cabeçalho para visão resumo
        thead.innerHTML = `
            <th class="px-3 py-2 text-left font-semibold text-gray-700 border-b">Máquina</th>
            <th class="px-3 py-2 text-left font-semibold text-gray-700 border-b">Produto/OP</th>
            <th class="px-3 py-2 text-right font-semibold text-blue-700 border-b bg-blue-50">Planejado (Lote)</th>
            <th class="px-3 py-2 text-right font-semibold text-green-700 border-b bg-green-50">Executado Total</th>
            <th class="px-3 py-2 text-right font-semibold text-cyan-700 border-b bg-cyan-50">Produção Dia</th>
            <th class="px-3 py-2 text-right font-semibold text-amber-700 border-b bg-amber-50">Faltante</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-700 border-b">Progresso</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-500 border-b w-20">Ações</th>
        `;
        
        // Buscar planejamentos do dia
        let queryPlanning = db.collection('planning').where('date', '==', data);
        if (maquinaFiltro) {
            queryPlanning = queryPlanning.where('machine', '==', maquinaFiltro);
        }
        const planningSnap = await queryPlanning.get();
        
        if (planningSnap.empty) {
            tbody.innerHTML = '<tr><td colspan="8" class="px-4 py-8 text-center text-gray-400">Nenhum planejamento encontrado para esta data.</td></tr>';
            return;
        }
        
        // Buscar production_entries do dia para calcular produção do dia
        let queryProd = db.collection('production_entries').where('data', '==', data);
        const prodSnap = await queryProd.get();
        
        // Mapear produção por planId
        const producaoPorPlan = new Map();
        prodSnap.docs.forEach(doc => {
            const d = doc.data();
            const planId = d.planId;
            if (planId) {
                const atual = producaoPorPlan.get(planId) || 0;
                producaoPorPlan.set(planId, atual + (Number(d.produzido) || Number(d.quantity) || 0));
            }
        });
        
        let html = '';
        const items = [];
        
        planningSnap.docs.forEach(doc => {
            const d = doc.data();
            const planId = doc.id;
            const planejado = Number(d.order_lot_size) || Number(d.lot_size) || 0;
            const executadoTotal = Number(d.total_produzido) || 0;
            const producaoDia = producaoPorPlan.get(planId) || 0;
            const faltante = Math.max(0, planejado - executadoTotal);
            const progresso = planejado > 0 ? Math.min(100, (executadoTotal / planejado) * 100) : 0;
            const progressoClass = progresso >= 100 ? 'text-green-600' : progresso >= 50 ? 'text-amber-600' : 'text-red-600';
            
            items.push({
                planId,
                orderId: d.order_id || d.orderId,
                machine: d.machine,
                product: d.product || d.product_name,
                orderNumber: d.order_number,
                planejado,
                executadoTotal,
                producaoDia,
                faltante,
                progresso
            });
            
            html += `
                <tr class="hover:bg-gray-50 transition" data-plan-id="${planId}" data-order-id="${d.order_id || d.orderId || ''}">
                    <td class="px-3 py-2 font-semibold text-indigo-700">${d.machine || '-'}</td>
                    <td class="px-3 py-2">
                        <div class="text-sm font-medium text-gray-800 truncate max-w-[200px]" title="${d.product || ''}">${d.product || d.product_name || '-'}</div>
                        <div class="text-xs text-gray-500">OP: ${d.order_number || '-'}</div>
                    </td>
                    <td class="px-3 py-2 text-right bg-blue-50">
                        <input type="number" class="ajuste-input-planejado w-24 text-right p-1 border border-transparent rounded hover:border-blue-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 bg-transparent font-semibold text-blue-700" 
                            value="${planejado}" data-original="${planejado}" data-field="planejado" data-plan-id="${planId}">
                    </td>
                    <td class="px-3 py-2 text-right bg-green-50">
                        <input type="number" class="ajuste-input-executado w-24 text-right p-1 border border-transparent rounded hover:border-green-300 focus:border-green-500 focus:ring-1 focus:ring-green-500 bg-transparent font-semibold text-green-700" 
                            value="${executadoTotal}" data-original="${executadoTotal}" data-field="executado" data-plan-id="${planId}">
                    </td>
                    <td class="px-3 py-2 text-right bg-cyan-50 text-cyan-700 font-medium">${producaoDia.toLocaleString('pt-BR')}</td>
                    <td class="px-3 py-2 text-right bg-amber-50 font-semibold text-amber-700" data-faltante="${planId}">${faltante.toLocaleString('pt-BR')}</td>
                    <td class="px-3 py-2 text-center">
                        <div class="flex items-center gap-2">
                            <div class="flex-1 bg-gray-200 rounded-full h-2">
                                <div class="h-2 rounded-full ${progresso >= 100 ? 'bg-green-500' : progresso >= 50 ? 'bg-amber-500' : 'bg-red-500'}" style="width: ${Math.min(100, progresso)}%"></div>
                            </div>
                            <span class="text-xs font-semibold ${progressoClass} w-12 text-right">${progresso.toFixed(1)}%</span>
                        </div>
                    </td>
                    <td class="px-3 py-2 text-center">
                        <button class="ajuste-btn-detalhe text-gray-500 hover:text-indigo-600 p-1 rounded hover:bg-indigo-50 transition" data-plan-id="${planId}" title="Ver detalhes">
                            <i data-lucide="eye" class="w-4 h-4"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        tbody.innerHTML = html || '<tr><td colspan="8" class="px-4 py-8 text-center text-gray-400">Nenhum dado encontrado.</td></tr>';
        ajustesLoteData = items;
        
        // Adicionar listeners aos inputs editáveis
        tbody.querySelectorAll('.ajuste-input-planejado, .ajuste-input-executado').forEach(input => {
            input.addEventListener('change', handleAjusteInputChange);
            input.addEventListener('focus', (e) => e.target.select());
        });
        
        // Listeners para detalhes
        tbody.querySelectorAll('.ajuste-btn-detalhe').forEach(btn => {
            btn.addEventListener('click', () => mostrarDetalhePlano(btn.dataset.planId));
        });
    }
    
    async function carregarLancamentosIndividuais(data, maquinaFiltro, tbody, thead) {
        // Ajustar cabeçalho para visão de lançamentos
        thead.innerHTML = `
            <th class="px-2 py-2 text-left font-semibold text-gray-700 border-b w-8"><input type="checkbox" id="ajuste-select-all" class="rounded"></th>
            <th class="px-3 py-2 text-left font-semibold text-gray-700 border-b">Máquina</th>
            <th class="px-3 py-2 text-left font-semibold text-gray-700 border-b">Produto</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-700 border-b">Turno</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-700 border-b">Hora</th>
            <th class="px-3 py-2 text-right font-semibold text-green-700 border-b bg-green-50">Quantidade</th>
            <th class="px-3 py-2 text-right font-semibold text-amber-700 border-b bg-amber-50">Peso (kg)</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-500 border-b w-20">Ações</th>
        `;
        
        // Buscar lançamentos do dia
        let query = db.collection('production_entries').where('data', '==', data);
        const snapshot = await query.limit(200).get();
        
        let docs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Filtrar por máquina se especificado
        if (maquinaFiltro) {
            docs = docs.filter(d => d.machine === maquinaFiltro || d.machine_id === maquinaFiltro);
        }
        
        // Ordenar por máquina e timestamp
        docs.sort((a, b) => {
            const machineCompare = (a.machine || '').localeCompare(b.machine || '');
            if (machineCompare !== 0) return machineCompare;
            const tsA = a.timestamp?.toMillis ? a.timestamp.toMillis() : 0;
            const tsB = b.timestamp?.toMillis ? b.timestamp.toMillis() : 0;
            return tsB - tsA;
        });
        
        if (docs.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="px-4 py-8 text-center text-gray-400">Nenhum lançamento encontrado para esta data.</td></tr>';
            return;
        }
        
        let html = '';
        
        docs.forEach(d => {
            const hora = d.timestamp?.toDate ? d.timestamp.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : d.horaInformada || '-';
            const qtd = Number(d.produzido) || Number(d.quantity) || 0;
            const peso = Number(d.peso_bruto) || Number(d.peso_kg) || 0;
            const turno = d.turno || d.shift || '-';
            
            html += `
                <tr class="hover:bg-gray-50 transition" data-entry-id="${d.id}">
                    <td class="px-2 py-2 text-center"><input type="checkbox" class="ajuste-checkbox rounded" data-id="${d.id}"></td>
                    <td class="px-3 py-2 font-semibold text-indigo-700">${d.machine || d.machine_id || '-'}</td>
                    <td class="px-3 py-2 text-sm text-gray-700 truncate max-w-[180px]" title="${d.product_name || d.product_code || ''}">${d.product_name || d.product_code || '-'}</td>
                    <td class="px-3 py-2 text-center"><span class="px-2 py-0.5 rounded text-xs font-semibold ${turno === 'T1' || turno == '1' ? 'bg-blue-100 text-blue-700' : turno === 'T2' || turno == '2' ? 'bg-amber-100 text-amber-700' : 'bg-purple-100 text-purple-700'}">${turno}</span></td>
                    <td class="px-3 py-2 text-center text-gray-600 text-sm">${hora}</td>
                    <td class="px-3 py-2 text-right bg-green-50">
                        <input type="number" class="ajuste-input-qty w-20 text-right p-1 border border-transparent rounded hover:border-green-300 focus:border-green-500 focus:ring-1 focus:ring-green-500 bg-transparent font-semibold text-green-700" 
                            value="${qtd}" data-original="${qtd}" data-field="produzido" data-entry-id="${d.id}">
                    </td>
                    <td class="px-3 py-2 text-right bg-amber-50">
                        <input type="number" step="0.01" class="ajuste-input-peso w-20 text-right p-1 border border-transparent rounded hover:border-amber-300 focus:border-amber-500 focus:ring-1 focus:ring-amber-500 bg-transparent font-semibold text-amber-700" 
                            value="${peso.toFixed(2)}" data-original="${peso.toFixed(2)}" data-field="peso" data-entry-id="${d.id}">
                    </td>
                    <td class="px-3 py-2 text-center">
                        <button class="ajuste-btn-delete-entry text-red-500 hover:text-red-700 p-1 rounded hover:bg-red-50 transition" data-entry-id="${d.id}" title="Excluir">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        tbody.innerHTML = html;
        ajustesLoteData = docs;
        
        // Listeners
        tbody.querySelectorAll('.ajuste-input-qty, .ajuste-input-peso').forEach(input => {
            input.addEventListener('change', handleAjusteEntryChange);
            input.addEventListener('focus', (e) => e.target.select());
        });
        
        // Select all checkbox
        const selectAll = document.getElementById('ajuste-select-all');
        if (selectAll) {
            selectAll.addEventListener('change', (e) => {
                tbody.querySelectorAll('.ajuste-checkbox').forEach(cb => cb.checked = e.target.checked);
            });
        }
        
        // Delete buttons
        tbody.querySelectorAll('.ajuste-btn-delete-entry').forEach(btn => {
            btn.addEventListener('click', () => excluirLancamento(btn.dataset.entryId));
        });
    }
    
    async function carregarOrdensDia(data, maquinaFiltro, tbody, thead) {
        // Ajustar cabeçalho para visão de ordens
        thead.innerHTML = `
            <th class="px-3 py-2 text-left font-semibold text-gray-700 border-b">Nº OP</th>
            <th class="px-3 py-2 text-left font-semibold text-gray-700 border-b">Produto</th>
            <th class="px-3 py-2 text-left font-semibold text-gray-700 border-b">Máquina</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-700 border-b">Status</th>
            <th class="px-3 py-2 text-right font-semibold text-blue-700 border-b bg-blue-50">Lote (Plan.)</th>
            <th class="px-3 py-2 text-right font-semibold text-green-700 border-b bg-green-50">Executado</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-700 border-b">Progresso</th>
            <th class="px-3 py-2 text-center font-semibold text-gray-500 border-b w-20">Ações</th>
        `;
        
        // Buscar ordens ativas ou do dia
        let query = db.collection('production_orders')
            .where('status', 'in', ['ativa', 'em_andamento', 'planejada']);
        
        const snapshot = await query.limit(100).get();
        
        let docs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        // Filtrar por máquina se especificado
        if (maquinaFiltro) {
            docs = docs.filter(d => d.machine_id === maquinaFiltro);
        }
        
        // Ordenar por número da OP
        docs.sort((a, b) => (a.order_number || '').localeCompare(b.order_number || ''));
        
        if (docs.length === 0) {
            tbody.innerHTML = '<tr><td colspan="8" class="px-4 py-8 text-center text-gray-400">Nenhuma ordem de produção ativa encontrada.</td></tr>';
            return;
        }
        
        let html = '';
        
        docs.forEach(d => {
            const lotSize = Number(d.lot_size) || 0;
            const executado = Number(d.total_produzido) || Number(d.totalProduced) || 0;
            const progresso = lotSize > 0 ? Math.min(100, (executado / lotSize) * 100) : 0;
            const statusClass = d.status === 'ativa' || d.status === 'em_andamento' ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600';
            const progressoClass = progresso >= 100 ? 'text-green-600' : progresso >= 50 ? 'text-amber-600' : 'text-red-600';
            
            html += `
                <tr class="hover:bg-gray-50 transition" data-order-id="${d.id}">
                    <td class="px-3 py-2 font-bold text-indigo-700">${d.order_number || '-'}</td>
                    <td class="px-3 py-2 text-sm text-gray-700 truncate max-w-[180px]" title="${d.product || ''}">${d.product || '-'}</td>
                    <td class="px-3 py-2 font-medium">${d.machine_id || '-'}</td>
                    <td class="px-3 py-2 text-center"><span class="px-2 py-0.5 rounded text-xs font-semibold ${statusClass}">${d.status || '-'}</span></td>
                    <td class="px-3 py-2 text-right bg-blue-50">
                        <input type="number" class="ajuste-input-lote w-24 text-right p-1 border border-transparent rounded hover:border-blue-300 focus:border-blue-500 focus:ring-1 focus:ring-blue-500 bg-transparent font-semibold text-blue-700" 
                            value="${lotSize}" data-original="${lotSize}" data-field="lot_size" data-order-id="${d.id}">
                    </td>
                    <td class="px-3 py-2 text-right bg-green-50">
                        <input type="number" class="ajuste-input-exec w-24 text-right p-1 border border-transparent rounded hover:border-green-300 focus:border-green-500 focus:ring-1 focus:ring-green-500 bg-transparent font-semibold text-green-700" 
                            value="${executado}" data-original="${executado}" data-field="total_produzido" data-order-id="${d.id}">
                    </td>
                    <td class="px-3 py-2 text-center">
                        <div class="flex items-center gap-2">
                            <div class="flex-1 bg-gray-200 rounded-full h-2">
                                <div class="h-2 rounded-full ${progresso >= 100 ? 'bg-green-500' : progresso >= 50 ? 'bg-amber-500' : 'bg-red-500'}" style="width: ${Math.min(100, progresso)}%"></div>
                            </div>
                            <span class="text-xs font-semibold ${progressoClass} w-12 text-right">${progresso.toFixed(1)}%</span>
                        </div>
                    </td>
                    <td class="px-3 py-2 text-center">
                        <button class="ajuste-btn-sync-ordem text-amber-500 hover:text-amber-700 p-1 rounded hover:bg-amber-50 transition" data-order-id="${d.id}" title="Recalcular total">
                            <i data-lucide="calculator" class="w-4 h-4"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        tbody.innerHTML = html;
        ajustesLoteData = docs;
        
        // Listeners
        tbody.querySelectorAll('.ajuste-input-lote, .ajuste-input-exec').forEach(input => {
            input.addEventListener('change', handleAjusteOrdemChange);
            input.addEventListener('focus', (e) => e.target.select());
        });
        
        // Sync buttons
        tbody.querySelectorAll('.ajuste-btn-sync-ordem').forEach(btn => {
            btn.addEventListener('click', () => recalcularTotalOrdem(btn.dataset.orderId));
        });
    }
    
    function handleAjusteInputChange(e) {
        const input = e.target;
        const planId = input.dataset.planId;
        const field = input.dataset.field;
        const original = Number(input.dataset.original);
        const newValue = Number(input.value);
        
        if (newValue !== original) {
            input.classList.add('bg-yellow-100', 'border-yellow-400');
            
            // Adicionar ao Map de pendentes
            if (!ajustesLotePendentes.has(planId)) {
                ajustesLotePendentes.set(planId, { type: 'planning', changes: {} });
            }
            ajustesLotePendentes.get(planId).changes[field] = newValue;
            
            // Atualizar faltante em tempo real
            const row = input.closest('tr');
            if (row) {
                const planejadoInput = row.querySelector('.ajuste-input-planejado');
                const executadoInput = row.querySelector('.ajuste-input-executado');
                const faltanteCell = row.querySelector(`[data-faltante="${planId}"]`);
                
                if (planejadoInput && executadoInput && faltanteCell) {
                    const planejado = Number(planejadoInput.value) || 0;
                    const executado = Number(executadoInput.value) || 0;
                    const novoFaltante = Math.max(0, planejado - executado);
                    faltanteCell.textContent = novoFaltante.toLocaleString('pt-BR');
                }
            }
        } else {
            input.classList.remove('bg-yellow-100', 'border-yellow-400');
            
            // Remover do Map se voltar ao original
            if (ajustesLotePendentes.has(planId)) {
                delete ajustesLotePendentes.get(planId).changes[field];
                if (Object.keys(ajustesLotePendentes.get(planId).changes).length === 0) {
                    ajustesLotePendentes.delete(planId);
                }
            }
        }
        
        atualizarContadorAjustes();
    }
    
    function handleAjusteEntryChange(e) {
        const input = e.target;
        const entryId = input.dataset.entryId;
        const field = input.dataset.field;
        const original = field === 'peso' ? parseFloat(input.dataset.original) : Number(input.dataset.original);
        const newValue = field === 'peso' ? parseFloat(input.value) : Number(input.value);
        
        if (newValue !== original) {
            input.classList.add('bg-yellow-100', 'border-yellow-400');
            
            if (!ajustesLotePendentes.has(entryId)) {
                ajustesLotePendentes.set(entryId, { type: 'entry', changes: {} });
            }
            ajustesLotePendentes.get(entryId).changes[field] = newValue;
        } else {
            input.classList.remove('bg-yellow-100', 'border-yellow-400');
            
            if (ajustesLotePendentes.has(entryId)) {
                delete ajustesLotePendentes.get(entryId).changes[field];
                if (Object.keys(ajustesLotePendentes.get(entryId).changes).length === 0) {
                    ajustesLotePendentes.delete(entryId);
                }
            }
        }
        
        atualizarContadorAjustes();
    }
    
    function handleAjusteOrdemChange(e) {
        const input = e.target;
        const orderId = input.dataset.orderId;
        const field = input.dataset.field;
        const original = Number(input.dataset.original);
        const newValue = Number(input.value);
        
        if (newValue !== original) {
            input.classList.add('bg-yellow-100', 'border-yellow-400');
            
            if (!ajustesLotePendentes.has(orderId)) {
                ajustesLotePendentes.set(orderId, { type: 'order', changes: {} });
            }
            ajustesLotePendentes.get(orderId).changes[field] = newValue;
        } else {
            input.classList.remove('bg-yellow-100', 'border-yellow-400');
            
            if (ajustesLotePendentes.has(orderId)) {
                delete ajustesLotePendentes.get(orderId).changes[field];
                if (Object.keys(ajustesLotePendentes.get(orderId).changes).length === 0) {
                    ajustesLotePendentes.delete(orderId);
                }
            }
        }
        
        atualizarContadorAjustes();
    }
    
    function atualizarContadorAjustes() {
        const count = ajustesLotePendentes.size;
        const countEl = document.getElementById('admin-ajustes-count');
        const btnSalvar = document.getElementById('admin-btn-salvar-ajustes');
        const btnDescartar = document.getElementById('admin-btn-descartar-ajustes');
        
        if (countEl) {
            countEl.textContent = count;
            countEl.classList.toggle('hidden', count === 0);
        }
        
        if (btnSalvar) btnSalvar.disabled = count === 0;
        if (btnDescartar) btnDescartar.disabled = count === 0;
    }
    
    async function adminSalvarAjustesLote() {
        if (ajustesLotePendentes.size === 0) {
            showNotification('Nenhuma alteração pendente', 'info');
            return;
        }
        
        if (!confirm(`Salvar ${ajustesLotePendentes.size} alteração(ões)?`)) return;
        
        const btnSalvar = document.getElementById('admin-btn-salvar-ajustes');
        if (btnSalvar) {
            btnSalvar.disabled = true;
            btnSalvar.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> Salvando...';
        }
        
        let successCount = 0;
        let errorCount = 0;
        const user = getActiveUser();
        
        try {
            for (const [docId, data] of ajustesLotePendentes) {
                try {
                    let collection = '';
                    let updateData = {
                        ...data.changes,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        editedBy: user?.name || 'Admin',
                        editedAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    
                    if (data.type === 'planning') {
                        collection = 'planning';
                        // Se alterou executado, também atualizar total_produzido
                        if (data.changes.executado !== undefined) {
                            updateData.total_produzido = data.changes.executado;
                        }
                        // Se alterou planejado, também atualizar lot_size e order_lot_size
                        if (data.changes.planejado !== undefined) {
                            updateData.lot_size = data.changes.planejado;
                            updateData.order_lot_size = data.changes.planejado;
                        }
                    } else if (data.type === 'entry') {
                        collection = 'production_entries';
                        // Mapear campos
                        if (data.changes.produzido !== undefined) {
                            updateData.produzido = data.changes.produzido;
                            updateData.quantity = data.changes.produzido;
                        }
                        if (data.changes.peso !== undefined) {
                            updateData.peso_bruto = data.changes.peso;
                            updateData.peso_kg = data.changes.peso;
                        }
                    } else if (data.type === 'order') {
                        collection = 'production_orders';
                        // Mapear campos
                        if (data.changes.total_produzido !== undefined) {
                            updateData.total_produzido = data.changes.total_produzido;
                            updateData.totalProduced = data.changes.total_produzido;
                        }
                    }
                    
                    await db.collection(collection).doc(docId).update(updateData);
                    
                    // Marcar visualmente como salvo
                    const inputs = document.querySelectorAll(`[data-plan-id="${docId}"], [data-entry-id="${docId}"], [data-order-id="${docId}"]`);
                    inputs.forEach(input => {
                        if (input.tagName === 'INPUT') {
                            input.classList.remove('bg-yellow-100', 'border-yellow-400');
                            input.classList.add('bg-green-100', 'border-green-400');
                            input.dataset.original = input.value;
                            setTimeout(() => {
                                input.classList.remove('bg-green-100', 'border-green-400');
                            }, 2000);
                        }
                    });
                    
                    successCount++;
                } catch (err) {
                    console.error(`Erro ao salvar ${docId}:`, err);
                    errorCount++;
                    
                    // Marcar visualmente como erro
                    const inputs = document.querySelectorAll(`[data-plan-id="${docId}"], [data-entry-id="${docId}"], [data-order-id="${docId}"]`);
                    inputs.forEach(input => {
                        if (input.tagName === 'INPUT') {
                            input.classList.add('bg-red-100', 'border-red-400');
                        }
                    });
                }
            }
            
            // Limpar pendentes salvos com sucesso
            ajustesLotePendentes.clear();
            atualizarContadorAjustes();
            
            if (errorCount === 0) {
                showNotification(`${successCount} alteração(ões) salva(s) com sucesso!`, 'success');
            } else {
                showNotification(`${successCount} salva(s), ${errorCount} erro(s)`, 'warning');
            }
            
        } catch (error) {
            console.error('[ADMIN] Erro ao salvar ajustes:', error);
            showNotification('Erro ao salvar: ' + error.message, 'error');
        } finally {
            if (btnSalvar) {
                btnSalvar.disabled = false;
                btnSalvar.innerHTML = '<i data-lucide="save" class="w-4 h-4"></i> Salvar Alterações <span id="admin-ajustes-count" class="bg-green-800 px-2 py-0.5 rounded text-xs hidden">0</span>';
                lucide.createIcons();
            }
        }
    }
    
    function adminDescartarAjustes() {
        if (ajustesLotePendentes.size === 0) return;
        
        if (!confirm('Descartar todas as alterações não salvas?')) return;
        
        // Restaurar valores originais
        ajustesLotePendentes.forEach((data, docId) => {
            const inputs = document.querySelectorAll(`[data-plan-id="${docId}"], [data-entry-id="${docId}"], [data-order-id="${docId}"]`);
            inputs.forEach(input => {
                if (input.tagName === 'INPUT') {
                    input.value = input.dataset.original;
                    input.classList.remove('bg-yellow-100', 'border-yellow-400');
                }
            });
        });
        
        ajustesLotePendentes.clear();
        atualizarContadorAjustes();
        showNotification('Alterações descartadas', 'info');
    }
    
    async function adminSincronizarTotais() {
        const data = document.getElementById('admin-ajuste-data')?.value;
        
        if (!data) {
            alert('Selecione uma data primeiro');
            return;
        }
        
        if (!confirm('Isso irá recalcular os totais de todas as ordens com base nos lançamentos.\n\nContinuar?')) return;
        
        const btnSync = document.getElementById('admin-btn-sync-totais');
        if (btnSync) {
            btnSync.disabled = true;
            btnSync.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> Sincronizando...';
        }
        
        try {
            // Buscar todos os lançamentos
            const prodSnap = await db.collection('production_entries').where('data', '==', data).get();
            
            // Agregar por orderId
            const totaisPorOrdem = new Map();
            prodSnap.docs.forEach(doc => {
                const d = doc.data();
                const orderId = d.orderId || d.order_id;
                if (orderId) {
                    const atual = totaisPorOrdem.get(orderId) || 0;
                    totaisPorOrdem.set(orderId, atual + (Number(d.produzido) || Number(d.quantity) || 0));
                }
            });
            
            // Atualizar cada ordem
            let updated = 0;
            for (const [orderId, total] of totaisPorOrdem) {
                try {
                    await db.collection('production_orders').doc(orderId).update({
                        total_produzido: total,
                        totalProduced: total,
                        syncedAt: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    updated++;
                } catch (e) {
                    console.warn(`Erro ao atualizar ordem ${orderId}:`, e);
                }
            }
            
            showNotification(`${updated} ordem(ns) sincronizada(s)`, 'success');
            
            // Recarregar dados
            adminCarregarAjustesLote();
            
        } catch (error) {
            console.error('[ADMIN] Erro ao sincronizar:', error);
            showNotification('Erro: ' + error.message, 'error');
        } finally {
            if (btnSync) {
                btnSync.disabled = false;
                btnSync.innerHTML = '<i data-lucide="calculator" class="w-4 h-4"></i> Sincronizar Totais';
                lucide.createIcons();
            }
        }
    }
    
    async function excluirLancamento(entryId) {
        if (!confirm('Excluir este lançamento? Esta ação não pode ser desfeita.')) return;
        
        try {
            await db.collection('production_entries').doc(entryId).delete();
            
            // Remover da tabela
            const row = document.querySelector(`tr[data-entry-id="${entryId}"]`);
            if (row) row.remove();
            
            showNotification('Lançamento excluído', 'success');
        } catch (error) {
            showNotification('Erro ao excluir: ' + error.message, 'error');
        }
    }
    
    async function recalcularTotalOrdem(orderId) {
        try {
            // Buscar todos os lançamentos desta ordem
            const prodSnap = await db.collection('production_entries')
                .where('orderId', '==', orderId)
                .get();
            
            let total = 0;
            prodSnap.docs.forEach(doc => {
                const d = doc.data();
                total += Number(d.produzido) || Number(d.quantity) || 0;
            });
            
            // Atualizar ordem
            await db.collection('production_orders').doc(orderId).update({
                total_produzido: total,
                totalProduced: total,
                syncedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            // Atualizar input na tabela
            const input = document.querySelector(`input[data-order-id="${orderId}"][data-field="total_produzido"]`);
            if (input) {
                input.value = total;
                input.dataset.original = total;
                input.classList.add('bg-green-100');
                setTimeout(() => input.classList.remove('bg-green-100'), 2000);
            }
            
            showNotification(`Total recalculado: ${total.toLocaleString('pt-BR')} peças`, 'success');
        } catch (error) {
            showNotification('Erro: ' + error.message, 'error');
        }
    }
    
    async function mostrarDetalhePlano(planId) {
        try {
            const planDoc = await db.collection('planning').doc(planId).get();
            if (!planDoc.exists) {
                alert('Planejamento não encontrado');
                return;
            }
            
            const plan = planDoc.data();
            
            // Buscar lançamentos deste plano
            const prodSnap = await db.collection('production_entries')
                .where('planId', '==', planId)
                .get();
            
            let lancamentos = prodSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            lancamentos.sort((a, b) => {
                const tsA = a.timestamp?.toMillis ? a.timestamp.toMillis() : 0;
                const tsB = b.timestamp?.toMillis ? b.timestamp.toMillis() : 0;
                return tsB - tsA;
            });
            
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4';
            modal.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[90vh] overflow-hidden flex flex-col">
                    <div class="bg-gradient-to-r from-indigo-600 to-purple-600 px-5 py-4 flex items-center justify-between">
                        <div>
                            <h3 class="text-lg font-bold text-white">${plan.machine || '-'} - Detalhes</h3>
                            <p class="text-indigo-200 text-sm">${plan.product || '-'} | OP: ${plan.order_number || '-'}</p>
                        </div>
                        <button class="modal-close text-white/80 hover:text-white p-1">
                            <i data-lucide="x" class="w-6 h-6"></i>
                        </button>
                    </div>
                    <div class="p-5 overflow-y-auto flex-1">
                        <div class="grid grid-cols-3 gap-3 mb-4">
                            <div class="bg-blue-50 rounded-lg p-3 text-center">
                                <div class="text-2xl font-bold text-blue-700">${(Number(plan.order_lot_size) || Number(plan.lot_size) || 0).toLocaleString('pt-BR')}</div>
                                <div class="text-xs text-blue-600">Planejado (Lote)</div>
                            </div>
                            <div class="bg-green-50 rounded-lg p-3 text-center">
                                <div class="text-2xl font-bold text-green-700">${(Number(plan.total_produzido) || 0).toLocaleString('pt-BR')}</div>
                                <div class="text-xs text-green-600">Executado Total</div>
                            </div>
                            <div class="bg-amber-50 rounded-lg p-3 text-center">
                                <div class="text-2xl font-bold text-amber-700">${Math.max(0, (Number(plan.order_lot_size) || Number(plan.lot_size) || 0) - (Number(plan.total_produzido) || 0)).toLocaleString('pt-BR')}</div>
                                <div class="text-xs text-amber-600">Faltante</div>
                            </div>
                        </div>
                        
                        <h4 class="font-semibold text-gray-700 mb-2">Lançamentos (${lancamentos.length})</h4>
                        <div class="border rounded-lg overflow-hidden max-h-64 overflow-y-auto">
                            <table class="w-full text-sm">
                                <thead class="bg-gray-100 sticky top-0">
                                    <tr>
                                        <th class="px-3 py-2 text-left text-gray-600">Data/Hora</th>
                                        <th class="px-3 py-2 text-center text-gray-600">Turno</th>
                                        <th class="px-3 py-2 text-right text-gray-600">Quantidade</th>
                                        <th class="px-3 py-2 text-left text-gray-600">Operador</th>
                                    </tr>
                                </thead>
                                <tbody class="divide-y">
                                    ${lancamentos.length > 0 ? lancamentos.map(l => `
                                        <tr class="hover:bg-gray-50">
                                            <td class="px-3 py-2 text-gray-700">${l.data || '-'} ${l.timestamp?.toDate ? l.timestamp.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : ''}</td>
                                            <td class="px-3 py-2 text-center"><span class="px-2 py-0.5 rounded text-xs font-semibold bg-gray-100">${l.turno || l.shift || '-'}</span></td>
                                            <td class="px-3 py-2 text-right font-semibold text-green-700">${(Number(l.produzido) || Number(l.quantity) || 0).toLocaleString('pt-BR')}</td>
                                            <td class="px-3 py-2 text-gray-600">${l.registradoPorNome || l.operador || '-'}</td>
                                        </tr>
                                    `).join('') : '<tr><td colspan="4" class="px-4 py-8 text-center text-gray-400">Nenhum lançamento encontrado</td></tr>'}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div class="border-t px-5 py-3 bg-gray-50 flex justify-end">
                        <button class="modal-close bg-gray-200 hover:bg-gray-300 text-gray-700 px-4 py-2 rounded-lg font-medium transition">Fechar</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            lucide.createIcons();
            
            modal.querySelectorAll('.modal-close').forEach(btn => {
                btn.addEventListener('click', () => modal.remove());
            });
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
            
        } catch (error) {
            alert('Erro ao carregar detalhes: ' + error.message);
        }
    }

    // ==================== FIM ADMINISTRAÇÃO DE DADOS ====================

    let historicoCurrentPage = 0;
    let historicoPageSize = 50;
    let historicoLastDoc = null;
    let historicoFirstDoc = null;
    let historicoDataSelecionada = null; // 'hoje', 'ontem' ou data específica
    let historicoSetupDone = false; // Flag para evitar setup duplicado

    function setupHistoricoSistema() {
        // Evitar configuração duplicada de event listeners
        if (historicoSetupDone) {
            // Apenas recarregar os dados
            carregarHistorico();
            return;
        }
        historicoSetupDone = true;

        const btnHoje = document.getElementById('historico-hoje');
        const btnOntem = document.getElementById('historico-ontem');
        const dataEspecifica = document.getElementById('historico-data-especifica');
        const btnRefresh = document.getElementById('historico-refresh');
        const btnPrev = document.getElementById('historico-prev');
        const btnNext = document.getElementById('historico-next');

        // Função para atualizar visual dos botões
        function atualizarBotaoAtivo(ativo) {
            if (btnHoje) {
                btnHoje.className = ativo === 'hoje' 
                    ? 'flex-1 px-3 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition'
                    : 'flex-1 px-3 py-2.5 bg-white border border-gray-200 rounded-lg text-sm font-medium hover:bg-gray-50 transition';
            }
            if (btnOntem) {
                btnOntem.className = ativo === 'ontem'
                    ? 'flex-1 px-3 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition'
                    : 'flex-1 px-3 py-2.5 bg-white border border-gray-200 rounded-lg text-sm font-medium hover:bg-gray-50 transition';
            }
            if (dataEspecifica && ativo !== 'hoje' && ativo !== 'ontem') {
                dataEspecifica.classList.add('ring-2', 'ring-blue-500');
            } else if (dataEspecifica) {
                dataEspecifica.classList.remove('ring-2', 'ring-blue-500');
            }
        }

        // Definir data padrão como hoje
        historicoDataSelecionada = new Date().toISOString().split('T')[0];
        atualizarBotaoAtivo('hoje');

        // Evento botão Hoje
        if (btnHoje) btnHoje.addEventListener('click', () => {
            historicoDataSelecionada = new Date().toISOString().split('T')[0];
            if (dataEspecifica) dataEspecifica.value = '';
            atualizarBotaoAtivo('hoje');
            historicoCurrentPage = 0;
            historicoLastDoc = null;
            carregarHistorico();
        });

        // Evento botão Ontem
        if (btnOntem) btnOntem.addEventListener('click', () => {
            const ontem = new Date();
            ontem.setDate(ontem.getDate() - 1);
            historicoDataSelecionada = ontem.toISOString().split('T')[0];
            if (dataEspecifica) dataEspecifica.value = '';
            atualizarBotaoAtivo('ontem');
            historicoCurrentPage = 0;
            historicoLastDoc = null;
            carregarHistorico();
        });

        // Evento seleção de data específica
        if (dataEspecifica) dataEspecifica.addEventListener('change', () => {
            if (dataEspecifica.value) {
                historicoDataSelecionada = dataEspecifica.value;
                atualizarBotaoAtivo('especifica');
                historicoCurrentPage = 0;
                historicoLastDoc = null;
                carregarHistorico();
            }
        });
        
        if (btnRefresh) btnRefresh.addEventListener('click', () => {
            historicoCurrentPage = 0;
            historicoLastDoc = null;
            carregarHistorico();
        });

        if (btnPrev) btnPrev.addEventListener('click', () => {
            if (historicoCurrentPage > 0) {
                historicoCurrentPage--;
                carregarHistorico('prev');
            }
        });

        if (btnNext) btnNext.addEventListener('click', () => {
            historicoCurrentPage++;
            carregarHistorico('next');
        });

        // Event listeners para os filtros
        const tipoAcaoSelect = document.getElementById('historico-tipo-acao');
        const usuarioInput = document.getElementById('historico-usuario');
        const maquinaInput = document.getElementById('historico-maquina');

        if (tipoAcaoSelect) {
            tipoAcaoSelect.addEventListener('change', () => {
                historicoCurrentPage = 0;
                historicoLastDoc = null;
                carregarHistorico();
            });
        }

        // Debounce para inputs de texto (evita muitas requisições)
        let debounceTimer = null;
        const debounceCarregar = () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                historicoCurrentPage = 0;
                historicoLastDoc = null;
                carregarHistorico();
            }, 500);
        };

        if (usuarioInput) {
            usuarioInput.addEventListener('input', debounceCarregar);
        }

        if (maquinaInput) {
            maquinaInput.addEventListener('input', debounceCarregar);
        }

        // Botão para gerar dados de teste
        const btnTeste = document.getElementById('historico-teste');
        if (btnTeste) btnTeste.addEventListener('click', async () => {
            try {
                btnTeste.disabled = true;
                btnTeste.textContent = 'Gerando...';
                
                const usuario = window.authSystem?.getCurrentUser();
                const now = new Date();
                const dataHoje = now.toISOString().split('T')[0];
                
                // Criar alguns registros de teste
                const testeLogs = [
                    { acao: 'LANÇAMENTO DE PRODUÇÃO', tipo: 'producao', descricao: 'Produção de teste - 500 peças', maquina: 'H-01', detalhes: { quantidade: 500, turno: 1 } },
                    { acao: 'ATIVAÇÃO DE ORDEM', tipo: 'ordem', descricao: 'Ordem OP-12345 ativada', maquina: 'H-05', detalhes: { orderNumber: 'OP-12345' } },
                    { acao: 'LANÇAMENTO DE PERDA', tipo: 'perda', descricao: 'Perda registrada - 20 peças', maquina: 'H-11', detalhes: { quantidade: 20, motivo: 'Material fora de especificação' } },
                    { acao: 'REGISTRO DE PARADA', tipo: 'parada', descricao: 'Parada por manutenção - 45min', maquina: 'H-01', detalhes: { duracao: 45, motivo: 'Manutenção preventiva' } },
                ];
                
                for (const log of testeLogs) {
                    await db.collection('system_logs').add({
                        ...log,
                        usuario: usuario?.name || 'Teste',
                        userId: usuario?.id || null,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        timestampLocal: now.toISOString(),
                        data: dataHoje,
                        hora: now.toTimeString().split(' ')[0]
                    });
                }
                
                showNotification('✅ 4 registros de teste criados!', 'success');
                carregarHistorico();
            } catch (error) {
                console.error('Erro ao gerar teste:', error);
                showNotification('Erro ao gerar dados de teste', 'error');
            } finally {
                btnTeste.disabled = false;
                btnTeste.innerHTML = '<i data-lucide="plus" class="w-4 h-4"></i> Gerar Teste';
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        });

        // Carregar dados iniciais (hoje)
        carregarHistorico();
    }

    async function carregarHistorico(direction = 'first') {
        const tbody = document.getElementById('historico-tbody');
        if (!tbody) return;

        tbody.innerHTML = `
            <tr>
                <td colspan="6" class="px-4 py-10 text-center text-gray-400">
                    <i data-lucide="loader-2" class="w-10 h-10 mx-auto mb-3 animate-spin opacity-50"></i>
                    <p>Carregando histórico...</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        try {
            const dataSelecionada = historicoDataSelecionada || new Date().toISOString().split('T')[0];
            const tipoAcao = document.getElementById('historico-tipo-acao')?.value;
            const usuarioFiltro = document.getElementById('historico-usuario')?.value?.toLowerCase();
            const maquinaFiltro = document.getElementById('historico-maquina')?.value?.toLowerCase();

            // Construir query base - filtra apenas pela data selecionada
            // Nota: ordenação será feita localmente para evitar necessidade de índice composto
            let query = db.collection('system_logs')
                .where('data', '==', dataSelecionada)
                .limit(500); // Buscar mais registros e ordenar localmente

            const snapshot = await query.get();
            
            if (snapshot.empty) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" class="px-4 py-10 text-center text-gray-400">
                            <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                            <p>Nenhum registro encontrado para a data selecionada</p>
                        </td>
                    </tr>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                atualizarEstatisticasHistorico([]);
                return;
            }

            // Converter para array e ordenar localmente por timestamp (mais recente primeiro)
            let registros = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            registros.sort((a, b) => {
                const tsA = a.timestamp?.toDate?.() || new Date(a.timestampLocal || 0);
                const tsB = b.timestamp?.toDate?.() || new Date(b.timestampLocal || 0);
                return tsB - tsA; // Ordem decrescente
            });

            // Aplicar filtros locais
            if (tipoAcao) {
                registros = registros.filter(r => r.tipo === tipoAcao);
            }
            if (usuarioFiltro) {
                registros = registros.filter(r => (r.usuario || '').toLowerCase().includes(usuarioFiltro));
            }
            if (maquinaFiltro) {
                registros = registros.filter(r => (r.maquina || '').toLowerCase().includes(maquinaFiltro));
            }

            // Atualizar estatísticas antes de paginar
            atualizarEstatisticasHistorico(registros);

            tbody.innerHTML = '';

            if (registros.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" class="px-4 py-10 text-center text-gray-400">
                            <i data-lucide="filter-x" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                            <p>Nenhum registro corresponde aos filtros aplicados</p>
                        </td>
                    </tr>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            registros.forEach(log => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 transition-colors';
                
                const tipoInfo = getTipoInfo(log.tipo);
                const dataHora = formatarDataHoraLog(log);
                const detalhesStr = formatarDetalhes(log.detalhes);
                
                row.innerHTML = `
                    <td class="px-4 py-3 text-sm text-gray-600 whitespace-nowrap">${dataHora}</td>
                    <td class="px-4 py-3">
                        <span class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-medium ${tipoInfo.class}">
                            ${tipoInfo.icon} ${tipoInfo.label}
                        </span>
                    </td>
                    <td class="px-4 py-3 text-sm text-gray-800">${log.descricao || log.acao || '-'}</td>
                    <td class="px-4 py-3 text-sm font-medium text-blue-600">${log.maquina || '-'}</td>
                    <td class="px-4 py-3 text-sm text-gray-600">${log.usuario || '-'}</td>
                    <td class="px-4 py-3 text-xs text-gray-500 max-w-xs truncate" title="${detalhesStr}">${detalhesStr || '-'}</td>
                `;
                
                tbody.appendChild(row);
            });

            // Atualizar info de paginação
            const info = document.getElementById('historico-info');
            if (info) {
                info.textContent = `Mostrando ${registros.length} registros`;
            }

            // Esconder botões de paginação (não necessário com ordenação local)
            const btnPrev = document.getElementById('historico-prev');
            const btnNext = document.getElementById('historico-next');
            if (btnPrev) btnPrev.style.display = 'none';
            if (btnNext) btnNext.style.display = 'none';

            if (typeof lucide !== 'undefined') lucide.createIcons();

        } catch (error) {
            console.error('[HISTORICO] Erro ao carregar:', error);
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="px-4 py-10 text-center text-red-400">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                        <p>Erro ao carregar: ${error.message}</p>
                    </td>
                </tr>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    function getTipoInfo(tipo) {
        const tipos = {
            'producao': { label: 'Produção', icon: '📦', class: 'bg-green-100 text-green-800' },
            'perda': { label: 'Perda', icon: '⚠️', class: 'bg-orange-100 text-orange-800' },
            'parada': { label: 'Parada', icon: '⏸️', class: 'bg-red-100 text-red-800' },
            'ordem': { label: 'Ordem', icon: '📋', class: 'bg-blue-100 text-blue-800' },
            'ordem_ativada': { label: 'Ordem Ativada', icon: '✅', class: 'bg-blue-100 text-blue-800' },
            'ordem_finalizada': { label: 'Ordem Finalizada', icon: '🏁', class: 'bg-purple-100 text-purple-800' },
            'ordem_criada': { label: 'Ordem Criada', icon: '📋', class: 'bg-indigo-100 text-indigo-800' },
            'exclusao': { label: 'Exclusão', icon: '🗑️', class: 'bg-red-100 text-red-800' },
            'edicao': { label: 'Edição', icon: '✏️', class: 'bg-yellow-100 text-yellow-800' },
            'login': { label: 'Login', icon: '🔐', class: 'bg-emerald-100 text-emerald-800' },
            'logout': { label: 'Logout', icon: '🚪', class: 'bg-gray-100 text-gray-800' },
            'ciclo_cavidade': { label: 'Ciclo/Cavidade', icon: '⚙️', class: 'bg-cyan-100 text-cyan-800' },
            'acompanhamento': { label: 'Acompanhamento', icon: '📊', class: 'bg-violet-100 text-violet-800' },
            'planejamento': { label: 'Planejamento', icon: '📅', class: 'bg-teal-100 text-teal-800' },
            'qualidade': { label: 'Qualidade', icon: '✔', class: 'bg-sky-100 text-sky-800' },
            'retrabalho': { label: 'Retrabalho', icon: '🔄', class: 'bg-amber-100 text-amber-800' }
        };
        return tipos[tipo] || { label: tipo || 'Outro', icon: '📝', class: 'bg-gray-100 text-gray-800' };
    }

    function formatarDataHoraLog(log) {
        if (log.timestamp?.toDate) {
            const d = log.timestamp.toDate();
            return d.toLocaleString('pt-BR');
        }
        if (log.timestampLocal) {
            return new Date(log.timestampLocal).toLocaleString('pt-BR');
        }
        return `${log.data || ''} ${log.hora || ''}`;
    }

    function formatarDetalhes(detalhes) {
        if (!detalhes || typeof detalhes !== 'object') return '';
        
        const partes = [];
        if (detalhes.quantidade) partes.push(`Qtd: ${detalhes.quantidade}`);
        if (detalhes.op) partes.push(`OP: ${detalhes.op}`);
        if (detalhes.produto) partes.push(`Prod: ${detalhes.produto}`);
        if (detalhes.motivo) partes.push(`Motivo: ${detalhes.motivo}`);
        if (detalhes.duracao) partes.push(`Dur: ${detalhes.duracao}min`);
        if (detalhes.turno) partes.push(`T${detalhes.turno}`);
        
        return partes.join(' | ') || JSON.stringify(detalhes).substring(0, 100);
    }

    function atualizarEstatisticasHistorico(registros) {
        const total = document.getElementById('historico-total');
        const producao = document.getElementById('historico-producao-count');
        const paradas = document.getElementById('historico-paradas-count');
        const ordens = document.getElementById('historico-ordens-count');
        const exclusoes = document.getElementById('historico-exclusoes-count');

        if (total) total.textContent = registros.length;
        if (producao) producao.textContent = registros.filter(r => r.tipo === 'producao').length;
        if (paradas) paradas.textContent = registros.filter(r => r.tipo === 'parada').length;
        if (ordens) ordens.textContent = registros.filter(r => r.tipo === 'ordem' || r.tipo?.startsWith('ordem')).length;
        if (exclusoes) exclusoes.textContent = registros.filter(r => r.tipo === 'exclusao' || (r.acao && r.acao.includes('EXCLUSÃO'))).length;
    }

    // ==================== FIM HISTÓRICO DO SISTEMA ====================

    function openExtendedDowntimeModal() {
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        const contextMachine = document.querySelector('#extended-downtime-modal .context-machine');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';

        const today = getProductionDateString();
        const ds = document.getElementById('extended-downtime-date-start');
        const de = document.getElementById('extended-downtime-date-end');
        
        if (ds && !ds.value) ds.value = today;
        if (de && !de.value) de.value = today;

        // Attach event listeners
        const dateStart = document.getElementById('extended-downtime-date-start');
        const dateEnd = document.getElementById('extended-downtime-date-end');
        const durationDisplay = document.getElementById('extended-downtime-duration');

        const updateDuration = () => {
            if (dateStart.value && dateEnd.value) {
                const start = new Date(dateStart.value);
                const end = new Date(dateEnd.value);
                const diffMs = end - start;
                const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                const diffDays = Math.floor(diffHours / 24);
                
                if (diffDays > 0) {
                    durationDisplay.textContent = `${diffDays} dia(s) e ${diffHours % 24}h`;
                } else {
                    durationDisplay.textContent = `${diffHours}h`;
                }
            }
        };

        dateStart.removeEventListener('change', updateDuration);
        dateEnd.removeEventListener('change', updateDuration);
        dateStart.addEventListener('change', updateDuration);
        dateEnd.addEventListener('change', updateDuration);
        updateDuration();

        openModal('extended-downtime-modal');
    }

    async function handleExtendedDowntimeSubmit(e) {
        e.preventDefault();

        if (!selectedMachineData) {
            alert('Máquina não selecionada.');
            return;
        }

        const type = document.getElementById('extended-downtime-type').value;
        const dateStart = document.getElementById('extended-downtime-date-start').value;
        const dateEnd = document.getElementById('extended-downtime-date-end').value;
        const timeStart = document.getElementById('extended-downtime-time-start').value || '00:00';
        const timeEnd = document.getElementById('extended-downtime-time-end').value || '23:59';
        const reason = document.getElementById('extended-downtime-reason').value || '';

        if (!type || !dateStart || !dateEnd) {
            alert('Preencha os campos obrigatórios.');
            return;
        }

        try {
            const startDateTime = new Date(`${dateStart}T${timeStart}`);
            const endDateTime = new Date(`${dateEnd}T${timeEnd}`);
            const durationMinutes = Math.floor((endDateTime - startDateTime) / (1000 * 60));

            const downtimeData = {
                machine_id: selectedMachineData.machine,
                type: type,
                reason: reason,
                start_date: dateStart,
                end_date: dateEnd,
                start_time: timeStart,
                end_time: timeEnd,
                start_datetime: firebase.firestore.Timestamp.fromDate(startDateTime),
                end_datetime: firebase.firestore.Timestamp.fromDate(endDateTime),
                duration_minutes: durationMinutes,
                status: 'registered',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                createdBy: getActiveUser()?.name || 'Sistema',
                shift: getCurrentShift(startDateTime),
                date: dateStart
            };

            await db.collection('extended_downtime_logs').add(downtimeData);

            alert('Parada longa registrada com sucesso!');
            closeModal('extended-downtime-modal');
            
            // Clear form
            document.getElementById('extended-downtime-type').value = '';
            document.getElementById('extended-downtime-reason').value = '';
            document.getElementById('extended-downtime-time-start').value = '';
            document.getElementById('extended-downtime-time-end').value = '';

        } catch (error) {
            console.error('Erro ao registrar parada longa:', error);
            alert('Erro ao registrar parada longa: ' + error.message);
        }
    }

    // ============================================================
    // ATUALIZAÇÃO AUTOMÁTICA DE PARADAS LONGAS (a cada 30 minutos)
    // ============================================================
    
    /**
     * Inicia o timer de atualização automática de paradas longas ativas
     * Atualiza o campo duration_minutes no Firebase a cada 30 minutos
     */
    function startExtendedDowntimeAutoUpdate() {
        // Limpar timer anterior se existir
        if (extendedDowntimeUpdateTimer) {
            clearInterval(extendedDowntimeUpdateTimer);
        }
        
        console.log('[PARADAS-LONGAS] Iniciando atualização automática a cada 30 minutos');
        
        // Executar imediatamente na primeira vez
        updateActiveExtendedDowntimes();
        
        // Agendar execução a cada 30 minutos
        extendedDowntimeUpdateTimer = setInterval(() => {
            updateActiveExtendedDowntimes();
        }, EXTENDED_DOWNTIME_UPDATE_INTERVAL);
    }
    
    /**
     * Atualiza o tempo de todas as paradas longas ativas no Firebase
     */
    async function updateActiveExtendedDowntimes() {
        try {
            console.log('[PARADAS-LONGAS] Atualizando tempo de paradas ativas...');
            
            // Buscar todas as paradas ativas
            const snapshot = await db.collection('extended_downtime_logs')
                .where('status', '==', 'active')
                .get();
            
            if (snapshot.empty) {
                console.log('[PARADAS-LONGAS] Nenhuma parada ativa para atualizar');
                return;
            }
            
            const now = new Date();
            const batch = db.batch();
            let updatedCount = 0;
            
            snapshot.docs.forEach(doc => {
                const data = doc.data();
                
                // Calcular duração atual
                let startDatetime;
                if (data.start_datetime?.toDate) {
                    startDatetime = data.start_datetime.toDate();
                } else if (data.start_date && data.start_time) {
                    startDatetime = new Date(`${data.start_date}T${data.start_time}:00`);
                } else {
                    console.warn('[PARADAS-LONGAS] Registro sem data de início válida:', doc.id);
                    return;
                }
                
                const durationMinutes = Math.floor((now - startDatetime) / (1000 * 60));
                
                // Atualizar no batch
                batch.update(doc.ref, {
                    duration_minutes: durationMinutes,
                    last_duration_update: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                updatedCount++;
                
                console.log(`[PARADAS-LONGAS] ${data.machine_id || 'N/A'}: ${Math.floor(durationMinutes/60)}h ${durationMinutes % 60}m`);
            });
            
            if (updatedCount > 0) {
                await batch.commit();
                console.log(`[PARADAS-LONGAS] ✅ ${updatedCount} parada(s) atualizada(s)`);
            }
            
        } catch (error) {
            console.error('[PARADAS-LONGAS] Erro ao atualizar paradas ativas:', error);
        }
    }
    
    /**
     * Para o timer de atualização automática
     */
    function stopExtendedDowntimeAutoUpdate() {
        if (extendedDowntimeUpdateTimer) {
            clearInterval(extendedDowntimeUpdateTimer);
            extendedDowntimeUpdateTimer = null;
            console.log('[PARADAS-LONGAS] Timer de atualização automática parado');
        }
    }

    async function handleExtendedDowntimeFormSubmit(e) {
        e.preventDefault();

        const machineSelect = document.getElementById('extended-downtime-machine');
        const categorySelect = document.getElementById('extended-downtime-category');
        const reasonSelect = document.getElementById('extended-downtime-reason');
        const startDateInput = document.getElementById('extended-downtime-start-date');
        const startTimeInput = document.getElementById('extended-downtime-custom-time');
        const statusDiv = document.getElementById('extended-downtime-status');
        const submitBtn = document.getElementById('extended-downtime-submit');

        // SINGLE MACHINE (not array)
        const selectedMachine = machineSelect?.value?.trim() || '';
        const category = categorySelect?.value?.trim() || '';
        const reason = reasonSelect?.value?.trim() || '';
        const selectedDate = startDateInput?.value || '';
        const selectedTime = startTimeInput?.value || '';

        console.log('[PARADAS-LONGAS] Registrando parada ATIVA:', { machine: selectedMachine, category, reason, date: selectedDate, time: selectedTime });

        // Validação
        if (!selectedMachine || !category || !reason) {
            const missing = [];
            if (!selectedMachine) missing.push('máquina');
            if (!category) missing.push('categoria');
            if (!reason) missing.push('motivo');
            
            statusDiv.textContent = `❌ Preencha: ${missing.join(', ')}`;
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            return;
        }

        // Validar data e hora
        if (!selectedDate || !selectedTime) {
            statusDiv.textContent = `❌ Preencha a data e hora de início`;
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            return;
        }

        try {
            submitBtn.disabled = true;
            statusDiv.textContent = 'Registrando parada...';
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-blue-600';

            // Criar data/hora a partir dos inputs
            const [hours, minutes] = selectedTime.split(':');
            const startDateTime = new Date(selectedDate + 'T' + selectedTime + ':00');
            
            console.log('[PARADAS-LONGAS] Data/hora selecionada:', { date: selectedDate, time: selectedTime, datetime: startDateTime });
            
            const userName = getActiveUser()?.name || 'Sistema';
            const normalizedMachineId = normalizeMachineId(selectedMachine);
            
            // Criar um ÚNICO documento para esta parada
            const downtimeData = {
                machine_id: normalizedMachineId,
                category: category,  // Nova campo de categoria
                type: reason,  // Usar reason como tipo (vem da lista de motivos)
                reason: reason,  // Manter também como reason para compatibilidade
                
                // Data/hora de início = SELECIONADA pelo usuário
                start_date: selectedDate,
                start_time: selectedTime,
                start_datetime: firebase.firestore.Timestamp.fromDate(startDateTime),
                
                // Data/hora de fim: NOT SET (vai ser preenchido ao finalizar)
                end_date: null,
                end_time: null,
                end_datetime: null,
                
                // Status: ATIVA (não finalized yet)
                status: 'active',
                
                // Auditoria
                createdBy: userName,
                shift: getCurrentShift(startDateTime),
                date: selectedDate
            };

            // Verificar se é edição ou criação
            const editingId = submitBtn.dataset.editingId;
            let docRef;
            
            if (editingId) {
                // ATUALIZAÇÃO de registro existente
                downtimeData.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                downtimeData.updatedBy = userName;
                await db.collection('extended_downtime_logs').doc(editingId).update(downtimeData);
                docRef = { id: editingId };
                
                console.log('[PARADAS-LONGAS] Parada atualizada com sucesso:', {
                    recordId: editingId,
                    machine: normalizedMachineId,
                    startTime: `${selectedDate} ${selectedTime}`
                });
                
                statusDiv.textContent = `✅ Parada atualizada para ${normalizedMachineId}`;
                
                // Limpar modo de edição
                delete submitBtn.dataset.editingId;
                submitBtn.innerHTML = '<i data-lucide="pause-circle" class="w-5 h-5"></i><span>🚨 REGISTRAR PARADA</span>';
            } else {
                // CRIAÇÃO de novo registro
                downtimeData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                docRef = await db.collection('extended_downtime_logs').add(downtimeData);
                
                console.log('[PARADAS-LONGAS] Parada registrada com sucesso:', {
                    recordId: docRef.id,
                    machine: normalizedMachineId,
                    startTime: `${selectedDate} ${selectedTime}`
                });

                statusDiv.textContent = `✅ Parada iniciada para ${normalizedMachineId} em ${selectedDate} às ${selectedTime}`;
            }
            
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-green-600';

            // Limpar formulário
            document.getElementById('extended-downtime-form').reset();
            setupExtendedDowntimeTab();  // Reinicializar (vai preencher com data/hora atual)
            
            submitBtn.disabled = false;
            lucide.createIcons();
            
            // Recarregar painel de máquinas (vai mostrar a parada ativa)
            const machinesDowntime = await getAllMachinesDowntimeStatus();
            await renderMachineCards([], [], [], new Set(), machinesDowntime);
            
            // Se lista de paradas está visível, atualizar
            if (typeof loadExtendedDowntimeList === 'function') {
                await loadExtendedDowntimeList();
            }

            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = 'text-sm font-semibold h-5 text-center';
            }, 5000);

        } catch (error) {
            console.error('[PARADAS-LONGAS] Erro ao registrar parada:', error);
            statusDiv.textContent = `❌ Erro: ${error.message}`;
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            submitBtn.disabled = false;
        }
    }

    // Cache de registros para filtragem
    let extendedDowntimeListCache = [];
    
    /**
     * Inicializa os filtros da lista de paradas longas
     */
    function initExtendedDowntimeListFilters() {
        const filterStatus = document.getElementById('extended-downtime-list-filter-status');
        const filterMachine = document.getElementById('extended-downtime-list-filter-machine');
        const refreshBtn = document.getElementById('extended-downtime-list-refresh');
        
        if (filterStatus) {
            filterStatus.addEventListener('change', () => renderFilteredDowntimeList());
        }
        
        if (filterMachine) {
            filterMachine.addEventListener('change', () => renderFilteredDowntimeList());
        }
        
        if (refreshBtn) {
            refreshBtn.addEventListener('click', async () => {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<i data-lucide="loader-2" class="w-3.5 h-3.5 animate-spin"></i> Atualizando...';
                await loadExtendedDowntimeList();
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i data-lucide="refresh-cw" class="w-3.5 h-3.5"></i> Atualizar';
                lucide.createIcons();
            });
        }
    }
    
    /**
     * Popula o filtro de máquinas com as máquinas disponíveis
     */
    function populateMachineFilter(records) {
        const filterMachine = document.getElementById('extended-downtime-list-filter-machine');
        if (!filterMachine) return;
        
        const machines = [...new Set(records.map(r => r.machine_id).filter(Boolean))].sort();
        filterMachine.innerHTML = '<option value="all">Todas Máquinas</option>' +
            machines.map(m => `<option value="${m}">${m}</option>`).join('');
    }
    
    /**
     * Atualiza os contadores do resumo
     */
    function updateDowntimeSummary(records) {
        const activeCount = records.filter(r => r.status === 'active').length;
        const finishedCount = records.filter(r => r.status !== 'active').length;
        const uniqueMachines = new Set(records.map(r => r.machine_id)).size;
        
        // Calcular total de horas
        let totalMinutes = 0;
        records.forEach(r => {
            if (r.status === 'active') {
                // Calcular até agora
                let startDt;
                if (r.start_datetime?.toDate) {
                    startDt = r.start_datetime.toDate();
                } else if (r.start_date && r.start_time) {
                    startDt = new Date(`${r.start_date}T${r.start_time}`);
                }
                if (startDt) {
                    totalMinutes += Math.floor((new Date() - startDt) / (1000 * 60));
                }
            } else {
                totalMinutes += (r.duration_minutes || 0);
            }
        });
        
        const totalHours = Math.floor(totalMinutes / 60);
        
        // Atualizar elementos
        const activeEl = document.getElementById('summary-active-count');
        const finishedEl = document.getElementById('summary-finished-count');
        const hoursEl = document.getElementById('summary-total-hours');
        const machinesEl = document.getElementById('summary-machines-count');
        
        if (activeEl) activeEl.textContent = activeCount;
        if (finishedEl) finishedEl.textContent = finishedCount;
        if (hoursEl) hoursEl.textContent = totalHours > 24 ? `${Math.floor(totalHours/24)}d ${totalHours%24}h` : `${totalHours}h`;
        if (machinesEl) machinesEl.textContent = uniqueMachines;
    }
    
    /**
     * Renderiza a lista filtrada
     */
    function renderFilteredDowntimeList() {
        const filterStatus = document.getElementById('extended-downtime-list-filter-status')?.value || 'all';
        const filterMachine = document.getElementById('extended-downtime-list-filter-machine')?.value || 'all';
        
        let filtered = [...extendedDowntimeListCache];
        
        // Filtrar por status
        if (filterStatus === 'active') {
            filtered = filtered.filter(r => r.status === 'active');
        } else if (filterStatus === 'finished') {
            filtered = filtered.filter(r => r.status !== 'active');
        }
        
        // Filtrar por máquina
        if (filterMachine !== 'all') {
            filtered = filtered.filter(r => r.machine_id === filterMachine);
        }
        
        renderDowntimeListItems(filtered);
    }
    
    /**
     * Renderiza os itens da lista
     */
    function renderDowntimeListItems(records) {
        const listContainer = document.getElementById('extended-downtime-list');
        const emptyDiv = document.getElementById('extended-downtime-list-empty');
        
        if (!listContainer) return;
        
        listContainer.innerHTML = '';
        
        if (records.length === 0) {
            emptyDiv?.classList.remove('hidden');
            return;
        }
        
        emptyDiv?.classList.add('hidden');
        
        const typeLabels = {
            weekend: 'Fim de Semana',
            maintenance: 'Manutenção Preventiva',
            preventive: 'Manutenção Preventiva',
            maintenance_planned: 'Manutenção Programada',
            maintenance_emergency: 'Manutenção Emergencial',
            no_order: 'Sem Pedido',
            commercial: 'Parada Comercial',
            holiday: 'Feriado',
            setup: 'Setup/Troca',
            other: 'Outro'
        };
        const typeColors = {
            weekend: 'bg-gray-100 text-gray-700',
            maintenance: 'bg-blue-100 text-blue-700',
            preventive: 'bg-blue-100 text-blue-700',
            maintenance_planned: 'bg-blue-100 text-blue-700',
            maintenance_emergency: 'bg-red-100 text-red-700',
            no_order: 'bg-orange-100 text-orange-700',
            commercial: 'bg-amber-100 text-amber-700',
            holiday: 'bg-amber-100 text-amber-700',
            setup: 'bg-purple-100 text-purple-700',
            other: 'bg-red-100 text-red-700'
        };

        records.forEach(record => {
            const html = createDowntimeListItemHTML(record, typeLabels, typeColors);
            listContainer.insertAdjacentHTML('beforeend', html);
        });

        // Attach event listeners
        attachExtendedDowntimeEventListeners();
        
        // Attach listeners para botão de finalizar
        document.querySelectorAll('.btn-finish-extended-downtime').forEach(btn => {
            btn.addEventListener('click', handleFinishExtendedDowntime);
        });
        
        lucide.createIcons();
    }
    
    /**
     * Cria o HTML de um item da lista
     */
    function createDowntimeListItemHTML(record, typeLabels, typeColors) {
        const startDate = record.start_date || '-';
        const endDate = record.end_date || '-';
        const startTime = record.start_time || '00:00';
        const endTime = record.end_time || '23:59';
        const machine = record.machine_id || '-';
        const type = record.type || 'other';
        const category = record.category || '';
        const reason = record.reason || '-';
        const isActive = record.status === 'active';
        
        // Calcular duração
        let durationText = '--';
        let durationMinutes = 0;
        
        if (isActive) {
            let startDt;
            if (record.start_datetime?.toDate) {
                startDt = record.start_datetime.toDate();
            } else if (startDate && startTime) {
                startDt = new Date(`${startDate}T${startTime}`);
            }
            if (startDt) {
                durationMinutes = Math.floor((new Date() - startDt) / (1000 * 60));
            }
        } else {
            durationMinutes = record.duration_minutes || 0;
        }
        
        const durationDays = Math.floor(durationMinutes / (24 * 60));
        const durationHours = Math.floor((durationMinutes % (24 * 60)) / 60);
        const durationMins = durationMinutes % 60;
        
        if (durationDays > 0) {
            durationText = `${durationDays}d ${durationHours}h`;
        } else if (durationHours > 0) {
            durationText = `${durationHours}h ${durationMins}min`;
        } else {
            durationText = `${durationMins}min`;
        }
        
        // Cores das categorias
        const categoryColors = {
            'FERRAMENTARIA': 'bg-indigo-100 text-indigo-700',
            'PROCESSO': 'bg-cyan-100 text-cyan-700',
            'COMPRAS': 'bg-green-100 text-green-700',
            'PREPARAÇÃO': 'bg-yellow-100 text-yellow-700',
            'QUALIDADE': 'bg-pink-100 text-pink-700',
            'MANUTENÇÃO': 'bg-blue-100 text-blue-700',
            'PRODUÇÃO': 'bg-orange-100 text-orange-700',
            'SETUP': 'bg-purple-100 text-purple-700',
            'ADMINISTRATIVO': 'bg-slate-100 text-slate-700',
            'PCP': 'bg-teal-100 text-teal-700',
            'COMERCIAL': 'bg-amber-100 text-amber-700',
            'HOKKAIDO': 'bg-gray-200 text-gray-700'
        };
        const categoryColor = categoryColors[category] || 'bg-gray-100 text-gray-600';
        const categoryBadge = category ? `<span class="text-xs px-2 py-0.5 rounded font-medium ${categoryColor}">${category}</span>` : '';
        
        // Badge de status
        const statusBadge = isActive 
            ? '<span class="text-xs px-2 py-0.5 rounded bg-red-100 text-red-700 font-semibold animate-pulse">🔴 ATIVA</span>'
            : '<span class="text-xs px-2 py-0.5 rounded bg-green-100 text-green-700 font-semibold">✅ Finalizada</span>';
        
        // Período formatado
        const periodStart = `${startDate} ${startTime}`;
        const periodEnd = isActive ? '(em andamento)' : `${endDate} ${endTime}`;
        
        // Registrado por
        const createdBy = record.createdBy || record.registered_by || '-';
        const finishedBy = record.finishedBy || record.finished_by || '-';
        
        // Botão de finalizar (apenas para ativas)
        const finishButton = isActive 
            ? `<button class="btn-finish-extended-downtime bg-green-500 hover:bg-green-600 text-white px-3 py-1.5 rounded-lg text-xs font-semibold transition flex items-center gap-1 shadow-sm" data-id="${record.id}" data-machine="${machine}">
                    <i data-lucide="check-circle" class="w-3.5 h-3.5"></i>
                    <span>Finalizar</span>
                </button>` 
            : '';

        return `
            <div class="bg-white border ${isActive ? 'border-red-300 bg-red-50' : 'border-gray-200'} rounded-xl px-4 py-3 shadow-sm hover:shadow-md transition-shadow">
                <!-- Header com máquina e status -->
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 bg-gradient-to-br ${isActive ? 'from-red-500 to-red-600' : 'from-slate-500 to-slate-600'} rounded-lg flex items-center justify-center text-white font-bold text-sm shadow">
                            ${machine.slice(-2)}
                        </div>
                        <div>
                            <span class="font-bold text-gray-800">${machine}</span>
                            <div class="flex items-center gap-2 mt-0.5">
                                ${categoryBadge}
                                ${statusBadge}
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-lg font-bold ${isActive ? 'text-red-600' : 'text-slate-700'}">${durationText}</span>
                    </div>
                </div>
                
                <!-- Detalhes -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-2 mb-3 text-xs">
                    <div class="bg-gray-50 rounded-lg px-2 py-1.5">
                        <span class="text-gray-500 block">Motivo</span>
                        <span class="font-medium text-gray-700 truncate block" title="${reason}">${reason}</span>
                    </div>
                    <div class="bg-gray-50 rounded-lg px-2 py-1.5">
                        <span class="text-gray-500 block">Início</span>
                        <span class="font-medium text-gray-700">${periodStart}</span>
                    </div>
                    <div class="bg-gray-50 rounded-lg px-2 py-1.5">
                        <span class="text-gray-500 block">Fim</span>
                        <span class="font-medium ${isActive ? 'text-red-600' : 'text-gray-700'}">${periodEnd}</span>
                    </div>
                </div>
                
                <!-- Rodapé com ações -->
                <div class="flex items-center justify-between pt-2 border-t border-gray-100">
                    <div class="text-xs text-gray-400">
                        Registrado por: <span class="font-medium">${createdBy}</span>
                        ${!isActive && finishedBy !== '-' ? ` | Finalizado por: <span class="font-medium">${finishedBy}</span>` : ''}
                    </div>
                    <div class="flex items-center gap-2">
                        ${finishButton}
                        <button class="btn-edit-extended-downtime bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded-lg text-xs font-semibold transition flex items-center gap-1 shadow-sm" data-id="${record.id}" data-machine="${machine}" data-type="${type}" data-category="${category}" data-start-date="${startDate}" data-end-date="${endDate}" data-reason="${reason}" data-start-time="${startTime}" data-end-time="${endTime}">
                            <i data-lucide="edit-2" class="w-3.5 h-3.5"></i>
                            <span>Editar</span>
                        </button>
                        <button class="btn-delete-extended-downtime bg-red-500 hover:bg-red-600 text-white px-3 py-1.5 rounded-lg text-xs font-semibold transition flex items-center gap-1 shadow-sm" data-id="${record.id}" data-machine="${machine}">
                            <i data-lucide="trash-2" class="w-3.5 h-3.5"></i>
                            <span>Excluir</span>
                        </button>
                    </div>
                </div>
            </div>
        `;
    }
    
    /**
     * Handler para finalizar uma parada ativa diretamente da lista
     */
    async function handleFinishExtendedDowntime(e) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('finalizar paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        const machine = btn.dataset.machine;
        
        const confirmMsg = `Finalizar parada da máquina ${machine}?\n\nA data/hora atual será registrada como fim da parada.`;
        if (!confirm(confirmMsg)) return;
        
        try {
            btn.disabled = true;
            btn.innerHTML = '<i data-lucide="loader-2" class="w-3.5 h-3.5 animate-spin"></i> Finalizando...';
            
            const now = new Date();
            const endDate = now.toISOString().split('T')[0];
            const endTime = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            // Buscar dados atuais para calcular duração
            const doc = await db.collection('extended_downtime_logs').doc(recordId).get();
            if (!doc.exists) {
                alert('Registro não encontrado!');
                return;
            }
            
            const data = doc.data();
            let startDateTime;
            if (data.start_datetime?.toDate) {
                startDateTime = data.start_datetime.toDate();
            } else if (data.start_date && data.start_time) {
                startDateTime = new Date(`${data.start_date}T${data.start_time}`);
            } else {
                startDateTime = new Date();
            }
            
            const durationMinutes = Math.floor((now - startDateTime) / (1000 * 60));
            const userName = getActiveUser()?.name || 'Sistema';
            
            await db.collection('extended_downtime_logs').doc(recordId).update({
                status: 'finished',
                end_date: endDate,
                end_time: endTime,
                end_datetime: firebase.firestore.Timestamp.fromDate(now),
                duration_minutes: durationMinutes,
                finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                finishedBy: userName,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedBy: userName
            });
            
            console.log('[EXTENDED-DOWNTIME] Parada finalizada:', recordId);
            
            // Registrar log
            registrarLogSistema('FINALIZAÇÃO DE PARADA LONGA', 'parada', {
                recordId: recordId,
                machine: machine,
                endDate: endDate,
                endTime: endTime,
                durationMinutes: durationMinutes
            });
            
            showNotification(`✅ Parada da ${machine} finalizada!`, 'success');
            
            // Recarregar lista
            await loadExtendedDowntimeList();
            
            // Atualizar cards de máquinas
            const machinesDowntime = await getAllMachinesDowntimeStatus();
            await renderMachineCards([], [], [], new Set(), machinesDowntime);
            
        } catch (error) {
            console.error('[EXTENDED-DOWNTIME] Erro ao finalizar:', error);
            alert('Erro ao finalizar parada: ' + error.message);
            btn.disabled = false;
            btn.innerHTML = '<i data-lucide="check-circle" class="w-3.5 h-3.5"></i><span>Finalizar</span>';
            lucide.createIcons();
        }
    }

    async function loadExtendedDowntimeList() {
        const listContainer = document.getElementById('extended-downtime-list');
        const loadingDiv = document.getElementById('extended-downtime-list-loading');
        const emptyDiv = document.getElementById('extended-downtime-list-empty');

        if (!listContainer) return;

        try {
            loadingDiv?.classList.remove('hidden');
            listContainer.innerHTML = '';

            const snap = await db.collection('extended_downtime_logs').orderBy('createdAt', 'desc').limit(100).get();
            const rawRecords = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            const records = [];
            const seenIds = new Set();

            rawRecords.forEach(record => {
                if (!record.id) return;
                if (seenIds.has(record.id)) {
                    console.warn('[EXTENDED-DOWNTIME] Registro duplicado ignorado:', record.id);
                    return;
                }
                seenIds.add(record.id);
                records.push(record);
            });
            
            // Guardar no cache para filtragem
            extendedDowntimeListCache = records;
            
            // Inicializar filtros (apenas na primeira vez)
            initExtendedDowntimeListFilters();
            
            // Popular filtro de máquinas
            populateMachineFilter(records);
            
            // Atualizar resumo
            updateDowntimeSummary(records);

            if (records.length === 0) {
                emptyDiv?.classList.remove('hidden');
                loadingDiv?.classList.add('hidden');
                return;
            }

            emptyDiv?.classList.add('hidden');
            loadingDiv?.classList.add('hidden');

            // Renderizar lista usando a nova função
            renderFilteredDowntimeList();

        } catch (error) {
            console.error('Erro ao carregar paradas longas:', error);
            emptyDiv?.classList.remove('hidden');
            loadingDiv?.classList.add('hidden');
        }
    }

    function attachExtendedDowntimeEventListeners() {
        // Botões de editar
        document.querySelectorAll('.btn-edit-extended-downtime').forEach(btn => {
            btn.removeEventListener('click', handleEditExtendedDowntime);
            btn.addEventListener('click', handleEditExtendedDowntime);
        });

        // Botões de deletar
        document.querySelectorAll('.btn-delete-extended-downtime').forEach(btn => {
            btn.removeEventListener('click', handleDeleteExtendedDowntime);
            btn.addEventListener('click', handleDeleteExtendedDowntime);
        });
    }

    // ============================================================
    // MODAL DE EDIÇÃO COMPLETA DE PARADAS LONGAS (INÍCIO E FIM)
    // ============================================================
    
    /**
     * Inicializa o modal de edição completa de paradas longas
     */
    function initEditExtendedDowntimeModal() {
        const modal = document.getElementById('edit-extended-downtime-modal');
        if (!modal) return;
        
        const closeBtn = document.getElementById('edit-extended-downtime-close');
        const cancelBtn = document.getElementById('edit-downtime-cancel');
        const form = document.getElementById('edit-extended-downtime-form');
        const isActiveCheckbox = document.getElementById('edit-downtime-is-active');
        const categorySelect = document.getElementById('edit-downtime-category');
        
        // Fechar modal
        if (closeBtn) {
            closeBtn.addEventListener('click', () => closeEditDowntimeModal());
        }
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => closeEditDowntimeModal());
        }
        
        // Fechar ao clicar fora
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeEditDowntimeModal();
        });
        
        // Toggle campos de fim quando checkbox "ativa" mudar
        if (isActiveCheckbox) {
            isActiveCheckbox.addEventListener('change', () => {
                toggleEndFields(isActiveCheckbox.checked);
                calculateEditDuration();
            });
        }
        
        // Atualizar duração quando datas/horas mudarem
        ['edit-downtime-start-date', 'edit-downtime-start-time', 'edit-downtime-end-date', 'edit-downtime-end-time'].forEach(id => {
            const el = document.getElementById(id);
            if (el) el.addEventListener('change', calculateEditDuration);
        });
        
        // Atualizar motivos quando categoria mudar
        if (categorySelect) {
            categorySelect.addEventListener('change', () => {
                updateEditDowntimeReasons(categorySelect.value);
            });
        }
        
        // Submit do formulário
        if (form) {
            form.addEventListener('submit', handleEditDowntimeSubmit);
        }
        
        // Popular select de máquinas
        populateEditDowntimeMachines();
        
        console.log('[EDIT-DOWNTIME-MODAL] Modal inicializado');
    }
    
    /**
     * Popula o select de máquinas no modal de edição
     */
    function populateEditDowntimeMachines() {
        const machineSelect = document.getElementById('edit-downtime-machine');
        if (!machineSelect) return;
        
        const validMachines = ['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                               'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                               'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32'];
        
        machineSelect.innerHTML = '<option value="">Selecione a máquina...</option>' +
            validMachines.map(m => `<option value="${m}">${m}</option>`).join('');
    }
    
    /**
     * Atualiza os motivos baseado na categoria selecionada
     */
    function updateEditDowntimeReasons(category) {
        const reasonSelect = document.getElementById('edit-downtime-reason');
        if (!reasonSelect) return;
        
        const motivosPorCategoria = {
            'FERRAMENTARIA': ['CORRETIVA DE MOLDE', 'PREVENTIVA DE MOLDE', 'TROCA DE VERSÃO', 'AJUSTE DE MOLDE'],
            'PROCESSO': ['ABERTURA DE CAVIDADE', 'AJUSTE DE PROCESSO', 'TRY OUT', 'TESTE DE PROCESSO'],
            'COMPRAS': ['FALTA DE INSUMO PLANEJADA', 'FALTA DE INSUMO NÃO PLANEJADA', 'ATRASO FORNECEDOR', 'FALTA DE MATÉRIA PRIMA'],
            'PREPARAÇÃO': ['AGUARDANDO PREPARAÇÃO DE MATERIAL', 'SECAGEM DE MATERIAL', 'PREPARAÇÃO DE PIGMENTO'],
            'QUALIDADE': ['AGUARDANDO CLIENTE/FORNECEDOR', 'LIBERAÇÃO', 'INSPEÇÃO', 'ANÁLISE DE DEFEITO'],
            'MANUTENÇÃO': ['MANUTENÇÃO CORRETIVA', 'MANUTENÇÃO PREVENTIVA', 'MANUTENÇÃO PROGRAMADA', 'MANUTENÇÃO EMERGENCIAL'],
            'PRODUÇÃO': ['FALTA DE OPERADOR', 'TROCA DE COR', 'LIMPEZA', 'ORGANIZAÇÃO'],
            'SETUP': ['INSTALAÇÃO DE MOLDE', 'RETIRADA DE MOLDE', 'TROCA DE MOLDE', 'AQUECIMENTO'],
            'ADMINISTRATIVO': ['FALTA DE ENERGIA', 'FALTA DE ÁGUA', 'QUEDA DE ENERGIA', 'FERIADO', 'FIM DE SEMANA'],
            'PCP': ['SEM PROGRAMAÇÃO', 'SEM PROGRAMAÇÃO-FIM DE SEMANA', 'ESTRATÉGIA PCP', 'AGUARDANDO OP'],
            'COMERCIAL': ['SEM PEDIDO', 'BAIXA DEMANDA', 'PARADA COMERCIAL'],
            'HOKKAIDO': ['HOKKAIDO']
        };
        
        const motivos = motivosPorCategoria[category] || [];
        reasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>' +
            motivos.map(m => `<option value="${m}">${m}</option>`).join('');
    }
    
    /**
     * Toggle dos campos de fim (habilita/desabilita baseado no checkbox "ativa")
     */
    function toggleEndFields(isActive) {
        const endFields = document.getElementById('edit-downtime-end-fields');
        const activeMsg = document.getElementById('edit-downtime-active-msg');
        const endDateInput = document.getElementById('edit-downtime-end-date');
        const endTimeInput = document.getElementById('edit-downtime-end-time');
        
        if (isActive) {
            endFields?.classList.add('opacity-50', 'pointer-events-none');
            activeMsg?.classList.remove('hidden');
            if (endDateInput) endDateInput.required = false;
            if (endTimeInput) endTimeInput.required = false;
        } else {
            endFields?.classList.remove('opacity-50', 'pointer-events-none');
            activeMsg?.classList.add('hidden');
            if (endDateInput) endDateInput.required = true;
            if (endTimeInput) endTimeInput.required = true;
        }
    }
    
    /**
     * Calcula e exibe a duração da parada
     */
    function calculateEditDuration() {
        const startDate = document.getElementById('edit-downtime-start-date')?.value;
        const startTime = document.getElementById('edit-downtime-start-time')?.value;
        const endDate = document.getElementById('edit-downtime-end-date')?.value;
        const endTime = document.getElementById('edit-downtime-end-time')?.value;
        const isActive = document.getElementById('edit-downtime-is-active')?.checked;
        const durationEl = document.getElementById('edit-downtime-duration');
        
        if (!durationEl) return;
        
        if (!startDate || !startTime) {
            durationEl.textContent = '--';
            return;
        }
        
        const start = new Date(`${startDate}T${startTime}`);
        let end;
        
        if (isActive) {
            end = new Date(); // Usar agora como fim
        } else if (endDate && endTime) {
            end = new Date(`${endDate}T${endTime}`);
        } else {
            durationEl.textContent = '--';
            return;
        }
        
        const diffMs = end - start;
        if (diffMs < 0) {
            durationEl.textContent = '⚠️ Inválido';
            durationEl.classList.add('text-red-600');
            return;
        }
        
        durationEl.classList.remove('text-red-600');
        const diffMinutes = Math.floor(diffMs / (1000 * 60));
        const days = Math.floor(diffMinutes / (24 * 60));
        const hours = Math.floor((diffMinutes % (24 * 60)) / 60);
        const minutes = diffMinutes % 60;
        
        let text = '';
        if (days > 0) text += `${days}d `;
        if (hours > 0 || days > 0) text += `${hours}h `;
        text += `${minutes}min`;
        
        if (isActive) text += ' (até agora)';
        
        durationEl.textContent = text.trim();
    }
    
    /**
     * Abre o modal de edição com os dados da parada
     */
    async function openEditDowntimeModal(recordId) {
        const modal = document.getElementById('edit-extended-downtime-modal');
        if (!modal) {
            console.error('[EDIT-DOWNTIME] Modal não encontrado');
            return;
        }
        
        try {
            // Buscar dados atuais do Firebase
            const doc = await db.collection('extended_downtime_logs').doc(recordId).get();
            if (!doc.exists) {
                alert('Registro não encontrado!');
                return;
            }
            
            const data = doc.data();
            console.log('[EDIT-DOWNTIME] Dados carregados:', data);
            
            // Preencher campos
            document.getElementById('edit-downtime-id').value = recordId;
            document.getElementById('edit-downtime-machine').value = data.machine_id || '';
            document.getElementById('edit-downtime-machine-display').textContent = data.machine_id || '-';
            
            // Categoria e motivo
            const categorySelect = document.getElementById('edit-downtime-category');
            if (categorySelect) {
                categorySelect.value = data.category || '';
                updateEditDowntimeReasons(data.category || '');
            }
            
            // Aguardar um pouco para os motivos serem carregados
            setTimeout(() => {
                const reasonSelect = document.getElementById('edit-downtime-reason');
                if (reasonSelect) reasonSelect.value = data.reason || data.type || '';
            }, 100);
            
            // Datas e horas de início
            document.getElementById('edit-downtime-start-date').value = data.start_date || '';
            document.getElementById('edit-downtime-start-time').value = data.start_time || '00:00';
            
            // Status (ativa ou finalizada)
            const isActive = data.status === 'active';
            const isActiveCheckbox = document.getElementById('edit-downtime-is-active');
            const statusBadge = document.getElementById('edit-downtime-status-badge');
            
            if (isActiveCheckbox) isActiveCheckbox.checked = isActive;
            if (statusBadge) {
                if (isActive) {
                    statusBadge.textContent = '🔴 ATIVA';
                    statusBadge.className = 'text-xs px-2 py-1 rounded bg-red-100 text-red-700 font-semibold animate-pulse';
                } else {
                    statusBadge.textContent = '✅ FINALIZADA';
                    statusBadge.className = 'text-xs px-2 py-1 rounded bg-green-100 text-green-700 font-semibold';
                }
            }
            
            // Datas e horas de fim
            document.getElementById('edit-downtime-end-date').value = data.end_date || '';
            document.getElementById('edit-downtime-end-time').value = data.end_time || '';
            
            // Atualizar estado dos campos de fim
            toggleEndFields(isActive);
            
            // Calcular duração
            calculateEditDuration();
            
            // Mostrar modal
            modal.classList.remove('hidden');
            lucide.createIcons();
            
        } catch (error) {
            console.error('[EDIT-DOWNTIME] Erro ao carregar dados:', error);
            alert('Erro ao carregar dados da parada: ' + error.message);
        }
    }
    
    /**
     * Fecha o modal de edição
     */
    function closeEditDowntimeModal() {
        const modal = document.getElementById('edit-extended-downtime-modal');
        if (modal) modal.classList.add('hidden');
        
        // Limpar status
        const statusDiv = document.getElementById('edit-downtime-status');
        if (statusDiv) {
            statusDiv.textContent = '';
            statusDiv.className = 'text-sm font-semibold h-5 text-center';
        }
    }
    
    /**
     * Handler do submit do formulário de edição
     */
    async function handleEditDowntimeSubmit(e) {
        e.preventDefault();
        
        const recordId = document.getElementById('edit-downtime-id')?.value;
        const machine = document.getElementById('edit-downtime-machine')?.value;
        const category = document.getElementById('edit-downtime-category')?.value;
        const reason = document.getElementById('edit-downtime-reason')?.value;
        const startDate = document.getElementById('edit-downtime-start-date')?.value;
        const startTime = document.getElementById('edit-downtime-start-time')?.value;
        const endDate = document.getElementById('edit-downtime-end-date')?.value;
        const endTime = document.getElementById('edit-downtime-end-time')?.value;
        const isActive = document.getElementById('edit-downtime-is-active')?.checked;
        
        const statusDiv = document.getElementById('edit-downtime-status');
        const submitBtn = document.getElementById('edit-downtime-submit');
        
        // Validações
        if (!machine || !category || !reason || !startDate || !startTime) {
            if (statusDiv) {
                statusDiv.textContent = '❌ Preencha todos os campos obrigatórios';
                statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            }
            return;
        }
        
        // Se não está ativa, precisa de data/hora de fim
        if (!isActive && (!endDate || !endTime)) {
            if (statusDiv) {
                statusDiv.textContent = '❌ Informe a data/hora de fim ou marque como ativa';
                statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            }
            return;
        }
        
        // Validar que fim é depois do início (se não está ativa)
        if (!isActive) {
            const start = new Date(`${startDate}T${startTime}`);
            const end = new Date(`${endDate}T${endTime}`);
            if (end <= start) {
                if (statusDiv) {
                    statusDiv.textContent = '❌ Data/hora de fim deve ser posterior ao início';
                    statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
                }
                return;
            }
        }
        
        try {
            if (submitBtn) submitBtn.disabled = true;
            if (statusDiv) {
                statusDiv.textContent = '⏳ Salvando alterações...';
                statusDiv.className = 'text-sm font-semibold h-5 text-center text-blue-600';
            }
            
            const startDateTime = new Date(`${startDate}T${startTime}`);
            let endDateTime = null;
            let durationMinutes = 0;
            
            if (!isActive && endDate && endTime) {
                endDateTime = new Date(`${endDate}T${endTime}`);
                durationMinutes = Math.floor((endDateTime - startDateTime) / (1000 * 60));
            } else if (isActive) {
                // Para paradas ativas, calcular duração até agora
                durationMinutes = Math.floor((new Date() - startDateTime) / (1000 * 60));
            }
            
            const userName = getActiveUser()?.name || 'Sistema';
            
            const updateData = {
                machine_id: machine,
                category: category,
                type: reason,
                reason: reason,
                start_date: startDate,
                start_time: startTime,
                start_datetime: firebase.firestore.Timestamp.fromDate(startDateTime),
                end_date: isActive ? null : endDate,
                end_time: isActive ? null : endTime,
                end_datetime: isActive ? null : (endDateTime ? firebase.firestore.Timestamp.fromDate(endDateTime) : null),
                status: isActive ? 'active' : 'finished',
                duration_minutes: durationMinutes,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedBy: userName,
                shift: getCurrentShift(startDateTime)
            };
            
            // Se estava ativa e foi finalizada agora
            if (!isActive && endDateTime) {
                updateData.finishedAt = firebase.firestore.FieldValue.serverTimestamp();
                updateData.finishedBy = userName;
            }
            
            await db.collection('extended_downtime_logs').doc(recordId).update(updateData);
            
            console.log('[EDIT-DOWNTIME] Parada atualizada:', recordId, updateData);
            
            // Registrar log
            registrarLogSistema('EDIÇÃO DE PARADA LONGA', 'parada', {
                recordId: recordId,
                machine: machine,
                startDate: startDate,
                endDate: endDate,
                status: isActive ? 'active' : 'finished'
            });
            
            if (statusDiv) {
                statusDiv.textContent = '✅ Parada atualizada com sucesso!';
                statusDiv.className = 'text-sm font-semibold h-5 text-center text-green-600';
            }
            
            // Fechar modal após 1.5s
            setTimeout(async () => {
                closeEditDowntimeModal();
                
                // Recarregar listas
                if (typeof loadExtendedDowntimeList === 'function') {
                    await loadExtendedDowntimeList();
                }
                
                // Se análise está visível, recarregar
                if (document.querySelector('#extended-downtime-analysis-list')) {
                    const filters = currentAnalysisFilters || {};
                    await loadExtendedDowntimeAnalysis(filters.startDate, filters.endDate, filters.machine);
                }
                
                // Recarregar cards de máquinas
                const machinesDowntime = await getAllMachinesDowntimeStatus();
                await renderMachineCards([], [], [], new Set(), machinesDowntime);
                
            }, 1500);
            
        } catch (error) {
            console.error('[EDIT-DOWNTIME] Erro ao salvar:', error);
            if (statusDiv) {
                statusDiv.textContent = `❌ Erro: ${error.message}`;
                statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            }
        } finally {
            if (submitBtn) submitBtn.disabled = false;
        }
    }

    /**
     * Handler para editar parada longa - ABRE O MODAL COMPLETO
     */
    async function handleEditExtendedDowntime(e) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('editar paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        
        console.log('[EXTENDED-DOWNTIME] Abrindo modal de edição para:', recordId);
        
        // Abrir o novo modal completo
        await openEditDowntimeModal(recordId);
    }

    async function handleDeleteExtendedDowntime(e) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        const machine = btn.dataset.machine;

        console.log('[EXTENDED-DOWNTIME] Deletando registro:', recordId);

        if (!confirm(`Tem certeza que deseja excluir a parada da máquina ${machine}?`)) {
            return;
        }

        try {
            btn.disabled = true;
            btn.textContent = 'Excluindo...';

            await db.collection('extended_downtime_logs').doc(recordId).delete();

            console.log('[EXTENDED-DOWNTIME] Registro excluído com sucesso');
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE PARADA ESTENDIDA', 'parada', {
                recordId: recordId,
                machine: machine
            });
            
            // Recarregar lista e análise
            await loadExtendedDowntimeList();
            
            // Se estiver na análise, recarregar também
            if (document.querySelector('#extended-downtime-analysis-list')) {
                const { startDate, endDate, machine } = currentAnalysisFilters;
                await loadExtendedDowntimeAnalysis(startDate, endDate, machine);
            }

        } catch (error) {
            console.error('[EXTENDED-DOWNTIME] Erro ao excluir:', error);
            alert('Erro ao excluir parada: ' + error.message);
            btn.disabled = false;
            btn.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4"></i><span>Excluir</span>';
            lucide.createIcons();
        }
    }

    // Handlers dos formulários
    async function handleManualProductionSubmit(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }

        // ✅ POKA-YOKE: Bloquear lançamento se ciclo/cavidades não foram informados
        if (!validateCycleCavityLaunched()) {
            return;
        }
        
        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }
        
        if (!window.authSystem.checkPermissionForAction('add_production')) {
            showNotification('Permissão negada para registrar produção', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }
        
        const dateInput = document.getElementById('manual-production-date');
        const hourInput = document.getElementById('manual-production-hour');
        const shiftSelect = document.getElementById('manual-production-shift');
        const qtyInput = document.getElementById('manual-production-qty');
        const weightInput = document.getElementById('manual-production-weight');
        const useTareCheckbox = document.getElementById('manual-production-use-tare');
        const obsInput = document.getElementById('manual-production-obs');

        // ✅ POKA-YOKE: Operador obrigatório
        const userInput = document.getElementById('manual-production-user');
        const userCod = userInput ? parseInt(userInput.value, 10) : null;
        if (userCod === null || isNaN(userCod) || userInput.value === '') {
            alert('⚠️ Operador obrigatório!\n\nPor favor, digite o código do operador responsável.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const userData = getUserByCode ? getUserByCode(userCod) : null;
        if (!userData) {
            alert('⚠️ Código inválido!\n\nO código digitado não foi encontrado no sistema.\nVerifique e tente novamente.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const nomeUsuario = userData.nomeUsuario;

        const dateValue = dateInput?.value || '';
        const hourValue = hourInput?.value || '';
        const shiftRaw = shiftSelect?.value || '';
        const quantityValue = parseInt(qtyInput?.value || '0', 10);
        const rawWeightGrams = parseWeightInputToGrams(weightInput?.value || '');
        let netWeightGrams = rawWeightGrams;
        const observations = (obsInput?.value || '').trim();
        
        if (!dateValue) {
            showNotification('Informe a data da produção', 'warning');
            dateInput?.focus({ preventScroll: true });
            return;
        }
        
        const hasQty = Number.isFinite(quantityValue) && quantityValue > 0;
        if (!hasQty && rawWeightGrams <= 0) {
            showNotification('Informe quantidade OU peso', 'warning');
            return;
        }

        if (useTareCheckbox?.checked && rawWeightGrams > 0) {
            const tareWeightGrams = getTareWeightForMachine(selectedMachineData?.machine);
            if (tareWeightGrams > 0) {
                netWeightGrams = Math.max(0, rawWeightGrams - tareWeightGrams);
            }
        }

        const hasWeight = netWeightGrams > 0;
        
        if (!hasQty && !hasWeight) {
            showNotification('Peso informado é inválido após descontar a tara', 'warning');
            return;
        }
        
        try {
            const shiftNumeric = parseInt(shiftRaw, 10);
            const turno = [1, 2, 3].includes(shiftNumeric) ? shiftNumeric : getCurrentShift();
            const planId = selectedMachineData?.id || null;
            const currentUser = getActiveUser();

            let resolvedQuantity = hasQty ? quantityValue : 0;
            if (!hasQty && hasWeight) {
                const pieceWeightGrams = getActivePieceWeightGrams();
                if (pieceWeightGrams <= 0) {
                    showNotification('Peso médio da peça não encontrado. Informe a quantidade manualmente ou cadastre o peso no planejamento.', 'warning');
                    return;
                }
                const conversion = calculateQuantityFromGrams(netWeightGrams, pieceWeightGrams);
                if (conversion.error || conversion.quantity <= 0) {
                    showNotification('Não foi possível converter o peso informado em peças. Verifique o valor digitado.', 'warning');
                    return;
                }
                resolvedQuantity = conversion.quantity;
            }

            const netWeightKg = hasWeight ? Number(gramsToKg(netWeightGrams).toFixed(3)) : 0;
            
            const payloadBase = {
                planId,
                data: dateValue,
                turno,
                produzido: resolvedQuantity,
                peso_bruto: netWeightKg,
                refugo_kg: 0,
                perdas: '',
                observacoes: observations,
                machine: selectedMachineData.machine || null,
                mp: selectedMachineData.mp || '',
                orderId: selectedMachineData.order_id || null,
                manual: true,
                horaInformada: hourValue || null,
                registradoPor: currentUser?.username || null,
                registradoPorNome: getCurrentUserName(),
                userCod: userCod,
                nomeUsuario: nomeUsuario
            };
            
            await db.collection('production_entries').add({
                ...payloadBase,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // CRÍTICO: Atualizar total_produzido na OP vinculada e no planejamento
            const linkedOrderId = selectedMachineData.order_id || selectedMachineData.orderId;
            if (linkedOrderId && resolvedQuantity > 0) {
                try {
                    const orderRef = db.collection('production_orders').doc(linkedOrderId);
                    const orderSnap = await orderRef.get();
                    if (orderSnap.exists) {
                        const orderData = orderSnap.data() || {};
                        const currentTotal = coerceToNumber(orderData.total_produzido ?? orderData.totalProduced, 0);
                        const newTotal = currentTotal + resolvedQuantity;
                        await orderRef.update({
                            total_produzido: newTotal,
                            totalProduced: newTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-ORDER] OP ${linkedOrderId} atualizada: total_produzido ${currentTotal} → ${newTotal}`);
                    }
                } catch (orderErr) {
                    console.warn('[SYNC-ORDER] Falha ao atualizar total da OP:', orderErr);
                }
            }

            // Atualizar total_produzido no planejamento também
            if (planId && resolvedQuantity > 0) {
                try {
                    const planRef = db.collection('planning').doc(planId);
                    const planSnap = await planRef.get();
                    if (planSnap.exists) {
                        const planData = planSnap.data() || {};
                        const currentPlanTotal = coerceToNumber(planData.total_produzido, 0);
                        const newPlanTotal = currentPlanTotal + resolvedQuantity;
                        await planRef.update({
                            total_produzido: newPlanTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-PLAN] Plano ${planId} atualizado: total_produzido ${currentPlanTotal} → ${newPlanTotal}`);
                    }
                } catch (planErr) {
                    console.warn('[SYNC-PLAN] Falha ao atualizar total do plano:', planErr);
                }
            }

            // =====================================================
            // INTEGRAÇÃO FERRAMENTARIA - Atualizar batidas do molde
            // =====================================================
            if (resolvedQuantity > 0 && typeof window.atualizarBatidasPorProducao === 'function') {
                try {
                    // Tentar obter product_cod de várias fontes
                    let productCod = selectedMachineData?.product_cod || selectedMachineData?.productCod;
                    
                    // Se não encontrou, buscar do planning
                    if (!productCod && planId) {
                        try {
                            const planDoc = await db.collection('planning').doc(planId).get();
                            if (planDoc.exists) {
                                const planData = planDoc.data();
                                productCod = planData.product_cod || planData.productCod || planData.part_code;
                            }
                        } catch (e) {
                            console.warn('[SYNC-FERRAMENTARIA] Erro ao buscar planning:', e);
                        }
                    }
                    
                    console.log('[SYNC-FERRAMENTARIA] Manual - Dados para integração:', { productCod, resolvedQuantity, planId });
                    
                    if (productCod) {
                        const resultadoBatidas = await window.atualizarBatidasPorProducao(productCod, resolvedQuantity);
                        if (resultadoBatidas.success) {
                            console.log(`[SYNC-FERRAMENTARIA] ✅ Produção Manual - Batidas atualizadas: molde "${resultadoBatidas.molde}", +${resultadoBatidas.batidasAdicionadas} batidas`);
                        } else {
                            console.log(`[SYNC-FERRAMENTARIA] ⚠️ Manual - Batidas não atualizadas:`, resultadoBatidas.reason);
                        }
                    } else {
                        console.log('[SYNC-FERRAMENTARIA] ⚠️ Manual - product_cod não encontrado');
                    }
                } catch (ferramentariaErr) {
                    console.warn('[SYNC-FERRAMENTARIA] Falha ao atualizar batidas (manual):', ferramentariaErr);
                }
            }

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('producao', `Produção manual: ${resolvedQuantity} peças`, {
                    quantidade: resolvedQuantity,
                    maquina: selectedMachineData.machine,
                    op: linkedOrderId || planId,
                    turno: turno,
                    data: dateValue,
                    peso: netWeightKg
                });
            }
            
            closeModal('manual-production-modal');
            await populateMachineSelector();
            await refreshLaunchCharts();
            await loadTodayStats();
            await loadRecentEntries(false);
            
            showNotification('✅ Produção manual registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar produção:', error);
            showNotification('❌ Erro ao registrar produção: ' + error.message, 'error');
        }
    }

    // ✅ POKA-YOKE: Validar se a OP está ativada
    function validateOrderActivated() {
        if (!currentActiveOrder || !currentActiveOrder.id) {
            showNotification('⚠️ ORDEM NÃO ATIVADA! Ative a OP antes de fazer qualquer lançamento.', 'error');
            console.warn('[POKA-YOKE] Tentativa de lançamento bloqueada: OP não ativada');
            return false;
        }
        const status = String(currentActiveOrder.status || '').toLowerCase();
        if (status !== 'ativa' && status !== 'em_andamento') {
            showNotification(`⚠️ OP NÃO ESTÁ ATIVA! Status atual: ${currentActiveOrder.status}. Ative antes de registrar.`, 'error');
            console.warn('[POKA-YOKE] Tentativa de lançamento bloqueada: status inválido -', status);
            return false;
        }
        return true;
    }

    // ✅ POKA-YOKE: Verificar se ciclo/cavidades foram lançados antes de permitir produção/perdas
    function validateCycleCavityLaunched() {
        // Verificar se há dados de máquina selecionada
        if (!selectedMachineData) {
            console.warn('[POKA-YOKE] validateCycleCavityLaunched: selectedMachineData não disponível');
            return true; // Permitir se não houver dados (fallback)
        }

        // Obter turno atual
        const currentShift = typeof getCurrentShift === 'function' ? getCurrentShift() : null;
        if (!currentShift) {
            console.warn('[POKA-YOKE] validateCycleCavityLaunched: turno atual não identificado');
            return true; // Permitir se não conseguir identificar o turno
        }

        // Mapear turno para chave do campo
        const shiftKey = `t${currentShift}`; // t1, t2, t3
        const realCycleField = `real_cycle_${shiftKey}`;
        const activeCavitiesField = `active_cavities_${shiftKey}`;

        // Verificar se ciclo e cavidades foram informados para o turno atual
        const realCycle = selectedMachineData[realCycleField];
        const activeCavities = selectedMachineData[activeCavitiesField];

        const hasCycle = realCycle !== null && realCycle !== undefined && realCycle !== '' && Number(realCycle) > 0;
        const hasCavities = activeCavities !== null && activeCavities !== undefined && activeCavities !== '' && Number(activeCavities) > 0;

        if (!hasCycle || !hasCavities) {
            const turnoLabel = currentShift === 1 ? '1º Turno' : currentShift === 2 ? '2º Turno' : '3º Turno';
            const missing = [];
            if (!hasCycle) missing.push('Ciclo Real');
            if (!hasCavities) missing.push('Cavidades Ativas');

            showNotification(
                `⚠️ CICLO/CAVIDADES NÃO INFORMADO!\n\n` +
                `Informe ${missing.join(' e ')} do ${turnoLabel} antes de fazer lançamentos.\n\n` +
                `Acesse a aba LIDERANÇA → Painel de Lançamento Ciclo/Cavidades`,
                'error'
            );
            console.warn('[POKA-YOKE] Tentativa de lançamento bloqueada: ciclo/cavidades não informados', {
                turno: turnoLabel,
                realCycle,
                activeCavities,
                machine: selectedMachineData.machine
            });
            return false;
        }

        console.log('[POKA-YOKE] validateCycleCavityLaunched: OK', {
            turno: `T${currentShift}`,
            realCycle,
            activeCavities,
            machine: selectedMachineData.machine
        });
        return true;
    }

    //  POKA-YOKE: Verificar se existe OP ativa para a máquina atual
    function isOrderActiveForCurrentMachine() {
        if (!currentActiveOrder || !currentActiveOrder.id) {
            return false;
        }
        const status = String(currentActiveOrder.status || '').toLowerCase();
        return status === 'ativa' || status === 'em_andamento';
    }


    async function handleQuickProductionSubmit(e) {
        e.preventDefault();
        e.stopPropagation();

        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }

        // ✅ POKA-YOKE: Bloquear lançamento se ciclo/cavidades não foram informados
        if (!validateCycleCavityLaunched()) {
            return;
        }


        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }

        if (!window.authSystem.checkPermissionForAction('add_production')) {
            showNotification('Permissão negada para registrar produção', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }

        // ✅ POKA-YOKE: Operador obrigatório
        const userInput = document.getElementById('quick-production-user');
        const userCod = userInput ? parseInt(userInput.value, 10) : null;
        if (userCod === null || isNaN(userCod) || userInput.value === '') {
            alert('⚠️ Operador obrigatório!\n\nPor favor, digite o código do operador responsável.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const userData = getUserByCode ? getUserByCode(userCod) : null;
        if (!userData) {
            alert('⚠️ Código inválido!\n\nO código digitado não foi encontrado no sistema.\nVerifique e tente novamente.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const nomeUsuario = userData.nomeUsuario;

        const qtyInput = document.getElementById('quick-production-qty');
        const weightInput = document.getElementById('quick-production-weight');
        const obsInput = document.getElementById('quick-production-obs');
        const useTareCheckbox = document.getElementById('quick-production-use-tare');

        const quantityValue = parseInt(qtyInput?.value || '0', 10);
        const rawWeightGrams = parseWeightInputToGrams(weightInput?.value || '');
        let netWeightGrams = rawWeightGrams;
        const observations = (obsInput?.value || '').trim();

        const hasQty = Number.isFinite(quantityValue) && quantityValue > 0;

        if (useTareCheckbox?.checked && rawWeightGrams > 0) {
            const tareWeight = getTareWeightForMachine(selectedMachineData?.machine);
            if (tareWeight > 0) {
                netWeightGrams = Math.max(0, rawWeightGrams - tareWeight);
            }
        }

        const hasWeight = netWeightGrams > 0;

        if (!hasQty && !hasWeight) {
            showNotification('Informe quantidade OU peso', 'warning');
            return;
        }

        try {
            const planId = selectedMachineData?.id || null;
            if (!planId) {
                showNotification('Não foi possível identificar o planejamento', 'error');
                return;
            }

            const turno = getCurrentShift();
            const currentUser = getActiveUser();

            let resolvedQuantity = hasQty ? quantityValue : 0;
            if (!hasQty && hasWeight) {
                const pieceWeightGrams = getActivePieceWeightGrams();
                if (pieceWeightGrams <= 0) {
                    showNotification('Peso médio da peça não encontrado. Informe quantidade ou cadastre o peso da peça.', 'warning');
                    return;
                }
                const conversion = calculateQuantityFromGrams(netWeightGrams, pieceWeightGrams);
                if (conversion.error || conversion.quantity <= 0) {
                    showNotification('Não foi possível converter o peso em peças. Verifique o valor informado.', 'warning');
                    return;
                }
                resolvedQuantity = conversion.quantity;
            }

            const netWeightKg = hasWeight ? Number(gramsToKg(netWeightGrams).toFixed(3)) : 0;

            const payloadBase = {
                planId,
                data: getProductionDateString(),
                turno,
                produzido: resolvedQuantity,
                peso_bruto: netWeightKg,
                refugo_kg: 0,
                perdas: '',
                observacoes: observations,
                machine: selectedMachineData.machine || null,
                mp: selectedMachineData.mp || '',
                orderId: selectedMachineData.order_id || null,
                manual: false,
                // Dados do operador responsável
                userCod: userCod,
                nomeUsuario: nomeUsuario,
                registradoPor: currentUser?.username || null,
                registradoPorNome: getCurrentUserName()
            };

            await db.collection('production_entries').add({
                ...payloadBase,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // CRÍTICO: Atualizar total_produzido na OP vinculada e no planejamento
            const linkedOrderId = selectedMachineData.order_id || selectedMachineData.orderId;
            if (linkedOrderId && resolvedQuantity > 0) {
                try {
                    const orderRef = db.collection('production_orders').doc(linkedOrderId);
                    const orderSnap = await orderRef.get();
                    if (orderSnap.exists) {
                        const orderData = orderSnap.data() || {};
                        const currentTotal = coerceToNumber(orderData.total_produzido ?? orderData.totalProduced, 0);
                        const newTotal = currentTotal + resolvedQuantity;
                        await orderRef.update({
                            total_produzido: newTotal,
                            totalProduced: newTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-ORDER] OP ${linkedOrderId} atualizada: total_produzido ${currentTotal} → ${newTotal}`);
                    }
                } catch (orderErr) {
                    console.warn('[SYNC-ORDER] Falha ao atualizar total da OP:', orderErr);
                }
            }

            // Atualizar total_produzido no planejamento também
            if (planId && resolvedQuantity > 0) {
                try {
                    const planRef = db.collection('planning').doc(planId);
                    const planSnap = await planRef.get();
                    if (planSnap.exists) {
                        const planData = planSnap.data() || {};
                        const currentPlanTotal = coerceToNumber(planData.total_produzido, 0);
                        const newPlanTotal = currentPlanTotal + resolvedQuantity;
                        await planRef.update({
                            total_produzido: newPlanTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-PLAN] Plano ${planId} atualizado: total_produzido ${currentPlanTotal} → ${newPlanTotal}`);
                    }
                } catch (planErr) {
                    console.warn('[SYNC-PLAN] Falha ao atualizar total do plano:', planErr);
                }
            }

            // =====================================================
            // INTEGRAÇÃO FERRAMENTARIA - Atualizar batidas do molde
            // =====================================================
            if (resolvedQuantity > 0 && typeof window.atualizarBatidasPorProducao === 'function') {
                try {
                    // Tentar obter product_cod de várias fontes
                    let productCod = selectedMachineData?.product_cod || selectedMachineData?.productCod;
                    
                    // Se não encontrou, buscar do planning
                    if (!productCod && planId) {
                        try {
                            const planDoc = await db.collection('planning').doc(planId).get();
                            if (planDoc.exists) {
                                const planData = planDoc.data();
                                productCod = planData.product_cod || planData.productCod || planData.part_code;
                            }
                        } catch (e) {
                            console.warn('[SYNC-FERRAMENTARIA] Erro ao buscar planning:', e);
                        }
                    }
                    
                    console.log('[SYNC-FERRAMENTARIA] Dados para integração:', { productCod, resolvedQuantity, planId });
                    
                    if (productCod) {
                        const resultadoBatidas = await window.atualizarBatidasPorProducao(productCod, resolvedQuantity);
                        if (resultadoBatidas.success) {
                            console.log(`[SYNC-FERRAMENTARIA] ✅ Batidas atualizadas: molde "${resultadoBatidas.molde}", +${resultadoBatidas.batidasAdicionadas} batidas`);
                        } else {
                            console.log(`[SYNC-FERRAMENTARIA] ⚠️ Batidas não atualizadas:`, resultadoBatidas.reason);
                        }
                    } else {
                        console.log('[SYNC-FERRAMENTARIA] ⚠️ product_cod não encontrado - batidas não atualizadas');
                    }
                } catch (ferramentariaErr) {
                    console.warn('[SYNC-FERRAMENTARIA] Falha ao atualizar batidas:', ferramentariaErr);
                }
            }

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('producao', `Produção rápida: ${resolvedQuantity} peças`, {
                    quantidade: resolvedQuantity,
                    maquina: selectedMachineData.machine,
                    op: linkedOrderId || planId,
                    turno: turno,
                    data: getProductionDateString(),
                    peso: netWeightKg
                });
            }

            closeModal('quick-production-modal');
            
            // Salvar posição do scroll antes de atualizar
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            // Executar atualizações em paralelo para reduzir tempo
            await Promise.all([
                populateMachineSelector(),
                refreshLaunchCharts(),
                loadTodayStats(),
                loadRecentEntries(false)
            ]);
            
            // Restaurar posição do scroll após atualizações
            requestAnimationFrame(() => {
                window.scrollTo({ left: scrollLeft, top: scrollTop, behavior: 'instant' });
            });

            showNotification('✅ Produção rápida registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar produção rápida:', error);
            showNotification('❌ Erro ao registrar produção: ' + error.message, 'error');
        }
    }

    async function handleManualLossesSubmit(e) {
        e.preventDefault();
        e.stopPropagation();

        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!isOrderActiveForCurrentMachine()) {
            showNotification('⚠️ Ative uma OP antes de fazer lançamentos. Vá em "Ordens" e clique em "Ativar" na OP desejada.', 'warning');
            return;
        }

        // ✅ POKA-YOKE: Bloquear lançamento se ciclo/cavidades não foram informados
        if (!validateCycleCavityLaunched()) {
            return;
        }


        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }

        if (!window.authSystem.checkPermissionForAction('add_losses')) {
            showNotification('Permissão negada para registrar perdas', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }

        const dateInput = document.getElementById('manual-losses-date');
        const shiftSelect = document.getElementById('manual-losses-shift');
        const hourInput = document.getElementById('manual-losses-hour');
        const qtyInput = document.getElementById('manual-losses-qty');
        const weightInput = document.getElementById('manual-losses-weight');
        const reasonSelect = document.getElementById('manual-losses-reason');
        const obsInput = document.getElementById('manual-losses-obs');

        // ✅ POKA-YOKE: Operador obrigatório
        const userInput = document.getElementById('manual-losses-user');
        const userCod = userInput ? parseInt(userInput.value, 10) : null;
        if (userCod === null || isNaN(userCod) || userInput.value === '') {
            alert('⚠️ Operador obrigatório!\n\nPor favor, digite o código do operador responsável.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const userData = getUserByCode ? getUserByCode(userCod) : null;
        if (!userData) {
            alert('⚠️ Código inválido!\n\nO código digitado não foi encontrado no sistema.\nVerifique e tente novamente.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const nomeUsuario = userData.nomeUsuario;

        const dateValue = (dateInput?.value || '').trim();
        const shiftRaw = shiftSelect?.value || '';
        const hourValue = (hourInput?.value || '').trim();
        const quantityValue = parseInt(qtyInput?.value || '0', 10);
        const weightValueKg = parseFloat(weightInput?.value || '0');
        let netWeightGrams = kgToGrams(weightValueKg);
        const reasonValue = reasonSelect?.value || '';
        const observations = (obsInput?.value || '').trim();

        if (!dateValue) {
            showNotification('Informe a data da perda', 'warning');
            dateInput?.focus({ preventScroll: true });
            return;
        }

        const hasQuantity = Number.isFinite(quantityValue) && quantityValue > 0;
        const hasWeight = netWeightGrams > 0;

        if (!hasQuantity && !hasWeight) {
            showNotification('Informe quantidade OU peso', 'warning');
            return;
        }

        if (!reasonValue) {
            showNotification('Selecione o motivo da perda', 'warning');
            reasonSelect?.focus({ preventScroll: true });
            return;
        }

        try {
            const planId = selectedMachineData?.id || null;
            if (!planId) {
                showNotification('Não foi possível identificar o planejamento', 'error');
                return;
            }

            const pieceWeightGrams = getActivePieceWeightGrams();
            let refugoQty = hasQuantity ? quantityValue : 0;

            if (!hasQuantity && hasWeight) {
                if (pieceWeightGrams <= 0) {
                    showNotification('Peso médio da peça não encontrado. Informe a quantidade manualmente ou cadastre o peso no planejamento.', 'warning');
                    qtyInput?.focus({ preventScroll: true });
                    return;
                }
                const conversion = calculateQuantityFromGrams(netWeightGrams, pieceWeightGrams);
                refugoQty = conversion.quantity > 0 ? conversion.quantity : 1;
            }

            if (refugoQty <= 0) {
                showNotification('Não foi possível determinar a quantidade de perdas.', 'warning');
                return;
            }

            let pesoTotalKg = hasWeight ? gramsToKg(netWeightGrams) : 0;
            if (pesoTotalKg <= 0 && pieceWeightGrams > 0) {
                pesoTotalKg = (refugoQty * pieceWeightGrams) / 1000;
            }
            pesoTotalKg = Number(pesoTotalKg.toFixed(3));

            const shiftNumeric = parseInt(shiftRaw, 10);
            const turno = [1, 2, 3].includes(shiftNumeric) ? shiftNumeric : getCurrentShift();
            const currentUser = getActiveUser();

            // ✅ NOVO: Buscar tipo de matéria prima do banco de dados
            const mpValue = selectedMachineData.mp || '';
            let tipoMateriaPrima = '';
            if (mpValue && window.materiaPrimaDatabase) {
                const materialFound = window.materiaPrimaDatabase.find(m => String(m.codigo) === String(mpValue));
                if (materialFound) {
                    tipoMateriaPrima = materialFound.descricao;
                }
            }

            const payloadBase = {
                planId,
                data: dateValue,
                turno,
                produzido: 0,
                peso_bruto: 0,
                refugo_kg: Number.isFinite(pesoTotalKg) && pesoTotalKg > 0 ? Number(pesoTotalKg) : 0,
                refugo_qty: refugoQty,
                perdas: reasonValue,
                observacoes: observations,
                machine: selectedMachineData.machine || null,
                mp: mpValue,
                tipoMateriaPrima: tipoMateriaPrima,  // ✅ NOVO: Tipo de matéria prima do banco de dados
                orderId: selectedMachineData.order_id || null,
                manual: true,
                horaInformada: hourValue || null,
                registradoPor: currentUser?.username || null,
                registradoPorNome: getCurrentUserName(),
                userCod: userCod,
                nomeUsuario: nomeUsuario
            };

            await db.collection('production_entries').add({
                ...payloadBase,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('perda', `Perda manual: ${payloadBase.refugo_qty || 0} peças (${payloadBase.refugo_kg || 0}kg)`, {
                    quantidade: payloadBase.refugo_qty,
                    pesoKg: payloadBase.refugo_kg,
                    maquina: selectedMachineData?.machine,
                    motivo: payloadBase.perdas,
                    turno: payloadBase.turno,
                    data: payloadBase.data
                });
            }

            closeModal('manual-losses-modal');
            
            // Salvar posição do scroll antes de atualizar
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            await Promise.all([
                populateMachineSelector(),
                refreshLaunchCharts(),
                loadTodayStats(),
                loadRecentEntries(false)
            ]);
            
            // Restaurar posição do scroll após atualizações
            requestAnimationFrame(() => {
                window.scrollTo({ left: scrollLeft, top: scrollTop, behavior: 'instant' });
            });

            showNotification('✅ Perda manual registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar perda:', error);
            showNotification('❌ Erro ao registrar perda: ' + error.message, 'error');
        }
    }
    
    // Helper: Converte string com vírgula ou ponto em número, normalizando para locale pt-BR
    function parseNumberPtBR(str) {
        if (!str) return 0;
        str = String(str).trim();
        // Remover espaços
        str = str.replace(/\s/g, '');
        // Se tem ambos vírgula e ponto, considerar o último como separador decimal
        const lastComma = str.lastIndexOf(',');
        const lastDot = str.lastIndexOf('.');
        let normalized = str;
        
        if (lastComma > lastDot) {
            // Vírgula é o separador decimal: "1.234,56" → "1234.56"
            normalized = str.replace(/\./g, '').replace(',', '.');
        } else if (lastDot > lastComma) {
            // Ponto é o separador decimal: "1,234.56" ou "1.23" → mantém "1.23"
            normalized = str.replace(/,/g, '');
        } else if (lastComma >= 0) {
            // Só tem vírgula: "1,50" → "1.50"
            normalized = str.replace(',', '.');
        }
        // Caso contrário (só números ou só ponto): mantém como está
        
        const result = parseFloat(normalized) || 0;
        console.log(`[TRACE][parseNumberPtBR] Input: "${str}" → Normalized: "${normalized}" → Result: ${result}`);
        return result;
    }

    async function handleLossesSubmit(e) {
        e.preventDefault();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }

        // ✅ POKA-YOKE: Bloquear lançamento se ciclo/cavidades não foram informados
        if (!validateCycleCavityLaunched()) {
            return;
        }
        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('add_losses')) {
            return;
        }
        
        console.log('[TRACE][handleLossesSubmit] triggered', {
            selectedMachineData,
            currentEditContext
        });

        const quantityInput = document.getElementById('quick-losses-qty');
        const weightInput = document.getElementById('quick-losses-weight');
        const quantity = parseInt(quantityInput.value, 10) || 0;
        // Entrada agora é em GRAMAS diretamente (não mais em kg)
        let weightGrams = parseInt(weightInput.value, 10) || 0;
        const reason = document.getElementById('quick-losses-reason').value;
        const obs = (document.getElementById('quick-losses-obs').value || '').trim();
        
        // ✅ POKA-YOKE: Operador obrigatório
        const userInput = document.getElementById('quick-losses-user');
        const userCod = userInput ? parseInt(userInput.value, 10) : null;
        if (userCod === null || isNaN(userCod) || userInput.value === '') {
            alert('⚠️ Operador obrigatório!\n\nPor favor, digite o código do operador responsável.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const userData = getUserByCode ? getUserByCode(userCod) : null;
        if (!userData) {
            alert('⚠️ Código inválido!\n\nO código digitado não foi encontrado no sistema.\nVerifique e tente novamente.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const nomeUsuario = userData.nomeUsuario;
        
        // Verificar se deve aplicar tara da caixa plástica
        const useTare = document.getElementById('quick-losses-use-tare').checked;
        if (useTare && weightGrams > 0) {
            const tareWeight = getTareWeightForMachine(selectedMachineData?.machine);
            if (tareWeight > 0) {
                weightGrams = Math.max(0, weightGrams - tareWeight);
                console.log(`[TRACE][handleLossesSubmit] Tara aplicada: ${tareWeight}g descontados. Peso líquido: ${weightGrams}g`);
            }
        }

        console.log('[TRACE][handleLossesSubmit] parsed form values', { quantity, weightGrams, reason, obs, useTare });

        if (quantity <= 0 && weightGrams <= 0) {
            alert('Informe a quantidade ou o peso da perda.');
            if (quantityInput) quantityInput.focus({ preventScroll: true });
            else if (weightInput) weightInput.focus({ preventScroll: true });
            return;
        }

        if (!reason) {
            alert('Por favor, selecione o motivo da perda.');
            return;
        }

        // ✅ POKA-YOKE: Observação obrigatória
        if (!obs || obs.length < 3) {
            alert('⚠️ Observação obrigatória!\n\nPor favor, descreva detalhes sobre a perda para garantir rastreabilidade.');
            document.getElementById('quick-losses-obs').focus({ preventScroll: true });
            return;
        }

        // ========================================
        // CONVERSÃO DE PESO PARA PEÇAS
        // ========================================
        let refugoQty = quantity > 0 ? quantity : 0;
        const pieceWeightGrams = getActivePieceWeightGrams();

        if (refugoQty <= 0 && weightGrams > 0) {
            if (pieceWeightGrams <= 0) {
                alert('Não foi possível converter peso para peças. O peso médio da peça não está configurado. Informe a quantidade diretamente.');
                console.warn('[TRACE][handleLossesSubmit] Peso médio não encontrado: selectedMachineData =', selectedMachineData);
                return;
            }
            const conversion = calculateQuantityFromGrams(weightGrams, pieceWeightGrams);
            refugoQty = conversion.quantity > 0 ? conversion.quantity : 1;
            console.log(`[TRACE][handleLossesSubmit] Conversão: ${weightGrams}g  /  ${pieceWeightGrams}g/peça = ${refugoQty} peças`);
            showNotification(`Convertido: ${weightGrams}g = ${refugoQty} peças`, 'info');
        }
        
        console.log('[TRACE][handleLossesSubmit] Perda em peças:', { quantity, weightGrams, refugoQty, pesoMedio: weightGrams > 0 ? (weightGrams / Math.max(refugoQty, 1)) : 0 });

        const isEditing = currentEditContext && currentEditContext.type === 'loss' && currentEditContext.id;
        const originalData = isEditing ? currentEditContext.original : null;

        console.log('[TRACE][handleLossesSubmit] context info', { isEditing, originalData });

        const fallbackPlan = selectedMachineData ? selectedMachineData.id : originalData?.planId;
        const planId = isEditing ? (originalData?.planId || fallbackPlan) : fallbackPlan;

        console.log('[TRACE][handleLossesSubmit] resolved plan', { fallbackPlan, planId });

        if (!planId) {
            alert('Não foi possível identificar o planejamento associado ao lançamento.');
            return;
        }

        const currentShift = getCurrentShift();
        const turno = isEditing ? (originalData?.turno || currentShift) : currentShift;
        const dataReferencia = isEditing ? (originalData?.data || getProductionDateString()) : getProductionDateString();
        const machineRef = isEditing ? (originalData?.machine || selectedMachineData?.machine) : selectedMachineData?.machine;
        const mpValue = isEditing ? (originalData?.mp || selectedMachineData?.mp || '') : (selectedMachineData?.mp || '');

        // ✅ NOVO: Buscar tipo de matéria prima do banco de dados
        let tipoMateriaPrima = '';
        if (mpValue && window.materiaPrimaDatabase) {
            const materialFound = window.materiaPrimaDatabase.find(m => String(m.codigo) === String(mpValue));
            if (materialFound) {
                tipoMateriaPrima = materialFound.descricao;
            }
        }

        // Calcular peso total se necessário (peças  x  peso médio)
        let pesoTotalKg = weightGrams > 0 ? gramsToKg(weightGrams) : 0;
        if (pesoTotalKg <= 0 && refugoQty > 0 && pieceWeightGrams > 0) {
            pesoTotalKg = (refugoQty * pieceWeightGrams) / 1000;
        }
        pesoTotalKg = Number(pesoTotalKg.toFixed(3));

        const payloadBase = {
            planId,
            data: dataReferencia,
            turno,
            produzido: 0,
            peso_bruto: 0,
            refugo_kg: pesoTotalKg,
            refugo_qty: refugoQty,  // SEMPRE em peças
            perdas: reason,
            observacoes: obs,
            machine: machineRef || null,
            mp: mpValue,
            tipoMateriaPrima: tipoMateriaPrima,  // ✅ NOVO: Tipo de matéria prima do banco de dados
            orderId: selectedMachineData?.order_id || null,
            orderNumber: selectedMachineData?.order_number || null,
            userCod: userCod,
            nomeUsuario: nomeUsuario
        };

        console.log('[TRACE][handleLossesSubmit] payloadBase prepared', payloadBase);

        const collectionRef = db.collection('production_entries');
        const successMessage = isEditing ? 'Perda atualizada com sucesso!' : 'Perda registrada com sucesso!';

        try {
            if (isEditing) {
                console.log('[TRACE][handleLossesSubmit] updating existing entry', currentEditContext.id);
                await collectionRef.doc(currentEditContext.id).update({
                    ...payloadBase,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            } else {
                console.log('[TRACE][handleLossesSubmit] creating new entry');
                await collectionRef.add({
                    ...payloadBase,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }

            closeModal('quick-losses-modal');
            
            // Salvar posição do scroll antes de atualizar
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            await populateMachineSelector();
            
            // Atualizar selectedMachineData com os dados mais recentes
            // machineCardData agora é array - pegar primeiro plano para compatibilidade
            if (selectedMachineData && selectedMachineData.machine && machineCardData[selectedMachineData.machine]) {
                const machineDataArray = machineCardData[selectedMachineData.machine];
                selectedMachineData = Array.isArray(machineDataArray) ? machineDataArray[0] : machineDataArray;
                updateMachineInfo();
                updateQuickProductionPieceWeightUI();
            }
            
            await Promise.all([
                loadTodayStats(),
                loadHourlyProductionChart(),
                loadRecentEntries(false),
                refreshAnalysisIfActive()
            ]);
            
            // Restaurar posição do scroll após atualizações
            requestAnimationFrame(() => {
                window.scrollTo({ left: scrollLeft, top: scrollTop, behavior: 'instant' });
            });
            
            showNotification(successMessage, 'success');
            
            // Registrar log
            registrarLogSistema(isEditing ? 'EDIÇÃO DE PERDA' : 'LANÇAMENTO DE PERDA', 'perda', {
                machine: machineRef,
                refugoQty: refugoQty,
                pesoKg: pesoTotalKg,
                motivo: reason,
                observacoes: obs
            });

            console.log('[TRACE][handleLossesSubmit] success path completed');
        } catch (error) {
            console.error('Erro ao registrar perda: ', error);
            alert('Erro ao registrar perda. Tente novamente.');
        }
    }
    
    /**
     * Handler para INICIAR uma parada (nova dinâmica - motivo informado no início)
     * Coleta o motivo do modal e inicia a parada
     */
    async function handleDowntimeSubmit(e) {
        e.preventDefault();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('add_downtime')) {
            return;
        }
        
        console.log('[DOWNTIME][SUBMIT] Coletando motivo para INICIAR parada', {
            selectedMachineData,
            machineStatus
        });

        const reason = document.getElementById('quick-downtime-reason').value;
        const obs = (document.getElementById('quick-downtime-obs').value || '').trim();
        
        // ✅ POKA-YOKE: Operador obrigatório
        const userInput = document.getElementById('quick-downtime-user');
        const userCod = userInput ? parseInt(userInput.value, 10) : null;
        if (userCod === null || isNaN(userCod) || userInput.value === '') {
            alert('⚠️ Operador obrigatório!\n\nPor favor, digite o código do operador responsável.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const userData = getUserByCode ? getUserByCode(userCod) : null;
        if (!userData) {
            alert('⚠️ Código inválido!\n\nO código digitado não foi encontrado no sistema.\nVerifique e tente novamente.');
            if (userInput) userInput.focus({ preventScroll: true });
            return;
        }
        const nomeUsuario = userData.nomeUsuario;
        
        console.log('[DOWNTIME][SUBMIT] Valores do formulário:', { reason, obs, userCod, nomeUsuario });

        if (!reason) {
            alert('Por favor, selecione o motivo da parada.');
            return;
        }

        // ✅ POKA-YOKE: Observação obrigatória
        if (!obs || obs.length < 3) {
            alert('⚠️ Observação obrigatória!\n\nPor favor, descreva detalhes sobre a parada para garantir rastreabilidade.');
            document.getElementById('quick-downtime-obs').focus({ preventScroll: true });
            return;
        }

        // Fechar o modal antes de iniciar a parada
        closeModal('quick-downtime-modal');
        
        // Iniciar a parada com o motivo informado e dados do usuário
        await startMachineDowntime(reason, obs, userCod, nomeUsuario);
        
        console.log('[DOWNTIME][SUBMIT] Parada iniciada com motivo:', reason, 'usuário:', nomeUsuario);
    }

    async function handleManualBorraSubmit(e) {
        e.preventDefault();

        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!isOrderActiveForCurrentMachine()) {
            showNotification('⚠️ Ative uma OP antes de fazer lançamentos. Vá em "Ordens" e clique em "Ativar" na OP desejada.', 'warning');
            return;
        }

        // ✅ POKA-YOKE: Bloquear lançamento se ciclo/cavidades não foram informados
        if (!validateCycleCavityLaunched()) {
            return;
        }


        if (!window.authSystem.checkPermissionForAction('add_losses')) {
            return;
        }

        if (!selectedMachineData) {
            alert('Nenhuma máquina selecionada. Selecione uma máquina para registrar a borra.');
            return;
        }

        const dateInput = document.getElementById('manual-borra-date');
        const shiftSelect = document.getElementById('manual-borra-shift');
        const hourInput = document.getElementById('manual-borra-hour');
        const machineSelect = document.getElementById('manual-borra-machine');
        const weightInput = document.getElementById('manual-borra-weight');
        const mpTypeSelect = document.getElementById('manual-borra-mp-type');
        const reasonInput = document.getElementById('manual-borra-reason');
        const obsInput = document.getElementById('manual-borra-obs');

        const dateValue = (dateInput?.value || '').trim();
        const shiftRaw = shiftSelect?.value || '';
        const hourValue = (hourInput?.value || '').trim();
    const machineValue = machineSelect?.value || '';
        // Entrada agora é em GRAMAS diretamente
        const weightGrams = parseInt(weightInput?.value || '0', 10);
        const weightKg = weightGrams / 1000; // Converter para kg para salvar
        const mpTypeValue = mpTypeSelect?.value || '';
        const reasonValue = (reasonInput?.value || '').trim();
        const observations = (obsInput?.value || '').trim();

        if (!dateValue) {
            alert('Informe a data de geração da borra.');
            if (dateInput) dateInput.focus();
            return;
        }

        if (!machineValue) {
            alert('Selecione a máquina que gerou a borra.');
            if (machineSelect) machineSelect.focus();
            return;
        }

        if (!Number.isFinite(weightGrams) || weightGrams <= 0) {
            alert('Informe o peso da borra em gramas (valor deve ser maior que zero).');
            if (weightInput) weightInput.focus();
            return;
        }

        if (!mpTypeValue) {
            alert('Selecione o tipo de matéria-prima da borra.');
            if (mpTypeSelect) mpTypeSelect.focus();
            return;
        }

        if (!reasonValue) {
            alert('Informe o motivo da geração da borra.');
            if (reasonInput) reasonInput.focus();
            return;
        }

        const statusDiv = document.getElementById('manual-borra-status');
        const submitButton = document.getElementById('manual-borra-save');

        try {
            if (statusDiv) statusDiv.textContent = 'Salvando borra...';
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.textContent = 'Salvando...';
            }

            const currentUser = getActiveUser();
            const workDay = getWorkDayFromDate(dateValue, hourValue);
            const normalizedMachine = normalizeMachineId(machineValue || selectedMachineData.machine || '');
            const resolvedPlanId = selectedMachineData?.id || selectedMachineData?.planId || selectedMachineData?.planningRef || null;
            if (!resolvedPlanId) {
                console.warn('[WARN][handleManualBorraSubmit] planId não encontrado para BORRA, registro será salvo sem vínculo de plano.', {
                    selectedMachineData
                });
            }
            
            // Preparar dados da borra (salvar como perda especial)
            const borraData = {
                data: dateValue,
                workDay: workDay,
                machine: normalizedMachine,
                planId: resolvedPlanId || null,
                planningRef: resolvedPlanId || null,
                refugo_kg: weightKg, // Salvar em kg (convertido de gramas)
                perdas: `BORRA - ${reasonValue}`,
                mp: '',
                mp_type: mpTypeValue,
                turno: parseInt(shiftRaw, 10) || 1,
                horaInformada: hourValue || null,
                observacoes: observations || '',
                tipo_lancamento: 'borra', // Identificador especial
                planningRef: selectedMachineData.id,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdBy: currentUser.username || 'sistema',
                createdByName: currentUser.name || 'Sistema'
            };

            console.log('[TRACE][handleManualBorraSubmit] prepared borra data', borraData);

            // Salvar na coleção production_entries (como outras perdas)
            const docRef = await db.collection('production_entries').add(borraData);
            
            console.log('[TRACE][handleManualBorraSubmit] borra saved successfully', { docId: docRef.id });

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('perda', `Borra registrada: ${weightKg.toFixed(3)}kg`, {
                    pesoKg: weightKg,
                    pesoGramas: weightGrams,
                    maquina: normalizedMachine,
                    motivo: reasonValue,
                    tipoMp: mpTypeValue,
                    turno: borraData.turno,
                    data: dateValue
                });
            }

            if (statusDiv) statusDiv.textContent = 'Borra registrada com sucesso!';
            showNotification(`Borra de ${weightGrams}g (${weightKg.toFixed(3)}kg) registrada com sucesso!`, 'success');

            // Fechar modal e atualizar dados
            setTimeout(() => {
                closeModal('manual-borra-modal');
                if (typeof updateOverviewData === 'function') {
                    updateOverviewData();
                }
                if (typeof refreshRecentEntries === 'function') {
                    refreshRecentEntries();
                }
            }, 1500);

        } catch (error) {
            console.error('[ERROR][handleManualBorraSubmit] falha ao salvar borra', error);
            
            if (statusDiv) statusDiv.textContent = 'Erro ao registrar borra. Tente novamente.';
            showNotification('Erro ao registrar borra. Verifique os dados e tente novamente.', 'error');
        } finally {
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Registrar Borra';
            }
        }
    }

    // ==============================================
    // PMP - GESTÃO DE MATERIAIS (MOÍDO)
    // ==============================================

    // Inicializar aba PMP
    function initPMPPage() {
        console.log('[TRACE][initPMPPage] Inicializando aba PMP');
        
        // Botão de lançar borra na aba PMP - NOVO MODAL
        const btnPmpBorra = document.getElementById('btn-pmp-borra');
        if (btnPmpBorra) {
            btnPmpBorra.addEventListener('click', openPmpBorraModal);
        }

        // =============================================
        // MODAL BORRA PMP - Event Listeners
        // =============================================
        
        // Form de borra PMP
        const pmpBorraForm = document.getElementById('pmp-borra-form');
        if (pmpBorraForm) {
            pmpBorraForm.addEventListener('submit', handlePmpBorraSubmit);
        }

        // Botão cancelar do modal borra PMP
        const pmpBorraCancel = document.getElementById('pmp-borra-cancel');
        if (pmpBorraCancel) {
            pmpBorraCancel.addEventListener('click', () => closeModal('pmp-borra-modal'));
        }

        // Botão fechar do modal borra PMP
        const pmpBorraClose = document.getElementById('pmp-borra-modal-close');
        if (pmpBorraClose) {
            pmpBorraClose.addEventListener('click', () => closeModal('pmp-borra-modal'));
        }

        // Evento de busca de operador pelo código
        const pmpBorraOperador = document.getElementById('pmp-borra-operador');
        if (pmpBorraOperador) {
            pmpBorraOperador.addEventListener('input', debounce(searchOperadorByCode, 500));
            pmpBorraOperador.addEventListener('blur', searchOperadorByCode);
        }

        // =============================================
        // FILTRO DE HISTÓRICO
        // =============================================

        // Filtro de histórico PMP
        const btnPmpFilter = document.getElementById('btn-pmp-filter');
        if (btnPmpFilter) {
            btnPmpFilter.addEventListener('click', loadPMPHistory);
        }

        // Data padrão para filtro
        const pmpFilterDate = document.getElementById('pmp-filter-date');
        if (pmpFilterDate) {
            pmpFilterDate.value = new Date().toISOString().split('T')[0];
        }
        
        // =============================================
        // INICIALIZAR MODAL DE SUCATA
        // =============================================
        if (typeof initSucataModal === 'function') {
            initSucataModal();
        }
    }

    // Abrir modal de moído
    function openMoidoModal() {
        console.log('[TRACE][openMoidoModal] Abrindo modal de moído');
        
        const dateInput = document.getElementById('moido-date');
        const hourInput = document.getElementById('moido-hour');
        
        // Preencher data e hora atuais
        if (dateInput) {
            dateInput.value = new Date().toISOString().split('T')[0];
        }
        if (hourInput) {
            const now = new Date();
            hourInput.value = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        }

        // Limpar campos
        const productCode = document.getElementById('moido-product-code');
        const mpCode = document.getElementById('moido-mp-code');
        const quantity = document.getElementById('moido-quantity');
        const obs = document.getElementById('moido-obs');
        
        if (productCode) productCode.value = '';
        if (mpCode) mpCode.value = '';
        if (quantity) quantity.value = '';
        if (obs) obs.value = '';

        // Esconder info boxes
        const productInfo = document.getElementById('moido-product-info');
        const mpInfo = document.getElementById('moido-mp-info');
        const productError = document.getElementById('moido-product-error');
        const mpError = document.getElementById('moido-mp-error');
        
        if (productInfo) productInfo.classList.add('hidden');
        if (mpInfo) mpInfo.classList.add('hidden');
        if (productError) productError.classList.add('hidden');
        if (mpError) mpError.classList.add('hidden');

        // Limpar status
        const statusDiv = document.getElementById('moido-status');
        if (statusDiv) statusDiv.textContent = '';

        openModal('moido-modal');
    }

    // Buscar produto pelo código
    function searchProductByCode() {
        const codeInput = document.getElementById('moido-product-code');
        const infoDiv = document.getElementById('moido-product-info');
        const errorDiv = document.getElementById('moido-product-error');
        const nameSpan = document.getElementById('moido-product-name');
        const clientSpan = document.getElementById('moido-product-client');

        if (!codeInput || !infoDiv || !errorDiv) return;

        const code = parseInt(codeInput.value, 10);
        
        if (!code || isNaN(code)) {
            infoDiv.classList.add('hidden');
            errorDiv.classList.add('hidden');
            return;
        }

        // Buscar no productDatabase
        const product = window.productDatabase ? window.productDatabase.find(p => p.cod === code) : null;
        
        if (product) {
            if (nameSpan) nameSpan.textContent = product.name || '-';
            if (clientSpan) clientSpan.textContent = product.client || '-';
            infoDiv.classList.remove('hidden');
            errorDiv.classList.add('hidden');
        } else {
            infoDiv.classList.add('hidden');
            errorDiv.classList.remove('hidden');
        }
    }

    // Buscar matéria prima pelo código
    function searchMpByCode() {
        const codeInput = document.getElementById('moido-mp-code');
        const infoDiv = document.getElementById('moido-mp-info');
        const errorDiv = document.getElementById('moido-mp-error');
        const nameSpan = document.getElementById('moido-mp-name');

        if (!codeInput || !infoDiv || !errorDiv) return;

        const code = parseInt(codeInput.value, 10);
        
        if (!code || isNaN(code)) {
            infoDiv.classList.add('hidden');
            errorDiv.classList.add('hidden');
            return;
        }

        // Buscar no materiaPrimaDatabase
        const mp = window.materiaPrimaDatabase ? window.materiaPrimaDatabase.find(m => m.codigo === code) : null;
        
        if (mp) {
            if (nameSpan) nameSpan.textContent = mp.descricao || '-';
            infoDiv.classList.remove('hidden');
            errorDiv.classList.add('hidden');
        } else {
            infoDiv.classList.add('hidden');
            errorDiv.classList.remove('hidden');
        }
    }

    // Debounce helper
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Submeter formulário de moído
    async function handleMoidoSubmit(e) {
        e.preventDefault();
        e.stopPropagation();
        
        console.log('[TRACE][handleMoidoSubmit] Iniciando lançamento de moído');

        const dateInput = document.getElementById('moido-date');
        const hourInput = document.getElementById('moido-hour');
        const productCodeInput = document.getElementById('moido-product-code');
        const mpCodeInput = document.getElementById('moido-mp-code');
        const quantityInput = document.getElementById('moido-quantity');
        const obsInput = document.getElementById('moido-obs');
        const statusDiv = document.getElementById('moido-status');
        const submitBtn = document.getElementById('moido-save');

        // Validações
        const dateValue = dateInput?.value;
        const hourValue = hourInput?.value;
        const productCode = parseInt(productCodeInput?.value, 10);
        const mpCode = parseInt(mpCodeInput?.value, 10);
        const quantity = parseFloat(quantityInput?.value);
        const obs = obsInput?.value?.trim() || '';

        if (!dateValue) {
            showNotification('Informe a data', 'warning');
            return;
        }
        if (!hourValue) {
            showNotification('Informe a hora', 'warning');
            return;
        }
        if (!productCode || isNaN(productCode)) {
            showNotification('Informe o código do produto', 'warning');
            return;
        }
        if (!mpCode || isNaN(mpCode)) {
            showNotification('Informe o código da matéria prima', 'warning');
            return;
        }
        if (!quantity || isNaN(quantity) || quantity <= 0) {
            showNotification('Informe uma quantidade válida', 'warning');
            return;
        }

        // Buscar produto e MP no banco
        const product = window.productDatabase ? window.productDatabase.find(p => p.cod === productCode) : null;
        const mp = window.materiaPrimaDatabase ? window.materiaPrimaDatabase.find(m => m.codigo === mpCode) : null;

        if (!product) {
            showNotification('Produto não encontrado no banco de dados', 'error');
            return;
        }
        if (!mp) {
            showNotification('Matéria prima não encontrada no banco de dados', 'error');
            return;
        }

        // Desabilitar botão
        if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = 'Salvando...';
        }

        try {
            const currentUser = getActiveUser();
            
            const moidoData = {
                tipo: 'moido',
                data: dateValue,
                hora: hourValue,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                
                // Produto
                productCode: productCode,
                productName: product.name,
                productClient: product.client,
                
                // Matéria Prima
                mpCode: mpCode,
                mpName: mp.descricao,
                
                // Quantidade
                quantidadeKg: quantity,
                
                // Observações
                observacoes: obs,
                
                // Usuário
                registradoPor: currentUser?.username || 'sistema',
                registradoPorNome: getCurrentUserName() || 'Sistema'
            };

            console.log('[TRACE][handleMoidoSubmit] Dados do moído:', moidoData);

            // Salvar no Firestore na coleção 'pmp_moido'
            const docRef = await db.collection('pmp_moido').add(moidoData);
            
            console.log('[TRACE][handleMoidoSubmit] Moído salvo com sucesso, ID:', docRef.id);

            if (statusDiv) {
                statusDiv.textContent = '✅ Moído registrado com sucesso!';
                statusDiv.classList.remove('text-red-500');
                statusDiv.classList.add('text-green-600');
            }

            showNotification('✅ Moído registrado com sucesso!', 'success');

            // Registrar log
            if (typeof registrarLogSistema === 'function') {
                registrarLogSistema('LANÇAMENTO DE MOÍDO', 'moido', {
                    productCode,
                    productName: product.name,
                    mpCode,
                    mpName: mp.descricao,
                    quantidadeKg: quantity
                });
            }

            // Fechar modal após 1.5s
            setTimeout(() => {
                closeModal('moido-modal');
                loadPMPHistory();
            }, 1500);

        } catch (error) {
            console.error('[ERROR][handleMoidoSubmit] Erro ao salvar moído:', error);
            
            if (statusDiv) {
                statusDiv.textContent = 'Erro ao registrar moído. Tente novamente.';
                statusDiv.classList.remove('text-green-600');
                statusDiv.classList.add('text-red-500');
            }

            showNotification('Erro ao registrar moído: ' + error.message, 'error');
        } finally {
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Registrar Moído';
            }
        }
    }

    // Carregar histórico PMP
    async function loadPMPHistory() {
        console.log('[TRACE][loadPMPHistory] Carregando histórico PMP (Borras e Sucatas)');
        
        const filterDate = document.getElementById('pmp-filter-date')?.value;
        const historyList = document.getElementById('pmp-history-list');

        if (!historyList) return;

        if (!filterDate) {
            showNotification('Selecione uma data para filtrar', 'warning');
            return;
        }

        historyList.innerHTML = `
            <div class="text-center py-8 text-gray-400">
                <i data-lucide="loader-2" class="w-8 h-8 mx-auto mb-2 opacity-50 animate-spin"></i>
                <p>Carregando...</p>
            </div>
        `;
        lucide.createIcons();

        try {
            const records = [];
            
            // Buscar borras do dia (sem orderBy para evitar necessidade de índice composto)
            const borraSnapshot = await db.collection('pmp_borra')
                .where('date', '==', filterDate)
                .get();

            borraSnapshot.forEach(doc => {
                records.push({ id: doc.id, ...doc.data(), tipo: 'borra' });
            });
            
            // ✅ NOVO: Buscar sucatas do dia
            const sucataSnapshot = await db.collection('pmp_sucata')
                .where('date', '==', filterDate)
                .get();

            sucataSnapshot.forEach(doc => {
                records.push({ id: doc.id, ...doc.data(), tipo: 'sucata' });
            });
            
            // Ordenar por hora localmente (mais recente primeiro)
            records.sort((a, b) => {
                const hourA = a.hour || '00:00';
                const hourB = b.hour || '00:00';
                return hourB.localeCompare(hourA);
            });

            if (records.length === 0) {
                historyList.innerHTML = `
                    <div class="text-center py-8 text-gray-400">
                        <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                        <p>Nenhum lançamento de borra ou sucata encontrado para esta data</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            historyList.innerHTML = records.map(record => {
                // Verificar se é borra ou sucata
                if (record.tipo === 'sucata') {
                    // Card de Sucata
                    const tipoIcon = record.sucataType === 'galhos' ? '🌿' : 
                                     record.sucataType === 'pecas' ? '🔩' : 
                                     record.sucataType === 'moido' ? '⚙️' : '📦';
                    return `
                        <div class="flex items-center justify-between p-3 bg-red-50 hover:bg-red-100 rounded-lg border border-red-200 transition-colors group">
                            <div class="flex items-center gap-3 flex-1">
                                <div class="p-2 rounded-lg bg-red-100">
                                    <i data-lucide="trash-2" class="w-4 h-4 text-red-600"></i>
                                </div>
                                <div>
                                    <p class="text-sm font-semibold text-gray-800">
                                        ${tipoIcon} Sucata - ${record.quantityKg?.toFixed(3) || '0.000'} Kg
                                    </p>
                                    <p class="text-xs text-gray-500">
                                        Tipo: ${record.sucataTypeLabel || record.sucataType || '-'} | Máquina: ${record.machine || '-'}
                                    </p>
                                    <p class="text-xs text-gray-400">
                                        Motivo: ${record.reason || '-'}
                                    </p>
                                </div>
                            </div>
                            <div class="flex items-center gap-3">
                                <div class="text-right">
                                    <p class="text-xs text-gray-500">${record.hour || '-'}</p>
                                    <p class="text-xs text-gray-400">${record.registeredBy || 'Sistema'}</p>
                                </div>
                                <button onclick="deletePMPSucataEntry('${record.id}')" class="p-2 rounded-lg bg-red-100 hover:bg-red-200 text-red-600 transition-colors opacity-0 group-hover:opacity-100" title="Excluir lançamento">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                    `;
                } else {
                    // Card de Borra (original)
                    return `
                        <div class="flex items-center justify-between p-3 bg-gray-50 hover:bg-gray-100 rounded-lg border border-gray-200 transition-colors group">
                            <div class="flex items-center gap-3 flex-1">
                                <div class="p-2 rounded-lg bg-yellow-100">
                                    <i data-lucide="droplet" class="w-4 h-4 text-yellow-600"></i>
                                </div>
                                <div>
                                    <p class="text-sm font-semibold text-gray-800">
                                        Borra - ${record.quantityKg?.toFixed(3) || '0.000'} Kg
                                    </p>
                                    <p class="text-xs text-gray-500">
                                        Máquina: ${record.machine || '-'} ${record.machineModel ? '(' + record.machineModel + ')' : ''}
                                    </p>
                                    <p class="text-xs text-gray-400">
                                        Operador: ${record.operadorName || ('Cod ' + record.operadorCod) || '-'}
                                    </p>
                                </div>
                            </div>
                            <div class="flex items-center gap-3">
                                <div class="text-right">
                                    <p class="text-xs text-gray-500">${record.hour || '-'}</p>
                                    <p class="text-xs text-gray-400">${record.registeredBy || 'Sistema'}</p>
                                </div>
                                <button onclick="deletePMPBorraEntry('${record.id}')" class="p-2 rounded-lg bg-red-100 hover:bg-red-200 text-red-600 transition-colors opacity-0 group-hover:opacity-100" title="Excluir lançamento">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                    `;
                }
            }).join('');

            lucide.createIcons();
            
        } catch (error) {
            console.error('[ERROR][loadPMPHistory] Erro ao carregar histórico:', error);
            historyList.innerHTML = `
                <div class="text-center py-8 text-red-400">
                    <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                    <p>Erro ao carregar histórico</p>
                </div>
            `;
            lucide.createIcons();
        }
    }

    // ==============================================
    // PMP - LANÇAMENTO DE BORRA
    // ==============================================
    
    // Abrir modal de borra PMP
    function openPmpBorraModal() {
        console.log('[TRACE][openPmpBorraModal] Abrindo modal de borra PMP');
        
        const dateInput = document.getElementById('pmp-borra-date');
        const hourInput = document.getElementById('pmp-borra-hour');
        
        // Preencher data e hora atuais
        if (dateInput) {
            dateInput.value = new Date().toISOString().split('T')[0];
        }
        if (hourInput) {
            const now = new Date();
            hourInput.value = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        }

        // Limpar campos
        const operadorInput = document.getElementById('pmp-borra-operador');
        const machineSelect = document.getElementById('pmp-borra-machine');
        const quantityInput = document.getElementById('pmp-borra-quantity');
        const obsInput = document.getElementById('pmp-borra-obs');
        const shiftSelect = document.getElementById('pmp-borra-shift');
        const statusDiv = document.getElementById('pmp-borra-status');
        
        if (operadorInput) operadorInput.value = '';
        if (quantityInput) quantityInput.value = '';
        if (obsInput) obsInput.value = '';
        if (shiftSelect) shiftSelect.value = '';
        if (statusDiv) statusDiv.textContent = '';
        
        // Esconder info do operador
        const operadorInfo = document.getElementById('pmp-borra-operador-info');
        const operadorError = document.getElementById('pmp-borra-operador-error');
        if (operadorInfo) operadorInfo.classList.add('hidden');
        if (operadorError) operadorError.classList.add('hidden');
        
        // Preencher select de máquinas
        if (machineSelect && window.machineDatabase) {
            machineSelect.innerHTML = '<option value="">Selecione uma máquina...</option>';
            window.machineDatabase.forEach(machine => {
                const option = document.createElement('option');
                option.value = machine.id;
                option.textContent = `${machine.id} - ${machine.model}`;
                machineSelect.appendChild(option);
            });
        }
        
        openModal('pmp-borra-modal');
        lucide.createIcons();
    }

    // Buscar operador pelo código
    function searchOperadorByCode() {
        const codeInput = document.getElementById('pmp-borra-operador');
        const infoDiv = document.getElementById('pmp-borra-operador-info');
        const nameSpan = document.getElementById('pmp-borra-operador-name');
        const errorP = document.getElementById('pmp-borra-operador-error');
        
        if (!codeInput || !infoDiv || !nameSpan || !errorP) return;
        
        const code = parseInt(codeInput.value, 10);
        
        if (!code || code <= 0) {
            infoDiv.classList.add('hidden');
            errorP.classList.add('hidden');
            return;
        }
        
        // Buscar no userDatabase
        if (window.userDatabase) {
            const user = window.userDatabase.find(u => u.cod === code);
            
            if (user) {
                nameSpan.textContent = user.nomeCompleto || user.nomeUsuario || 'N/A';
                infoDiv.classList.remove('hidden');
                errorP.classList.add('hidden');
            } else {
                infoDiv.classList.add('hidden');
                errorP.classList.remove('hidden');
            }
        } else {
            console.warn('[PMP-BORRA] userDatabase não disponível');
            infoDiv.classList.add('hidden');
            errorP.classList.add('hidden');
        }
    }

    // Submeter form de borra PMP
    async function handlePmpBorraSubmit(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const statusDiv = document.getElementById('pmp-borra-status');
        const saveBtn = document.getElementById('pmp-borra-save');
        
        try {
            // Coletar dados do form
            const date = document.getElementById('pmp-borra-date')?.value;
            const hour = document.getElementById('pmp-borra-hour')?.value;
            const shift = document.getElementById('pmp-borra-shift')?.value;
            const operadorCod = parseInt(document.getElementById('pmp-borra-operador')?.value, 10);
            const machine = document.getElementById('pmp-borra-machine')?.value;
            const quantity = parseFloat(document.getElementById('pmp-borra-quantity')?.value);
            const observations = document.getElementById('pmp-borra-obs')?.value?.trim() || '';
            
            // Validações
            if (!date || !hour) {
                statusDiv.textContent = '⚠️ Informe data e hora';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            if (!shift) {
                statusDiv.textContent = '⚠️ Selecione um turno';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            if (!operadorCod || operadorCod <= 0) {
                statusDiv.textContent = '⚠️ Informe o código do operador';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            if (!machine) {
                statusDiv.textContent = '⚠️ Selecione uma máquina';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            if (!quantity || quantity <= 0) {
                statusDiv.textContent = '⚠️ Informe a quantidade em Kg';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            // Verificar se operador existe
            let operadorName = 'Desconhecido';
            if (window.userDatabase) {
                const user = window.userDatabase.find(u => u.cod === operadorCod);
                if (user) {
                    operadorName = user.nomeCompleto || user.nomeUsuario || 'N/A';
                } else {
                    statusDiv.textContent = '⚠️ Operador não encontrado no banco de dados';
                    statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                    return;
                }
            }
            
            // Desabilitar botão
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin inline mr-2"></i>Salvando...';
            }
            
            statusDiv.textContent = '⏳ Salvando...';
            statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-blue-600';
            
            // Buscar info da máquina
            const machineInfo = window.machineDatabase?.find(m => m.id === machine);
            
            // Usuário logado
            const activeUser = getActiveUser() || {};
            
            // Payload para Firebase
            const borraData = {
                type: 'pmp_borra',
                date: date,
                hour: hour,
                shift: shift,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                timestampLocal: new Date().toISOString(),
                operadorCod: operadorCod,
                operadorName: operadorName,
                machine: machine,
                machineModel: machineInfo?.model || '',
                quantityKg: quantity,
                observations: observations,
                registeredBy: activeUser.name || 'Sistema',
                registeredByEmail: activeUser.email || '',
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            console.log('[PMP-BORRA] Salvando borra:', borraData);
            
            // Salvar no Firebase
            await db.collection('pmp_borra').add(borraData);
            
            console.log('[PMP-BORRA] Borra salva com sucesso!');
            
            statusDiv.textContent = '✅ Borra registrada com sucesso!';
            statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-green-600';
            
            showNotification('✅ Borra registrada com sucesso!', 'success');
            
            // Fechar modal após 1.5s
            setTimeout(() => {
                closeModal('pmp-borra-modal');
                // Recarregar histórico se estiver visível
                if (document.getElementById('pmp-page') && !document.getElementById('pmp-page').classList.contains('hidden')) {
                    loadPMPHistory();
                }
            }, 1500);
            
        } catch (error) {
            console.error('[PMP-BORRA] Erro ao salvar borra:', error);
            statusDiv.textContent = '❌ Erro ao salvar borra';
            statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
            showNotification('Erro ao salvar borra', 'error');
        } finally {
            // Reabilitar botão
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'Registrar Borra';
            }
        }
    }

    // Deletar lançamento de borra
    async function deletePMPBorraEntry(docId) {
        try {
            const confirmed = confirm('Tem certeza que deseja excluir este lançamento de borra?');
            if (!confirmed) return;

            await db.collection('pmp_borra').doc(docId).delete();
            
            showNotification('Lançamento de borra excluído com sucesso', 'success');
            
            // Recarregar o histórico
            await loadPMPHistory();
            
            // Recarregar análise se estiver aberta
            if (document.getElementById('analise-page').style.display !== 'none') {
                await loadLossesAnalysis();
            }
        } catch (error) {
            console.error('[ERROR][deletePMPBorraEntry]', error);
            showNotification('Erro ao excluir lançamento: ' + error.message, 'error');
        }
    }

    // Expor funções globalmente
    window.initPMPPage = initPMPPage;
    window.openPmpBorraModal = openPmpBorraModal;
    window.loadPMPHistory = loadPMPHistory;
    window.deletePMPBorraEntry = deletePMPBorraEntry;

    // =====================================================
    // MÓDULO DE LANÇAMENTO DE SUCATA (PMP)
    // =====================================================
    
    // Variáveis para paginação da tabela de sucata
    let sucataTableData = [];
    let sucataTablePage = 1;
    const sucataTablePageSize = 10;
    
    // Gráficos de sucata
    let sucataByTypeChart = null;
    let sucataByMachineChart = null;
    let sucataMonthlyChart = null;

    // Abrir modal de sucata
    function openPmpSucataModal() {
        console.log('[PMP-SUCATA] Abrindo modal de sucata');
        
        const modal = document.getElementById('manual-sucata-modal');
        if (!modal) {
            console.error('[PMP-SUCATA] Modal não encontrado');
            return;
        }
        
        // Preencher data atual
        const dateInput = document.getElementById('manual-sucata-date');
        if (dateInput) {
            dateInput.value = new Date().toISOString().split('T')[0];
        }
        
        // Preencher turno atual
        const shiftInput = document.getElementById('manual-sucata-shift');
        if (shiftInput) {
            const currentShift = getCurrentShift();
            shiftInput.value = currentShift || '1';
        }
        
        // Limpar formulário
        document.getElementById('manual-sucata-form')?.reset();
        if (dateInput) dateInput.value = new Date().toISOString().split('T')[0];
        if (shiftInput) shiftInput.value = getCurrentShift() || '1';
        
        // Limpar info do operador
        const operadorInfo = document.getElementById('manual-sucata-operador-info');
        const operadorError = document.getElementById('manual-sucata-operador-error');
        if (operadorInfo) operadorInfo.classList.add('hidden');
        if (operadorError) operadorError.classList.add('hidden');
        
        // Limpar status
        const statusDiv = document.getElementById('manual-sucata-status');
        if (statusDiv) {
            statusDiv.textContent = '';
            statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2';
        }
        
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
            lucide.createIcons();
        }
    }

    // Salvar sucata
    async function savePMPSucata(e) {
        e.preventDefault();
        
        const statusDiv = document.getElementById('manual-sucata-status');
        const saveBtn = document.getElementById('manual-sucata-save');
        
        try {
            const date = document.getElementById('manual-sucata-date')?.value;
            const hour = document.getElementById('manual-sucata-hour')?.value || '';
            const shift = document.getElementById('manual-sucata-shift')?.value || '1';
            const operadorCod = document.getElementById('manual-sucata-operador')?.value;
            const sucataType = document.getElementById('manual-sucata-type')?.value;
            const weightKg = parseFloat(document.getElementById('manual-sucata-weight')?.value) || 0;
            const observations = document.getElementById('manual-sucata-obs')?.value?.trim() || '';
            
            // Validações
            if (!date) {
                statusDiv.textContent = '⚠️ Informe a data';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            if (!operadorCod) {
                statusDiv.textContent = '⚠️ Informe o código do operador';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            // Buscar operador no userDatabase (igual ao modal de borra)
            let operadorInfo = null;
            const operadorCodInt = parseInt(operadorCod, 10);
            if (window.userDatabase) {
                operadorInfo = window.userDatabase.find(u => u.cod === operadorCodInt);
            }
            
            if (!operadorInfo) {
                statusDiv.textContent = '⚠️ Operador não encontrado';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            if (!sucataType) {
                statusDiv.textContent = '⚠️ Selecione o tipo de sucata';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            if (!weightKg || weightKg <= 0) {
                statusDiv.textContent = '⚠️ Informe o peso da sucata';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                return;
            }
            
            // Desabilitar botão
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin inline mr-2"></i>Salvando...';
            }
            
            statusDiv.textContent = '⏳ Salvando...';
            statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-blue-600';
            
            // Usuário logado
            const activeUser = getActiveUser() || {};
            
            // Labels dos tipos de sucata
            const sucataTypeLabels = {
                'galhos': 'Galhos',
                'pecas': 'Peças Defeituosas',
                'moido': 'Moído'
            };
            
            // Payload para Firebase
            const sucataData = {
                type: 'pmp_sucata',
                date: date,
                hour: hour,
                shift: shift,
                operadorCod: operadorCodInt,
                operadorName: operadorInfo?.nomeCompleto || operadorInfo?.nomeUsuario || '',
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                timestampLocal: new Date().toISOString(),
                sucataType: sucataType,
                sucataTypeLabel: sucataTypeLabels[sucataType] || sucataType,
                quantityKg: weightKg,
                observations: observations,
                registeredBy: activeUser.name || 'Sistema',
                registeredByEmail: activeUser.email || '',
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            console.log('[PMP-SUCATA] Salvando sucata:', sucataData);
            
            // Salvar no Firebase
            await db.collection('pmp_sucata').add(sucataData);
            
            console.log('[PMP-SUCATA] Sucata salva com sucesso!');
            
            statusDiv.textContent = '✅ Sucata registrada com sucesso!';
            statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-green-600';
            
            showNotification('✅ Sucata registrada com sucesso!', 'success');
            
            // Fechar modal após 1.5s
            setTimeout(() => {
                closeModal('manual-sucata-modal');
                // Recarregar histórico se estiver visível
                if (document.getElementById('pmp-page') && !document.getElementById('pmp-page').classList.contains('hidden')) {
                    loadPMPHistory();
                }
            }, 1500);
            
        } catch (error) {
            console.error('[PMP-SUCATA] Erro ao salvar sucata:', error);
            statusDiv.textContent = '❌ Erro ao salvar sucata';
            statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
            showNotification('Erro ao salvar sucata', 'error');
        } finally {
            // Reabilitar botão
            if (saveBtn) {
                saveBtn.disabled = false;
                saveBtn.innerHTML = 'Registrar Sucata';
            }
        }
    }

    // Deletar lançamento de sucata
    async function deletePMPSucataEntry(docId) {
        try {
            const confirmed = confirm('Tem certeza que deseja excluir este lançamento de sucata?');
            if (!confirmed) return;

            await db.collection('pmp_sucata').doc(docId).delete();
            
            showNotification('Lançamento de sucata excluído com sucesso', 'success');
            
            // Recarregar o histórico
            await loadPMPHistory();
            
            // Recarregar análise se estiver aberta
            if (document.getElementById('analise-page').style.display !== 'none') {
                await loadLossesAnalysis();
            }
        } catch (error) {
            console.error('[ERROR][deletePMPSucataEntry]', error);
            showNotification('Erro ao excluir lançamento: ' + error.message, 'error');
        }
    }

    // Carregar e renderizar análise de sucata
    async function loadSucataAnalysis(startDate, endDate, machine = 'all', shift = 'all') {
        console.log('[SUCATA] Carregando análise de sucata...');
        
        try {
            // Buscar dados de sucata do Firebase
            let query = db.collection('pmp_sucata')
                .where('date', '>=', startDate)
                .where('date', '<=', endDate);
            
            const snapshot = await query.get();
            
            let sucataData = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                const machineId = normalizeMachineId(data.machine || '');
                
                // Aplicar filtros
                if (machine !== 'all' && machineId !== normalizeMachineId(machine)) {
                    return;
                }
                
                if (shift !== 'all' && data.shift !== shift) {
                    return;
                }
                
                sucataData.push({
                    id: doc.id,
                    ...data
                });
            });
            
            console.log('[SUCATA] Dados carregados:', sucataData.length);
            
            // Calcular totais por tipo
            let totalGalhos = 0;
            let totalPecas = 0;
            let totalMoido = 0;
            
            const byMachine = {};
            const byType = {};
            
            sucataData.forEach(item => {
                const kg = item.quantityKg || 0;
                const tipo = item.sucataType || 'outros';
                const machine = item.machine || 'N/A';
                
                // Totais por tipo
                if (tipo === 'galhos') totalGalhos += kg;
                else if (tipo === 'pecas') totalPecas += kg;
                else if (tipo === 'moido') totalMoido += kg;
                
                // Agrupamento por máquina
                byMachine[machine] = (byMachine[machine] || 0) + kg;
                
                // Agrupamento por tipo
                const typeLabel = item.sucataTypeLabel || tipo;
                byType[typeLabel] = (byType[typeLabel] || 0) + kg;
            });
            
            const totalSucata = totalGalhos + totalPecas + totalMoido;
            
            // Atualizar KPIs
            const totalEl = document.getElementById('total-sucata');
            const galhosEl = document.getElementById('total-sucata-galhos');
            const pecasEl = document.getElementById('total-sucata-pecas');
            const moidoEl = document.getElementById('total-sucata-moido');
            
            if (totalEl) totalEl.textContent = totalSucata.toFixed(3) + ' kg';
            if (galhosEl) galhosEl.textContent = totalGalhos.toFixed(3) + ' kg';
            if (pecasEl) pecasEl.textContent = totalPecas.toFixed(3) + ' kg';
            if (moidoEl) moidoEl.textContent = totalMoido.toFixed(3) + ' kg';
            
            // Renderizar gráficos
            renderSucataByTypeChart(byType);
            renderSucataByMachineChart(byMachine);
            renderSucataMonthlyChart(sucataData);
            
            // Atualizar tabela
            sucataTableData = sucataData.sort((a, b) => {
                const dateA = new Date(a.date + ' ' + (a.hour || '00:00'));
                const dateB = new Date(b.date + ' ' + (b.hour || '00:00'));
                return dateB - dateA;
            });
            sucataTablePage = 1;
            renderSucataTable();
            
        } catch (error) {
            console.error('[SUCATA] Erro ao carregar análise:', error);
        }
    }

    // Gráfico de sucata por tipo (pizza)
    function renderSucataByTypeChart(data) {
        const ctx = document.getElementById('sucata-by-type-chart');
        if (!ctx) return;
        
        // Destruir gráfico anterior se existir
        if (sucataByTypeChart) {
            sucataByTypeChart.destroy();
        }
        
        const labels = Object.keys(data);
        const values = Object.values(data);
        
        sucataByTypeChart = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    data: values,
                    backgroundColor: [
                        'rgba(34, 197, 94, 0.8)',   // Verde - Galhos
                        'rgba(239, 68, 68, 0.8)',   // Vermelho - Peças
                        'rgba(59, 130, 246, 0.8)',  // Azul - Moído
                        'rgba(156, 163, 175, 0.8)'  // Cinza - Outros
                    ],
                    borderColor: [
                        'rgba(34, 197, 94, 1)',
                        'rgba(239, 68, 68, 1)',
                        'rgba(59, 130, 246, 1)',
                        'rgba(156, 163, 175, 1)'
                    ],
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            font: { size: 10 }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.raw || 0;
                                return context.label + ': ' + value.toFixed(3) + ' kg';
                            }
                        }
                    }
                }
            }
        });
    }

    // Gráfico de sucata por máquina (barras)
    function renderSucataByMachineChart(data) {
        const ctx = document.getElementById('sucata-by-machine-chart');
        if (!ctx) return;
        
        // Destruir gráfico anterior se existir
        if (sucataByMachineChart) {
            sucataByMachineChart.destroy();
        }
        
        // Ordenar por valor e pegar top 10
        const sorted = Object.entries(data)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 10);
        
        const labels = sorted.map(x => x[0]);
        const values = sorted.map(x => x[1]);
        
        sucataByMachineChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Sucata (kg)',
                    data: values,
                    backgroundColor: 'rgba(239, 68, 68, 0.7)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 1,
                    borderRadius: 4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.raw.toFixed(3) + ' kg';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            callback: function(value) {
                                return value.toFixed(2) + ' kg';
                            }
                        }
                    },
                    y: {
                        ticks: {
                            font: { size: 10 }
                        }
                    }
                }
            }
        });
    }

    // Gráfico de sucata mensal + acumulado
    function renderSucataMonthlyChart(data) {
        const ctx = document.getElementById('sucata-monthly-chart');
        if (!ctx) return;
        
        // Destruir gráfico anterior se existir
        if (sucataMonthlyChart) {
            sucataMonthlyChart.destroy();
        }
        
        // Agrupar dados por mês
        const byMonth = {};
        const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
        
        data.forEach(item => {
            if (!item.date) return;
            const dateParts = item.date.split('-');
            if (dateParts.length < 2) return;
            
            const year = dateParts[0];
            const month = parseInt(dateParts[1]) - 1;
            const key = `${year}-${String(month + 1).padStart(2, '0')}`;
            const label = `${monthNames[month]}/${year.slice(2)}`;
            
            if (!byMonth[key]) {
                byMonth[key] = { label, value: 0 };
            }
            byMonth[key].value += item.quantityKg || 0;
        });
        
        // Ordenar por data
        const sortedKeys = Object.keys(byMonth).sort();
        const labels = sortedKeys.map(k => byMonth[k].label);
        const monthlyValues = sortedKeys.map(k => byMonth[k].value);
        
        // Calcular acumulado
        let accumulated = 0;
        const accumulatedValues = monthlyValues.map(v => {
            accumulated += v;
            return accumulated;
        });
        
        sucataMonthlyChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [
                    {
                        label: 'Mensal (kg)',
                        data: monthlyValues,
                        backgroundColor: 'rgba(239, 68, 68, 0.7)',
                        borderColor: 'rgba(239, 68, 68, 1)',
                        borderWidth: 1,
                        borderRadius: 4,
                        order: 2,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Acumulado (kg)',
                        data: accumulatedValues,
                        type: 'line',
                        backgroundColor: 'rgba(220, 38, 38, 0.1)',
                        borderColor: 'rgba(220, 38, 38, 1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3,
                        pointBackgroundColor: 'rgba(220, 38, 38, 1)',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2,
                        pointRadius: 4,
                        order: 1,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            font: { size: 11 }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.raw.toFixed(3) + ' kg';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: { display: false },
                        ticks: { font: { size: 10 } }
                    },
                    y: {
                        type: 'linear',
                        display: true,
                        position: 'left',
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Mensal (kg)',
                            font: { size: 10 }
                        },
                        ticks: {
                            font: { size: 10 },
                            callback: function(value) {
                                return value.toFixed(1);
                            }
                        }
                    },
                    y1: {
                        type: 'linear',
                        display: true,
                        position: 'right',
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Acumulado (kg)',
                            font: { size: 10 }
                        },
                        grid: { drawOnChartArea: false },
                        ticks: {
                            font: { size: 10 },
                            callback: function(value) {
                                return value.toFixed(1);
                            }
                        }
                    }
                }
            }
        });
    }

    // Renderizar tabela de sucata
    function renderSucataTable() {
        const tbody = document.getElementById('sucata-apontamentos-table');
        if (!tbody) return;
        
        const start = (sucataTablePage - 1) * sucataTablePageSize;
        const end = start + sucataTablePageSize;
        const pageData = sucataTableData.slice(start, end);
        
        if (pageData.length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="4" class="px-4 py-8 text-center text-gray-400">
                        <i data-lucide="inbox" class="w-6 h-6 mx-auto mb-2 opacity-50"></i>
                        Nenhum registro de sucata encontrado
                    </td>
                </tr>
            `;
        } else {
            tbody.innerHTML = pageData.map(item => {
                const dateStr = item.date || '-';
                const hourStr = item.hour || '-';
                const tipo = item.sucataTypeLabel || item.sucataType || '-';
                const kg = (item.quantityKg || 0).toFixed(3);
                const shift = item.shift || '-';
                
                return `
                    <tr class="hover:bg-red-50 transition">
                        <td class="px-4 py-3 text-gray-700">${dateStr} ${hourStr}</td>
                        <td class="px-4 py-3 text-center">
                            <span class="inline-flex items-center gap-1 px-2 py-1 bg-red-100 text-red-700 rounded-full text-xs font-medium">
                                ${tipo}
                            </span>
                        </td>
                        <td class="px-4 py-3 text-center font-semibold text-red-600">${kg} kg</td>
                        <td class="px-4 py-3 text-gray-600">T${shift}</td>
                    </tr>
                `;
            }).join('');
        }
        
        // Atualizar paginação
        const showingEl = document.getElementById('sucata-table-showing');
        const totalEl = document.getElementById('sucata-table-total');
        const pageEl = document.getElementById('sucata-table-page');
        const prevBtn = document.getElementById('sucata-table-prev');
        const nextBtn = document.getElementById('sucata-table-next');
        
        const totalPages = Math.ceil(sucataTableData.length / sucataTablePageSize);
        
        if (showingEl) showingEl.textContent = Math.min(end, sucataTableData.length);
        if (totalEl) totalEl.textContent = sucataTableData.length;
        if (pageEl) pageEl.textContent = `Página ${sucataTablePage} de ${totalPages || 1}`;
        
        if (prevBtn) prevBtn.disabled = sucataTablePage <= 1;
        if (nextBtn) nextBtn.disabled = sucataTablePage >= totalPages;
        
        if (typeof lucide !== 'undefined' && lucide.createIcons) {
            lucide.createIcons();
        }
    }

    // Paginação da tabela de sucata
    function sucataTablePrevPage() {
        if (sucataTablePage > 1) {
            sucataTablePage--;
            renderSucataTable();
        }
    }

    function sucataTableNextPage() {
        const totalPages = Math.ceil(sucataTableData.length / sucataTablePageSize);
        if (sucataTablePage < totalPages) {
            sucataTablePage++;
            renderSucataTable();
        }
    }

    // Exportar tabela de sucata
    function exportSucataTable() {
        if (sucataTableData.length === 0) {
            showNotification('Nenhum dado para exportar', 'warning');
            return;
        }
        
        const csvContent = [
            ['Data', 'Hora', 'Máquina', 'Tipo', 'Quantidade (kg)', 'Turno', 'MP', 'Motivo', 'Observações'].join(';'),
            ...sucataTableData.map(item => [
                item.date || '',
                item.hour || '',
                item.machine || '',
                item.sucataTypeLabel || item.sucataType || '',
                (item.quantityKg || 0).toFixed(3),
                item.shift || '',
                item.mpType || '',
                item.reason || '',
                (item.observations || '').replace(/;/g, ',')
            ].join(';'))
        ].join('\n');
        
        const blob = new Blob(['\ufeff' + csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', `sucata_${new Date().toISOString().split('T')[0]}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showNotification('Exportação concluída!', 'success');
    }

    // Inicializar eventos do modal de sucata
    function initSucataModal() {
        // Botão para abrir modal
        const btnSucata = document.getElementById('btn-pmp-sucata');
        if (btnSucata) {
            btnSucata.addEventListener('click', openPmpSucataModal);
        }
        
        // Fechar modal
        const closeBtn = document.getElementById('manual-sucata-close');
        const cancelBtn = document.getElementById('manual-sucata-cancel');
        
        if (closeBtn) {
            closeBtn.addEventListener('click', () => closeModal('manual-sucata-modal'));
        }
        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => closeModal('manual-sucata-modal'));
        }
        
        // Listener para validar operador
        const operadorInput = document.getElementById('manual-sucata-operador');
        if (operadorInput) {
            operadorInput.addEventListener('input', function() {
                const cod = parseInt(this.value, 10);
                const infoDiv = document.getElementById('manual-sucata-operador-info');
                const nameSpan = document.getElementById('manual-sucata-operador-name');
                const errorP = document.getElementById('manual-sucata-operador-error');
                
                if (!cod || cod <= 0) {
                    if (infoDiv) infoDiv.classList.add('hidden');
                    if (errorP) errorP.classList.add('hidden');
                    return;
                }
                
                // Buscar operador no userDatabase (igual ao modal de borra)
                let operador = null;
                if (window.userDatabase) {
                    operador = window.userDatabase.find(u => u.cod === cod);
                }
                
                if (operador) {
                    if (infoDiv) {
                        infoDiv.classList.remove('hidden');
                        if (nameSpan) nameSpan.textContent = operador.nomeCompleto || operador.nomeUsuario || '-';
                    }
                    if (errorP) errorP.classList.add('hidden');
                } else {
                    if (infoDiv) infoDiv.classList.add('hidden');
                    if (errorP) errorP.classList.remove('hidden');
                }
            });
        }
        
        // Submit do formulário
        const form = document.getElementById('manual-sucata-form');
        if (form) {
            form.addEventListener('submit', savePMPSucata);
        }
        
        console.log('[PMP-SUCATA] Modal inicializado');
    }

    // Expor funções de sucata globalmente
    window.openPmpSucataModal = openPmpSucataModal;
    window.deletePMPSucataEntry = deletePMPSucataEntry;
    window.loadSucataAnalysis = loadSucataAnalysis;
    window.sucataTablePrevPage = sucataTablePrevPage;
    window.sucataTableNextPage = sucataTableNextPage;
    window.exportSucataTable = exportSucataTable;
    window.initSucataModal = initSucataModal;
    
    // Função para lançamento manual de parada passada
    async function handleManualDowntimeSubmit(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }

        if (!window.authSystem.checkPermissionForAction('add_downtime')) {
            showNotification('Permissão negada para registrar paradas', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }

        // ✅ POKA-YOKE: Operador obrigatório
        const userInput = document.getElementById('manual-downtime-user');
        const userCod = userInput ? parseInt(userInput.value, 10) : null;
        if (userCod === null || isNaN(userCod) || userInput.value === '') {
            alert('⚠️ Operador obrigatório!\n\nPor favor, digite o código do operador responsável.');
            if (userInput) userInput.focus();
            return;
        }
        const userData = getUserByCode ? getUserByCode(userCod) : null;
        if (!userData) {
            alert('⚠️ Código inválido!\n\nO código digitado não foi encontrado no sistema.\nVerifique e tente novamente.');
            if (userInput) userInput.focus();
            return;
        }
        const nomeUsuario = userData.nomeUsuario;

        const dateStartInput = document.getElementById('manual-downtime-date-start');
        const dateEndInput = document.getElementById('manual-downtime-date-end');
        const startTimeInput = document.getElementById('manual-downtime-start');
        const endTimeInput = document.getElementById('manual-downtime-end');
        const reasonSelect = document.getElementById('manual-downtime-reason');
        const obsInput = document.getElementById('manual-downtime-obs');

        const dateStartStr = (dateStartInput?.value || '').trim();
        const dateEndStr = (dateEndInput?.value || '').trim();
        const startTime = (startTimeInput?.value || '').trim();
        const endTime = (endTimeInput?.value || '').trim();
        const reason = reasonSelect?.value || '';
        const obs = (obsInput?.value || '').trim();

        if (!dateStartStr || !startTime || !endTime || !reason) {
            showNotification('Preencha data inicial, horários e motivo', 'warning');
            return;
        }

        try {
            const todayStr = getProductionDateString();
            const finalDateEnd = dateEndStr || dateStartStr;

            // Validar coerência temporal
            const dtStart = new Date(`${dateStartStr}T${startTime}:00`);
            const dtEnd = new Date(`${finalDateEnd}T${endTime}:00`);
            
            if (Number.isNaN(dtStart.getTime()) || Number.isNaN(dtEnd.getTime()) || dtEnd <= dtStart) {
                showNotification('Intervalo de parada inválido', 'warning');
                return;
            }

            // Quebrar em segmentos por dia
            const segments = splitDowntimeIntoDailySegments(dateStartStr, startTime, finalDateEnd, endTime);
            if (!segments.length) {
                showNotification('Não foi possível processar o período informado', 'error');
                return;
            }

            // Persistir cada segmento
            const currentUser = getActiveUser();
            for (const seg of segments) {
                const downtimeData = {
                    machine: selectedMachineData.machine,
                    date: seg.date,
                    startTime: seg.startTime,
                    endTime: seg.endTime,
                    duration: seg.duration,
                    reason: reason,
                    observations: obs,
                    // Dados do operador
                    userCod: userCod,
                    nomeUsuario: nomeUsuario,
                    registradoPor: currentUser?.username || null,
                    registradoPorNome: getCurrentUserName(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                await db.collection('downtime_entries').add(downtimeData);
            }

            // Calcular duração total para o log
            const totalDuration = segments.reduce((sum, seg) => sum + (seg.duration || 0), 0);

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('parada', `Parada manual registrada: ${reason}`, {
                    maquina: selectedMachineData?.machine,
                    motivo: reason,
                    inicio: startTime,
                    fim: endTime,
                    duracao: totalDuration,
                    dataInicio: dateStartStr,
                    dataFim: finalDateEnd
                });
            }

            closeModal('manual-downtime-modal');
            
            // Salvar posição do scroll antes de atualizar
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            
            await Promise.all([
                loadTodayStats(),
                loadRecentEntries(false)
            ]);
            
            // Restaurar posição do scroll após atualizações
            requestAnimationFrame(() => {
                window.scrollTo({ left: scrollLeft, top: scrollTop, behavior: 'instant' });
            });

            showNotification('✅ Parada manual registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar parada:', error);
            showNotification('❌ Erro ao registrar parada: ' + error.message, 'error');
        }
    }
    
    async function finishDowntime() {
        try {
            console.log('[TRACE][finishDowntime] invoked', { currentDowntimeStart, machineStatus });
            if (!currentDowntimeStart) {
                console.warn('Nenhuma parada ativa para finalizar.');
                return;
            }

            const now = new Date();
            const endTime = now.toTimeString().substr(0, 5);

            const startDateStr = currentDowntimeStart.date || formatDateYMD(currentDowntimeStart.startTimestamp || now);
            const endDateStr = formatDateYMD(now);

            const segments = splitDowntimeIntoDailySegments(startDateStr, currentDowntimeStart.startTime, endDateStr, endTime);
            console.log('[TRACE][finishDowntime] segments', segments);

            if (!segments.length) {
                // fallback simples - validar motivo antes de salvar
                if (!currentDowntimeStart.reason || currentDowntimeStart.reason.trim() === '') {
                    console.error('[DOWNTIME][FINISH] Tentativa de salvar parada sem motivo');
                    alert('⚠️ Erro: Motivo da parada não foi informado.\n\nEsta parada não pode ser finalizada sem um motivo válido.');
                    return;
                }
                const downtimeData = {
                    ...currentDowntimeStart,
                    endTime,
                    duration: 1,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                await db.collection('downtime_entries').add(downtimeData);
            } else {
                // Validar motivo antes de salvar os segmentos
                if (!currentDowntimeStart.reason || currentDowntimeStart.reason.trim() === '') {
                    console.error('[DOWNTIME][FINISH] Tentativa de salvar parada sem motivo');
                    alert('⚠️ Erro: Motivo da parada não foi informado.\n\nEsta parada não pode ser finalizada sem um motivo válido.');
                    return;
                }
                for (const seg of segments) {
                    const downtimeData = {
                        machine: currentDowntimeStart.machine,
                        date: seg.date,
                        startTime: seg.startTime,
                        endTime: seg.endTime,
                        duration: seg.duration,
                        reason: currentDowntimeStart.reason,
                        observations: currentDowntimeStart.observations || '',
                        userCod: currentDowntimeStart.userCod ?? null,
                        nomeUsuario: currentDowntimeStart.nomeUsuario || null,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    await db.collection('downtime_entries').add(downtimeData);
                }
            }
            
            // Remover parada ativa do Firebase
            try {
                const normalizedMachineForDelete = normalizeMachineId(currentDowntimeStart.machine);
                await db.collection('active_downtimes').doc(normalizedMachineForDelete).delete();
                console.log('[TRACE] Parada ativa removida do Firebase');
            } catch (error) {
                console.error('Erro ao remover parada ativa do Firebase:', error);
            }
            
            // Resetar status
            currentDowntimeStart = null;
            machineStatus = 'running';
            updateMachineStatus();
            stopDowntimeTimer();
            resumeProductionTimer();
            
            loadTodayStats();
            await loadRecentEntries(false);
            
            // Mostrar sucesso
            showNotification('Parada finalizada!', 'success');

            console.log('[TRACE][finishDowntime] successfully persisted and reset state');
            
        } catch (error) {
            console.error("Erro ao finalizar parada: ", error);
            alert('Erro ao finalizar parada. Tente novamente.');
        }
    }
    
    // Handler para registrar retrabalho
    async function handleReworkSubmit(e) {
        e.preventDefault();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!isOrderActiveForCurrentMachine()) {
            showNotification('⚠️ Ative uma OP antes de fazer lançamentos. Vá em "Ordens" e clique em "Ativar" na OP desejada.', 'warning');
            return;
        }

        // ✅ POKA-YOKE: Bloquear lançamento se ciclo/cavidades não foram informados
        if (!validateCycleCavityLaunched()) {
            return;
        }
        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('add_rework')) {
            return;
        }
        
        console.log('[TRACE][handleReworkSubmit] triggered', { selectedMachineData });

        if (!selectedMachineData) {
            alert('Nenhuma máquina selecionada. Selecione uma máquina para registrar o retrabalho.');
            return;
        }

        const qtyInput = document.getElementById('quick-rework-qty');
        const weightInput = document.getElementById('quick-rework-weight');
        const reasonSelect = document.getElementById('quick-rework-reason');
        const obsInput = document.getElementById('quick-rework-obs');

        const quantity = parseInt(qtyInput?.value, 10) || 0;
        const weight = parseFloat(weightInput?.value) || 0;
        const reason = reasonSelect?.value || '';
        const observations = (obsInput?.value || '').trim();

        if (quantity <= 0) {
            alert('Informe uma quantidade válida de peças para retrabalho.');
            if (qtyInput) qtyInput.focus();
            return;
        }

        if (!reason) {
            alert('Selecione o motivo do retrabalho.');
            if (reasonSelect) reasonSelect.focus();
            return;
        }

        const planId = selectedMachineData?.id || null;
        if (!planId) {
            alert('Não foi possível identificar o planejamento associado a esta máquina.');
            return;
        }

        const currentShift = getCurrentShift();
        const dataReferencia = getProductionDateString();
        const currentUser = getActiveUser();

        console.log('[TRACE][handleReworkSubmit] starting rework submission');

        try {
            const machineId = selectedMachineData.machine || '';
            const shiftKey = `T${currentShift}`;
            const productionDocsMap = new Map();
            const dateFields = ['data', 'workDay'];
            const shiftVariants = [currentShift, shiftKey, String(currentShift)];

            for (const field of dateFields) {
                for (const shiftVariant of shiftVariants) {
                    try {
                        const snapshot = await db.collection('production_entries')
                            .where('machine', '==', machineId)
                            .where(field, '==', dataReferencia)
                            .where('turno', '==', shiftVariant)
                            .get();

                        if (!snapshot.empty) {
                            console.log(`[TRACE][handleReworkSubmit] found ${snapshot.size} production entries via ${field}/${shiftVariant}`);
                            snapshot.docs.forEach((doc) => productionDocsMap.set(doc.id, doc));
                        }
                    } catch (queryError) {
                        console.warn(`[TRACE][handleReworkSubmit] query failed for ${field}/${shiftVariant}`, queryError);
                    }
                }
            }

            const productionDocs = Array.from(productionDocsMap.values());
            console.log(`[TRACE][handleReworkSubmit] total candidate production docs: ${productionDocs.length}`);

            const transactionResult = await db.runTransaction(async (transaction) => {
                const reworkRef = db.collection('rework_entries').doc();
                let totalDeducted = 0;
                let adjustedDocs = 0;

                for (const doc of productionDocs) {
                    const freshSnapshot = await transaction.get(doc.ref);
                    if (!freshSnapshot.exists) {
                        console.warn(`[TRACE][handleReworkSubmit] skipping missing production doc ${doc.id}`);
                        continue;
                    }

                    const prodData = freshSnapshot.data() || {};
                    const docShiftKey = normalizeShiftValue(prodData.turno);
                    if (docShiftKey && docShiftKey !== shiftKey) {
                        console.log(`[TRACE][handleReworkSubmit] skipping production doc ${doc.id} for shift ${docShiftKey}`);
                        continue;
                    }

                    const currentQty = Number(prodData.produzido ?? prodData.quantity ?? prodData.quantidade ?? 0) || 0;
                    if (currentQty <= 0) {
                        console.log(`[TRACE][handleReworkSubmit] skipping production doc ${doc.id} (current quantity <= 0)`);
                        continue;
                    }

                    const newQty = Math.max(0, currentQty - quantity);
                    const deducted = currentQty - newQty;
                    if (deducted <= 0) {
                        console.log(`[TRACE][handleReworkSubmit] no deduction applied to doc ${doc.id} (current=${currentQty}, requested=${quantity})`);
                        continue;
                    }

                    totalDeducted += deducted;
                    adjustedDocs += 1;

                    const updatePayload = {
                        produzido: newQty,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastAdjustment: {
                            type: 'rework_deduction',
                            requestedQty: quantity,
                            appliedQty: deducted,
                            previousQty: currentQty,
                            newQty,
                            shift: shiftKey,
                            reworkTurn: currentShift,
                            reworkWorkDay: dataReferencia,
                            adjustedBy: currentUser.username || currentUser.email || 'sistema',
                            adjustedByName: getCurrentUserName(),
                            adjustedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            reason: reason,
                            observations: observations
                        }
                    };

                    const aliasFields = ['quantity', 'quantidade', 'executed', 'executedQty', 'executedQuantity', 'finalQuantity'];
                    aliasFields.forEach((field) => {
                        if (Object.prototype.hasOwnProperty.call(prodData, field)) {
                            updatePayload[field] = newQty;
                        }
                    });

                    transaction.update(doc.ref, updatePayload);
                    console.log(`[TRACE][handleReworkSubmit] adjusted production doc ${doc.id}: ${currentQty} -> ${newQty} (deducted ${deducted})`);
                }

                if (totalDeducted > 0) {
                    try {
                        const planRef = db.collection('planning').doc(planId);
                        const planSnapshot = await transaction.get(planRef);
                        if (planSnapshot.exists) {
                            const planData = planSnapshot.data() || {};
                            const planUpdate = {};
                            const planShiftData = planData[shiftKey];

                            if (planShiftData && typeof planShiftData === 'object') {
                                const planShiftCurrent = Number(planShiftData.produzido ?? planShiftData.quantity ?? planShiftData.quantidade ?? 0) || 0;
                                const planShiftNew = Math.max(0, planShiftCurrent - totalDeducted);
                                planUpdate[`${shiftKey}.produzido`] = planShiftNew;
                                if (Object.prototype.hasOwnProperty.call(planShiftData, 'quantity')) {
                                    planUpdate[`${shiftKey}.quantity`] = planShiftNew;
                                }
                                if (Object.prototype.hasOwnProperty.call(planShiftData, 'quantidade')) {
                                    planUpdate[`${shiftKey}.quantidade`] = planShiftNew;
                                }
                            }

                            ['total_produzido', 'totalProduced', 'executed_total', 'produzido_total'].forEach((field) => {
                                if (planData[field] !== undefined) {
                                    const currentTotal = Number(planData[field]) || 0;
                                    planUpdate[field] = Math.max(0, currentTotal - totalDeducted);
                                }
                            });

                            if (Object.keys(planUpdate).length > 0) {
                                planUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                                transaction.update(planRef, planUpdate);
                                console.log(`[TRACE][handleReworkSubmit] plan ${planId} updated (deducted ${totalDeducted})`);
                            }
                        }
                    } catch (planError) {
                        console.warn('[TRACE][handleReworkSubmit] failed to update plan totals during rework', planError);
                    }

                    const resolveOrderId = () => {
                        const candidates = [
                            selectedMachineData.order_id,
                            selectedMachineData.production_order_id,
                            selectedMachineData.production_order,
                            selectedMachineData.orderId
                        ];
                        for (const candidate of candidates) {
                            if (!candidate) continue;
                            const trimmed = String(candidate).trim();
                            if (trimmed) return trimmed;
                        }
                        return null;
                    };

                    const linkedOrderId = resolveOrderId();
                    if (linkedOrderId) {
                        try {
                            const orderRef = db.collection('production_orders').doc(linkedOrderId);
                            const orderSnapshot = await transaction.get(orderRef);
                            if (orderSnapshot.exists) {
                                const orderData = orderSnapshot.data() || {};
                                const orderUpdate = {};
                                const currentOrderTotal = Number(orderData.total_produzido ?? orderData.totalProduced ?? 0) || 0;
                                const newOrderTotal = Math.max(0, currentOrderTotal - totalDeducted);

                                if ('total_produzido' in orderData || !('totalProduced' in orderData)) {
                                    orderUpdate.total_produzido = newOrderTotal;
                                }
                                if ('totalProduced' in orderData) {
                                    orderUpdate.totalProduced = newOrderTotal;
                                }

                                if (orderData.last_progress && typeof orderData.last_progress === 'object') {
                                    const lastProgressExecuted = Number(orderData.last_progress.executed ?? orderData.last_progress.total ?? 0) || 0;
                                    const newLastExecuted = Math.max(0, lastProgressExecuted - totalDeducted);
                                    orderUpdate['last_progress.executed'] = newLastExecuted;
                                    orderUpdate['last_progress.updatedAt'] = firebase.firestore.FieldValue.serverTimestamp();
                                }

                                if (Object.keys(orderUpdate).length > 0) {
                                    orderUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                                    transaction.update(orderRef, orderUpdate);
                                    console.log(`[TRACE][handleReworkSubmit] production order ${linkedOrderId} updated (deducted ${totalDeducted})`);
                                }
                            }
                        } catch (orderError) {
                            console.warn('[TRACE][handleReworkSubmit] failed to update production order totals during rework', orderError);
                        }
                    }
                }

                const reworkData = {
                    planId,
                    data: dataReferencia,
                    turno: currentShift,
                    shiftKey,
                    quantidade: quantity,
                    appliedQuantity: totalDeducted,
                    documentosAjustados: adjustedDocs,
                    peso_kg: weight > 0 ? weight : null,
                    motivo: reason,
                    observacoes: observations,
                    machine: selectedMachineData.machine || null,
                    mp: selectedMachineData.mp || '',
                    registradoPor: currentUser.username || null,
                    registradoPorNome: getCurrentUserName(),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                transaction.set(reworkRef, reworkData);
                console.log(`[TRACE][handleReworkSubmit] rework document prepared (adjustedDocs=${adjustedDocs}, totalDeducted=${totalDeducted})`);

                return { totalDeducted, adjustedDocs };
            });

            closeModal('quick-rework-modal');
            await populateMachineSelector();
            await Promise.all([
                loadTodayStats(),
                refreshLaunchCharts(),
                loadRecentEntries(false),
                refreshAnalysisIfActive()
            ]);

            if (transactionResult?.totalDeducted > 0) {
                showNotification('Retrabalho registrado e quantidade ajustada com sucesso!', 'success');
            } else {
                showNotification('Retrabalho registrado. Nenhum lançamento de produção foi ajustado para este turno.', 'warning');
            }
            
            // Registrar log de retrabalho
            registrarLogSistema('LANÇAMENTO DE RETRABALHO', 'retrabalho', {
                machine: selectedMachineData?.machine,
                quantidade: quantity,
                peso_kg: weight,
                motivo: reason,
                observacoes: observations
            });

            console.log('[TRACE][handleReworkSubmit] success path completed', transactionResult);
        } catch (error) {
            console.error('Erro ao registrar retrabalho:', error);
            alert('Erro ao registrar retrabalho. Tente novamente.');
        }
    }

    // Função utilitária para retry com backoff exponencial (para erros 429)
    async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
        let lastError;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                const is429 = error.message?.includes('429') || error.code === 'resource-exhausted';
                if (!is429 || attempt === maxRetries) {
                    throw error;
                }
                const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 500;
                console.log(`[RETRY] Tentativa ${attempt + 1} falhou com 429, aguardando ${Math.round(delay)}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        throw lastError;
    }
    
    // Funções auxiliares
    function getCurrentShift(reference = new Date()) {
        const hour = reference.getHours();
        const minute = reference.getMinutes();
        
        // T1: 06:30-14:59, T2: 15:00-23:19, T3: 23:20-06:29
        if ((hour === 6 && minute >= 30) || (hour >= 7 && hour < 15)) {
            return 1; // 1º Turno
        } else if (hour >= 15 && (hour < 23 || (hour === 23 && minute < 20))) {
            return 2; // 2º Turno
        } else {
            return 3; // 3º Turno
        }
    }

    function getShiftStartDateTime(reference = new Date()) {
        const shift = getCurrentShift(reference);
        const productionDay = getProductionDateString(reference);
        const shiftStartMap = {
            1: '07:00',
            2: '15:00',
            3: '23:20'
        };
        const startTime = shiftStartMap[shift] || '07:00';
        const startDate = combineDateAndTime(productionDay, startTime);
        if (startDate instanceof Date && !Number.isNaN(startDate.getTime())) {
            return startDate;
        }
        return null;
    }
    
    function updateMachineStatus() {
        // Notificação Web Push se máquina parada > 10 minutos
        if (machineStatus === 'stopped' && currentDowntimeStart) {
            const now = new Date();
            const startDateTime = combineDateAndTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            if (startDateTime instanceof Date && !Number.isNaN(startDateTime.getTime())) {
                const elapsedMs = now - startDateTime;
                if (elapsedMs > 10 * 60 * 1000 && !downtimeNotificationSent) {
                    sendDowntimeNotification();
                    downtimeNotificationSent = true;
                }
                if (elapsedMs <= 10 * 60 * 1000) {
                    downtimeNotificationSent = false;
                }
            }
        } else {
            downtimeNotificationSent = false;
        }
// Envia notificação Web Push se permitido
function sendDowntimeNotification() {
    if ('serviceWorker' in navigator && 'Notification' in window && Notification.permission === 'granted') {
        navigator.serviceWorker.getRegistration().then(function(reg) {
            if (reg) {
                reg.showNotification('Atenção: Máquina parada', {
                    body: 'Uma máquina está parada há mais de 10 minutos.',
                    icon: 'https://i.postimg.cc/5jdHwhF9/hokkaido-logo-110.png',
                    badge: 'https://i.postimg.cc/5jdHwhF9/hokkaido-logo-110.png',
                    data: '/'
                });
            }
        });
    }
}
    console.log('[DEBUG] updateMachineStatus: machineStatus=', machineStatus, 'currentDowntimeStart=', currentDowntimeStart);
    console.log('[DEBUG] toggleDowntime: chamado, machineStatus=', machineStatus, 'currentDowntimeStart=', currentDowntimeStart);
    console.log('[DEBUG] handleDowntimeSubmit: início, machineStatus=', machineStatus, 'currentDowntimeStart=', currentDowntimeStart);
        const btnDowntime = document.getElementById('btn-downtime');
        const downtimeIcon = document.getElementById('downtime-icon');
        const downtimeText = document.getElementById('downtime-text');
        const downtimeSubtitle = document.getElementById('downtime-subtitle');
        
        if (machineStatus === 'stopped') {
            // Máquina parada - mostrar botão START (verde)
            btnDowntime.classList.remove('from-red-500', 'to-red-600', 'hover:from-red-600', 'hover:to-red-700');
            btnDowntime.classList.add('from-green-500', 'to-green-600', 'hover:from-green-600', 'hover:to-green-700');
            downtimeIcon.setAttribute('data-lucide', 'play-circle');
            downtimeText.textContent = 'START';
            
            // Mostrar tempo da parada atual se disponível
            if (currentDowntimeStart) {
                const now = new Date();
                const startDateTime = combineDateAndTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
                if (startDateTime instanceof Date && !Number.isNaN(startDateTime.getTime())) {
                    const elapsedHours = ((now - startDateTime) / (1000 * 60 * 60)).toFixed(1);
                    downtimeSubtitle.textContent = `PARADA ATIVA - ${elapsedHours}h`;
                } else {
                    downtimeSubtitle.textContent = 'PARADA ATIVA - Retomar produção';
                }
            } else {
                downtimeSubtitle.textContent = 'Retomar produção';
            }
            
            downtimeSubtitle.classList.remove('text-red-100');
            downtimeSubtitle.classList.add('text-green-100');
        } else {
            // Máquina rodando - mostrar botão STOP (vermelho)
            btnDowntime.classList.remove('from-green-500', 'to-green-600', 'hover:from-green-600', 'hover:to-green-700');
            btnDowntime.classList.add('from-red-500', 'to-red-600', 'hover:from-red-600', 'hover:to-red-700');
            downtimeIcon.setAttribute('data-lucide', 'pause-circle');
            downtimeText.textContent = 'STOP';
            downtimeSubtitle.textContent = 'Parar máquina';
            downtimeSubtitle.classList.remove('text-green-100');
            downtimeSubtitle.classList.add('text-red-100');
        }
        
        lucide.createIcons();
    }
    
    /**
     * Timer visual de parada - atualiza a cada segundo
     * Usa múltiplas fontes de timestamp para robustez
     */
    function startDowntimeTimer() {
        const downtimeTimer = document.getElementById('downtime-timer');
        if (!downtimeTimer) return;
        
        downtimeTimer.classList.remove('hidden');
        
        const updateTimer = () => {
            if (!currentDowntimeStart) {
                downtimeTimer.textContent = '00:00:00';
                return;
            }
            
            const now = new Date();
            
            // Tentar obter o timestamp de início de múltiplas fontes
            let start = null;
            
            // Prioridade 1: Timestamp direto (objeto Date)
            if (currentDowntimeStart.startTimestamp instanceof Date && !isNaN(currentDowntimeStart.startTimestamp.getTime())) {
                start = currentDowntimeStart.startTimestamp;
            }
            // Prioridade 2: Timestamp ISO local
            else if (currentDowntimeStart.startTimestampLocal) {
                start = new Date(currentDowntimeStart.startTimestampLocal);
            }
            // Prioridade 3: Combinar data + hora
            else if (currentDowntimeStart.date && currentDowntimeStart.startTime) {
                start = parseDateTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            }
            // Prioridade 4: Fallback para combineDateAndTime
            else {
                start = combineDateAndTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            }
            
            if (!(start instanceof Date) || isNaN(start.getTime())) {
                downtimeTimer.textContent = '--:--:--';
                downtimeTimer.title = 'Erro ao calcular duração';
                return;
            }
            
            let diffMs = now.getTime() - start.getTime();
            if (diffMs < 0) diffMs = 0;
            
            const diffSec = Math.floor(diffMs / 1000);
            const days = Math.floor(diffSec / 86400);
            const hours = Math.floor((diffSec % 86400) / 3600);
            const minutes = Math.floor((diffSec % 3600) / 60);
            const seconds = diffSec % 60;
            
            // Formatar exibição baseada na duração
            let timeDisplay;
            if (days >= 1) {
                timeDisplay = `${days}d ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            } else {
                timeDisplay = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            downtimeTimer.textContent = timeDisplay;
            
            // Limpar classes anteriores
            downtimeTimer.classList.remove(
                'bg-red-300', 'bg-red-500', 'bg-orange-300', 'bg-yellow-300', 'bg-purple-300',
                'text-red-800', 'text-orange-800', 'text-yellow-800', 'text-purple-800', 'text-white',
                'animate-pulse'
            );
            
            // Alertas visuais baseados na duração
            const totalHours = diffMs / (1000 * 60 * 60);
            
            if (days >= 1) {
                // 1+ dia - Roxo/Crítico com animação
                downtimeTimer.classList.add('bg-purple-300', 'text-purple-800', 'animate-pulse');
                downtimeTimer.title = `⚠️ PARADA CRÍTICA: ${days} dia(s) e ${hours}h - Verificar urgentemente!`;
            } else if (totalHours >= 8) {
                // 8+ horas - Vermelho escuro (turno completo)
                downtimeTimer.classList.add('bg-red-500', 'text-white');
                downtimeTimer.title = `⚠️ Parada muito longa: ${hours}h${minutes}m - Atenção!`;
            } else if (totalHours >= 4) {
                // 4+ horas - Laranja
                downtimeTimer.classList.add('bg-orange-300', 'text-orange-800');
                downtimeTimer.title = `Parada longa: ${hours}h${minutes}m`;
            } else if (totalHours >= 1) {
                // 1+ hora - Amarelo
                downtimeTimer.classList.add('bg-yellow-300', 'text-yellow-800');
                downtimeTimer.title = `Parada em andamento: ${hours}h${minutes}m`;
            } else {
                // < 1 hora - Vermelho padrão
                downtimeTimer.classList.add('bg-red-300', 'text-red-800');
                downtimeTimer.title = `Parada ativa: ${timeDisplay}`;
            }
        };
        
        // Executar imediatamente e depois a cada segundo
        updateTimer();
        
        // Limpar intervalo anterior se existir
        if (downtimeTimer.interval) {
            clearInterval(downtimeTimer.interval);
        }
        downtimeTimer.interval = setInterval(updateTimer, 1000);
    }
    
    function stopDowntimeTimer() {
        const downtimeTimer = document.getElementById('downtime-timer');
        if (downtimeTimer) {
            downtimeTimer.classList.add('hidden');
            if (downtimeTimer.interval) {
                clearInterval(downtimeTimer.interval);
            }
        }
    }

    function formatSecondsToClock(totalSeconds) {
        const safeSeconds = Math.max(0, Math.floor(totalSeconds || 0));
        const hours = Math.floor(safeSeconds / 3600);
        const minutes = Math.floor((safeSeconds % 3600) / 60);
        const seconds = safeSeconds % 60;
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function updateProductionTimeDisplay(seconds) {
        if (!productionTimeDisplay) return;
        productionTimeDisplay.textContent = formatSecondsToClock(seconds);
    }

    function clearProductionTimerInterval() {
        if (productionTimer) {
            clearInterval(productionTimer);
            productionTimer = null;
        }
    }

    function resetProductionTimer() {
        productionTimerBaseSeconds = 0;
        productionTimerResumeTimestamp = null;
        clearProductionTimerInterval();
        updateProductionTimeDisplay(0);
    }

    function freezeProductionTimer() {
        if (productionTimerResumeTimestamp) {
            const elapsed = Math.floor((Date.now() - productionTimerResumeTimestamp) / 1000);
            productionTimerBaseSeconds += Math.max(elapsed, 0);
            productionTimerResumeTimestamp = null;
        }
        clearProductionTimerInterval();
        updateProductionTimeDisplay(productionTimerBaseSeconds);
    }

    function resumeProductionTimer() {
        if (productionTimerResumeTimestamp) {
            return;
        }
        productionTimerResumeTimestamp = Date.now();
        clearProductionTimerInterval();
        updateProductionTimeDisplay(productionTimerBaseSeconds);
        productionTimer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - productionTimerResumeTimestamp) / 1000);
            updateProductionTimeDisplay(productionTimerBaseSeconds + Math.max(elapsed, 0));
        }, 1000);
    }

    function synchronizeProductionTimer(elapsedSeconds, shouldRun) {
        productionTimerBaseSeconds = Math.max(0, Math.floor(elapsedSeconds || 0));
        productionTimerResumeTimestamp = shouldRun ? Date.now() : null;
        clearProductionTimerInterval();
        updateProductionTimeDisplay(productionTimerBaseSeconds);

        if (!shouldRun) {
            return;
        }

        productionTimer = setInterval(() => {
            if (!productionTimerResumeTimestamp) {
                clearProductionTimerInterval();
                return;
            }
            const elapsed = Math.floor((Date.now() - productionTimerResumeTimestamp) / 1000);
            updateProductionTimeDisplay(productionTimerBaseSeconds + Math.max(elapsed, 0));
        }, 1000);
    }

    // Calcula o tempo de produção efetivo do turno atual desconsiderando paradas registradas.
    function calculateProductionRuntimeSeconds({ shiftStart, now, downtimes = [], activeDowntime = null }) {
        if (!(shiftStart instanceof Date) || Number.isNaN(shiftStart.getTime())) {
            return 0;
        }

        const referenceNow = now instanceof Date ? now : new Date();
        if (referenceNow <= shiftStart) {
            return 0;
        }

        const shiftStartMs = shiftStart.getTime();
        const nowMs = referenceNow.getTime();
        let downtimeMillis = 0;

        // Helper function to extract start time with multiple field name support
        const extractStartTime = (dt) => {
            // Try multiple date field names
            const dateStr = dt.date || dt.start_date || dt.data_inicio;
            
            // Try multiple start time field names
            const timeStr = dt.startTime || dt.start_time || dt.hora_inicio || dt.horaInicio;
            
            if (dateStr && timeStr) {
                const combined = combineDateAndTime(dateStr, timeStr);
                if (combined instanceof Date && !Number.isNaN(combined.getTime())) {
                    return combined;
                }
            }
            
            // Try parsing as a full datetime
            if (dt.start_datetime) {
                const asDate = dt.start_datetime?.toDate?.() || new Date(dt.start_datetime);
                if (asDate instanceof Date && !Number.isNaN(asDate.getTime())) {
                    return asDate;
                }
            }
            
            return null;
        };

        // Helper function to extract end time with multiple field name support
        const extractEndTime = (dt) => {
            // Try multiple date field names
            const dateStr = dt.date || dt.end_date || dt.data_fim;
            
            // Try multiple end time field names
            const timeStr = dt.endTime || dt.end_time || dt.hora_fim || dt.horaFim;
            
            if (dateStr && timeStr) {
                const combined = combineDateAndTime(dateStr, timeStr);
                if (combined instanceof Date && !Number.isNaN(combined.getTime())) {
                    return combined;
                }
            }
            
            // Try parsing as a full datetime
            if (dt.end_datetime) {
                const asDate = dt.end_datetime?.toDate?.() || new Date(dt.end_datetime);
                if (asDate instanceof Date && !Number.isNaN(asDate.getTime())) {
                    return asDate;
                }
            }
            
            return null;
        };

        downtimes.forEach(dt => {
            if (!dt) return;
            
            const start = extractStartTime(dt);
            if (!(start instanceof Date) || Number.isNaN(start.getTime())) {
                return;
            }

            let effectiveEnd = extractEndTime(dt);
            
            // If no explicit end time, try to calculate from duration
            if (!(effectiveEnd instanceof Date) || Number.isNaN(effectiveEnd.getTime()) || effectiveEnd <= start) {
                // Try multiple duration field names
                const durationMinutes = Number(dt.duration || dt.duracao || dt.duration_minutes || dt.duracao_minutos || 0);
                effectiveEnd = new Date(start.getTime() + Math.max(durationMinutes, 0) * 60000);
            }

            const windowStart = Math.max(start.getTime(), shiftStartMs);
            const windowEnd = Math.min(effectiveEnd.getTime(), nowMs);
            if (windowEnd > windowStart) {
                downtimeMillis += windowEnd - windowStart;
            }
        });

        if (activeDowntime) {
            const activeStart = extractStartTime(activeDowntime);
            if (activeStart instanceof Date && !Number.isNaN(activeStart.getTime())) {
                const windowStart = Math.max(activeStart.getTime(), shiftStartMs);
                if (nowMs > windowStart) {
                    downtimeMillis += nowMs - windowStart;
                }
            }
        }

        const elapsedMillis = nowMs - shiftStartMs;
        const runtimeMillis = Math.max(0, elapsedMillis - downtimeMillis);
        return Math.floor(runtimeMillis / 1000);
    }
    
    function setRecentEntriesState({ loading = false, empty = false }) {
        if (recentEntriesLoading) {
            recentEntriesLoading.classList.toggle('hidden', !loading);
        }
        if (recentEntriesEmpty) {
            recentEntriesEmpty.classList.toggle('hidden', !empty);
        }
        if (recentEntriesList) {
            recentEntriesList.classList.toggle('hidden', empty);
        }
    }

    function updateRecentEntriesEmptyMessage(message) {
        if (recentEntriesEmpty) {
            recentEntriesEmpty.innerHTML = `<p class="text-sm text-gray-500">${message}</p>`;
        }
    }

    function formatEntryTimestamp(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        return new Intl.DateTimeFormat('pt-BR', {
            day: '2-digit',
            month: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        }).format(date);
    }

    function buildRecentEntryMarkup(entry) {
        const typeConfig = {
            production: { label: 'Produção', badge: 'bg-green-100 text-green-700 border border-green-200' },
            loss: { label: 'Perda', badge: 'bg-orange-100 text-orange-700 border border-orange-200' },
            downtime: { label: 'Parada', badge: 'bg-red-100 text-red-700 border border-red-200' },
            rework: { label: 'Retrabalho', badge: 'bg-purple-100 text-purple-700 border border-purple-200' }
        };

        const config = typeConfig[entry.type] || { label: 'Lançamento', badge: 'bg-gray-100 text-gray-600 border border-gray-200' };
        const turnoLabel = entry.data.turno ? `Turno ${entry.data.turno}` : null;
        const timeLabel = formatEntryTimestamp(entry.timestamp);
        // Operador que fez o lançamento (código + nome)
        const operadorNome = entry.data.nomeUsuario || null;
        const operadorCod = entry.data.userCod !== undefined ? entry.data.userCod : null;
        const details = [];
        const parseNumber = (value) => {
            const parsed = parseOptionalNumber(value);
            return parsed !== null ? parsed : 0;
        };

        if (entry.data.mp) {
            details.push(`MP: ${entry.data.mp}`);
        }

        if (entry.type === 'production') {
            const produzido = parseInt(entry.data.produzido ?? entry.data.quantity ?? 0, 10) || 0;
            
            details.push(`<span class="font-semibold text-gray-800">${produzido} peça(s)</span>`);
            const pesoBruto = parseNumber(entry.data.peso_bruto ?? entry.data.weight ?? 0);
            if (pesoBruto > 0) {
                details.push(`${pesoBruto.toFixed(3)} kg`);
            }
        } else if (entry.type === 'loss') {
            const refugoKg = parseNumber(entry.data.refugo_kg ?? entry.data.weight ?? 0);
            const quantidade = parseInt(entry.data.quantidade ?? 0, 10) || 0;
            
            if (quantidade > 0) {
                details.push(`<span class="font-semibold text-gray-800">${quantidade} peça(s)</span>`);
            }
            if (refugoKg > 0) {
                details.push(`<span class="font-semibold text-gray-800">${refugoKg.toFixed(3)} kg</span>`);
            }
            if (entry.data.perdas || entry.data.motivo) {
                details.push(`Motivo: ${entry.data.perdas || entry.data.motivo}`);
            }
        } else if (entry.type === 'downtime') {
            const start = entry.data.startTime ? `${entry.data.startTime}` : '';
            const end = entry.data.endTime ? ` - ${entry.data.endTime}` : '';
            details.push(`Período: ${start}${end}`);
            
            // Calcular duração da parada
            if (entry.data.startTime && entry.data.endTime) {
                const [startHour, startMin] = entry.data.startTime.split(':').map(Number);
                const [endHour, endMin] = entry.data.endTime.split(':').map(Number);
                
                let startTotalMin = startHour * 60 + startMin;
                let endTotalMin = endHour * 60 + endMin;
                
                // Se fim é menor que inicio, passou da meia noite
                if (endTotalMin < startTotalMin) {
                    endTotalMin += 24 * 60;
                }
                
                const durationMin = endTotalMin - startTotalMin;
                const durationHours = Math.floor(durationMin / 60);
                const durationMins = durationMin % 60;
                
                let durationStr = '';
                if (durationHours > 0) {
                    durationStr = `${durationHours}h`;
                }
                if (durationMins > 0) {
                    durationStr += durationStr ? ` ${durationMins}min` : `${durationMins}min`;
                }
                if (durationMin === 0) {
                    durationStr = '0min';
                }
                
                details.push(`<span class="font-semibold text-red-600">⏱️ Duração: ${durationStr}</span>`);
            }
            
            if (entry.data.reason) {
                details.push(`Motivo: ${entry.data.reason}`);
            }
        } else if (entry.type === 'rework') {
            const quantidade = parseInt(entry.data.quantidade ?? entry.data.quantity ?? 0, 10) || 0;
            details.push(`<span class="font-semibold text-gray-800">${quantidade} peça(s)</span>`);
            const pesoKg = parseNumber(entry.data.peso_kg ?? entry.data.weight ?? 0);
            if (pesoKg > 0) {
                details.push(`${pesoKg.toFixed(3)} kg`);
            }
            if (entry.data.motivo) {
                details.push(`Motivo: ${entry.data.motivo}`);
            }
        }

        const observations = entry.data.observacoes || entry.data.observations || entry.data.notes;
        const canEdit = entry.type === 'production' || entry.type === 'loss';
        const actions = [];

        if (canEdit) {
            actions.push(`
                <button class="flex items-center gap-1 px-3 py-1.5 text-sm text-blue-600 border border-blue-200 rounded-lg hover:bg-blue-50"
                        data-action="edit" data-entry-id="${entry.id}" data-entry-type="${entry.type}">
                    <i data-lucide="pencil" class="w-4 h-4"></i>
                    Editar
                </button>
            `);
        }

        actions.push(`
            <button class="flex items-center gap-1 px-3 py-1.5 text-sm text-red-600 border border-red-200 rounded-lg hover:bg-red-50"
                    data-action="delete" data-entry-id="${entry.id}" data-entry-type="${entry.type}">
                <i data-lucide="trash-2" class="w-4 h-4"></i>
                Excluir
            </button>
        `);

        const metaChips = [config.label];
        if (turnoLabel) metaChips.push(turnoLabel);
        if (timeLabel) metaChips.push(timeLabel);
        
        // Construir badge do operador (somente se tiver nome)
        let operadorBadge = '';
        if (operadorNome) {
            operadorBadge = `<span class="px-2 py-1 rounded-full bg-indigo-50 text-indigo-600 border border-indigo-200" title="Código: ${operadorCod}">👤 ${operadorNome}</span>`;
        }

        return `
            <div class="border border-gray-200 rounded-lg p-4 bg-white shadow-sm">
                <div class="flex flex-col gap-3 md:flex-row md:items-start md:justify-between">
                    <div class="space-y-2 flex-1">
                        <div class="flex flex-wrap items-center gap-2 text-xs text-gray-500">
                            <span class="px-2 py-1 rounded-full ${config.badge}">${config.label}</span>
                            ${turnoLabel ? `<span class="px-2 py-1 rounded-full bg-gray-100 text-gray-600 border border-gray-200">${turnoLabel}</span>` : ''}
                            ${timeLabel ? `<span>${timeLabel}</span>` : ''}
                            ${operadorBadge}
                        </div>
                        <div class="text-sm text-gray-700 space-x-2">
                            ${details.join('<span class="text-gray-300">–</span>')}
                        </div>
                        ${observations ? `<div class="text-xs text-gray-500">Obs.: ${observations}</div>` : ''}
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        ${actions.join('')}
                    </div>
                </div>
            </div>
        `;
    }

    function renderRecentEntries(entries) {
        if (!recentEntriesList) return;
        recentEntriesList.innerHTML = entries.map(buildRecentEntryMarkup).join('');
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    async function loadRecentEntries(showLoading = true, filterDate = null) {
        if (!recentEntriesList) return;

        if (showLoading) {
            setRecentEntriesState({ loading: true, empty: false });
        }

        if (!selectedMachineData) {
            recentEntriesCache = new Map();
            if (recentEntriesList) recentEntriesList.innerHTML = '';
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
            return;
        }

        try {
            const date = filterDate || window.lancamentoFilterDate || getProductionDateString();
            const planId = selectedMachineData.id;

            const productionSnapshot = await db.collection('production_entries')
                .where('planId', '==', planId)
                .where('data', '==', date)
                .get();

            const entries = [];
            recentEntriesCache = new Map();

            productionSnapshot.forEach(doc => {
                const data = doc.data();
                const type = (data.refugo_kg && data.refugo_kg > 0) || data.perdas ? 'loss' : 'production';
                const resolvedTimestamp = resolveProductionDateTime(data) || data.updatedAt?.toDate?.() || data.timestamp?.toDate?.() || data.createdAt?.toDate?.() || (data.datetime ? new Date(data.datetime) : null);

                const entry = {
                    id: doc.id,
                    type,
                    collection: 'production_entries',
                    data,
                    timestamp: resolvedTimestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });

            // Fallback: buscar lançamentos da máquina (ex. BORRA) que não possuem planId associado
            const machineId = normalizeMachineId(selectedMachineData.machine || '');
            if (machineId) {
                const machineSnapshot = await db.collection('production_entries')
                    .where('machine', '==', machineId)
                    .where('data', '==', date)
                    .get();

                machineSnapshot.forEach(doc => {
                    if (recentEntriesCache.has(doc.id)) return;
                    const data = doc.data();
                    const type = (data.refugo_kg && data.refugo_kg > 0) || data.perdas ? 'loss' : 'production';
                    const resolvedTimestamp = resolveProductionDateTime(data) || data.updatedAt?.toDate?.() || data.timestamp?.toDate?.() || data.createdAt?.toDate?.() || (data.datetime ? new Date(data.datetime) : null);

                    const entry = {
                        id: doc.id,
                        type,
                        collection: 'production_entries',
                        data,
                        timestamp: resolvedTimestamp
                    };

                    entries.push(entry);
                    recentEntriesCache.set(doc.id, entry);
                });
            }

            const downtimeSnapshot = await db.collection('downtime_entries')
                .where('machine', '==', selectedMachineData.machine)
                .where('date', '==', date)
                .get();

            downtimeSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || resolveProductionDateTime(data) || (data.startTime ? new Date(`${data.date}T${data.startTime}`) : null);

                const entry = {
                    id: doc.id,
                    type: 'downtime',
                    collection: 'downtime_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });

            const reworkSnapshot = await db.collection('rework_entries')
                .where('planId', '==', planId)
                .where('data', '==', date)
                .get();

            reworkSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || (data.data ? new Date(`${data.data}T12:00:00`) : null);

                const entry = {
                    id: doc.id,
                    type: 'rework',
                    collection: 'rework_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });

            entries.sort((a, b) => {
                const timeA = a.timestamp instanceof Date ? a.timestamp.getTime() : 0;
                const timeB = b.timestamp instanceof Date ? b.timestamp.getTime() : 0;
                return timeB - timeA;
            });

            // Armazenar todas as entradas para filtro
            allRecentEntries = entries;

            if (!entries.length) {
                updateRecentEntriesEmptyMessage('Ainda não há lançamentos para esta máquina.');
                setRecentEntriesState({ loading: false, empty: true });
            } else {
                applyEntryFilter(currentEntryFilter);
                setRecentEntriesState({ loading: false, empty: false });
            }
        } catch (error) {
            console.error('Erro ao carregar lançamentos recentes: ', error);
            updateRecentEntriesEmptyMessage('Não foi possível carregar os lançamentos. Tente novamente.');
            setRecentEntriesState({ loading: false, empty: true });
        }
    }

    function refreshRecentEntries(showLoading = false) {
        loadRecentEntries(showLoading);
    }
    window.refreshRecentEntries = refreshRecentEntries;

    // Funções auxiliares para indicador de data de lançamentos
    // Funções auxiliares para indicador de filtros de lançamentos
    function updateEntriesFilterIndicator() {
        const indicator = document.getElementById('entries-filter-indicator');
        const display = document.getElementById('entries-filter-display');
        const today = getProductionDateString();
        const filterDate = window.lancamentoFilterDate;
        const filterMachine = window.lancamentoFilterMachine;
        
        if (indicator && display) {
            const parts = [];
            
            if (filterDate && filterDate !== today) {
                const [year, month, day] = filterDate.split('-');
                parts.push(`Data: ${day}/${month}/${year}`);
            }
            
            if (filterMachine) {
                parts.push(`Máquina: ${filterMachine}`);
            }
            
            if (parts.length > 0) {
                display.textContent = parts.join(' | ');
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }
    }
    
    function hideEntriesFilterIndicator() {
        const indicator = document.getElementById('entries-filter-indicator');
        if (indicator) {
            indicator.classList.add('hidden');
        }
    }
    
    // Função para carregar lançamentos com filtros de data e máquina
    async function loadRecentEntriesWithFilters() {
        if (!recentEntriesList) return;
        
        setRecentEntriesState({ loading: true, empty: false });
        
        const filterDate = window.lancamentoFilterDate || getProductionDateString();
        const filterMachine = window.lancamentoFilterMachine;
        
        // Se tiver máquina específica selecionada, buscar por ela
        const machineToSearch = filterMachine || (selectedMachineData ? selectedMachineData.machine : null);
        
        if (!machineToSearch) {
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
            return;
        }
        
        try {
            const entries = [];
            recentEntriesCache = new Map();
            
            // Buscar lançamentos de produção pela máquina
            const productionSnapshot = await db.collection('production_entries')
                .where('machine', '==', machineToSearch)
                .where('data', '==', filterDate)
                .get();
            
            productionSnapshot.forEach(doc => {
                const data = doc.data();
                // Verificar se é borra
                const isBorra = data.tipo_lancamento === 'BORRA' || data.lote === 'BORRA' || (data.observacoes && data.observacoes.toUpperCase().includes('BORRA'));
                const type = isBorra ? 'borra' : ((data.refugo_kg && data.refugo_kg > 0) || data.perdas ? 'loss' : 'production');
                const resolvedTimestamp = resolveProductionDateTime(data) || data.updatedAt?.toDate?.() || data.timestamp?.toDate?.() || data.createdAt?.toDate?.() || (data.datetime ? new Date(data.datetime) : null);

                const entry = {
                    id: doc.id,
                    type,
                    collection: 'production_entries',
                    data,
                    timestamp: resolvedTimestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });
            
            // Buscar paradas
            const downtimeSnapshot = await db.collection('downtime_entries')
                .where('machine', '==', machineToSearch)
                .where('date', '==', filterDate)
                .get();

            downtimeSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || resolveProductionDateTime(data) || (data.startTime ? new Date(`${data.date}T${data.startTime}`) : null);

                const entry = {
                    id: doc.id,
                    type: 'downtime',
                    collection: 'downtime_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });
            
            // Buscar retrabalhos
            const reworkSnapshot = await db.collection('rework_entries')
                .where('machine', '==', machineToSearch)
                .where('data', '==', filterDate)
                .get();

            reworkSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || (data.data ? new Date(`${data.data}T12:00:00`) : null);

                const entry = {
                    id: doc.id,
                    type: 'rework',
                    collection: 'rework_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });
            
            // Ordenar por timestamp
            entries.sort((a, b) => {
                const timeA = a.timestamp instanceof Date ? a.timestamp.getTime() : 0;
                const timeB = b.timestamp instanceof Date ? b.timestamp.getTime() : 0;
                return timeB - timeA;
            });

            allRecentEntries = entries;

            if (!entries.length) {
                updateRecentEntriesEmptyMessage(`Nenhum lançamento encontrado para ${machineToSearch} em ${filterDate.split('-').reverse().join('/')}.`);
                setRecentEntriesState({ loading: false, empty: true });
            } else {
                applyEntryFilter(currentEntryFilter);
                setRecentEntriesState({ loading: false, empty: false });
            }
        } catch (error) {
            console.error('Erro ao carregar lançamentos com filtros:', error);
            updateRecentEntriesEmptyMessage('Erro ao carregar lançamentos. Tente novamente.');
            setRecentEntriesState({ loading: false, empty: true });
        }
    }

    // Função para aplicar filtro de tipo de entrada
    function applyEntryFilter(filter) {
        currentEntryFilter = filter;
        
        let filteredEntries = allRecentEntries;
        
        if (filter !== 'all') {
            filteredEntries = allRecentEntries.filter(entry => entry.type === filter);
        }
        
        if (filteredEntries.length === 0) {
            const filterLabels = {
                all: 'lançamentos',
                production: 'lançamentos de produção',
                downtime: 'paradas',
                loss: 'perdas',
                rework: 'retrabalhos'
            };
            updateRecentEntriesEmptyMessage(`Não há ${filterLabels[filter]} para exibir.`);
            setRecentEntriesState({ loading: false, empty: true });
        } else {
            renderRecentEntries(filteredEntries);
            setRecentEntriesState({ loading: false, empty: false });
        }
        
        // Atualizar estado visual dos botões de filtro
        updateFilterButtons(filter);
    }
    
    // Função para atualizar estado visual dos botões de filtro
    function updateFilterButtons(activeFilter) {
        const filterButtons = document.querySelectorAll('.filter-entry-btn');
        filterButtons.forEach(btn => {
            const btnFilter = btn.dataset.filter;
            if (btnFilter === activeFilter) {
                btn.classList.add('active', 'bg-white', 'text-blue-600', 'shadow-sm');
                btn.classList.remove('text-gray-600', 'hover:text-gray-900', 'hover:bg-gray-50');
            } else {
                btn.classList.remove('active', 'bg-white', 'text-blue-600', 'shadow-sm');
                btn.classList.add('text-gray-600', 'hover:text-gray-900', 'hover:bg-gray-50');
            }
        });
    }

    function handleRecentEntryAction(event) {
        const actionButton = event.target.closest('[data-action]');
        if (!actionButton) return;

        const action = actionButton.dataset.action;
        const entryId = actionButton.dataset.entryId;
        const entryType = actionButton.dataset.entryType;

        if (!entryId || !entryType) return;

        if (action === 'edit') {
            // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar lançamentos
            if (!isUserGestorOrAdmin()) {
                showPermissionDeniedNotification('editar lançamentos');
                return;
            }
            openEntryForEditing(entryType, entryId);
        } else if (action === 'delete') {
            // A verificação de permissão é feita dentro de showConfirmModal
            let collection = 'production_entries';
            if (entryType === 'downtime') {
                collection = 'downtime_entries';
            } else if (entryType === 'rework') {
                collection = 'rework_entries';
            }
            showConfirmModal(entryId, collection);
        }
    }

    function openEntryForEditing(entryType, entryId) {
        const entry = recentEntriesCache.get(entryId);
        if (!entry) {
            console.warn('Registro para edição não encontrado:', entryId);
            return;
        }

        currentEditContext = {
            type: entryType,
            id: entryId,
            collection: entry.collection,
            original: entry.data
        };

        if (entryType === 'production') {
            document.getElementById('quick-production-qty').value = entry.data.produzido || 0;
            document.getElementById('quick-production-weight').value = entry.data.peso_bruto || 0;
            document.getElementById('quick-production-obs').value = entry.data.observacoes || '';
            openModal('quick-production-modal');
        } else if (entryType === 'loss') {
            document.getElementById('quick-losses-qty').value = entry.data.refugo_qty || entry.data.quantity || 0;
            document.getElementById('quick-losses-weight').value = entry.data.refugo_kg || 0;
            document.getElementById('quick-losses-reason').value = entry.data.perdas || '';
            document.getElementById('quick-losses-obs').value = entry.data.observacoes || '';
            const quickLossesDeleteBtn = document.getElementById('quick-losses-delete-btn');
            if (quickLossesDeleteBtn) quickLossesDeleteBtn.classList.remove('hidden');
            openModal('quick-losses-modal');
        } else {
            alert('Edição deste tipo de lançamento ainda não está disponível.');
        }
    }

    function showNotification(message, type = 'info') {
        console.log('🔔 Mostrando notificação:', { message, type });
        // Criar notificação toast
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg ${
            type === 'success' ? 'bg-green-100 text-green-800 border-green-200' :
            type === 'warning' ? 'bg-yellow-100 text-yellow-800 border-yellow-200' :
            type === 'error' ? 'bg-red-100 text-red-800 border-red-200' :
            'bg-blue-100 text-blue-800 border-blue-200'
        } border`;
        
        notification.innerHTML = `
            <div class="flex items-center gap-2">
                <i data-lucide="${
                    type === 'success' ? 'check-circle' :
                    type === 'warning' ? 'alert-triangle' :
                    type === 'error' ? 'x-circle' : 'info'
                }" class="w-5 h-5"></i>
                <span>${message}</span>
            </div>
        `;
        
        document.body.appendChild(notification);
        lucide.createIcons();
        
        // Remover após 3 segundos
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }
    
    // Função para carregar o painel de lançamento
    async function loadLaunchPanel() {
        try {
            showLoadingState('launch-panel', true);
            await populateMachineSelector();
            updateCurrentShiftDisplay();
            showLoadingState('launch-panel', false, false);
        } catch (error) {
            console.error("Erro ao carregar painel de lançamento: ", error);
            showLoadingState('launch-panel', false, true);
        }
    }
    
    function setActiveMachineCard(machine) {
        if (!machineCardGrid) return;

        // Remove seleção anterior
        const previousSelected = machineCardGrid.querySelector('.machine-card.selected');
        if (previousSelected) {
            previousSelected.classList.remove('selected');
        }

        if (!machine) {
            activeMachineCard = null;
            return;
        }

        // Adiciona seleção no novo card
        const nextCard = machineCardGrid.querySelector(`[data-machine="${machine}"]`);
        if (nextCard) {
            nextCard.classList.add('selected');
            activeMachineCard = nextCard;
            
            // Scroll suave para o card selecionado se necessário
            nextCard.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'nearest',
                inline: 'nearest'
            });
        } else {
            activeMachineCard = null;
        }
    }

    function isPlanActive(plan) {
        if (!plan) return false;
        const status = String(plan.status || '').toLowerCase();
        const inactiveStatuses = ['concluida', 'concluido', 'finalizada', 'finalizado', 'cancelada', 'cancelado', 'encerrada', 'encerrado'];
        if (status && inactiveStatuses.includes(status)) {
            return false;
        }
        // Não esconder automaticamente quando atingir a meta.
        // O card só deve sair quando for explicitamente finalizado (status atualizado para concluída).
        return true;
    }

    /**
     * Renderiza a barra de status das máquinas (estilo Excel)
     * Mostra todas as máquinas como células coloridas de acordo com o status
     */
    function renderMachineStatusBar(activePlans = [], activeDowntimeSet = new Set(), machinesDowntime = {}) {
        const statusBar = document.getElementById('machine-status-cells');
        if (!statusBar) return;
        
        // Criar set de máquinas com planejamento ativo
        const machinesWithPlan = new Set();
        activePlans.forEach(plan => {
            if (plan && plan.machine) {
                machinesWithPlan.add(normalizeMachineId(plan.machine));
            }
        });
        
        // Ordenar todas as máquinas do banco
        const sortedMachines = [...machineDatabase].sort((a, b) => 
            normalizeMachineId(a.id).localeCompare(normalizeMachineId(b.id), 'pt-BR', { numeric: true })
        );
        
        // Renderizar células
        statusBar.innerHTML = sortedMachines.map(machine => {
            const mid = normalizeMachineId(machine.id);
            const hasActiveDowntime = activeDowntimeSet.has(mid);
            const hasExtendedDowntime = machinesDowntime && machinesDowntime[mid];
            const hasPlan = machinesWithPlan.has(mid);
            
            // Determinar status e cor
            let statusClass = '';
            let statusTitle = '';
            
            if (hasActiveDowntime || hasExtendedDowntime) {
                // Máquina parada (normal ou longa)
                statusClass = 'bg-red-500 text-white border-red-600';
                const downtimeInfo = hasExtendedDowntime ? machinesDowntime[mid] : null;
                statusTitle = downtimeInfo 
                    ? `${mid} - PARADA: ${downtimeInfo.reason || downtimeInfo.type || 'Parada longa'}`
                    : `${mid} - PARADA`;
            } else if (hasPlan) {
                // Máquina produzindo (tem OP ativa)
                statusClass = 'bg-emerald-500 text-white border-emerald-600';
                statusTitle = `${mid} - Produzindo`;
            } else {
                // Máquina sem OP
                statusClass = 'bg-slate-600 text-slate-300 border-slate-500';
                statusTitle = `${mid} - Sem OP`;
            }
            
            // Extrair número da máquina para exibição compacta
            const machineNumber = mid.replace(/[^\d]/g, '') || mid.slice(-2);
            
            return `
                <div class="machine-status-cell ${statusClass} w-8 h-8 flex items-center justify-center 
                            text-xs font-bold rounded border cursor-pointer transition-all duration-200
                            hover:scale-110 hover:shadow-lg hover:z-10"
                     data-machine="${mid}"
                     title="${statusTitle}">
                    ${machineNumber}
                </div>
            `;
        }).join('');
        
        // Adicionar evento de clique nas células
        statusBar.querySelectorAll('.machine-status-cell').forEach(cell => {
            cell.addEventListener('click', () => {
                const machineId = cell.dataset.machine;
                // Scroll para o card da máquina se existir
                const machineCard = document.querySelector(`.machine-card[data-machine="${machineId}"]`);
                if (machineCard) {
                    machineCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    machineCard.classList.add('ring-2', 'ring-blue-500', 'ring-offset-2');
                    setTimeout(() => {
                        machineCard.classList.remove('ring-2', 'ring-blue-500', 'ring-offset-2');
                    }, 2000);
                    // Simular clique no card
                    machineCard.click();
                    
                    // NOVO: Scroll automático para painel de lançamento após seleção
                    setTimeout(() => {
                        const productionPanel = document.getElementById('production-control-panel');
                        if (productionPanel && !productionPanel.classList.contains('hidden')) {
                            productionPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 500);
                }
            });
        });
    }

    // Cache para evitar que valores de produção diminuam entre renders (anti-oscilação)
    const machineCardProductionCache = new Map();
    
    function renderMachineCards(plans = [], productionEntries = [], downtimeEntries = [], activeDowntimeMachines = new Set(), machinesDowntime = {}) {
        if (!machineCardGrid) {
            if (machineSelector) {
                machineSelector.machineData = {};
                machineSelector.innerHTML = '<option value="">Selecione uma máquina...</option>';
            }
            return;
        }

        if (machineCardEmptyState) {
            machineCardEmptyState.textContent = 'Nenhuma máquina com planejamento ativo.';
            machineCardEmptyState.classList.add('hidden');
            machineCardEmptyState.classList.remove('text-red-100');
        }
        
        // Converter para Set para busca rápida (pode ser array ou Set)
        const activeDowntimeSet = activeDowntimeMachines instanceof Set 
            ? activeDowntimeMachines 
            : new Set(Array.isArray(activeDowntimeMachines) ? activeDowntimeMachines : []);

        // NOVO: Cache de status de paradas para cronômetro
        downtimeStatusCache = machinesDowntime;

        const activePlans = Array.isArray(plans) ? plans.filter(isPlanActive) : [];
        
        // NOVO: Renderizar barra de status das máquinas (estilo Excel)
        renderMachineStatusBar(activePlans, activeDowntimeSet, machinesDowntime);

        // NOVO: Criar set de máquinas válidas do banco de dados
        const validMachineIds = new Set(machineDatabase.map(m => normalizeMachineId(m.id)));

        // NOVO: Mostrar TODAS as máquinas (planejadas + paradas + inativas)
        // Filtrar APENAS máquinas que existem no machineDatabase (evita contagem incorreta)
        const allMachineIds = new Set();
        
        // Adicionar máquinas com planejamento (somente se existir no machineDatabase)
        activePlans.forEach(plan => {
            if (plan && plan.machine) {
                const mid = normalizeMachineId(plan.machine);
                if (validMachineIds.has(mid)) {
                    allMachineIds.add(mid);
                } else {
                    console.warn(`[renderMachineCards] Máquina "${plan.machine}" do planejamento não existe no machineDatabase`);
                }
            }
        });
        
        // Adicionar máquinas com parada longa ativa (somente se existir no machineDatabase)
        Object.keys(machinesDowntime).forEach(machineId => {
            const mid = normalizeMachineId(machineId);
            if (validMachineIds.has(mid)) {
                allMachineIds.add(mid);
            } else {
                console.warn(`[renderMachineCards] Máquina "${machineId}" com parada não existe no machineDatabase`);
            }
        });
        
        // Se nenhuma máquina, mostrar todas do machineDatabase
        if (allMachineIds.size === 0) {
            machineDatabase.forEach(m => {
                allMachineIds.add(normalizeMachineId(m.id));
            });
        }

        machineCardData = {};
        if (machineSelector) {
            machineSelector.machineData = {};
        }

        const planById = {};
        const machineOrder = Array.from(allMachineIds).sort((a, b) => a.localeCompare(b, 'pt-BR', { numeric: true }));

        // Mapear plans por máquina - AGORA SUPORTA MÚLTIPLOS PLANOS (ARRAY)
        activePlans.forEach(plan => {
            if (!plan || !plan.machine) return;
            const mid = normalizeMachineId(plan.machine);
            const enrichedPlan = { id: plan.id, ...plan };
            // Armazenar como array para suportar múltiplas ordens na mesma máquina
            if (!machineCardData[mid]) {
                machineCardData[mid] = [];
            }
            machineCardData[mid].push(enrichedPlan);
            planById[plan.id] = enrichedPlan;
        });

        if (machineSelector) {
            const selectorOptions = ['<option value="">Selecione uma máquina...</option>']
                .concat(machineOrder.map(machine => `<option value="${machine}">${machine}</option>`));
            machineSelector.innerHTML = selectorOptions.join('');
            machineOrder.forEach(machine => {
                // Retornar o primeiro plano ou array completo no seletor
                machineSelector.machineData[machine] = machineCardData[machine] ? machineCardData[machine][0] : null;
            });
        }

        // IMPORTANTE: Inicializar aggregated para TODAS as máquinas (mesmo sem planejamento)
        // Agora suporta múltiplos planos por máquina
        const aggregated = {};
        machineOrder.forEach(machine => {
            const plans = machineCardData[machine] || [];
            aggregated[machine] = {
                plans: plans,  // Array de todos os planos da máquina
                plan: plans[0] || {},  // Primeiro plano para compatibilidade
                totalProduced: 0,
                totalLossesKg: 0,
                entries: [],
                byShift: { T1: 0, T2: 0, T3: 0 },
                byPlan: {}  // Produção separada por plano
            };
            // Inicializar byPlan para cada plano
            plans.forEach(p => {
                aggregated[machine].byPlan[p.id] = {
                    totalProduced: 0,
                    totalLossesKg: 0,
                    byShift: { T1: 0, T2: 0, T3: 0 }
                };
            });
        });

        const planIdSet = new Set(activePlans.map(plan => plan.id));
        const machineSet = new Set(machineOrder);
        const filteredProductionEntries = Array.isArray(productionEntries)
            ? productionEntries.filter(entry => entry && planIdSet.has(entry.planId))
            : [];
        const filteredDowntimeEntries = Array.isArray(downtimeEntries)
            ? downtimeEntries.filter(entry => entry && machineSet.has(entry.machine))
            : [];
        const combinedEntries = [];
        const fallbackShiftKey = `T${getCurrentShift()}`;

        filteredProductionEntries.forEach(entry => {
            if (!entry || !planIdSet.has(entry.planId)) return;
            const plan = planById[entry.planId];
            if (!plan) return;
            const machine = plan.machine;
            const produced = coerceToNumber(entry.produzido ?? entry.quantity, 0);
            const turno = normalizeShiftValue(entry.turno);
            const lossKg = coerceToNumber(entry.refugo_kg, 0);

            aggregated[machine].totalProduced += produced;
            aggregated[machine].totalLossesKg += lossKg;
            if (turno) {
                aggregated[machine].byShift[turno] = (aggregated[machine].byShift[turno] || 0) + produced;
            }
            
            // Agregar também por plano individual
            if (aggregated[machine].byPlan[entry.planId]) {
                aggregated[machine].byPlan[entry.planId].totalProduced += produced;
                aggregated[machine].byPlan[entry.planId].totalLossesKg += lossKg;
                if (turno) {
                    aggregated[machine].byPlan[entry.planId].byShift[turno] = 
                        (aggregated[machine].byPlan[entry.planId].byShift[turno] || 0) + produced;
                }
            }

            const entryForOee = {
                machine,
                turno,
                produzido: produced,
                duracao_min: coerceToNumber(entry.duracao_min ?? entry.duration_min ?? entry.duration, 0),
                refugo_kg: lossKg,
                piece_weight: plan.piece_weight,
                real_cycle_t1: plan.real_cycle_t1,
                real_cycle_t2: plan.real_cycle_t2,
                real_cycle_t3: plan.real_cycle_t3,
                budgeted_cycle: plan.budgeted_cycle,
                active_cavities_t1: plan.active_cavities_t1,
                active_cavities_t2: plan.active_cavities_t2,
                active_cavities_t3: plan.active_cavities_t3,
                mold_cavities: plan.mold_cavities
            };

            aggregated[machine].entries.push(entryForOee);
            combinedEntries.push(entryForOee);
        });

        Object.keys(machineCardCharts).forEach(machine => {
            if (machineCardCharts[machine]) {
                machineCardCharts[machine].destroy();
            }
            delete machineCardCharts[machine];
        });

        if (machineOrder.length === 0) {
            machineCardGrid.innerHTML = '';
            if (machineCardEmptyState) {
                machineCardEmptyState.classList.remove('hidden');
            }
            setActiveMachineCard(null);
            return;
        }

    const oeeSummary = combinedEntries.length > 0 ? calculateRealTimeOEE(combinedEntries) : null;
    const oeeByMachine = oeeSummary?.oeeByMachine || {};
    const currentShiftKey = oeeSummary?.currentShift || fallbackShiftKey;

    const resolvePackagingMultiple = (plan) => {
        if (!plan || typeof plan !== 'object') return 0;

        const flatCandidates = [
            'bag_capacity', 'bagCapacity', 'package_quantity', 'packageQuantity',
            'package_qty', 'packaging_qty', 'packagingQuantity', 'packagingQty',
            'units_per_bag', 'unitsPerBag', 'unit_per_bag', 'unitPerBag',
            'units_per_package', 'unitsPerPackage', 'pieces_per_bag', 'piecesPerBag',
            'pecas_por_saco', 'quantidade_por_saco', 'quantidadePorSaco',
            'qtd_por_saco', 'qtdPorSaco', 'quantidade_saco', 'quantidadeSaco',
            'capacidade_saco', 'capacidadeSaco', 'capacidade_embalagem', 'capacidadeEmbalagem'
        ];

        for (const key of flatCandidates) {
            if (Object.prototype.hasOwnProperty.call(plan, key)) {
                const value = parseOptionalNumber(plan[key]);
                if (Number.isFinite(value) && value > 0) {
                    return Math.round(value);
                }
            }
        }

        const nestedCandidates = [
            plan.packaging,
            plan.packaging_info,
            plan.packagingInfo,
            plan.embalagem,
            plan.embalagem_info,
            plan.embalagemInfo
        ];

        for (const nested of nestedCandidates) {
            if (!nested || typeof nested !== 'object') continue;
            for (const key of flatCandidates) {
                if (Object.prototype.hasOwnProperty.call(nested, key)) {
                    const value = parseOptionalNumber(nested[key]);
                    if (Number.isFinite(value) && value > 0) {
                        return Math.round(value);
                    }
                }
            }
            if (Object.prototype.hasOwnProperty.call(nested, 'quantity') || Object.prototype.hasOwnProperty.call(nested, 'quantidade')) {
                const fallbackValue = parseOptionalNumber(nested.quantity ?? nested.quantidade);
                if (Number.isFinite(fallbackValue) && fallbackValue > 0) {
                    return Math.round(fallbackValue);
                }
            }
        }

        return 0;
    };

    const formatQty = (value) => {
        const parsed = coerceToNumber(value, 0);
        return Math.round(parsed).toLocaleString('pt-BR');
    };
    const machineProgressInfo = {};

    machineCardGrid.innerHTML = machineOrder.map(machine => {
        const data = aggregated[machine];
        const plans = data.plans || [];
        const plan = data.plan || {};  // Primeiro plano (para compatibilidade)
        const hasMultiplePlans = plans.length > 1;
        
        // Resolver nome do produto - priorizar nome sobre código
        const resolveProductName = (p) => {
            if (!p) return 'Produto não definido';
            
            // 1. Tentar buscar no database de produtos pelo código
            const productCode = p.product_cod || p.product_code || p.part_code;
            if (productCode) {
                const dbProduct = getProductByCode(productCode);
                if (dbProduct?.name) {
                    return dbProduct.name.trim();
                }
            }
            
            // 2. Tentar campos de nome explícitos
            const nameFields = [
                p.product_name,
                p.productName,
                p.produto_nome,
                p.produtoNome,
                p.part_name,
                p.partName,
                p.product_snapshot?.name,
                p.product_snapshot?.product_name
            ];
            for (const name of nameFields) {
                if (name && typeof name === 'string' && name.trim()) {
                    return name.trim();
                }
            }
            
            // 3. Se product não parece ser um código (tem espaço ou mais de 15 chars), usar
            if (p.product && typeof p.product === 'string') {
                const prod = p.product.trim();
                if (prod.includes(' ') || prod.length > 15) {
                    return prod;
                }
            }
            
            // 4. Fallback para product mesmo que pareça código
            return p.product || 'Produto não definido';
        };
        
        // Calcular dados combinados de todos os planos
        // CORREÇÃO: Usar total_produzido acumulado da OP (não apenas produção do dia)
        // Isso garante consistência com a aba Admin > Dados > Ordens
        let totalPlannedQty = 0;
        let totalProducedAllPlans = 0;
        const plansWithData = plans.map(p => {
            const planData = data.byPlan[p.id] || { totalProduced: 0, totalLossesKg: 0, byShift: { T1: 0, T2: 0, T3: 0 } };
            const plannedQtyPrimary = parseOptionalNumber(p.order_lot_size);
            const plannedQtyFallback = parseOptionalNumber(p.lot_size);
            const plannedQty = Math.round(plannedQtyPrimary ?? plannedQtyFallback ?? 0);
            
            // CORREÇÃO CONSISTÊNCIA COM ADMIN:
            // Usar APENAS o total_produzido armazenado no planning/ordem
            // Esse é o mesmo valor exibido em Admin > Dados > Ordens
            const storedTotal = coerceToNumber(p.total_produzido ?? p.totalProduced, 0);
            const produced = Math.round(storedTotal);
            
            // Atualizar cache (mantido para referência, mas não usado na lógica principal)
            machineCardProductionCache.set(p.id, produced);
            
            const lossKg = Math.round(planData.totalLossesKg ?? 0);
            const pieceWeight = coerceToNumber(p.piece_weight, 0);
            const scrapPcs = pieceWeight > 0 ? Math.round((lossKg * 1000) / pieceWeight) : 0;
            
            // MUDANÇA: Usar 'produced' diretamente para cálculos (igual ao Admin)
            // Não subtrair refugo aqui - o Admin mostra o total_produzido bruto
            const progressPct = plannedQty > 0 ? (produced / plannedQty) * 100 : 0;
            
            totalPlannedQty += plannedQty;
            totalProducedAllPlans += produced; // Usar produced direto, não goodProd
            
            return {
                ...p,
                displayName: resolveProductName(p),
                plannedQty,
                produced,
                goodProd: produced, // Manter igual a produced para consistência
                lossKg,
                progressPct,
                isCompleted: plannedQty > 0 && produced >= plannedQty
            };
        });
        
        // Dados agregados da máquina
        const totalAccumulatedProduced = Math.round(data.totalProduced ?? 0);
        const lossesKg = Math.round(coerceToNumber(data.totalLossesKg, 0));
        const pieceWeight = coerceToNumber(plan.piece_weight, 0);
        const scrapPcs = pieceWeight > 0 ? Math.round((lossesKg * 1000) / pieceWeight) : 0;
        const goodProductionRaw = Math.max(0, totalAccumulatedProduced - scrapPcs);
        const goodProduction = Math.round(goodProductionRaw);
        
        // Progresso geral da máquina (combinado de todos os planos)
        const progressPercentRaw = totalPlannedQty > 0 ? (totalProducedAllPlans / totalPlannedQty) * 100 : 0;
        const normalizedProgress = Math.max(0, Math.min(progressPercentRaw, 100));
        const progressPalette = resolveProgressPalette(progressPercentRaw);
        const progressTextClass = progressPalette.textClass || 'text-slate-600';
        const progressText = `${Math.max(0, progressPercentRaw).toFixed(progressPercentRaw >= 100 ? 0 : 1)}%`;
        const allCompleted = plansWithData.length > 0 && plansWithData.every(p => p.isCompleted);

        machineProgressInfo[machine] = {
            normalizedProgress,
            progressPercent: progressPercentRaw,
            palette: progressPalette
        };

        const oeeShiftData = oeeByMachine[machine]?.[currentShiftKey];
        const oeePercent = Math.max(0, Math.min((oeeShiftData?.oee || 0) * 100, 100));
        const oeePercentText = oeePercent ? oeePercent.toFixed(1) : '0.0';
        const oeeColorClass = oeePercent >= 85 ? 'text-emerald-600' : oeePercent >= 70 ? 'text-amber-500' : 'text-red-500';
        const nowRef = new Date();
        const shiftStart = getShiftStartDateTime(nowRef);
        let runtimeHours = 0, downtimeHours = 0;
        if (shiftStart instanceof Date && !Number.isNaN(shiftStart.getTime())) {
            const elapsedSec = Math.max(0, Math.floor((nowRef.getTime() - shiftStart.getTime()) / 1000));
            if (elapsedSec > 0) {
                const dts = filteredDowntimeEntries.filter(dt => dt && dt.machine === machine);
                const runtimeSec = calculateProductionRuntimeSeconds({ shiftStart, now: nowRef, downtimes: dts });
                runtimeHours = Math.max(0, runtimeSec / 3600);
                downtimeHours = Math.max(0, (elapsedSec / 3600) - runtimeHours);
            }
        }

        // Lógica de cor do card: vermelho se houver parada ativa (normal OU longa)
        let cardColorClass = '';
        const hasActiveDowntime = activeDowntimeSet.has(machine);
        const hasExtendedDowntime = downtimeStatusCache && downtimeStatusCache[machine];
        if (hasActiveDowntime || hasExtendedDowntime) {
            cardColorClass = 'machine-stopped'; // vermelho para parada ativa (normal ou longa)
        }
        
        // Gerar HTML para múltiplos produtos
        const generateMultiProductSection = () => {
            if (!hasMultiplePlans) return '';
            
            return `
                <div class="mb-2 p-2 rounded-lg bg-purple-50 border border-purple-200">
                    <div class="flex items-center gap-2 mb-2">
                        <i data-lucide="layers" class="w-4 h-4 text-purple-600"></i>
                        <span class="text-xs font-bold text-purple-700">MOLDE MULTI-PRODUTO (${plans.length} OPs)</span>
                    </div>
                    <div class="space-y-2 max-h-40 overflow-y-auto">
                        ${plansWithData.map((p, idx) => `
                            <div class="p-2 rounded bg-white border border-purple-100 ${p.isCompleted ? 'opacity-60' : ''}">
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-xs font-semibold text-slate-700 truncate max-w-[100px]" title="${p.displayName}">${p.displayName}</span>
                                    <span class="text-xs font-mono text-purple-600">${p.order_number || '-'}</span>
                                </div>
                                <div class="flex items-center justify-between text-[10px]">
                                    <span class="text-slate-500">${formatQty(p.goodProd)}/${formatQty(p.plannedQty)}</span>
                                    <span class="${p.progressPct >= 100 ? 'text-emerald-600 font-bold' : 'text-slate-600'}">${p.progressPct.toFixed(1)}%</span>
                                </div>
                                <div class="w-full bg-slate-100 rounded-full h-1 mt-1">
                                    <div class="h-1 rounded-full transition-all duration-300 ${p.isCompleted ? 'bg-emerald-500' : 'bg-purple-500'}" style="width: ${Math.min(p.progressPct, 100)}%"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        };
        
        // Determinar nome do produto para exibição principal
        const displayProductName = hasMultiplePlans 
            ? `${plans.length} produtos` 
            : resolveProductName(plan);
        
        // Determinar número da OP para exibição
        const displayOrderNumber = hasMultiplePlans 
            ? `${plans.length} OPs`
            : (plan.order_number || plan.order_number_original || '-');

        return `
            <div class="machine-card group relative bg-white rounded-lg border border-slate-200 hover:border-blue-300 shadow-sm hover:shadow-md transition-all duration-200 cursor-pointer p-3 ${allCompleted && String(plan.status||'').toLowerCase()!=='concluida' ? 'completed-blink' : ''} ${cardColorClass} ${hasMultiplePlans ? 'ring-2 ring-purple-300' : ''}" data-machine="${machine}" data-plan-id="${plan.id}" data-order-id="${plan.order_id||''}" data-part-code="${plan.product_cod||''}" data-multi-plan="${hasMultiplePlans}">
                <!-- Header compacto -->
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <div class="machine-identifier w-8 h-8 bg-gradient-to-br ${hasMultiplePlans ? 'from-purple-500 to-purple-600' : 'from-blue-500 to-blue-600'} rounded-full flex items-center justify-center text-white text-xs font-bold">
                            ${machine.slice(-2)}
                        </div>
                        <div>
                            <h3 class="text-sm font-bold text-slate-900">${machine}</h3>
                            <p class="text-xs ${hasMultiplePlans ? 'text-purple-600 font-medium' : 'text-slate-500'} truncate max-w-[120px]" title="${displayProductName}">${displayProductName}</p>
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-xs font-semibold ${hasMultiplePlans ? 'text-purple-600' : 'text-blue-600'}">${displayOrderNumber}</div>
                        <div class="text-[10px] text-slate-400 uppercase">OP</div>
                    </div>
                </div>
                
                ${generateMultiProductSection()}

                <!-- Indicadores principais em linha -->
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="text-center">
                        <div class="text-sm font-semibold text-slate-900">${formatQty(totalProducedAllPlans)}</div>
                        <div class="text-[10px] text-slate-500 uppercase">Exec. Total</div>
                    </div>
                    <div class="text-center">
                        <div class="text-sm font-semibold text-slate-900">${formatQty(Math.max(0, totalPlannedQty - totalProducedAllPlans))}</div>
                        <div class="text-[10px] text-slate-500 uppercase">Faltante</div>
                    </div>
                </div>

                <!-- Barra de progresso compacta -->
                <div class="mb-2">
                    <div class="flex items-center justify-between mb-1">
                        <span class="text-xs text-slate-500">${hasMultiplePlans ? 'Progresso Geral' : 'OP Total'} (${formatQty(totalPlannedQty)})</span>
                        <span class="text-xs font-semibold ${progressTextClass}">${progressText}</span>
                    </div>
                    <div class="w-full bg-slate-100 rounded-full h-2">
                        <div class="h-2 rounded-full transition-all duration-300 ${hasMultiplePlans ? 'bg-purple-500' : (progressPalette.bgClass || 'bg-blue-500')}" style="width: ${normalizedProgress}%"></div>
                    </div>
                </div>

                <!-- Status compacto -->
                <div class="flex items-center justify-between text-xs mb-2">
                    <div class="flex gap-1">
                        <span class="px-2 py-0.5 rounded-full bg-green-100 text-green-700 text-[10px]" title="Tempo rodando">${runtimeHours.toFixed(1)}h</span>
                        ${downtimeHours > 0 ? `<span class="px-2 py-0.5 rounded-full bg-red-100 text-red-700 text-[10px]" title="Tempo parado">${downtimeHours.toFixed(1)}h</span>` : ''}
                    </div>
                    <div class="text-slate-500">
                        <span class="font-medium">${formatShiftLabel(currentShiftKey)}</span>
                    </div>
                </div>

                <!-- Indicador de Parada Longa -->
                ${(() => {
                    const hasMachineDowntime = machinesDowntime && machinesDowntime[machine];
                    if (hasMachineDowntime) {
                        const typeLabel = getDowntimeTypeLabel(hasMachineDowntime.type);
                        const typeColor = getDowntimeTypeColor(hasMachineDowntime.type);
                        const recordId = hasMachineDowntime.recordId || '';
                        return `
                            <div class="mb-2 p-2 rounded-lg bg-amber-50 border border-amber-200">
                                <div class="flex items-center justify-between mb-1">
                                    <div class="flex items-center gap-2">
                                        <i data-lucide="alert-triangle" class="w-4 h-4 text-amber-600"></i>
                                        <span class="text-xs font-bold text-amber-700">PARADA ATIVA</span>
                                    </div>
                                    <span class="inline-block px-2 py-0.5 text-xs font-semibold rounded ${typeColor}">${typeLabel}</span>
                                </div>
                                <p class="text-xs text-amber-600 mb-2">${hasMachineDowntime.reason}</p>
                                <button type="button" 
                                        onclick="finalizarParada('${recordId}', '${machine}')"
                                        class="w-full py-1 px-2 bg-red-600 hover:bg-red-700 text-white text-xs font-semibold rounded transition-colors">
                                    🛑 FINALIZAR PARADA
                                </button>
                            </div>
                        `;
                    }
                    return '';
                })()}

                <!-- Mini card de parada ativa -->
                ${(() => {
                    // Verifica se há parada ativa (downtime sem fim) para esta máquina
                    const paradaAtiva = filteredDowntimeEntries.some(dt => dt && dt.machine === machine && (!dt.endTime && !dt.endDate));
                    return paradaAtiva ? `
                        <div class="mb-2 p-2 rounded-lg bg-red-50 border border-red-200 flex items-center gap-2">
                            <i data-lucide="alert-circle" class="w-4 h-4 text-red-600 animate-pulse"></i>
                            <span class="text-xs font-bold text-red-700">PARADA ATIVA - MÁQUINA PARADA</span>
                        </div>
                    ` : '';
                })()}                ${allCompleted ? `
                    <div class="card-actions flex gap-2 mt-3">
                        ${String(plan.status||'').toLowerCase()!=='concluida' && plan.order_id ? `
                            <button type="button" class="btn btn-finalize card-finalize-btn" data-plan-id="${plan.id}" data-order-id="${plan.order_id}" title="Finalizar OP">
                                 <i data-lucide="check-circle"></i>
                                 <span>Finalizar OP</span>
                            </button>
                        ` : ''}
                        ${String(plan.status||'').toLowerCase()==='concluida' ? `
                            <button type="button" class="btn btn-activate card-activate-next-btn" data-plan-id="${plan.id}" data-machine="${machine}" data-part-code="${plan.product_cod||''}" title="Ativar próxima OP">
                                 <i data-lucide="play-circle"></i>
                                 <span>Ativar próxima OP</span>
                            </button>
                        ` : ''}
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');

        machineOrder.forEach(machine => {
            renderMachineCardProgress(machine, machineProgressInfo[machine]);
        });

        // NOVO: Iniciar cronômetros para máquinas paradas
        machineOrder.forEach(machine => {
            if (machinesDowntime && machinesDowntime[machine]) {
                const cardElement = machineCardGrid.querySelector(`[data-machine="${machine}"]`);
                if (cardElement) {
                    startDowntimeTimer(machine, cardElement);
                }
            }
        });

        // machineCardData agora é array - verificar se tem dados
        const machineHasPlans = selectedMachineData && selectedMachineData.machine && 
            machineCardData[selectedMachineData.machine] && 
            machineCardData[selectedMachineData.machine].length > 0;
        if (machineHasPlans) {
            setActiveMachineCard(selectedMachineData.machine);
        } else {
            selectedMachineData = null;
            setActiveMachineCard(null);
            if (productionControlPanel) {
                productionControlPanel.classList.add('hidden');
            }
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
        }

        // Recriar ícones (por causa dos botões novos)
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    function renderMachineCardProgress(machine, progressInfo) {
        if (!machine || !progressInfo) return;

        const canvasId = `progress-donut-${machine}`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            return;
        }

        if (machineCardCharts[machine]) {
            try {
                machineCardCharts[machine].destroy();
            } catch (error) {
                console.warn('[TRACE][renderMachineCardProgress] falha ao destruir gráfico anterior', { machine, error });
            }
        }

        const executed = Math.max(0, Math.min(progressInfo.normalizedProgress ?? 0, 100));
        const remainder = Math.max(0, 100 - executed);
        const primaryColor = progressInfo.palette?.start || '#2563EB';
        const secondaryColor = hexWithAlpha(primaryColor, 0.18);

        machineCardCharts[machine] = new Chart(canvas, {
            type: 'doughnut',
            data: {
                datasets: [{
                    data: [executed, remainder],
                    backgroundColor: [primaryColor, secondaryColor],
                    borderWidth: 0,
                    hoverOffset: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '70%',
                rotation: -90,
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false }
                },
                animation: {
                    animateRotate: executed > 0,
                    duration: 600
                }
            }
        });
    }

    // Função para popular o seletor de máquinas (e cards)
    async function populateMachineSelector(filterDate = null) {
        try {
            const today = filterDate || window.lancamentoFilterDate || getProductionDateString();
            const planSnapshot = await db.collection('planning').where('date', '==', today).get();
            let plans = planSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Enriquecer planos com dados da OP (lot size, execução acumulada)
            const orderCacheByPartCode = new Map();
            const orderCacheById = new Map();
            const productionTotalsByOrderId = new Map();

            for (const plan of plans) {
                const partCode = String(plan.product_cod || plan.product_code || plan.part_code || '').trim();
                let resolvedOrder = null;

                // Priorizar vínculo direto com a OP se existir no planejamento
                const linkedOrderId = plan.production_order_id || plan.production_order || plan.order_id || null;
                if (linkedOrderId) {
                    try {
                        if (!orderCacheById.has(linkedOrderId)) {
                            const doc = await db.collection('production_orders').doc(linkedOrderId).get();
                            if (doc.exists) {
                                orderCacheById.set(linkedOrderId, { id: doc.id, ...doc.data() });
                            } else {
                                orderCacheById.set(linkedOrderId, null);
                            }
                        }
                        resolvedOrder = orderCacheById.get(linkedOrderId);
                    } catch (e) {
                        console.warn('Falha ao carregar OP vinculada ao plano', plan.id, linkedOrderId, e);
                    }
                }

                if (!resolvedOrder && partCode) {
                    if (!orderCacheByPartCode.has(partCode)) {
                        try {
                            const ordersSnapshot = await db.collection('production_orders')
                                .where('part_code', '==', partCode)
                                .get();

                            const orders = ordersSnapshot.docs
                                .map(doc => ({ id: doc.id, ...doc.data() }))
                                .sort((a, b) => {
                                    // Ordenar da mais antiga para a mais recente para priorizar a OP antiga
                                    const aTs = a.createdAt?.toMillis ? a.createdAt.toMillis() : (a.createdAt?._seconds ? a.createdAt._seconds * 1000 : 0);
                                    const bTs = b.createdAt?.toMillis ? b.createdAt.toMillis() : (b.createdAt?._seconds ? b.createdAt._seconds * 1000 : 0);
                                    if (aTs && bTs && aTs !== bTs) return aTs - bTs; // mais antiga primeiro
                                    // Fallback por número da OP (numérico ascendente)
                                    const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
                                    return toNum(a.order_number) - toNum(b.order_number);
                                });

                            orderCacheByPartCode.set(partCode, orders);
                        } catch (orderError) {
                            console.warn('Não foi possível recuperar OPs para o código', partCode, orderError);
                            orderCacheByPartCode.set(partCode, []);
                        }
                    }

                    const cachedOrders = orderCacheByPartCode.get(partCode) || [];
                    if (cachedOrders.length > 0) {
                        // Preferir OP ativa/andamento na mesma máquina do plano
                        const sameMachine = cachedOrders.filter(o => (o.machine_id || o.machine) === plan.machine);
                        const isOpen = (o) => !['concluida','cancelada','finalizada','encerrada'].includes(String(o.status||'').toLowerCase());
                        resolvedOrder = sameMachine.find(o => ['ativa','em_andamento'].includes(String(o.status||'').toLowerCase()))
                            || sameMachine.find(isOpen)
                            || cachedOrders.find(isOpen)
                            || cachedOrders[0];
                    }
                }

                if (resolvedOrder) {
                    const resolvedLotSize = Number(resolvedOrder.lot_size) || 0;
                    plan.order_lot_size = resolvedLotSize;
                    plan.order_id = resolvedOrder.id;
                    plan.order_number = resolvedOrder.order_number || resolvedOrder.order_number_original || resolvedOrder.id;

                    // Buscar produção acumulada da OP se ainda não calculada
                    if (!productionTotalsByOrderId.has(resolvedOrder.id)) {
                        try {
                            const prodSnapshot = await db.collection('production_entries')
                                .where('orderId', '==', resolvedOrder.id)
                                .get();

                            const totalProduced = prodSnapshot.docs.reduce((sum, doc) => {
                                const entry = doc.data();
                                return sum + (Number(entry.produzido || entry.quantity || 0) || 0);
                            }, 0);

                            productionTotalsByOrderId.set(resolvedOrder.id, totalProduced);
                        } catch (prodError) {
                            console.warn('Não foi possível recuperar lançamentos da OP', resolvedOrder.id, prodError);
                            productionTotalsByOrderId.set(resolvedOrder.id, 0);
                        }
                    }

                    const accumulated = productionTotalsByOrderId.get(resolvedOrder.id) || 0;
                    const resolvedOrderTotal = coerceToNumber(resolvedOrder.total_produzido ?? resolvedOrder.totalProduced, 0);
                    const planAccumulated = coerceToNumber(plan.total_produzido, 0);
                    
                    // CORREÇÃO CONSISTÊNCIA COM ADMIN:
                    // O Admin mostra APENAS o total_produzido da OP
                    // Usar o mesmo valor para garantir que cards e Admin mostrem o mesmo número
                    // Prioridade: valor da OP > soma dos entries > valor do planning
                    if (resolvedOrderTotal > 0) {
                        plan.total_produzido = resolvedOrderTotal;
                    } else if (accumulated > 0) {
                        plan.total_produzido = accumulated;
                    } else {
                        plan.total_produzido = planAccumulated;
                    }

                    console.log('[MachineCard][OP]', {
                        machine: plan.machine,
                        partCode,
                        orderId: resolvedOrder.id,
                        lotSize: plan.order_lot_size,
                        accumulated: plan.total_produzido,
                        fromOrder: resolvedOrderTotal,
                        fromEntries: accumulated
                    });
                } else {
                    // Caso não exista OP vinculada, manter total produzido local e sinalizar lot size zerado
                    plan.order_lot_size = Number(plan.lot_size) || 0;
                    if (!Number.isFinite(plan.total_produzido)) {
                        plan.total_produzido = 0;
                    }
                    console.warn('[MachineCard][OP] Nenhuma OP encontrada para o plano', plan.id, 'partCode:', partCode);
                }
            }

            const activePlans = plans.filter(isPlanActive);

            let productionEntries = [];
            let downtimeEntries = [];
            if (activePlans.length > 0) {
                const productionSnapshot = await db.collection('production_entries').where('data', '==', today).get();
                const planIdSet = new Set(activePlans.map(plan => plan.id));
                productionEntries = productionSnapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(entry => planIdSet.has(entry.planId));

                // Paradas do dia (inclui dia anterior para cobrir T3 após 00:00)
                const base = new Date(`${today}T12:00:00`);
                const prev = new Date(base); prev.setDate(prev.getDate() - 1);
                const prevStr = new Date(prev.getTime() - prev.getTimezoneOffset()*60000).toISOString().split('T')[0];
                const dtSnapshot = await db.collection('downtime_entries')
                    .where('date', 'in', [prevStr, today])
                    .get();
                const machineSet = new Set(activePlans.map(p => p.machine));
                downtimeEntries = dtSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(dt => machineSet.has(dt.machine));
            }

            // Buscar paradas ativas para colorir cards de vermelho
            // IMPORTANTE: Filtrar apenas máquinas válidas do machineDatabase
            const validMachineIdsSet = new Set(machineDatabase.map(m => normalizeMachineId(m.id)));
            let activeDowntimeSet = new Set();
            try {
                const activeSnapshot = await db.collection('active_downtimes').get();
                // Filtrar apenas máquinas que existem no machineDatabase
                const validDowntimeIds = activeSnapshot.docs
                    .map(doc => doc.id)
                    .filter(id => {
                        const normalizedId = normalizeMachineId(id);
                        const isValid = validMachineIdsSet.has(normalizedId);
                        if (!isValid) {
                            console.warn(`[loadMachineCards] Máquina "${id}" em active_downtimes não existe no machineDatabase`);
                        }
                        return isValid;
                    });
                activeDowntimeSet = new Set(validDowntimeIds);
            } catch (e) {
                console.warn('Erro ao buscar paradas ativas:', e);
            }

            // NOVO: Carregar paradas longas para mostrar no painel de máquinas
            const machinesDowntime = await getAllMachinesDowntimeStatus();
            renderMachineCards(activePlans, productionEntries, downtimeEntries, activeDowntimeSet, machinesDowntime);
            
            // Disparar evento para sinalizar que dados foram atualizados
            document.dispatchEvent(new CustomEvent('machineDataUpdated', { detail: { machineCardData, activePlans } }));
        } catch (error) {
            console.error('Erro ao carregar máquinas: ', error);
            if (machineCardGrid) {
                machineCardGrid.innerHTML = '';
            }
            if (machineCardEmptyState) {
                machineCardEmptyState.textContent = 'Erro ao carregar máquinas. Tente novamente.';
                machineCardEmptyState.classList.remove('hidden');
                machineCardEmptyState.classList.add('text-red-100');
            }
            if (machineSelector) {
                machineSelector.innerHTML = '<option value="">Erro ao carregar máquinas</option>';
                machineSelector.machineData = {};
            }
        }
    }
    
    // Função para atualizar display do turno atual
    function updateCurrentShiftDisplay() {
        if (!currentShiftDisplay) return;
        
        const currentShift = getCurrentShift();
        currentShiftDisplay.textContent = `T${currentShift}`;
    }
    
    // ========== SISTEMA DE SCROLL LOCK PARA PAINEL DE APONTAMENTO ==========
    let scrollLockActive = false;
    let scrollLockTimeout = null;
    let scrollLockPosition = null;
    
    // Função para ativar o lock de scroll (mantém a posição atual)
    function activateScrollLock(duration = 3000) {
        scrollLockActive = true;
        scrollLockPosition = window.pageYOffset;
        
        // Limpar timeout anterior se existir
        if (scrollLockTimeout) {
            clearTimeout(scrollLockTimeout);
        }
        
        // Listener para manter a posição durante o lock
        const maintainPosition = () => {
            if (scrollLockActive && scrollLockPosition !== null) {
                // Verificar se a página tentou subir (scroll < posição travada)
                if (window.pageYOffset < scrollLockPosition - 50) {
                    window.scrollTo({
                        top: scrollLockPosition,
                        behavior: 'instant'
                    });
                }
            }
        };
        
        // Adicionar listener temporário
        window.addEventListener('scroll', maintainPosition, { passive: true });
        
        // Desativar após o tempo especificado
        scrollLockTimeout = setTimeout(() => {
            scrollLockActive = false;
            scrollLockPosition = null;
            window.removeEventListener('scroll', maintainPosition);
            console.log('[SCROLL-LOCK] Desbloqueado após', duration, 'ms');
        }, duration);
        
        console.log('[SCROLL-LOCK] Ativado por', duration, 'ms na posição', scrollLockPosition);
    }
    
    // Função para fazer scroll para o painel de apontamento e ativar lock
    function scrollToPanelWithLock() {
        const scrollTarget = document.getElementById('production-control-panel');
        if (!scrollTarget) return;
        
        // Calcular posição ideal (deixar um pequeno espaço no topo)
        const targetRect = scrollTarget.getBoundingClientRect();
        const absoluteTop = window.pageYOffset + targetRect.top;
        const offsetTop = Math.max(0, absoluteTop - 80); // 80px de margem no topo
        
        // Scroll suave para a posição calculada
        window.scrollTo({
            top: offsetTop,
            behavior: 'smooth'
        });
        
        // Adicionar destaque visual temporário
        scrollTarget.classList.add('ring-2', 'ring-blue-400', 'ring-offset-2');
        setTimeout(() => {
            scrollTarget.classList.remove('ring-2', 'ring-blue-400', 'ring-offset-2');
        }, 1500);
        
        // Aguardar o scroll terminar e então ativar o lock
        setTimeout(() => {
            activateScrollLock(4000); // Lock por 4 segundos após o scroll
        }, 500); // Aguardar 500ms para o scroll suave terminar
    }
    // ========== FIM SISTEMA DE SCROLL LOCK ==========

    // Função para quando uma máquina é selecionada
    // @param {string} machine - ID da máquina
    // @param {object} options - Opções: { scrollToPanel: boolean } - se true, faz scroll para o painel de apontamento
    async function onMachineSelected(machine, options = {}) {
        const { scrollToPanel = false } = options;
        const previousMachine = selectedMachineData ? selectedMachineData.machine : null;
        // machineCardData agora é array - pegar primeiro plano para compatibilidade
        const machineDataArray = machineCardData[machine];
        const machineData = Array.isArray(machineDataArray) ? machineDataArray[0] : (machineDataArray || machineSelector?.machineData?.[machine]);

        if (!machine || !machineData) {
            productionControlPanel.classList.add('hidden');
            selectedMachineData = null;
            setActiveMachineCard(null);
            resetProductionTimer();
            if (recentEntriesList) {
                recentEntriesList.innerHTML = '';
            }
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
            if (productMp) productMp.textContent = 'Matéria-prima não definida';
            return;
        }
        
        selectedMachineData = machineData;
        if (machineSelector) {
            machineSelector.value = machine;
        }
        setActiveMachineCard(machine);
        updateQuickProductionPieceWeightUI({ forceUpdateInput: true });
        
        // Carregar estado persistente da tara
        loadTareStateForAllForms(selectedMachineData.machine);
        
        // Atualizar informações de tara nos formulários
        updateTareDisplay('quick', document.getElementById('quick-production-use-tare')?.checked || false);
        updateTareDisplay('manual', document.getElementById('manual-production-use-tare')?.checked || false);
        updateTareDisplay('losses', document.getElementById('quick-losses-use-tare')?.checked || false);

        if (previousMachine !== selectedMachineData.machine) {
            resetProductionTimer();
        }
        
        // Atualizar informações da máquina
        if (machineIcon) machineIcon.textContent = machine;
        if (machineName) machineName.textContent = `Máquina ${machine}`;
        if (productName) productName.textContent = selectedMachineData.product || 'Produto não definido';
        if (productMp) {
            productMp.textContent = selectedMachineData.mp ? `MP: ${selectedMachineData.mp}` : 'Matéria-prima não definida';
        }

        // Sincronizar com OP ativa (se existir) antes de atualizar o card principal
        await syncSelectedMachineWithActiveOrder();
        // Centralizar atualização do card principal (inclui shiftTarget)
        updateMachineInfo();
        
        // Mostrar painel
        productionControlPanel.classList.remove('hidden');
        
        // Scroll automático para o painel de apontamento (apenas quando solicitado - click direto no card)
        if (scrollToPanel) {
            // Usar requestAnimationFrame para garantir que o DOM foi atualizado
            requestAnimationFrame(() => {
                scrollToPanelWithLock();
            });
        }
        
        // Verificar e alertar sobre paradas longas
        const downtime = await getActiveMachineDowntime(machine);
        if (downtime) {
            const typeLabel = getDowntimeTypeLabel(downtime.type);
            const startDate = new Date(downtime.startDate).toLocaleDateString('pt-BR');
            const endDate = new Date(downtime.endDate).toLocaleDateString('pt-BR');
            
            // Criar alerta visual
            const alertDiv = document.createElement('div');
            alertDiv.className = 'fixed top-4 right-4 bg-amber-100 border-l-4 border-amber-500 text-amber-800 p-4 rounded shadow-lg max-w-md z-50 animate-pulse';
            alertDiv.innerHTML = `
                <div class="flex items-start gap-3">
                    <i data-lucide="alert-triangle" class="w-6 h-6 flex-shrink-0"></i>
                    <div>
                        <h3 class="font-bold mb-1">⚠️ Máquina em Parada Longa</h3>
                        <p class="text-sm mb-2"><strong>${machine}</strong> está registrada em parada:</p>
                        <p class="text-sm font-semibold text-amber-700 mb-1">${typeLabel}</p>
                        <p class="text-xs mb-2"><strong>Período:</strong> ${startDate} a ${endDate}</p>
                        <p class="text-xs"><strong>Motivo:</strong> ${downtime.reason}</p>
                    </div>
                </div>
            `;
            document.body.appendChild(alertDiv);
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Remover alerta após 8 segundos
            setTimeout(() => {
                alertDiv.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => alertDiv.remove(), 500);
            }, 8000);
        }
        
        // Carregar dados
        await refreshLaunchCharts();
        await loadTodayStats();
        await loadRecentEntries(false);
        
        // Reset machine status (mas verificar se há parada ativa primeiro)
        machineStatus = 'running';
        updateMachineStatus();
        
        // Verificar se há parada ativa para esta máquina
        await checkActiveDowntimes();
    }
    
    // Função para carregar gráfico de produção por hora
    async function loadHourlyProductionChart() {
        if (!selectedMachineData || !hourlyProductionChart) return;

        currentActiveOrder = null;
        currentOrderProgress = { executed: 0, planned: 0, expected: 0 };

        try {
            const today = getProductionDateString();
            // 1) Recuperar todos os lançamentos de produção da MÁQUINA no dia atual
            //    (filtraremos em memória pelos planos do MESMO PRODUTO)
            const productionSnapshot = await db.collection('production_entries')
                .where('data', '==', today)
                .where('machine', '==', selectedMachineData.machine)
                .get();

            const hourlyData = {};
            for (let i = 7; i < 31; i++) {
                const hour = i >= 24 ? i - 24 : i;
                const hourStr = `${String(hour).padStart(2, '0')}:00`;
                hourlyData[hourStr] = { planned: 0, actual: 0 };
            }

            const partCode = selectedMachineData.product_cod || selectedMachineData.product_code;
            let matchedOrder = null;
            let lotSize = Number(selectedMachineData.planned_quantity) || 0;

            // 2) Identificar todos os planos de HOJE para esta máquina e MESMO PRODUTO
            //    para consolidar entre trocas de OP do mesmo produto
            let relevantPlans = [];
            try {
                const planSnap = await db.collection('planning')
                    .where('date', '==', today)
                    .where('machine', '==', selectedMachineData.machine)
                    .get();
                const partMatcher = String(partCode || '').trim().toLowerCase();
                relevantPlans = planSnap.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(plan => {
                        const code = String(plan.product_cod || plan.product_code || plan.part_code || '').trim().toLowerCase();
                        return partMatcher && code && code === partMatcher;
                    });
            } catch (e) {
                console.warn('[HOUR-CHART] Falha ao recuperar planos do dia para consolidação', e);
                relevantPlans = [];
            }

            // Preferir a OP vinculada ao planejamento, se existir
            if (selectedMachineData.order_id) {
                try {
                    const doc = await db.collection('production_orders').doc(selectedMachineData.order_id).get();
                    if (doc.exists) {
                        matchedOrder = { id: doc.id, ...doc.data() };
                        const orderLotSize = Number(matchedOrder.lot_size);
                        if (Number.isFinite(orderLotSize) && orderLotSize > 0) {
                            lotSize = orderLotSize;
                        }
                    }
                } catch (e) {
                    console.warn('Falha ao recuperar OP vinculada ao plano:', e);
                }
            }

            // Fallback por código da peça, mantendo prioridade da mesma máquina
            if (!matchedOrder && partCode) {
                try {
                    const lotsSnapshot = await db.collection('production_orders')
                        .where('part_code', '==', String(partCode))
                        .get();

                    if (!lotsSnapshot.empty) {
                        const orderDocs = lotsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                        const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
                        const isOpen = (o) => !['concluida','cancelada','finalizada','encerrada'].includes(String(o.status||'').toLowerCase());
                        const sameMachine = orderDocs.filter(o => (o.machine_id || o.machine) === selectedMachineData.machine);
                        matchedOrder = sameMachine.find(o => ['ativa','em_andamento'].includes(String(o.status||'').toLowerCase()))
                            || sameMachine.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orderDocs.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orderDocs.sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0];

                        if (matchedOrder) {
                            const orderLotSize = Number(matchedOrder.lot_size);
                            if (Number.isFinite(orderLotSize) && orderLotSize > 0) {
                                lotSize = orderLotSize;
                            }
                        }
                    }
                } catch (lotError) {
                    console.warn('Não foi possível recuperar informações da ordem vinculada:', lotError);
                }
            }

            // 3) Calcular META DIÁRIA consolidada por MÁQUINA + PRODUTO (somatório dos planos do dia)
            let dailyTarget = 0;
            if (Array.isArray(relevantPlans) && relevantPlans.length > 0) {
                dailyTarget = relevantPlans.reduce((sum, p) => {
                    const pq = Number(p.planned_quantity || p.daily_target || 0) || 0;
                    return sum + pq;
                }, 0);
            }
            // Fallback: manter meta do plano selecionado se não houver agrupamento
            if (!Number.isFinite(dailyTarget) || dailyTarget <= 0) {
                dailyTarget = Number(selectedMachineData.planned_quantity) || Number(selectedMachineData.daily_target) || 0;
            }
            const hourlyTarget = HOURS_IN_PRODUCTION_DAY > 0 ? (dailyTarget / HOURS_IN_PRODUCTION_DAY) : 0;

            Object.keys(hourlyData).forEach(hour => {
                hourlyData[hour].planned = hourlyTarget;
            });

            // 4) Somar EXECUTADO por hora somente para lançamentos pertencentes aos planos do mesmo produto
            const relevantPlanIdSet = new Set((relevantPlans || []).map(p => p.id));
            // Se não encontramos planos relevantes (edge), considerar ao menos o plano atual como elegível
            if (relevantPlanIdSet.size === 0 && selectedMachineData.id) {
                relevantPlanIdSet.add(selectedMachineData.id);
            }

            productionSnapshot.forEach(doc => {
                const data = doc.data();
                // Filtrar por plano relevante (mesmo produto)
                if (data.planId && !relevantPlanIdSet.has(data.planId)) {
                    return;
                }
                const prodDate = resolveProductionDateTime(data);
                if (!prodDate) {
                    return;
                }
                const hour = `${String(prodDate.getHours()).padStart(2, '0')}:00`;
                if (!hourlyData[hour]) {
                    hourlyData[hour] = { planned: hourlyTarget, actual: 0 };
                }
                hourlyData[hour].actual += data.produzido || 0;
            });

            const totalExecuted = Object.values(hourlyData).reduce((sum, entry) => sum + (entry.actual || 0), 0);
            const hoursElapsed = getHoursElapsedInProductionDay(new Date());
            const expectedByNow = Math.min(dailyTarget, hoursElapsed * hourlyTarget);

            if (matchedOrder) {
                currentActiveOrder = { ...matchedOrder };
            }
            currentOrderProgress = {
                executed: totalExecuted,
                planned: dailyTarget,
                expected: expectedByNow
            };

            updateTimelineProgress(totalExecuted, dailyTarget, expectedByNow);

            if (hourlyChartInstance) {
                hourlyChartInstance.destroy();
                hourlyChartInstance = null;
            }

            const hours = Object.keys(hourlyData);
            const plannedData = hours.map(hour => Number(hourlyData[hour].planned || 0));
            const actualData = hours.map(hour => Number(hourlyData[hour].actual || 0));

            hourlyChartInstance = createHourlyProductionChart({
                canvas: hourlyProductionChart,
                labels: hours,
                executedPerHour: actualData,
                plannedPerHour: plannedData,
                highlightCurrentHour: true
            });

        } catch (error) {
            console.error('Erro ao carregar dados do gráfico: ', error);
        }
    }
    
    // Função para carregar estatísticas do dia (janela de produção 07:00 -> 07:00)
    async function loadTodayStats(filterDate = null) {
        if (!selectedMachineData) return;
        
        try {
            const today = filterDate || window.lancamentoFilterDate || getProductionDateString();
            // Janela do dia de produção atual: [hoje 07:00, amanhã 07:00)
            const windowStart = combineDateAndTime(today, '07:00');
            const nextDay = new Date(windowStart);
            nextDay.setDate(nextDay.getDate() + 1);
            const tomorrow = nextDay.toISOString().split('T')[0];
            const windowEnd = combineDateAndTime(tomorrow, '07:00');
            
            // Buscar dados de produção
            const prodSnapshot = await db.collection('production_entries')
                .where('machine', '==', selectedMachineData.machine)
                .where('data', '==', today)
                .get();
            
            const productions = prodSnapshot.docs.map(doc => doc.data());
            
                        // Buscar paradas de hoje e de amanhã (duas consultas simples)
                        const [dtSnapToday, dtSnapTomorrow] = await Promise.all([
                                db.collection('downtime_entries')
                                    .where('machine', '==', selectedMachineData.machine)
                                    .where('date', '==', today)
                                    .get(),
                                db.collection('downtime_entries')
                                    .where('machine', '==', selectedMachineData.machine)
                                    .where('date', '==', tomorrow)
                                    .get()
                        ]);
                        const downtimes = [...dtSnapToday.docs, ...dtSnapTomorrow.docs].map(doc => doc.data());
            
            // Calcular totais e produção por turno
            let totalProduced = 0;
            let totalLosses = 0;
            let producedT1 = 0;
            let producedT2 = 0;
            let producedT3 = 0;
            
            productions.forEach(prod => {
                const quantidade = Number(prod.produzido || prod.quantity || 0) || 0;
                const turno = Number(prod.turno || prod.shift || 0);
                
                totalProduced += quantidade;
                totalLosses += Number(prod.refugo_kg || 0) || 0;
                
                // Separar por turno
                if (turno === 1) {
                    producedT1 += quantidade;
                } else if (turno === 2) {
                    producedT2 += quantidade;
                } else if (turno === 3) {
                    producedT3 += quantidade;
                }
            });
            
            // Somar apenas a interseção com a janela de produção (evita inflar com 00:00-07:00 que pertence ao dia anterior)
            let totalDowntime = 0;
            downtimes.forEach(dt => {
                const start = combineDateAndTime(dt.date, dt.startTime);
                const end = combineDateAndTime(dt.date, dt.endTime);
                if (!(start instanceof Date) || Number.isNaN(start.getTime())) return;
                if (!(end instanceof Date) || Number.isNaN(end.getTime())) return;
                // Overlap com [windowStart, windowEnd)
                const overlapStart = start > windowStart ? start : windowStart;
                const overlapEnd = end < windowEnd ? end : windowEnd;
                if (overlapEnd > overlapStart) {
                    totalDowntime += Math.round((overlapEnd - overlapStart) / 60000);
                }
            });
            
            // Calcular eficiência baseado na meta diária (com fallback para planned_quantity)
            const dailyTarget = Number(selectedMachineData.daily_target || selectedMachineData.planned_quantity || 0);
            const efficiency = dailyTarget > 0 ? (totalProduced / dailyTarget * 100) : 0;
            
            // Atualizar display - produção por turno
            const producedT1El = document.getElementById('produced-t1');
            const producedT2El = document.getElementById('produced-t2');
            const producedT3El = document.getElementById('produced-t3');
            if (producedT1El) producedT1El.textContent = producedT1.toLocaleString('pt-BR');
            if (producedT2El) producedT2El.textContent = producedT2.toLocaleString('pt-BR');
            if (producedT3El) producedT3El.textContent = producedT3.toLocaleString('pt-BR');
            
            // Atualizar displays - totais
            if (producedToday) producedToday.textContent = totalProduced.toLocaleString('pt-BR');
            if (efficiencyToday) efficiencyToday.textContent = `${efficiency.toFixed(1)}%`;
            if (lossesToday) lossesToday.textContent = totalLosses.toFixed(2);
            if (downtimeToday) downtimeToday.textContent = totalDowntime;

            const shiftReference = new Date();
            const shiftStart = getShiftStartDateTime(shiftReference);
            const activeDowntime = (machineStatus === 'stopped' && currentDowntimeStart && currentDowntimeStart.machine === selectedMachineData.machine)
                ? currentDowntimeStart
                : null;

            if (shiftStart) {
                const runtimeSeconds = calculateProductionRuntimeSeconds({
                    shiftStart,
                    now: shiftReference,
                    downtimes,
                    activeDowntime
                });
                synchronizeProductionTimer(runtimeSeconds, machineStatus === 'running');
            } else {
                resetProductionTimer();
            }
            
        } catch (error) {
            console.error("Erro ao carregar estatísticas: ", error);
        }
    }



    // --- ABA DE ANÁLISE: RESUMO ---
    async function loadResumoData(showLoading = true) {
        const date = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
        if (!date) return;

        if (showLoading) showLoadingState('resumo', true);

        try {
            // NOVO: Buscar todos os planejamentos e filtrar os ATIVOS no cliente
            const planSnapshot = await db.collection('planning').get();
            const allPlans = planSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const plans = allPlans.filter(isPlanActive);

            if (plans.length === 0) {
                showLoadingState('resumo', false, true);
                return;
            }
            
            const productionSnapshot = await db.collection('production_entries').where('data', '==', date).get();
            const productions = productionSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const downtimeSnapshot = await db.collection('downtime_entries').where('date', '==', date).get();
            const downtimes = downtimeSnapshot.docs.map(doc => doc.data());

            currentReportData = processResumoData(plans, productions, downtimes);
            
            const currentView = reportQuantBtn && reportQuantBtn.classList.contains('active') ? 'quant' : 'effic';
            switchReportView(currentView);

            showLoadingState('resumo', false, false);

        } catch (error) {
            console.error("Erro ao carregar dados de resumo: ", error);
            showLoadingState('resumo', false, true);
        }
    }
    
    function processResumoData(plans, productions, downtimes) {
        return plans.map(plan => {
            const data = { ...plan, T1: {}, T2: {}, T3: {} };
            const turnos = ['T1', 'T2', 'T3'];

            turnos.forEach(turno => {
                const entries = productions.filter(p => p.planId === plan.id && p.turno === turno);
                const produzido = entries.reduce((sum, item) => sum + item.produzido, 0);
                
                // Obter categorias excluídas do OEE
                const oeeExcludedCategoriesResumo = window.databaseModule?.oeeExcludedCategories || [];
                
                const machineDowntimes = downtimes.filter(d => {
                    if (d.machine !== plan.machine) return false;
                    // Excluir paradas de categorias que não devem afetar OEE (ex: HOKKAIDO)
                    const reason = d.reason || '';
                    const category = getDowntimeCategory(reason);
                    if (oeeExcludedCategoriesResumo.includes(category)) {
                        return false;
                    }
                    return true;
                });
                const totalParadas = machineDowntimes.reduce((sum, item) => {
                    const start = new Date(`${item.date}T${item.startTime}`);
                    const end = new Date(`${item.date}T${item.endTime}`);
                    return sum + (end > start ? Math.round((end - start) / 60000) : 0);
                }, 0);

                const refugo_kg = entries.reduce((sum, item) => sum + item.refugo_kg, 0);
                const refugo_pcs = plan.piece_weight > 0 ? Math.round((refugo_kg * 1000) / plan.piece_weight) : 0;
                
                const ciclo_real = plan[`real_cycle_${turno.toLowerCase()}`] || plan.budgeted_cycle;
                const cav_ativas = plan[`active_cavities_${turno.toLowerCase()}`] || plan.mold_cavities;
                
                const oee = calculateShiftOEE(produzido, totalParadas / 3, refugo_pcs, ciclo_real, cav_ativas);

                data[turno] = { produzido, paradas: totalParadas, refugo_kg, refugo_pcs, ...oee };
                
                // Salvar histórico de OEE para este turno
                const dateStr = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
                saveOeeHistory(plan.machine, turno, dateStr, oee);
            });
            
            data.total_produzido = (data.T1.produzido || 0) + (data.T2.produzido || 0) + (data.T3.produzido || 0);
            return data;
        });
    }
    
    function calculateShiftOEE(produzido, tempoParadaMin, refugoPcs, cicloReal, cavAtivas) {
        const tempoTurnoMin = 480;
        
        const tempoProgramado = tempoTurnoMin;
        const tempoProduzindo = Math.max(0, tempoProgramado - Math.max(0, tempoParadaMin));
        const disponibilidade = tempoProgramado > 0 ? (tempoProduzindo / tempoProgramado) : 0;

        const producaoTeorica = cicloReal > 0 && cavAtivas > 0 ? (tempoProduzindo * 60 / cicloReal) * cavAtivas : 0;
        const performance = producaoTeorica > 0 ? Math.min(1, produzido / producaoTeorica) : (produzido > 0 ? 1 : 0);
        
        const totalProduzido = Math.max(0, produzido) + Math.max(0, refugoPcs);
        const qualidade = totalProduzido > 0 ? (Math.max(0, produzido) / totalProduzido) : (produzido > 0 ? 1 : 0);
        
        const oee = disponibilidade * performance * qualidade;

        const result = {
            disponibilidade: isNaN(disponibilidade) || !isFinite(disponibilidade) ? 0 : Math.max(0, Math.min(1, disponibilidade)),
            performance: isNaN(performance) || !isFinite(performance) ? 0 : Math.max(0, Math.min(1, performance)),
            qualidade: isNaN(qualidade) || !isFinite(qualidade) ? 0 : Math.max(0, Math.min(1, qualidade)),
            oee: isNaN(oee) || !isFinite(oee) ? 0 : Math.max(0, Math.min(1, oee))
        };

        // ✂️ Log de debug removido - estava poluindo o console (linha repetida)
        // Se precisar debugar novamente, descomente:
        // console.log('[TRACE][calculateShiftOEE]', { inputs: { produzido, tempoParadaMin, refugoPcs, cicloReal, cavAtivas }, calculations: { tempoProgramado, tempoProduzindo, producaoTeorica, totalProduzido }, result });

        return result;
    }

    // --- FUNÇÕES PARA OEE EM TEMPO REAL ---
    
    // Função para calcular OEE em tempo real baseado nos dados atuais
    function calculateRealTimeOEE(data) {
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        
        // Determinar turno atual - T1: 06:30-14:59, T2: 15:00-23:19, T3: 23:20-06:29
        let currentShift;
        if ((currentHour === 6 && currentMinute >= 30) || (currentHour >= 7 && currentHour < 15)) {
            currentShift = 'T1';
        } else if (currentHour >= 15 && (currentHour < 23 || (currentHour === 23 && currentMinute < 20))) {
            currentShift = 'T2';
        } else {
            currentShift = 'T3';
        }
        
        // Calcular tempo decorrido no turno atual
        let tempoDecorridoMin;
        if (currentShift === 'T1') {
            // T1 começa às 6:30
            tempoDecorridoMin = (currentHour - 6) * 60 + currentMinute - 30;
        } else if (currentShift === 'T2') {
            tempoDecorridoMin = (currentHour - 15) * 60 + currentMinute;
        } else { // T3
            if (currentHour >= 23) {
                // Após 23:20, calcular minutos desde 23:20
                tempoDecorridoMin = (currentHour - 23) * 60 + (currentMinute - 20);
            } else {
                tempoDecorridoMin = (currentHour + 1) * 60 + currentMinute; // Para horas 0-6
            }
        }
        
        // Limitar o tempo decorrido ao máximo do turno (T1: 510min, T2: 500min, T3: 430min)
        const maxTurnoMin = currentShift === 'T1' ? 510 : (currentShift === 'T2' ? 500 : 430);
        tempoDecorridoMin = Math.min(tempoDecorridoMin, maxTurnoMin);
        
        const oeeByShift = {};
        const oeeByMachine = {};
        
        // Agrupar dados por máquina e turno
        const groupedData = {};
        data.forEach(item => {
            const key = `${item.machine}_${item.turno}`;
            if (!groupedData[key]) {
                groupedData[key] = {
                    machine: item.machine,
                    turno: item.turno,
                    produzido: 0,
                    paradas: 0,
                    refugo_pcs: 0,
                    ciclo_real: item.real_cycle_t1 || item.real_cycle_t2 || item.real_cycle_t3 || item.budgeted_cycle,
                    cav_ativas: item.active_cavities_t1 || item.active_cavities_t2 || item.active_cavities_t3 || item.mold_cavities
                };
            }
            
            groupedData[key].produzido += item.produzido || 0;
            groupedData[key].paradas += item.duracao_min || 0;
            
            if (item.piece_weight > 0) {
                groupedData[key].refugo_pcs += Math.round(((item.refugo_kg || 0) * 1000) / item.piece_weight);
            }
        });
        
        // Calcular OEE para cada grupo
        Object.values(groupedData).forEach(group => {
            const tempoParadaMin = group.paradas;
            const oeeCalc = calculateShiftOEE(
                group.produzido,
                tempoParadaMin,
                group.refugo_pcs,
                group.ciclo_real,
                group.cav_ativas
            );
            
            // Ajustar cálculo para tempo real se for o turno atual
            if (group.turno === currentShift) {
                const tempoProgramadoReal = tempoDecorridoMin;
                const tempoProduzindoReal = Math.max(0, tempoProgramadoReal - tempoParadaMin);
                const disponibilidadeReal = tempoProgramadoReal > 0 ? (tempoProduzindoReal / tempoProgramadoReal) : 0;
                
                const producaoTeoricaReal = group.ciclo_real > 0 && group.cav_ativas > 0 ? 
                    (tempoProduzindoReal * 60 / group.ciclo_real) * group.cav_ativas : 0;
                const performanceReal = producaoTeoricaReal > 0 ? (group.produzido / producaoTeoricaReal) : 0;
                
                const totalProduzidoReal = group.produzido + group.refugo_pcs;
                const qualidadeReal = totalProduzidoReal > 0 ? (group.produzido / totalProduzidoReal) : 0;
                
                const oeeReal = disponibilidadeReal * performanceReal * qualidadeReal;
                
                oeeCalc.disponibilidade = isNaN(disponibilidadeReal) || !isFinite(disponibilidadeReal) ? 0 : disponibilidadeReal;
                oeeCalc.performance = isNaN(performanceReal) || !isFinite(performanceReal) ? 0 : performanceReal;
                oeeCalc.qualidade = isNaN(qualidadeReal) || !isFinite(qualidadeReal) ? 0 : qualidadeReal;
                oeeCalc.oee = isNaN(oeeReal) || !isFinite(oeeReal) ? 0 : oeeReal;
                oeeCalc.isRealTime = true;
                oeeCalc.tempoDecorrido = tempoDecorridoMin;
            }
            
            // Armazenar por turno
            if (!oeeByShift[group.turno]) {
                oeeByShift[group.turno] = [];
            }
            oeeByShift[group.turno].push({
                machine: group.machine,
                ...oeeCalc
            });
            
            // Armazenar por máquina
            if (!oeeByMachine[group.machine]) {
                oeeByMachine[group.machine] = {};
            }
            oeeByMachine[group.machine][group.turno] = oeeCalc;
        });
        
        return {
            currentShift,
            tempoDecorridoMin,
            oeeByShift,
            oeeByMachine
        };
    }
    
    // Função para salvar histórico de OEE
    async function saveOeeHistory(machine, turno, data, oeeData) {
        try {
            const historyEntry = {
                machine,
                turno,
                data,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                disponibilidade: oeeData.disponibilidade,
                performance: oeeData.performance,
                qualidade: oeeData.qualidade,
                oee: oeeData.oee,
                isRealTime: oeeData.isRealTime || false,
                tempoDecorrido: oeeData.tempoDecorrido || 480
            };
            
            // Usar ID único baseado em máquina, turno e data para evitar duplicatas
            const docId = `${machine}_${turno}_${data}`;
            await db.collection('oee_history').doc(docId).set(historyEntry, { merge: true });
            
        } catch (error) {
            console.error("Erro ao salvar histórico de OEE: ", error);
        }
    }
    
    // Função para carregar histórico de OEE
    async function loadOeeHistory(startDate, endDate, machine = null, turno = null) {
        try {
            let query = db.collection('oee_history')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate)
                .orderBy('data')
                .orderBy('timestamp');
            
            if (machine) {
                query = query.where('machine', '==', machine);
            }
            
            if (turno) {
                query = query.where('turno', '==', turno);
            }
            
            const snapshot = await query.get();
            return snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data(),
                timestamp: doc.data().timestamp?.toDate()
            }));
            
        } catch (error) {
            console.error("Erro ao carregar histórico de OEE: ", error);
            return [];
        }
    }
    
    // Função para agrupar OEE por períodos (hora, dia, semana)
    function groupOeeByPeriod(oeeHistory, period = 'day') {
        const grouped = {};
        
        oeeHistory.forEach(entry => {
            let key;
            const date = entry.timestamp || new Date(entry.data);
            
            switch (period) {
                case 'hour':
                    key = `${entry.data}_${String(date.getHours()).padStart(2, '0')}:00`;
                    break;
                case 'day':
                    key = entry.data;
                    break;
                case 'week':
                    const startOfWeek = new Date(date);
                    startOfWeek.setDate(date.getDate() - date.getDay());
                    key = startOfWeek.toISOString().split('T')[0];
                    break;
                default:
                    key = entry.data;
            }
            
            if (!grouped[key]) {
                grouped[key] = {
                    period: key,
                    machines: {},
                    shifts: {},
                    overall: {
                        disponibilidade: [],
                        performance: [],
                        qualidade: [],
                        oee: []
                    }
                };
            }
            
            // Agrupar por máquina
            if (!grouped[key].machines[entry.machine]) {
                grouped[key].machines[entry.machine] = {
                    disponibilidade: [],
                    performance: [],
                    qualidade: [],
                    oee: []
                };
            }
            
            // Agrupar por turno
            if (!grouped[key].shifts[entry.turno]) {
                grouped[key].shifts[entry.turno] = {
                    disponibilidade: [],
                    performance: [],
                    qualidade: [],
                    oee: []
                };
            }
            
            // Adicionar valores
            const metrics = ['disponibilidade', 'performance', 'qualidade', 'oee'];
            metrics.forEach(metric => {
                grouped[key].machines[entry.machine][metric].push(entry[metric]);
                grouped[key].shifts[entry.turno][metric].push(entry[metric]);
                grouped[key].overall[metric].push(entry[metric]);
            });
        });
        
        // Calcular médias
        Object.values(grouped).forEach(group => {
            const calculateAverage = (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
            
            // Médias por máquina
            Object.values(group.machines).forEach(machine => {
                machine.avgDisponibilidade = calculateAverage(machine.disponibilidade);
                machine.avgPerformance = calculateAverage(machine.performance);
                machine.avgQualidade = calculateAverage(machine.qualidade);
                machine.avgOee = calculateAverage(machine.oee);
            });
            
            // Médias por turno
            Object.values(group.shifts).forEach(shift => {
                shift.avgDisponibilidade = calculateAverage(shift.disponibilidade);
                shift.avgPerformance = calculateAverage(shift.performance);
                shift.avgQualidade = calculateAverage(shift.qualidade);
                shift.avgOee = calculateAverage(shift.oee);
            });
            
            // Médias gerais
            group.overall.avgDisponibilidade = calculateAverage(group.overall.disponibilidade);
            group.overall.avgPerformance = calculateAverage(group.overall.performance);
            group.overall.avgQualidade = calculateAverage(group.overall.qualidade);
            group.overall.avgOee = calculateAverage(group.overall.oee);
        });
        
        return grouped;
    }

    function switchReportView(view) {
        if (reportQuantBtn && reportEfficBtn) {
            reportQuantBtn.classList.toggle('active', view === 'quant');
            reportEfficBtn.classList.toggle('active', view === 'effic');
        }
        if (view === 'quant') {
            renderRelatorioQuantitativo(currentReportData);
        } else {
            renderRelatorioEficiencia(currentReportData);
        }
    }
    
    function handleResumoTableClick(e) {
        const deleteButton = e.target.closest('.delete-resumo-btn');
        if (deleteButton) {
            const docId = deleteButton.dataset.id;
            showConfirmModal(docId, 'planning');
        }
    }
    
    function renderRelatorioQuantitativo(data) {
        if (!resumoContentContainer) return;
        
        const date = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
        const tableHTML = `
            <h3 class="text-lg font-bold mb-4 no-print">Relatório Quantitativo - ${date}</h3>
            <div class="print-header hidden">
                <h1 class="text-xl font-bold">Hokkaido Synchro - Relatório de Produção</h1>
                <p>Data: ${new Date(date.replace(/-/g, '/')).toLocaleDateString('pt-BR')}</p>
            </div>
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Máquina</th>
                        <th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Produto</th>
                        <th colspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase">Turno 1</th>
                        <th colspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 2</th>
                        <th colspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 3</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">Qtd. Planejada</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">Total Dia</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">Prod. Faltante</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle no-print">Ação</th>
                    </tr>
                    <tr>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase">Prod.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Refugo (kg)</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Prod.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Refugo (kg)</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Prod.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Refugo (kg)</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                    ${data.map(item => {
                        const plannedTotal = coerceToNumber(item.planned_quantity, 0);
                        const producedTotal = coerceToNumber(item.total_produzido, 0);
                        const faltante = plannedTotal - producedTotal;
                        return `
                        <tr>
                            <td class="px-2 py-2 whitespace-nowrap">${item.machine}</td><td class="px-2 py-2 whitespace-nowrap">${item.product}</td>
                            <td class="px-2 py-2 text-center">${(item.T1.produzido || 0).toLocaleString('pt-BR')}</td><td class="px-2 py-2 text-center">${(item.T1.refugo_kg || 0).toFixed(2)}</td>
                            <td class="px-2 py-2 text-center border-l">${(item.T2.produzido || 0).toLocaleString('pt-BR')}</td><td class="px-2 py-2 text-center">${(item.T2.refugo_kg || 0).toFixed(2)}</td>
                            <td class="px-2 py-2 text-center border-l">${(item.T3.produzido || 0).toLocaleString('pt-BR')}</td><td class="px-2 py-2 text-center">${(item.T3.refugo_kg || 0).toFixed(2)}</td>
                            <td class="px-2 py-2 text-center border-l">${plannedTotal.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-2 text-center font-bold border-l">${producedTotal.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-2 text-center font-bold border-l ${faltante > 0 ? 'text-status-error' : 'text-status-success'}">${faltante.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-2 text-center border-l no-print">
                                <button data-id="${item.id}" class="delete-resumo-btn text-status-error hover:text-red-700 p-1"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </td>
                        </tr>
                    `}).join('')}
                </tbody>
            </table>`;
        resumoContentContainer.innerHTML = tableHTML;
        lucide.createIcons();
    }

    function renderRelatorioEficiencia(data) {
        if (!resumoContentContainer) return;
        
        const formatPercent = (val, isRealTime = false) => {
            const colorClass = val < 0.7 ? 'text-status-error' : val < 0.85 ? 'text-status-warning' : 'text-status-success';
            const realtimeIndicator = isRealTime ? ' ⚡' : '';
            return `<span class="${colorClass}" title="${isRealTime ? 'OEE em Tempo Real' : 'OEE Calculado'}">${(val * 100).toFixed(1)}%${realtimeIndicator}</span>`;
        };
        
        const date = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
        const today = getProductionDateString();
        const isToday = date === today;
        
        // Se for hoje, calcular OEE em tempo real para cada item
        let realTimeData = {};
        if (isToday) {
            data.forEach(async (item) => {
                const combinedData = [{
                    machine: item.machine,
                    turno: 'T1',
                    produzido: item.T1.produzido || 0,
                    duracao_min: item.T1.paradas || 0,
                    refugo_kg: item.T1.refugo_kg || 0,
                    piece_weight: item.piece_weight,
                    real_cycle_t1: item.real_cycle_t1,
                    active_cavities_t1: item.active_cavities_t1,
                    budgeted_cycle: item.budgeted_cycle,
                    mold_cavities: item.mold_cavities
                }];
                
                const realTimeOee = calculateRealTimeOEE(combinedData);
                if (realTimeOee && realTimeOee.oeeByMachine[item.machine]) {
                    realTimeData[item.machine] = realTimeOee.oeeByMachine[item.machine];
                }
            });
        }
        
        const tableHTML = `
             <h3 class="text-lg font-bold mb-4 no-print">
                Relatório de Eficiência - ${date}
                ${isToday ? '<span class="text-sm text-green-600 ml-2">⚡ Dados em Tempo Real Disponíveis</span>' : ''}
             </h3>
             <div class="print-header hidden">
                <h1 class="text-xl font-bold">Hokkaido Synchro - Relatório de Eficiência</h1>
                <p>Data: ${new Date(date.replace(/-/g, '/')).toLocaleDateString('pt-BR')}</p>
                ${isToday ? '<p class="text-sm">⚡ Inclui dados em tempo real</p>' : ''}
            </div>
            <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <h4 class="font-semibold text-blue-800 mb-2">Legenda:</h4>
                <div class="flex flex-wrap gap-4 text-sm">
                    <span class="text-status-success">★ ≥85% - Excelente</span>
                    <span class="text-status-warning">★ 70-84% - Aceitável</span>
                    <span class="text-status-error">★ <70% - Crítico</span>
                    ${isToday ? '<span class="text-green-600">⚡ Tempo Real</span>' : ''}
                </div>
            </div>
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Máquina</th><th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Produto</th>
                        <th colspan="4" class="px-2 py-2 text-center text-xs font-medium uppercase">Turno 1</th>
                        <th colspan="4" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 2</th>
                        <th colspan="4" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 3</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">OEE Médio</th>
                         <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle no-print">Ação</th>
                    </tr>
                    <tr>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase">Disp.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Perf.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Qual.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase font-bold">OEE</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Disp.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Perf.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Qual.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase font-bold">OEE</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Disp.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Perf.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Qual.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase font-bold">OEE</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                    ${data.map(item => {
                        // Calcular OEE médio
                        const oeeValues = [item.T1.oee, item.T2.oee, item.T3.oee].filter(v => v > 0);
                        const avgOee = oeeValues.length > 0 ? oeeValues.reduce((a, b) => a + b, 0) / oeeValues.length : 0;
                        
                        // Verificar se há dados em tempo real para esta máquina
                        const machineRealTime = realTimeData[item.machine];
                        const hasRealTime = isToday && machineRealTime;
                        
                        return `
                        <tr class="${hasRealTime ? 'bg-green-50' : ''}">
                            <td class="px-2 py-2 whitespace-nowrap font-medium">${item.machine}</td>
                            <td class="px-2 py-2 whitespace-nowrap text-sm">${item.product}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T1.disponibilidade, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T1.performance, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T1.qualidade, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center font-bold">${formatPercent(item.T1.oee, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center border-l">${formatPercent(item.T2.disponibilidade, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T2.performance, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T2.qualidade, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center font-bold">${formatPercent(item.T2.oee, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center border-l">${formatPercent(item.T3.disponibilidade, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T3.performance, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T3.qualidade, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center font-bold">${formatPercent(item.T3.oee, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center border-l font-bold text-lg">${formatPercent(avgOee, hasRealTime)}</td>
                            <td class="px-2 py-2 text-center border-l no-print">
                                <button data-id="${item.id}" class="delete-resumo-btn text-status-error hover:text-red-700 p-1"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </td>
                        </tr>
                    `;}).join('')}
                </tbody>
            </table>
            ${isToday ? `
            <div class="mt-4 p-3 bg-green-50 border border-green-200 rounded-lg">
                <p class="text-sm text-green-700">
                    <strong>Nota:</strong> Os valores marcados com ⚡ representam cálculos de OEE em tempo real, 
                    atualizados conforme o progresso do turno atual.
                </p>
            </div>
            ` : ''}`;
        resumoContentContainer.innerHTML = tableHTML;
        lucide.createIcons();
    }

    function handlePrintReport() {
        window.print();
    }

    // --- ABA DE ANÁLISE: DASHBOARD ---
    
    async function loadDashboardData() {
        const startDate = startDateSelector ? startDateSelector.value : getProductionDateString();
        const endDate = endDateSelector ? endDateSelector.value : getProductionDateString();

        if (!startDate || !endDate) {
            alert('Por favor, selecione as datas de início e fim.');
            return;
        }
        
        showLoadingState('dashboard', true);
        const dashboardContent = document.getElementById('dashboard-content');
        if (dashboardContent) dashboardContent.style.display = 'none';

        try {
            const prodSnapshot = await db.collection('production_entries').where('data', '>=', startDate).where('data', '<=', endDate).get();
            const productions = prodSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            if (productions.length === 0) {
                fullDashboardData = { perdas: [] };
                populateMachineFilter([]);
                processAndRenderDashboard(fullDashboardData);
                if (dashboardContent) dashboardContent.style.display = 'block';
                showLoadingState('dashboard', false, false);
                return;
            }

            const planIds = [...new Set(productions.map(p => p.planId))];
            const plans = {};
            
            for (let i = 0; i < planIds.length; i += 10) {
                const batchIds = planIds.slice(i, i + 10);
                if (batchIds.length > 0) {
                    const planBatchSnapshot = await db.collection('planning').where(firebase.firestore.FieldPath.documentId(), 'in', batchIds).get();
                    planBatchSnapshot.docs.forEach(doc => {
                        plans[doc.id] = doc.data();
                    });
                }
            }
            
            const combinedData = productions.filter(prod => plans[prod.planId]).map(prod => ({ ...prod, ...plans[prod.planId] }));

            fullDashboardData = { perdas: combinedData };
            
            populateMachineFilter(combinedData);
            if (graphMachineFilter && graphMachineFilter.options.length > 1 && !graphMachineFilter.value) {
                 graphMachineFilter.value = graphMachineFilter.options[1].value;
            }
            processAndRenderDashboard(fullDashboardData);
            
            if (dashboardContent) dashboardContent.style.display = 'block';
            showLoadingState('dashboard', false, false);
        } catch (error) {
            console.error("Erro ao carregar dados do dashboard: ", error);
            showLoadingState('dashboard', false, true);
            const dashboardError = document.getElementById('dashboard-error');
            if (dashboardError) dashboardError.style.display = 'block';
        }
    }

    function processAndRenderDashboard({ perdas }) {
        const mainFilterMachine = machineFilter ? machineFilter.value : 'total';
        const graphFilterMachine = graphMachineFilter ? graphMachineFilter.value : null;

        const filteredDataForKpis = mainFilterMachine === 'total' ? perdas : perdas.filter(p => p.machine === mainFilterMachine);
        const filteredDataForGraphs = graphFilterMachine ? perdas.filter(p => p.machine === graphFilterMachine && p.data >= startDateSelector.value && p.data <= endDateSelector.value) : [];
        
        // Calcular OEE em tempo real
        const realTimeOee = calculateRealTimeOEE(filteredDataForKpis);
        
        // Usar OEE em tempo real se disponível, senão usar cálculo tradicional
        let kpis;
        if (realTimeOee && Object.keys(realTimeOee.oeeByMachine).length > 0) {
            // Calcular médias dos OEEs em tempo real
            const allOeeValues = Object.values(realTimeOee.oeeByMachine)
                .flatMap(machine => Object.values(machine));
            
            if (allOeeValues.length > 0) {
                kpis = {
                    disponibilidade: allOeeValues.reduce((sum, oee) => sum + oee.disponibilidade, 0) / allOeeValues.length,
                    performance: allOeeValues.reduce((sum, oee) => sum + oee.performance, 0) / allOeeValues.length,
                    qualidade: allOeeValues.reduce((sum, oee) => sum + oee.qualidade, 0) / allOeeValues.length,
                    oee: allOeeValues.reduce((sum, oee) => sum + oee.oee, 0) / allOeeValues.length,
                    isRealTime: true,
                    currentShift: realTimeOee.currentShift,
                    tempoDecorrido: realTimeOee.tempoDecorridoMin
                };
            } else {
                kpis = calculateDashboardOEE(filteredDataForKpis);
            }
        } else {
            kpis = calculateDashboardOEE(filteredDataForKpis);
        }
        
        updateKpiCards(kpis);
        
        if (graphFilterMachine) {
            renderProductionTimelineChart(filteredDataForGraphs, graphFilterMachine);
            renderOeeByShiftChart(filteredDataForGraphs, graphFilterMachine);
            renderOeeTrendChart(graphFilterMachine); // Novo gráfico de tendência
        } else {
             if (productionTimelineChartInstance) productionTimelineChartInstance.destroy();
             if (oeeByShiftChartInstance) oeeByShiftChartInstance.destroy();
             if (oeeTrendChartInstance) oeeTrendChartInstance.destroy();
             const messageDiv = document.getElementById('timeline-chart-message');
             if (messageDiv) messageDiv.style.display = 'flex';
        }

        renderParetoChart(filteredDataForKpis);
    }
    
    function calculateDashboardOEE(data) {
        if (data.length === 0) return { disponibilidade: 0, performance: 0, qualidade: 0, oee: 0 };

        let totalTempoProgramado = 0;
        let totalTempoParada = 0;
        let totalProducaoBoa = 0;
        let totalProducaoTeorica = 0;
        let totalRefugoPcs = 0;

        const machineDays = new Set(data.map(d => `${d.machine}-${d.data}`));
        totalTempoProgramado = machineDays.size * 3 * 480;

        data.forEach(item => {
            const cicloReal = item[`real_cycle_${item.turno.toLowerCase()}`] || item.budgeted_cycle;
            const cavAtivas = item[`active_cavities_${item.turno.toLowerCase()}`] || item.mold_cavities;
            const pesoPeca = item.piece_weight;
            
            totalTempoParada += item.duracao_min || 0;
            totalProducaoBoa += item.produzido || 0;

            if (pesoPeca > 0) {
               totalRefugoPcs += Math.round(((item.refugo_kg || 0) * 1000) / pesoPeca);
            }
            
            if (cicloReal > 0 && cavAtivas > 0) {
                const tempoProduzindo = 480 - (item.duracao_min || 0);
                totalProducaoTeorica += (tempoProduzindo * 60 / cicloReal) * cavAtivas;
            }
        });
        
        const tempoProduzindoTotal = totalTempoProgramado - totalTempoParada;

        const disponibilidade = totalTempoProgramado > 0 ? (tempoProduzindoTotal / totalTempoProgramado) : 0;
        const performance = totalProducaoTeorica > 0 ? (totalProducaoBoa / totalProducaoTeorica) : 0;
        const qualidade = (totalProducaoBoa + totalRefugoPcs) > 0 ? (totalProducaoBoa / (totalProducaoBoa + totalRefugoPcs)) : 0;
        const oee = disponibilidade * performance * qualidade;

        return {
            disponibilidade: isNaN(disponibilidade) ? 0 : disponibilidade,
            performance: isNaN(performance) ? 0 : performance,
            qualidade: isNaN(qualidade) ? 0 : qualidade,
            oee: isNaN(oee) ? 0 : oee
        };
    }

    function updateKpiCards(kpis) {
        const disponibilidadeEl = document.getElementById('kpi-disponibilidade');
        const performanceEl = document.getElementById('kpi-performance');
        const qualidadeEl = document.getElementById('kpi-qualidade');
        const oeeEl = document.getElementById('kpi-oee');
        
        if (disponibilidadeEl) {
            const dispValue = (kpis.disponibilidade * 100).toFixed(1) + '%';
            disponibilidadeEl.textContent = dispValue;
            if (kpis.isRealTime) {
                disponibilidadeEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
            }
        }
        
        if (performanceEl) {
            const perfValue = (kpis.performance * 100).toFixed(1) + '%';
            performanceEl.textContent = perfValue;
            if (kpis.isRealTime) {
                performanceEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
            }
        }
        
        if (qualidadeEl) {
            const qualValue = (kpis.qualidade * 100).toFixed(1) + '%';
            qualidadeEl.textContent = qualValue;
            if (kpis.isRealTime) {
                qualidadeEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
            }
        }
        
        if (oeeEl) {
            const oeeValue = (kpis.oee * 100).toFixed(1) + '%';
            oeeEl.textContent = oeeValue;
            if (kpis.isRealTime) {
                oeeEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
                oeeEl.style.color = '#059669'; // Verde para indicar tempo real
            } else {
                oeeEl.style.color = '';
            }
        }
    }

    function renderProductionTimelineChart(data, selectedMachine) {
        const ctx = document.getElementById('productionTimelineChart');
        if (!ctx) return;
        
        const messageDiv = document.getElementById('timeline-chart-message');
        
        if (productionTimelineChartInstance) productionTimelineChartInstance.destroy();
        
        if (!selectedMachine || selectedMachine === 'total') {
            ctx.style.display = 'none';
            if (messageDiv) messageDiv.style.display = 'flex';
            return;
        }
        ctx.style.display = 'block';
        if (messageDiv) messageDiv.style.display = 'none';
        
        const hourlyData = {};
        for (let i = 7; i < 24; i++) { hourlyData[`${String(i).padStart(2,'0')}:00`] = 0; }
        for (let i = 0; i < 7; i++) { hourlyData[`${String(i).padStart(2,'0')}:00`] = 0; }

        data.forEach(item => {
            const ts = item.timestamp?.toDate();
            if (!ts) return;
            const hour = `${String(ts.getHours()).padStart(2,'0')}:00`;
            if (hourlyData[hour] !== undefined) {
               hourlyData[hour] += item.produzido || 0;
            }
        });

        const sortedHours = Object.keys(hourlyData).sort((a,b) => {
            const hourA = parseInt(a.split(':')[0]);
            const hourB = parseInt(b.split(':')[0]);
            if (hourA >= 6 && hourB < 6) return -1;
            if (hourA < 6 && hourB >= 6) return 1;
            return hourA - hourB;
        });
        
        let cumulativeTotal = 0;
        const cumulativeProductionData = sortedHours.map(hour => {
            cumulativeTotal += hourlyData[hour];
            return cumulativeTotal;
        });

        const planItem = data.length > 0 ? data.find(d => d.planned_quantity > 0) : null;
        const metaDiaria = planItem ? planItem.planned_quantity : 0;
        const metaPorHora = metaDiaria / 24;
        
        let cumulativeTarget = 0;
        const cumulativeTargetData = sortedHours.map(() => {
            cumulativeTarget += metaPorHora;
            return cumulativeTarget;
        });
        
        let displayLabels = sortedHours;
        let displayProdData = cumulativeProductionData;
        let displayTargetData = cumulativeTargetData;
        
        const todayString = getProductionDateString();
        const viewingToday = (endDateSelector.value === todayString && startDateSelector.value === todayString);

        if (viewingToday) {
            const currentHour = new Date().getHours();
            let currentHourIndex = sortedHours.findIndex(h => parseInt(h.split(':')[0]) === currentHour);
            
            if (currentHourIndex === -1 && currentHour < 6) {
                currentHourIndex = 18 + currentHour;
            } else if (currentHourIndex === -1) {
                currentHourIndex = 23;
            }

            const sliceIndex = Math.min(currentHourIndex + 2, sortedHours.length);

            displayLabels = sortedHours.slice(0, sliceIndex);
            displayProdData = cumulativeProductionData.slice(0, sliceIndex);
            displayTargetData = cumulativeTargetData.slice(0, sliceIndex);
        }

        productionTimelineChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: displayLabels,
                datasets: [
                    { 
                        label: 'Produção Acumulada', 
                        data: displayProdData, 
                        borderColor: '#0077C2',
                        backgroundColor: 'rgba(0, 119, 194, 0.1)',
                        fill: true,
                        tension: 0.3
                    },
                    {
                        label: 'Meta Acumulada',
                        data: displayTargetData,
                        borderColor: '#DC2626',
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,

                scales: { y: { beginAtZero: true, title: { display: true, text: 'Quantidade de Peças' } } },
                plugins: { 
                    legend: { position: 'top' },
                    tooltip: { mode: 'index', intersect: false }
                },
                hover: { mode: 'index', intersect: false }
            }
        });
    }

    function renderOeeByShiftChart(data, selectedMachine) {
        const ctx = document.getElementById('oeeByShiftChart');
        if (!ctx) return;
        
        if (oeeByShiftChartInstance) oeeByShiftChartInstance.destroy();
        
        if (!selectedMachine || selectedMachine === 'total') {
            return;
        }
        
        const oeeData = { T1: [], T2: [], T3: [] };
        data.forEach(item => {
            const refugoPcs = item.piece_weight > 0 ? ((item.refugo_kg || 0) * 1000) / item.piece_weight : 0;
            const oee = calculateShiftOEE(item.produzido || 0, item.duracao_min || 0, refugoPcs, item[`real_cycle_${item.turno.toLowerCase()}`] || item.budgeted_cycle, item[`active_cavities_${item.turno.toLowerCase()}`] || item.mold_cavities);
            if (oeeData[item.turno]) {
                oeeData[item.turno].push(oee.oee);
            }
        });

        const avgOee = (arr) => arr.length > 0 ? (arr.reduce((a, b) => a + b, 0) / arr.length) * 100 : 0;

        oeeByShiftChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Turno 1', 'Turno 2', 'Turno 3'],
                datasets: [{
                    label: 'Eficiência (OEE)',
                    data: [avgOee(oeeData.T1), avgOee(oeeData.T2), avgOee(oeeData.T3)],
                    backgroundColor: ['#4F46E5', '#10B981', '#0077C2']
                }]
            },
            options: {
                responsive: true,

                scales: { y: { beginAtZero: true, max: 100, ticks: { callback: value => value + '%' } } },
                plugins: { legend: { display: false } }
            }
        });
    }
    
    async function renderOeeTrendChart(selectedMachine) {
        const ctx = document.getElementById('oeeTrendChart');
        if (!ctx) return;
        
        if (oeeTrendChartInstance) oeeTrendChartInstance.destroy();
        
        if (!selectedMachine || selectedMachine === 'total') {
            return;
        }
        
        try {
            // Carregar histórico de OEE dos últimos 7 dias
            const endDate = endDateSelector.value;
            const startDateObj = new Date(endDate);
            startDateObj.setDate(startDateObj.getDate() - 6);
            const startDate = startDateObj.toISOString().split('T')[0];
            
            const oeeHistory = await loadOeeHistory(startDate, endDate, selectedMachine);
            
            if (oeeHistory.length === 0) {
                return;
            }
            
            // Agrupar por dia e turno
            const groupedByDay = groupOeeByPeriod(oeeHistory, 'day');
            
            // Preparar dados para o gráfico
            const dates = Object.keys(groupedByDay).sort();
            const datasets = [
                {
                    label: 'Turno 1',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.shifts.T1 ? (dayData.shifts.T1.avgOee * 100) : null;
                    }),
                    borderColor: '#4F46E5',
                    backgroundColor: 'rgba(79, 70, 229, 0.1)',
                    tension: 0.3,
                    fill: false
                },
                {
                    label: 'Turno 2',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.shifts.T2 ? (dayData.shifts.T2.avgOee * 100) : null;
                    }),
                    borderColor: '#10B981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    tension: 0.3,
                    fill: false
                },
                {
                    label: 'Turno 3',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.shifts.T3 ? (dayData.shifts.T3.avgOee * 100) : null;
                    }),
                    borderColor: '#0077C2',
                    backgroundColor: 'rgba(0, 119, 194, 0.1)',
                    tension: 0.3,
                    fill: false
                },
                {
                    label: 'OEE Médio Diário',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.overall.avgOee * 100;
                    }),
                    borderColor: '#DC2626',
                    backgroundColor: 'rgba(220, 38, 38, 0.1)',
                    borderWidth: 3,
                    borderDash: [5, 5],
                    tension: 0.3,
                    fill: false
                }
            ];
            
            // Formatear datas para exibição
            const formattedDates = dates.map(date => {
                const dateObj = new Date(date);
                return dateObj.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
            });
            
            oeeTrendChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: formattedDates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
    
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'OEE (%)'
                            },
                            ticks: {
                                callback: value => value + '%'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Data'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: `Tendência de OEE - ${selectedMachine} (Últimos 7 dias)`
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + (context.parsed.y || 0).toFixed(1) + '%';
                                }
                            }
                        }
                    },
                    hover: {
                        mode: 'index',
                        intersect: false
                    },
                    elements: {
                        point: {
                            radius: 4,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
        } catch (error) {
            console.error("Erro ao carregar gráfico de tendência de OEE: ", error);
        }
    }

    function renderParetoChart(data) {
        const ctx = document.getElementById('paretoChart');
        if (!ctx) return;
        
        if (paretoChartInstance) paretoChartInstance.destroy();

        const reasonCounts = data.reduce((acc, item) => {
            if(item.motivo_refugo && (item.refugo_kg || 0) > 0) {
                acc[item.motivo_refugo] = (acc[item.motivo_refugo] || 0) + (item.refugo_kg || 0);
            }
            return acc;
        }, {});

        const sortedReasons = Object.entries(reasonCounts).sort(([, a], [, b]) => b - a);
        const labels = sortedReasons.map(([reason]) => reason);
        const values = sortedReasons.map(([, count]) => count);
        const total = values.reduce((sum, val) => sum + val, 0);

        let cumulative = 0;
        const cumulativePercentage = values.map(val => {
            cumulative += val;
            return total > 0 ? (cumulative / total) * 100 : 0;
        });
        
        paretoChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels,
                datasets: [
                    {
                        label: 'Refugo (kg)',
                        data: values,
                        backgroundColor: 'rgba(220, 38, 38, 0.7)',
                        yAxisID: 'y'
                    },
                    {
                        label: 'Acumulado %',
                        data: cumulativePercentage,
                        type: 'line',
                        borderColor: '#4F46E5',
                        backgroundColor: 'rgba(79, 70, 229, 0.2)',
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    y: { type: 'linear', display: true, position: 'left', beginAtZero: true, title: { display: true, text: 'Kg' }},
                    y1: { type: 'linear', display: true, position: 'right', min: 0, max: 105, grid: { drawOnChartArea: false }, ticks: { callback: value => value + '%' } }
                }
            }
        });
    }
    
    function populateMachineFilter(data) {
        const machines = [...new Set(data.map(item => item.machine))].sort();
        const mainOptions = '<option value="total">Visão Geral (Total)</option>' + machines.map(m => `<option value="${m}">${m}</option>`).join('');
        const graphOptions = '<option value="">Selecione...</option>' + machines.map(m => `<option value="${m}">${m}</option>`).join('');
        if (machineFilter) machineFilter.innerHTML = mainOptions;
        if (graphMachineFilter) graphMachineFilter.innerHTML = graphOptions;
    }

    init();
    // Função para popular opções dos formulários rápidos
    function populateQuickFormOptions() {
        // Popular motivos de perda
        const lossReasonSelect = document.getElementById('quick-losses-reason');
        if (lossReasonSelect) {
            lossReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            // Grupo PROCESSO
            const processoGroup = document.createElement('optgroup');
            processoGroup.label = 'PROCESSO';
            ["BOLHA", "CHUPAGEM", "CONTAMINAÇÃO", "DEGRADAÇÃO", "EMPENAMENTO", "FALHA", 
             "FIAPO", "FORA DE COR", "INÍCIO/REÍNICIO", "JUNÇÃO", "MANCHAS", 
             "MEDIDA FORA DO ESPECIFICADO", "MOÍDO", "PEÇAS PERDIDAS", "QUEIMA", "REBARBA"].forEach(reason => {
                const option = document.createElement('option');
                option.value = reason;
                option.textContent = reason;
                processoGroup.appendChild(option);
            });
            lossReasonSelect.appendChild(processoGroup);
            
            // Grupo FERRAMENTARIA
            const ferramentariaGroup = document.createElement('optgroup');
            ferramentariaGroup.label = 'FERRAMENTARIA';
            ["DEFORMAÇÃO", "GALHO PRESO", "MARCA D'ÁGUA", "MARCA EXTRATOR", "RISCOS", "SUJIDADE"].forEach(reason => {
                const option = document.createElement('option');
                option.value = reason;
                option.textContent = reason;
                ferramentariaGroup.appendChild(option);
            });
            lossReasonSelect.appendChild(ferramentariaGroup);
            
            // Grupo QUALIDADE
            const qualidadeGroup = document.createElement('optgroup');
            qualidadeGroup.label = 'QUALIDADE';
            const option = document.createElement('option');
            option.value = "INSPEÇÃO DE LINHA";
            option.textContent = "INSPEÇÃO DE LINHA";
            qualidadeGroup.appendChild(option);
            lossReasonSelect.appendChild(qualidadeGroup);
        }
        
        // Popular motivos de parada
        const downtimeReasonSelect = document.getElementById('quick-downtime-reason');
        if (downtimeReasonSelect) {
            downtimeReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            // Usar motivos do database.js ou fallback
            const downtimeReasons = getGroupedDowntimeReasons();
            
            Object.entries(downtimeReasons).forEach(([groupName, reasons]) => {
                const group = document.createElement('optgroup');
                group.label = groupName;
                reasons.forEach(reason => {
                    const option = document.createElement('option');
                    option.value = reason;
                    option.textContent = reason;
                    group.appendChild(option);
                });
                downtimeReasonSelect.appendChild(group);
            });
        }

        // Também popular o select de paradas manuais
        const manualDowntimeReasonSelect = document.getElementById('manual-downtime-reason');
        if (manualDowntimeReasonSelect) {
            manualDowntimeReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            // Usar motivos do database.js ou fallback
            const downtimeReasons = getGroupedDowntimeReasons();
            
            Object.entries(downtimeReasons).forEach(([groupName, reasons]) => {
                const group = document.createElement('optgroup');
                group.label = groupName;
                reasons.forEach(reason => {
                    const option = document.createElement('option');
                    option.value = reason;
                    option.textContent = reason;
                    group.appendChild(option);
                });
                manualDowntimeReasonSelect.appendChild(group);
            });
        }
    }

    // ================================
    // NOVO: Função para buscar paradas ativas por máquina
    // ================================
    async function getActiveMachineDowntime(machineId) {
        try {
            if (!window.db) return null;
            
            const normalizedId = normalizeMachineId(machineId);
            const now = new Date();
            const todayStr = now.toISOString().split('T')[0];  // YYYY-MM-DD
            
            // PRIORIDADE 1: Buscar paradas em "active_downtimes" (paradas iniciadas via "Parar Máquina")
            const activeDowntimeRef = window.db.collection('active_downtimes').doc(normalizedId);
            const activeDowntimeSnap = await activeDowntimeRef.get();
            
            if (activeDowntimeSnap.exists) {
                const data = activeDowntimeSnap.data();
                if (data && data.isActive) {
                    // Log removido - estava poluindo o console a cada polling
                    return {
                        recordId: normalizedId, // Usar ID da máquina como recordId para paradas em active_downtimes
                        type: 'active_downtime_live',
                        reason: data.reason || 'Parada ativa',
                        startDate: data.startDate,
                        endDate: null,
                        status: 'active',
                        durationMinutes: data.durationMinutes
                    };
                }
            }
            
            // PRIORIDADE 2: Buscar paradas com status='active' em extended_downtime_logs (paradas longas)
            const activeSnap = await window.db
                .collection('extended_downtime_logs')
                .where('machine_id', '==', normalizedId)
                .where('status', '==', 'active')
                .get();
            
            // Se encontrou parada ativa, retorna imediatamente
            for (const doc of activeSnap.docs) {
                const data = doc.data();
                // Log removido - estava poluindo o console a cada polling
                return {
                    recordId: doc.id,
                    type: data.type || 'maintenance',
                    reason: data.reason || 'Parada longa ativa',
                    startDate: data.start_date,
                    endDate: data.end_date,
                    status: 'active',
                    durationMinutes: data.duration_minutes
                };
            }
            
            // PRIORIDADE 3: Buscar paradas programadas (com end_date futuro)
            const extendedSnap = await window.db
                .collection('extended_downtime_logs')
                .where('machine_id', '==', normalizedId)
                .get();
            
            for (const doc of extendedSnap.docs) {
                const data = doc.data();
                
                // Ignorar paradas já finalizadas
                if (data.status === 'inactive' || data.status === 'finalized') {
                    continue;
                }
                
                // Verificar se a parada está dentro do período válido
                const startDate = data.start_date ? new Date(data.start_date + 'T00:00:00') : null;
                const endDate = data.end_date ? new Date(data.end_date + 'T23:59:59') : null;
                
                // Parada válida: já começou E (não tem fim OU fim é futuro)
                const hasStarted = startDate && startDate <= now;
                const isOngoing = !endDate || endDate >= now;
                
                if (hasStarted && isOngoing) {
                    return {
                        recordId: doc.id,
                        type: data.type || 'maintenance',
                        reason: data.reason || 'Parada longa ativa',
                        startDate: data.start_date,
                        endDate: data.end_date,
                        status: data.status || 'active',
                        durationMinutes: data.duration_minutes
                    };
                }
            }
            
            return null;
        } catch (error) {
            console.warn('[MACHINE-DOWNTIME] Erro ao buscar paradas:', error);
            return null;
        }
    }

    // ========== CACHE PARA DOWNTIME STATUS ==========
    // Evita múltiplas leituras Firebase para cada máquina
    let _downtimeStatusCache = null;
    let _downtimeStatusCacheTimestamp = 0;
    const DOWNTIME_CACHE_TTL = 15000; // 15 segundos - mesmo intervalo do polling

    // OTIMIZADO: Função para buscar status de todas as máquinas com cache
    async function getAllMachinesDowntimeStatus(forceRefresh = false) {
        // Verificar cache
        const now = Date.now();
        if (!forceRefresh && _downtimeStatusCache && (now - _downtimeStatusCacheTimestamp) < DOWNTIME_CACHE_TTL) {
            // Usar cache - economia de leituras
            return _downtimeStatusCache;
        }
        
        const statusMap = {};
        
        try {
            // OTIMIZAÇÃO: Buscar TODOS de uma vez ao invés de um por um
            
            // 1. Buscar todas as paradas ativas de active_downtimes
            const activeDowntimesSnap = await window.db.collection('active_downtimes').get();
            activeDowntimesSnap.forEach(doc => {
                const data = doc.data();
                if (data && data.isActive) {
                    const mid = normalizeMachineId(doc.id);
                    statusMap[mid] = {
                        recordId: mid,
                        type: 'active_downtime_live',
                        reason: data.reason || 'Parada ativa',
                        startDate: data.startDate,
                        endDate: null,
                        status: 'active',
                        durationMinutes: data.durationMinutes
                    };
                }
            });
            
            // 2. Buscar paradas ativas de extended_downtime_logs
            const extendedActiveSnap = await window.db.collection('extended_downtime_logs')
                .where('status', '==', 'active')
                .get();
            extendedActiveSnap.forEach(doc => {
                const data = doc.data();
                const mid = normalizeMachineId(data.machine_id);
                // Só adicionar se não já existe (active_downtimes tem prioridade)
                if (!statusMap[mid]) {
                    statusMap[mid] = {
                        recordId: doc.id,
                        type: data.type || 'maintenance',
                        reason: data.reason || 'Parada longa ativa',
                        startDate: data.start_date,
                        endDate: data.end_date,
                        status: 'active',
                        durationMinutes: data.duration_minutes
                    };
                }
            });
            
            // Atualizar cache
            _downtimeStatusCache = statusMap;
            _downtimeStatusCacheTimestamp = now;
            
        } catch (error) {
            console.error('[MACHINE-STATUS] Erro ao carregar status:', error);
        }
        
        return statusMap;
    }

    // ================================
    // NOVO: Variáveis globais do downtime
    // ================================
    // Armazenar timers de paradas
    const downtimeTimers = new Map();
    
    // Cache de status de paradas (inicializado em renderMachineCards)
    let downtimeStatusCache = {};

    // ============================================================
    // FINALIZAR PARADA - Encerra parada ativa
    // ============================================================
    async function finalizarParada(recordId, machineId) {
        console.log('[FINALIZAR-PARADA] Solicitação de finalização:', { recordId, machineId });
        
        if (!recordId || !machineId) {
            console.error('[FINALIZAR-PARADA] IDs inválidos');
            return;
        }

        try {
            const normalizedMachineId = normalizeMachineId(machineId);
            const now = new Date();
            
            // Verificar se é uma parada em "active_downtimes" (parada iniciada via "Parar Máquina")
            const isActiveDowttimeRecord = recordId === normalizedMachineId;
            
            let downtimeData = null;
            let recordSnapshot = null;
            
            if (isActiveDowttimeRecord) {
                // CASO 1: Parada em "active_downtimes"
                recordSnapshot = await db.collection('active_downtimes').doc(recordId).get();
                if (!recordSnapshot.exists) {
                    showNotification('Registro de parada não encontrado', 'error');
                    return;
                }
                downtimeData = recordSnapshot.data();
            } else {
                // CASO 2: Parada em "extended_downtime_logs"
                recordSnapshot = await db.collection('extended_downtime_logs').doc(recordId).get();
                if (!recordSnapshot.exists) {
                    showNotification('Registro de parada não encontrado', 'error');
                    return;
                }
                downtimeData = recordSnapshot.data();
            }
            
            console.log('[FINALIZAR-PARADA] Dados do registro:', downtimeData);
            
            // Calcular duração prévia para mostrar no alerta
            let startDatetime = null;
            
            // Tentar diferentes formas de obter a data de início
            if (isActiveDowttimeRecord) {
                // Para paradas em active_downtimes
                if (downtimeData.startTimestamp) {
                    startDatetime = downtimeData.startTimestamp.toDate?.() || new Date(downtimeData.startTimestamp);
                } else if (downtimeData.startTimestampLocal) {
                    startDatetime = new Date(downtimeData.startTimestampLocal);
                } else if (downtimeData.startDate && downtimeData.startTime) {
                    startDatetime = new Date(downtimeData.startDate + 'T' + downtimeData.startTime);
                }
            } else {
                // Para paradas em extended_downtime_logs
                if (downtimeData.start_datetime) {
                    startDatetime = downtimeData.start_datetime.toDate?.() || new Date(downtimeData.start_datetime);
                } else if (downtimeData.start_date && downtimeData.start_time) {
                    startDatetime = new Date(downtimeData.start_date + 'T' + downtimeData.start_time);
                } else if (downtimeData.createdAt) {
                    startDatetime = downtimeData.createdAt.toDate?.() || new Date(downtimeData.createdAt);
                }
            }
            
            // Validar se a data é válida
            if (!startDatetime || isNaN(startDatetime.getTime())) {
                startDatetime = new Date(now.getTime() - 60 * 60 * 1000); // Fallback: 1 hora atrás
            }
            
            const durationMinutes = Math.max(0, Math.floor((now - startDatetime) / (1000 * 60)));
            const hours = Math.floor(durationMinutes / 60);
            const mins = durationMinutes % 60;
            const durationText = hours > 0 ? `${hours}h ${mins}min` : `${mins}min`;
            
            // Tipo/Motivo da parada - VALIDAÇÃO OBRIGATÓRIA
            const reasonText = downtimeData.reason || downtimeData.type || '';
            
            // Não permitir finalizar parada sem motivo válido
            if (!reasonText || reasonText.trim() === '' || reasonText.toLowerCase() === 'não informado') {
                console.error('[FINALIZAR-PARADA] Parada sem motivo válido');
                alert('⚠️ Erro: Esta parada não possui um motivo válido registrado.\n\nNão é possível finalizá-la sem um motivo.\nPor favor, edite a parada para adicionar o motivo antes de finalizar.');
                showNotification('Parada sem motivo válido', 'error');
                return;
            }
            
            const startDateStr = isActiveDowttimeRecord 
                ? (downtimeData.startDate || '?') 
                : (downtimeData.start_date || '?');
            const startTimeStr = isActiveDowttimeRecord 
                ? (downtimeData.startTime || '?') 
                : (downtimeData.start_time || '?');
            const startText = `${startDateStr} às ${startTimeStr}`;
            
            // 2. ALERTA DE CONFIRMAÇÃO
            const confirmMessage = `⚠️ FINALIZAR PARADA LONGA?\n\n` +
                `🏭 Máquina: ${normalizedMachineId}\n` +
                `📋 Motivo: ${reasonText}\n` +
                `🕐 Início: ${startText}\n` +
                `⏱️ Duração: ${durationText}\n\n` +
                `Deseja realmente finalizar esta parada?`;
            
            if (!confirm(confirmMessage)) {
                console.log('[FINALIZAR-PARADA] Usuário cancelou a finalização');
                showNotification('Finalização cancelada', 'info');
                return;
            }
            
            // 3. Usuário confirmou - prosseguir com finalização
            console.log('[FINALIZAR-PARADA] Usuário confirmou - encerrando parada');
            
            const endDate = now.toISOString().split('T')[0];  // YYYY-MM-DD
            const endTime = now.toTimeString().split(' ')[0].substring(0, 5);  // HH:MM

            // 4. Atualizar registro: marcar como inativo/finalizado
            if (isActiveDowttimeRecord) {
                // Para paradas em active_downtimes: registrar histórico e depois deletar
                
                // Primeiro, registrar em downtime_entries para histórico
                const downtimeEntryData = {
                    machine: normalizedMachineId,
                    date: startDateStr,
                    startTime: startTimeStr,
                    endTime: endTime,
                    duration: durationMinutes,
                    reason: reasonText,
                    observations: downtimeData.observations || '',
                    registradoPor: getActiveUser()?.username || null,
                    registradoPorNome: getActiveUser()?.name || 'Sistema',
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                await db.collection('downtime_entries').add(downtimeEntryData);
                console.log('[FINALIZAR-PARADA] Registrado em downtime_entries para histórico:', downtimeEntryData);
                
                // Depois, deletar o documento de active_downtimes (o padrão do sistema é deletar, não atualizar)
                await db.collection('active_downtimes').doc(recordId).delete();
                console.log('[FINALIZAR-PARADA] Documento active_downtimes deletado:', recordId);
            } else {
                // Para paradas em extended_downtime_logs: atualizar status
                const updateData = {
                    end_date: endDate,
                    end_time: endTime,
                    end_datetime: firebase.firestore.Timestamp.fromDate(now),
                    duration_minutes: durationMinutes,
                    status: 'inactive',  // Muda de 'active' para 'inactive'
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Adicionar usuário apenas se existir
                const activeUser = getActiveUser();
                if (activeUser && activeUser.name) {
                    updateData.updatedBy = activeUser.name;
                }
                
                await db.collection('extended_downtime_logs').doc(recordId).update(updateData);
            }

            console.log('[FINALIZAR-PARADA] Registrado como finalizado:', { 
                recordId, 
                machineId: normalizedMachineId, 
                durationMinutes: `${hours}h ${mins}m`
            });

            // 5. Limpar cache e timers
            const mid = normalizedMachineId;
            
            // Limpar status cache
            if (window.downtimeStatusCache && window.downtimeStatusCache[mid]) {
                delete window.downtimeStatusCache[mid];
            }

            // Limpar timer de cronômetro
            if (window.downtimeTimers && window.downtimeTimers.has(mid)) {
                clearInterval(window.downtimeTimers.get(mid));
                window.downtimeTimers.delete(mid);
            }

            // 6. Mostrar notificação de sucesso
            showNotification(
                `✅ Parada finalizada para ${mid} após ${durationText}`,
                'success'
            );

            // 7. Re-renderizar painel de máquinas (recarrega todos os dados)
            if (typeof populateMachineSelector === 'function') {
                console.log('[FINALIZAR-PARADA] Recarregando painel de máquinas...');
                await populateMachineSelector();
            }

            // 8. Recarregar lista de paradas (se tab está aberta)
            if (typeof loadExtendedDowntimeList === 'function') {
                await loadExtendedDowntimeList();
            }

        } catch (error) {
            console.error('[FINALIZAR-PARADA] Erro completo:', error);
            console.error('[FINALIZAR-PARADA] Stack:', error.stack);
            showNotification(`Erro ao finalizar parada: ${error.message}`, 'error');
        }
    }

    // NOVO: Função auxiliar para obter cor do badge baseado no tipo
    function getDowntimeTypeColor(type) {
        const colors = {
            'maintenance': 'bg-blue-100 text-blue-800',
            'preventive': 'bg-blue-100 text-blue-800',
            'maintenance_planned': 'bg-blue-100 text-blue-800',
            'no_order': 'bg-red-100 text-red-800',
            'commercial': 'bg-amber-100 text-amber-800',
            'weekend': 'bg-gray-100 text-gray-800',
            'holiday': 'bg-purple-100 text-purple-800',
            'setup': 'bg-green-100 text-green-800',
            'other': 'bg-gray-100 text-gray-800'
        };
        return colors[type] || 'bg-gray-100 text-gray-800';
    }

    // NOVO: Função auxiliar para obter rótulo do tipo
    function getDowntimeTypeLabel(type) {
        const labels = {
            'maintenance': 'Manutenção Preventiva',
            'preventive': 'Manutenção Preventiva',
            'maintenance_planned': 'Manutenção Programada',
            'maintenance_emergency': 'Manutenção Emergencial',
            'no_order': 'Sem Pedido',
            'commercial': 'Parada Comercial',
            'weekend': 'Fim de Semana',
            'holiday': 'Feriado',
            'setup': 'Setup/Troca',
            'other': 'Outro'
        };
        return labels[type] || type;
    }

    // ================================
    // NOVO: Funções para cronômetro de parada
    // ================================
    
    // Calcular duração da parada em tempo real
    function getDowntimeDuration(startDate) {
        try {
            const start = new Date(startDate);
            const now = new Date();
            const diffMs = now.getTime() - start.getTime();
            
            if (diffMs < 0) return '0h 0m';
            
            const totalSeconds = Math.floor(diffMs / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            } else {
                return `${seconds}s`;
            }
        } catch (e) {
            return '0h 0m';
        }
    }
    
    // Iniciar cronômetro para uma máquina parada
    function startDowntimeTimer(machineId, cardElement) {
        try {
            // Verificar se cardElement é válido
            if (!cardElement || typeof cardElement.querySelector !== 'function') {
                console.warn('[DOWNTIME-TIMER] cardElement inválido para máquina:', machineId);
                return;
            }
            
            // Limpar timer anterior se existir
            if (downtimeTimers.has(machineId)) {
                clearInterval(downtimeTimers.get(machineId));
            }
            
            // Atualizar a cada segundo
            const interval = setInterval(() => {
                const timerElement = cardElement?.querySelector(`[data-timer-machine="${machineId}"]`);
                if (timerElement && window.db) {
                    // Buscar parada atual
                    const statusMap = downtimeStatusCache || {};
                    const downtime = statusMap[machineId];
                    
                    if (downtime) {
                        const duration = getDowntimeDuration(downtime.startDate);
                        timerElement.textContent = duration;
                    }
                } else if (!timerElement) {
                    // Elemento removido, limpar interval
                    clearInterval(interval);
                    downtimeTimers.delete(machineId);
                }
            }, 1000);
            
            downtimeTimers.set(machineId, interval);
        } catch (e) {
            console.warn('[DOWNTIME-TIMER] Erro ao iniciar timer:', e);
        }
    }

// Função de debug para modais
window.debugModals = function() {
    console.log('📍 DEBUG MODALS - Checking all modals...');
    
    const allModals = document.querySelectorAll('[id$="-modal"]');
    allModals.forEach(modal => {
        const rect = modal.getBoundingClientRect();
        const computed = window.getComputedStyle(modal);
        
        console.log(`📋 Modal: ${modal.id}`);
        console.log(`  - Hidden class: ${modal.classList.contains('hidden')}`);
        console.log(`  - Display: ${computed.display}`);
        console.log(`  - Opacity: ${computed.opacity}`);
        console.log(`  - Z-index: ${computed.zIndex}`);
        console.log(`  - Visibility: ${computed.visibility}`);
        console.log(`  - Position: ${rect.top}, ${rect.left} (${rect.width}x${rect.height})`);
        console.log(`  - In viewport: ${rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth}`);
        console.log('---');
    });
    
    return 'Debug complete. Check console for details.';
};

// Função para forçar abertura de qualquer modal
window.forceOpenModal = function(modalId) {
    console.log(`🔧 FORCE OPEN MODAL: ${modalId}`);
    
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error(`❌ Modal ${modalId} not found`);
        return false;
    }

    modalManager.portalize(modal);
    modal.setAttribute('data-modal-open', 'true');
    modal.setAttribute('aria-hidden', 'false');
    modal.classList.remove('hidden');
    modalManager.applyStyles(modal);

    const modalContent = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
    if (modalContent) {
        modalManager.applyContentStyles(modalContent);
    }

    requestAnimationFrame(() => modalManager.verify(modal));
    console.log(`✅ Modal ${modalId} forced open via modalManager`);
    return true;
};

    // Função para popular o modal de BORRA com máquinas e motivos do database.js
    function populateBorraModal() {
        // Popular máquinas no modal de BORRA
        const borraMachineSelect = document.getElementById('manual-borra-machine');
        if (borraMachineSelect) {
            borraMachineSelect.innerHTML = '<option value="">Selecione...</option>';
            machineDatabase.forEach(machine => {
                const option = document.createElement('option');
                const mid = normalizeMachineId(machine.id);
                option.value = mid;
                option.textContent = `${mid} - ${machine.model}`;
                borraMachineSelect.appendChild(option);
            });
            console.log('✅ Máquinas do modal de BORRA populadas');
        }

        // Popular motivos no modal de BORRA usando database.js
        const borraReasonSelect = document.getElementById('manual-borra-reason');
        if (borraReasonSelect) {
            borraReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            const groupedReasons = getGroupedLossReasons();
            Object.entries(groupedReasons).forEach(([groupName, reasons]) => {
                const group = document.createElement('optgroup');
                group.label = groupName;
                reasons.forEach(reason => {
                    const option = document.createElement('option');
                    option.value = reason;
                    option.textContent = reason;
                    group.appendChild(option);
                });
                borraReasonSelect.appendChild(group);
            });
            console.log('✅ Motivos do modal de BORRA populados via database.js');
        }
    }

    // ======================================
    // QUALIDADE: Carregamento e renderização hora-a-hora
    // ======================================

    function loadQualityHourlyRecords() {
        console.log(`📍 loadQualityHourlyRecords() chamada`);
        console.log(`  currentQualityContext:`, currentQualityContext);
        
        if (!currentQualityContext) {
            console.log(`  ❌ currentQualityContext está vazio!`);
            return;
        }

        const { plan, hourly_entries } = currentQualityContext;
        console.log(`  plan:`, plan);
        console.log(`  hourly_entries (${hourly_entries?.length || 0} items):`, hourly_entries);
        
        if (!plan || !hourly_entries || hourly_entries.length === 0) {
            console.log(`  ⚠️ Sem dados - renderizando mensagem vazia`);
            if (qualityHourlyContainer) {
                qualityHourlyContainer.innerHTML = '<div id="quality-hourly-empty" class="py-6 text-center text-sm text-gray-500">Nenhum apontamento de produção registrado para este plano e data.</div>';
            }
            return;
        }

        // Agrupar por hora e calcular sacos
        const hourlyGroups = {};
        hourly_entries.forEach(entry => {
            const hora = entry.hora || '00:00';
            if (!hourlyGroups[hora]) {
                hourlyGroups[hora] = [];
            }
            hourlyGroups[hora].push(entry);
        });

        console.log(`  ✅ Agrupado por hora:`, hourlyGroups);
        renderQualityHourlyTable(hourlyGroups, plan);
    }

    function renderQualityHourlyTable(hourlyGroups, plan) {
        if (!qualityHourlyContainer) return;

        const cavitiesStandard = Number(plan?.mold_cavities) || 1;
        const horas = Object.keys(hourlyGroups).sort();

        let html = '<div class="overflow-x-auto">';
        html += '<table class="min-w-full divide-y divide-gray-200 border rounded-lg">';
        html += '<thead class="bg-gray-50"><tr>';
        html += '<th class="px-4 py-2 text-left text-xs font-semibold uppercase tracking-wide text-gray-600">Hora</th>';
        html += '<th class="px-4 py-2 text-right text-xs font-semibold uppercase tracking-wide text-gray-600">Quantidade (pcs)</th>';
        html += '<th class="px-4 py-2 text-right text-xs font-semibold uppercase tracking-wide text-gray-600">Sacos</th>';
        html += '<th class="px-4 py-2 text-right text-xs font-semibold uppercase tracking-wide text-gray-600">Cavidades</th>';
        html += '<th class="px-4 py-2 text-center text-xs font-semibold uppercase tracking-wide text-gray-600">Inspeção</th>';
        html += '<th class="px-4 py-2 text-left text-xs font-semibold uppercase tracking-wide text-gray-600">Observações</th>';
        html += '<th class="px-4 py-2 text-center text-xs font-semibold uppercase tracking-wide text-gray-600">Ação</th>';
        html += '</tr></thead>';
        html += '<tbody class="divide-y divide-gray-200">';

        horas.forEach((hora, index) => {
            const entries = hourlyGroups[hora];
            const totalQty = entries.reduce((sum, e) => sum + (Number(e.quantidade) || 0), 0);
            const totalEmbalagens = entries.reduce((sum, e) => sum + (Number(e.embalagem_fechada) || 0), 0);
            const sacos = totalEmbalagens > 0 ? totalEmbalagens : Math.ceil(totalQty / cavitiesStandard);
            const formId = `quality-hourly-form-${index}`;

            html += `<tr class="hover:bg-emerald-50">`;
            html += `<td class="px-4 py-3 text-sm font-medium text-gray-800">${hora}</td>`;
            html += `<td class="px-4 py-3 text-right text-sm text-gray-600">${totalQty}</td>`;
            html += `<td class="px-4 py-3 text-right text-sm font-semibold text-emerald-700">${sacos}</td>`;
            html += `<td class="px-4 py-3 text-right text-sm text-gray-600">${cavitiesStandard}</td>`;
            
            // Coluna: OK / Não OK (radio buttons)
            html += `<td class="px-4 py-3 text-center">`;
            html += `<div class="flex items-center justify-center gap-3">`;
            html += `<label class="inline-flex items-center gap-1 text-xs text-green-600 cursor-pointer">`;
            html += `<input type="radio" name="quality-ok-${index}" value="ok" class="quality-inspection-radio" data-hora="${hora}" data-index="${index}">`;
            html += `OK`;
            html += `</label>`;
            html += `<label class="inline-flex items-center gap-1 text-xs text-red-600 cursor-pointer">`;
            html += `<input type="radio" name="quality-ok-${index}" value="nao-ok" class="quality-inspection-radio" data-hora="${hora}" data-index="${index}">`;
            html += `Não OK`;
            html += `</label>`;
            html += `</div>`;
            html += `</td>`;
            
            // Coluna: Observações
            html += `<td class="px-4 py-3">`;
            html += `<textarea id="quality-obs-${index}" class="quality-obs-textarea w-full px-2 py-1 text-xs rounded border border-gray-300 focus:border-emerald-500 focus:ring-emerald-500" placeholder="Observações..." rows="2"></textarea>`;
            html += `</td>`;
            
            // Coluna: Botão Salvar
            html += `<td class="px-4 py-3 text-center">`;
            html += `<button type="button" class="quality-save-hourly-btn inline-flex items-center justify-center gap-1 rounded-lg bg-emerald-600 px-3 py-1 text-xs font-semibold text-white shadow-sm transition hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-500" data-hora="${hora}" data-index="${index}" data-qty="${totalQty}" data-sacos="${sacos}" data-cavities="${cavitiesStandard}">`;
            html += `<i data-lucide="save" class="w-3 h-3"></i>`;
            html += `Salvar`;
            html += `</button>`;
            html += `</td>`;
            html += `</tr>`;
        });

        html += '</tbody></table></div>';
        qualityHourlyContainer.innerHTML = html;

        // Adicionar event listeners
        document.querySelectorAll('.quality-save-hourly-btn').forEach(btn => {
            btn.addEventListener('click', handleQualityHourlyRowSubmit);
        });

        lucide.createIcons();
    }

    function handleQualityHourlyRowSubmit(event) {
        event.preventDefault();
        const btn = event.currentTarget;
        const index = btn.getAttribute('data-index');
        const hora = btn.getAttribute('data-hora');
        const qty = Number(btn.getAttribute('data-qty')) || 0;
        const sacos = Number(btn.getAttribute('data-sacos')) || 0;
        const cavities = Number(btn.getAttribute('data-cavities')) || 1;

        // Capturar status de inspeção (OK / Não OK)
        const inspectionRadio = document.querySelector(`input[name="quality-ok-${index}"]:checked`);
        if (!inspectionRadio) {
            showNotification('Por favor, marque OK ou Não OK para esta hora', 'warning');
            return;
        }
        const inspectionStatus = inspectionRadio.value;

        // Capturar observações
        const obsTextarea = document.getElementById(`quality-obs-${index}`);
        const observations = obsTextarea ? obsTextarea.value.trim() : '';

        // Montar payload
        const payload = {
            planId: currentQualityContext.plan.id,
            date: currentQualityContext.plan.date,
            hora: hora,
            turno: currentQualityContext.plan.turno || '1',
            quantity: qty,
            bags: sacos,
            cavitiesStandard: cavities,
            inspectionStatus: inspectionStatus, // 'ok' ou 'nao-ok'
            observations: observations,
            registeredBy: getCurrentUserName(),
            createdAt: new Date().toISOString()
        };

        // Salvar no Firestore
        if (!db) {
            showNotification('Banco de dados não inicializado', 'error');
            return;
        }

        // Bloquear botão durante salvamento
        btn.disabled = true;
        btn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin mr-1"></i>Salvando...';

        db.collection('qualityHourly').add(payload).then(docRef => {
            console.log('Controle de qualidade salvo com sucesso:', docRef.id);
            showNotification('Controle de qualidade registrado com sucesso!', 'success');
            
            // Recarregar dados de qualidade
            loadQualityHourlyControls();
            
        }).catch(error => {
            console.error('Erro ao salvar controle de qualidade:', error);
            showNotification('Erro ao salvar controle de qualidade: ' + error.message, 'error');
        }).finally(() => {
            // Reativar botão
            btn.disabled = false;
            btn.innerHTML = '<i data-lucide="save" class="w-4 h-4 mr-1"></i>Salvar';
            lucide.createIcons();
        });
    }

    // ============================================================
    // EXPOR FUNÇÕES GLOBALMENTE para HTML onclick handlers
    // ============================================================
    // Essas funções estão definidas dentro do DOMContentLoaded, mas precisam
    // ser acessadas pelo HTML onclick. Exposição via window permite acesso global.
    window.finalizarParada = finalizarParada;
    window.getActiveUser = getActiveUser;
    window.showNotification = showNotification;
    window.getActiveMachineDowntime = getActiveMachineDowntime;
    window.getAllMachinesDowntimeStatus = getAllMachinesDowntimeStatus;
    window.normalizeMachineId = normalizeMachineId;
    window.renderMachineCards = renderMachineCards;
    window.loadExtendedDowntimeList = loadExtendedDowntimeList;
    window.populateMachineSelector = populateMachineSelector;
    
    // Expor variáveis de cache para acesso em finalizarParada
    window.downtimeStatusCache = downtimeStatusCache;
    window.downtimeTimers = downtimeTimers;
    
    // ============================================================
    // FUNÇÃO DE DEBUG/LIMPEZA DE PARADAS ÓRFÃS
    // ============================================================
    window.debugActiveDowntimes = async function() {
        console.log('🔍 [DEBUG] Verificando active_downtimes...');
        
        // Lista de máquinas válidas (26 máquinas)
        const validMachineIds = new Set(['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                                         'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                                         'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32']);
        
        const snapshot = await db.collection('active_downtimes').get();
        const orphans = [];
        const valid = [];
        
        console.log(`📊 Total de documentos em active_downtimes: ${snapshot.size}`);
        
        snapshot.forEach(doc => {
            const data = doc.data();
            const docId = doc.id;
            const normalizedId = normalizeMachineId(docId);
            
            console.log(`  - Doc ID: "${docId}" → Normalizado: "${normalizedId}" | isActive: ${data.isActive} | Machine: ${data.machine}`);
            
            if (!validMachineIds.has(normalizedId)) {
                orphans.push({ id: docId, data: data, reason: 'ID inválido' });
            } else if (docId !== normalizedId) {
                orphans.push({ id: docId, data: data, reason: `ID não normalizado (deveria ser ${normalizedId})` });
            } else {
                valid.push({ id: docId, data: data });
            }
        });
        
        console.log(`\n✅ Registros válidos: ${valid.length}`);
        console.log(`⚠️ Registros órfãos/problemáticos: ${orphans.length}`);
        
        if (orphans.length > 0) {
            console.log('\n🗑️ Registros órfãos encontrados:');
            orphans.forEach(o => console.log(`  - "${o.id}" (${o.reason}):`, o.data));
        }
        
        return { valid, orphans, total: snapshot.size };
    };
    
    window.cleanOrphanDowntimes = async function(dryRun = true) {
        const result = await window.debugActiveDowntimes();
        
        if (result.orphans.length === 0) {
            console.log('✨ Nenhum registro órfão para limpar!');
            return;
        }
        
        if (dryRun) {
            console.log(`\n⚠️ DRY RUN: ${result.orphans.length} registros seriam removidos.`);
            console.log('Para remover de verdade, execute: cleanOrphanDowntimes(false)');
            return;
        }
        
        console.log(`\n🗑️ Removendo ${result.orphans.length} registros órfãos...`);
        
        for (const orphan of result.orphans) {
            try {
                await db.collection('active_downtimes').doc(orphan.id).delete();
                console.log(`  ✅ Removido: "${orphan.id}"`);
            } catch (error) {
                console.error(`  ❌ Erro ao remover "${orphan.id}":`, error);
            }
        }
        
        console.log('🎉 Limpeza concluída! Recarregue a página para atualizar os dados.');
    };
    
    console.log('[GLOBAL-EXPOSURES] Funções de parada expostas no window global');
    console.log('[DEBUG] Use debugActiveDowntimes() no console para diagnosticar paradas órfãs');
    console.log('[DEBUG] Use cleanOrphanDowntimes(false) para remover paradas órfãs');
});

// Funções globais para navegação de subtabs Analytics IA
window.showPredictiveSubtab = function(subtabName) {
    // Esconder todas as subtabs
    const subtabs = document.querySelectorAll('.predictive-subtab-content');
    subtabs.forEach(tab => tab.classList.add('hidden'));
    
    // Remover classe ativa de todos os botões (novo estilo moderno)
    const buttons = document.querySelectorAll('.predictive-subtab-btn');
    buttons.forEach(btn => {
        btn.classList.remove('bg-gradient-to-r', 'from-purple-600', 'to-indigo-600', 'bg-purple-600', 'text-white', 'shadow-sm');
        btn.classList.add('bg-gray-50', 'text-gray-600');
    });
    
    // Mostrar subtab selecionada
    const targetTab = document.getElementById(`predictive-${subtabName}-content`);
    if (targetTab) {
        targetTab.classList.remove('hidden');
    }
    
    // Ativar botão clicado com novo estilo
    const clickedButton = event?.target?.closest('.predictive-subtab-btn');
    if (clickedButton) {
        clickedButton.classList.remove('bg-gray-50', 'text-gray-600', 'bg-gray-200', 'text-gray-700');
        clickedButton.classList.add('bg-purple-600', 'text-white', 'shadow-sm');
    }

    // Inicializar módulos específicos da subtab
    if (subtabName === 'dashboard' && window.analyticsIA) {
        console.log('[Analytics IA] Dashboard selecionado, inicializando...');
        setTimeout(async () => {
            try {
                if (!window.analyticsIA.isInitialized) {
                    await window.analyticsIA.initialize();
                } else {
                    window.analyticsIA.updateDashboard();
                }
            } catch (err) {
                console.error('[Analytics IA] Erro ao inicializar dashboard:', err);
            }
        }, 150);
    }

    if (subtabName === 'ranking' && window.analyticsIA) {
        console.log('[Analytics IA] Ranking selecionado, atualizando...');
        setTimeout(async () => {
            try {
                await window.analyticsIA.updateRanking();
            } catch (err) {
                console.error('[Analytics IA] Erro ao atualizar ranking:', err);
            }
        }, 150);
    }

    if (subtabName === 'spc' && window.spcController) {
        console.log('[SPC] Subtab SPC selecionada, inicializando...');
        // Pequeno delay para garantir que o container está visível
        setTimeout(async () => {
            try {
                if (!window.spcController.spcData.lastUpdate) {
                    console.log('[SPC] Primeira inicialização do SPC...');
                    await window.spcController.initialize();
                } else {
                    console.log('[SPC] SPC já inicializado, atualizando interface...');
                    window.spcController.updateSPCInterface();
                }
            } catch (err) {
                console.error('[SPC] Erro ao inicializar:', err);
            }
        }, 150);
    }

    const refreshBtn = document.getElementById('traceability-refresh-btn');
    if (refreshBtn) {
        if (subtabName === 'traceability') {
            refreshBtn.classList.remove('hidden');
        } else {
            refreshBtn.classList.add('hidden');
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = refreshBtn.dataset.defaultLabel || refreshBtn.innerHTML;
            refreshBtn.classList.remove('opacity-60', 'cursor-not-allowed');
        }
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
    
    console.log(`[PREDICTIVE-NAV] Navegando para subtab: ${subtabName}`);
};

// ===== NOVO: Importador de Ordens do ERP Sankhya =====

// Estado global do importador
window.importOrdersState = {
    file: null,
    parsedOrders: [],
    selectedRows: new Set()
};

// Abrir modal de importação
function openImportOrdersModal() {
    const modal = document.getElementById('import-orders-modal');
    if (modal) {
        modal.classList.remove('hidden');
        resetImportModal();
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Fechar modal de importação
function closeImportOrdersModal() {
    const modal = document.getElementById('import-orders-modal');
    if (modal) {
        modal.classList.add('hidden');
        resetImportModal();
    }
}

// Resetar estado do modal
function resetImportModal() {
    window.importOrdersState = { file: null, parsedOrders: [], selectedRows: new Set() };
    
    document.getElementById('import-file-input').value = '';
    document.getElementById('import-upload-area').classList.remove('hidden');
    document.getElementById('import-file-info').classList.add('hidden');
    document.getElementById('import-config').classList.add('hidden');
    document.getElementById('import-preview').classList.add('hidden');
    document.getElementById('import-status').classList.add('hidden');
    document.getElementById('import-execute-btn').disabled = true;
}

// Limpar arquivo selecionado
function clearImportFile() {
    resetImportModal();
}

// Handler para seleção de arquivo
function handleImportFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    window.importOrdersState.file = file;
    
    // Mostrar info do arquivo
    document.getElementById('import-upload-area').classList.add('hidden');
    document.getElementById('import-file-info').classList.remove('hidden');
    document.getElementById('import-file-name').textContent = file.name;
    document.getElementById('import-file-size').textContent = formatFileSize(file.size);
    
    // Processar arquivo
    parseImportExcel(file);
}

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' bytes';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// Parsear arquivo Excel do ERP Sankhya
async function parseImportExcel(file) {
    try {
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        
        // Converter para array de arrays para ter acesso às linhas brutas
        const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        
        console.log('[Import] Dados brutos:', rawData.slice(0, 5));
        
        // Encontrar a linha de cabeçalho (contém "Nro. OP", "Centro de Trabalho", etc)
        let headerRowIndex = -1;
        let headers = [];
        
        for (let i = 0; i < Math.min(10, rawData.length); i++) {
            const row = rawData[i];
            if (row && row.some(cell => String(cell).includes('Nro. OP') || String(cell).includes('Centro de Trabalho'))) {
                headerRowIndex = i;
                headers = row.map(h => String(h || '').trim());
                break;
            }
        }
        
        if (headerRowIndex === -1) {
            alert('Formato de arquivo não reconhecido. Certifique-se de que é um relatório de Ordens de Produção do ERP.');
            resetImportModal();
            return;
        }
        
        console.log('[Import] Cabeçalhos encontrados na linha', headerRowIndex + 1, ':', headers);
        
        // Mapear índices das colunas
        const colIndex = {
            centroTrabalho: headers.findIndex(h => h.includes('Centro de Trabalho')),
            nroOP: headers.findIndex(h => h === 'Nro. OP' || h.includes('Nro. OP')),
            tamLote: headers.findIndex(h => h.includes('Tam. Lote')),
            saldoProduzir: headers.findIndex(h => h.includes('Saldo a Produzir')),
            produtoAcabado: headers.findIndex(h => h.includes('Produto Acabado')),
            status: headers.findIndex(h => h === 'Status'),
            descrProduto: headers.findIndex(h => h.includes('Descr. Produto')),
            nroLote: headers.findIndex(h => h === 'Nro. Lote' || h.includes('Nro. Lote')),
            cliente: headers.findIndex(h => h.includes('Nome Parceiro')),
            observacoes: headers.findIndex(h => h.includes('Observações'))
        };
        
        console.log('[Import] Índices de colunas:', colIndex);
        
        // Extrair dados das linhas após o cabeçalho
        const orders = [];
        for (let i = headerRowIndex + 1; i < rawData.length; i++) {
            const row = rawData[i];
            if (!row || row.length === 0) continue;
            
            // Pegar valores das colunas
            const centroTrabalho = colIndex.centroTrabalho >= 0 ? String(row[colIndex.centroTrabalho] || '') : '';
            const nroOP = colIndex.nroOP >= 0 ? String(row[colIndex.nroOP] || '') : '';
            const tamLote = colIndex.tamLote >= 0 ? row[colIndex.tamLote] : '';
            const saldoProduzir = colIndex.saldoProduzir >= 0 ? row[colIndex.saldoProduzir] : '';
            const produtoAcabado = colIndex.produtoAcabado >= 0 ? String(row[colIndex.produtoAcabado] || '') : '';
            const status = colIndex.status >= 0 ? String(row[colIndex.status] || '') : '';
            const descrProduto = colIndex.descrProduto >= 0 ? String(row[colIndex.descrProduto] || '') : '';
            const nroLote = colIndex.nroLote >= 0 ? String(row[colIndex.nroLote] || '') : '';
            const cliente = colIndex.cliente >= 0 ? String(row[colIndex.cliente] || '') : '';
            
            // Validar se é uma linha de dados (tem número de OP válido)
            if (!nroOP || nroOP === '' || isNaN(Number(nroOP))) continue;
            
            // Extrair código da máquina do Centro de Trabalho (ex: "3 - H02 - SANDRETTO" -> "H02")
            let machineId = '';
            if (centroTrabalho) {
                const match = centroTrabalho.match(/\d+\s*-\s*([A-Z0-9]+)/i);
                if (match) {
                    machineId = match[1].toUpperCase();
                } else {
                    machineId = centroTrabalho.split('-')[0]?.trim() || centroTrabalho;
                }
            }
            
            // Converter status do ERP para status do sistema
            let systemStatus = 'planejada';
            const statusLower = status.toLowerCase();
            if (statusLower.includes('andamento')) systemStatus = 'em_andamento';
            else if (statusLower.includes('criado')) systemStatus = 'planejada';
            else if (statusLower.includes('conclu') || statusLower.includes('finaliz')) systemStatus = 'concluida';
            else if (statusLower.includes('cancel')) systemStatus = 'cancelada';
            
            orders.push({
                index: orders.length,
                order_number: nroOP.trim(),
                part_code: produtoAcabado.trim(),
                part_name: descrProduto.trim(),
                machine_id: machineId,
                machine_full: centroTrabalho,
                customer: cliente.trim(),
                lot_size: parseImportNumber(tamLote) || 0,
                remaining: parseImportNumber(saldoProduzir) || 0,
                batch_number: nroLote.trim(),
                status_erp: status,
                status: systemStatus,
                selected: true
            });
        }
        
        console.log('[Import] Ordens extraídas:', orders.length, orders);
        
        if (orders.length === 0) {
            alert('Nenhuma ordem de produção válida encontrada no arquivo.');
            resetImportModal();
            return;
        }
        
        // Atualizar estado
        window.importOrdersState.parsedOrders = orders;
        window.importOrdersState.selectedRows = new Set(orders.map((_, i) => i));
        
        // Mostrar configurações e preview
        document.getElementById('import-config').classList.remove('hidden');
        document.getElementById('import-preview').classList.remove('hidden');
        document.getElementById('import-records-count').textContent = `${orders.length} registros encontrados`;
        document.getElementById('import-execute-btn').disabled = false;
        
        // Popular select de máquinas
        populateImportMachineSelect(orders);
        
        // Renderizar preview
        renderImportPreview(orders);
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
    } catch (error) {
        console.error('[Import] Erro ao processar arquivo:', error);
        alert('Erro ao processar arquivo Excel: ' + error.message);
        resetImportModal();
    }
}

// Popular select de máquinas
function populateImportMachineSelect(orders) {
    const select = document.getElementById('import-default-machine');
    if (!select) return;
    
    const machines = [...new Set(orders.map(o => o.machine_id).filter(m => m))];
    select.innerHTML = '<option value="">Usar do arquivo</option>';
    machines.forEach(m => {
        select.innerHTML += `<option value="${m}">${m}</option>`;
    });
}

// Renderizar preview da tabela
function renderImportPreview(orders) {
    const tbody = document.getElementById('import-preview-body');
    if (!tbody) return;
    
    tbody.innerHTML = orders.map((order, idx) => `
        <tr class="hover:bg-gray-50 ${order.selected ? '' : 'opacity-50'}">
            <td class="px-3 py-2">
                <input type="checkbox" 
                       class="import-row-checkbox w-4 h-4 text-indigo-600 rounded" 
                       data-index="${idx}" 
                       ${order.selected ? 'checked' : ''}
                       onchange="toggleImportRow(${idx}, this.checked)">
            </td>
            <td class="px-3 py-2 font-medium text-gray-800">${order.order_number}</td>
            <td class="px-3 py-2">${order.part_code}</td>
            <td class="px-3 py-2 text-gray-600 text-xs max-w-xs truncate" title="${order.part_name}">${order.part_name || '-'}</td>
            <td class="px-3 py-2">
                <span class="px-2 py-0.5 bg-blue-100 text-blue-700 rounded text-xs font-medium">${order.machine_id || '-'}</span>
            </td>
            <td class="px-3 py-2 text-center font-medium">${order.lot_size.toLocaleString('pt-BR')}</td>
            <td class="px-3 py-2">
                <span class="px-2 py-0.5 rounded text-xs font-medium ${getStatusBadgeClass(order.status)}">${order.status_erp || order.status}</span>
            </td>
            <td class="px-3 py-2 text-gray-600 text-xs max-w-xs truncate" title="${order.customer}">${order.customer || '-'}</td>
        </tr>
    `).join('');
}

function getStatusBadgeClass(status) {
    switch(status) {
        case 'em_andamento': return 'bg-amber-100 text-amber-700';
        case 'concluida': return 'bg-green-100 text-green-700';
        case 'cancelada': return 'bg-red-100 text-red-700';
        default: return 'bg-gray-100 text-gray-700';
    }
}

// Toggle seleção de linha
function toggleImportRow(index, checked) {
    const orders = window.importOrdersState.parsedOrders;
    if (orders[index]) {
        orders[index].selected = checked;
        if (checked) {
            window.importOrdersState.selectedRows.add(index);
        } else {
            window.importOrdersState.selectedRows.delete(index);
        }
    }
    updateImportSelectAll();
}

// Toggle todas as linhas
function toggleAllImportRows(checked) {
    const orders = window.importOrdersState.parsedOrders;
    orders.forEach((order, idx) => {
        order.selected = checked;
        if (checked) {
            window.importOrdersState.selectedRows.add(idx);
        } else {
            window.importOrdersState.selectedRows.delete(idx);
        }
    });
    renderImportPreview(orders);
}

function updateImportSelectAll() {
    const checkbox = document.getElementById('import-select-all');
    const orders = window.importOrdersState.parsedOrders;
    const allSelected = orders.every(o => o.selected);
    const someSelected = orders.some(o => o.selected);
    
    if (checkbox) {
        checkbox.checked = allSelected;
        checkbox.indeterminate = someSelected && !allSelected;
    }
}

// Executar importação
async function executeImportOrders() {
    const orders = window.importOrdersState.parsedOrders.filter(o => o.selected);
    
    if (orders.length === 0) {
        alert('Selecione pelo menos uma ordem para importar.');
        return;
    }
    
    const skipExisting = document.getElementById('import-skip-existing')?.checked ?? true;
    const defaultStatus = document.getElementById('import-default-status')?.value || 'from_file';
    const defaultMachine = document.getElementById('import-default-machine')?.value || '';
    
    // Mostrar status
    document.getElementById('import-config').classList.add('hidden');
    document.getElementById('import-preview').classList.add('hidden');
    document.getElementById('import-status').classList.remove('hidden');
    document.getElementById('import-result').classList.add('hidden');
    document.getElementById('import-progress-container').classList.remove('hidden');
    document.getElementById('import-execute-btn').disabled = true;
    
    let imported = 0;
    let skipped = 0;
    let errors = 0;
    
    try {
        // Verificar ordens existentes usando cache para economizar leituras
        const existingOrders = new Set();
        if (skipExisting) {
            const cachedOrders = await getProductionOrdersCached();
            cachedOrders.forEach(order => {
                if (order.order_number) {
                    existingOrders.add(String(order.order_number));
                }
            });
        }
        
        const batch = db.batch();
        const ordersToImport = [];
        
        for (const order of orders) {
            // Verificar se já existe
            if (skipExisting && existingOrders.has(order.order_number)) {
                skipped++;
                continue;
            }
            
            // Preparar dados da ordem
            const orderData = {
                order_number: order.order_number,
                part_code: order.part_code,
                product: order.part_name || order.part_code || '',
                product_cod: order.part_code,
                machine_id: defaultMachine || order.machine_id || '',
                machine_name: order.machine_full || '',
                customer: order.customer || '',
                lot_size: order.lot_size,
                total_produced: 0,
                remaining: order.remaining || order.lot_size,
                batch_number: order.batch_number || '',
                status: defaultStatus === 'from_file' ? (order.status || 'planejada') : defaultStatus,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                imported_at: firebase.firestore.FieldValue.serverTimestamp(),
                import_source: 'excel_erp'
            };
            
            console.log('[Import] Ordem preparada:', orderData);
            ordersToImport.push(orderData);
        }
        
        // Importar em lotes de 500 (limite do Firestore batch)
        const batchSize = 450;
        for (let i = 0; i < ordersToImport.length; i += batchSize) {
            const batchOrders = ordersToImport.slice(i, i + batchSize);
            const currentBatch = db.batch();
            
            for (const orderData of batchOrders) {
                const docRef = db.collection('production_orders').doc();
                currentBatch.set(docRef, orderData);
            }
            
            await currentBatch.commit();
            imported += batchOrders.length;
            
            // Atualizar progresso
            const progress = Math.round(((i + batchOrders.length) / ordersToImport.length) * 100);
            document.getElementById('import-progress-bar').style.width = `${progress}%`;
            document.getElementById('import-progress-text').textContent = `Importando... ${imported} de ${ordersToImport.length}`;
        }
        
        // Mostrar resultado
        document.getElementById('import-progress-container').classList.add('hidden');
        document.getElementById('import-result').classList.remove('hidden');
        
        if (imported > 0) {
            document.getElementById('import-result-icon').innerHTML = '<div class="p-4 bg-green-100 rounded-full inline-block"><i data-lucide="check-circle" class="w-12 h-12 text-green-600"></i></div>';
            document.getElementById('import-result-text').className = 'text-lg font-semibold text-green-700';
            document.getElementById('import-result-text').textContent = `${imported} ordem(s) importada(s) com sucesso!`;
        } else {
            document.getElementById('import-result-icon').innerHTML = '<div class="p-4 bg-amber-100 rounded-full inline-block"><i data-lucide="alert-circle" class="w-12 h-12 text-amber-600"></i></div>';
            document.getElementById('import-result-text').className = 'text-lg font-semibold text-amber-700';
            document.getElementById('import-result-text').textContent = 'Nenhuma ordem foi importada.';
        }
        
        let details = [];
        if (skipped > 0) details.push(`${skipped} ignorada(s) (já existem)`);
        if (errors > 0) details.push(`${errors} erro(s)`);
        document.getElementById('import-result-details').textContent = details.length > 0 ? details.join(' – ') : '';
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
        // Invalidar cache e atualizar lista de ordens
        productionOrdersCache = null;
        
        // Atualizar lista de ordens após 1.5 segundos
        setTimeout(async () => {
            if (typeof loadOrdersAnalysis === 'function') {
                await loadOrdersAnalysis();
                showNotification('Lista de ordens atualizada!', 'info');
            }
        }, 1500);
        
    } catch (error) {
        console.error('[Import] Erro durante importação:', error);
        
        document.getElementById('import-progress-container').classList.add('hidden');
        document.getElementById('import-result').classList.remove('hidden');
        document.getElementById('import-result-icon').innerHTML = '<div class="p-4 bg-red-100 rounded-full inline-block"><i data-lucide="x-circle" class="w-12 h-12 text-red-600"></i></div>';
        document.getElementById('import-result-text').className = 'text-lg font-semibold text-red-700';
        document.getElementById('import-result-text').textContent = 'Erro durante a importação';
        document.getElementById('import-result-details').textContent = error.message;
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Expor funções globalmente
window.openImportOrdersModal = openImportOrdersModal;
window.closeImportOrdersModal = closeImportOrdersModal;
window.handleImportFileSelect = handleImportFileSelect;
window.clearImportFile = clearImportFile;
window.toggleImportRow = toggleImportRow;
window.toggleAllImportRows = toggleAllImportRows;
window.executeImportOrders = executeImportOrders;

// ====== CADASTRO DE NOVOS PRODUTOS ======

// Abrir modal de novo produto
function openNewProductModal() {
    const modal = document.getElementById('new-product-modal');
    if (modal) {
        modal.classList.remove('hidden');
        resetNewProductModal();
        populateNewProductMPSelect();
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Fechar modal de novo produto
function closeNewProductModal() {
    const modal = document.getElementById('new-product-modal');
    if (modal) {
        modal.classList.add('hidden');
        resetNewProductModal();
    }
}

// Resetar modal de novo produto
function resetNewProductModal() {
    const form = document.getElementById('new-product-form');
    if (form) form.reset();
    
    const feedback = document.getElementById('new-product-feedback');
    if (feedback) {
        feedback.classList.add('hidden');
        feedback.textContent = '';
    }
    
    const calcResult = document.getElementById('new-product-calc-result');
    if (calcResult) calcResult.textContent = '';
}

// Popular select de matéria-prima
function populateNewProductMPSelect() {
    const select = document.getElementById('new-product-mp');
    if (!select) return;
    
    select.innerHTML = '<option value="">Selecione (opcional)...</option>';
    
    // Usar o banco de matérias-primas se disponível
    if (typeof materiaPrimaDatabase !== 'undefined' && Array.isArray(materiaPrimaDatabase)) {
        materiaPrimaDatabase.forEach(mp => {
            const opt = document.createElement('option');
            opt.value = mp.codigo;
            opt.textContent = `${mp.codigo} - ${mp.descricao}`;
            select.appendChild(opt);
        });
    }
}

// Calcular meta de peças por hora
function calcularMetaPPH() {
    const cavities = parseFloat(document.getElementById('new-product-cavities')?.value) || 0;
    const cycle = parseFloat(document.getElementById('new-product-cycle')?.value) || 0;
    
    if (cavities <= 0 || cycle <= 0) {
        document.getElementById('new-product-calc-result').textContent = '⚠️ Preencha cavidades e ciclo';
        return;
    }
    
    const pph = Math.round((3600 / cycle) * cavities);
    document.getElementById('new-product-calc-result').textContent = `= ${pph.toLocaleString('pt-BR')} peças/hora`;
    document.getElementById('new-product-pph').value = pph;
}

// Mostrar feedback no modal
function showNewProductFeedback(message, type = 'info') {
    const feedback = document.getElementById('new-product-feedback');
    if (!feedback) return;
    
    feedback.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-amber-100', 'text-amber-800');
    
    if (type === 'success') {
        feedback.classList.add('bg-green-100', 'text-green-800');
    } else if (type === 'error') {
        feedback.classList.add('bg-red-100', 'text-red-800');
    } else {
        feedback.classList.add('bg-amber-100', 'text-amber-800');
    }
    
    feedback.textContent = message;
}

// Salvar novo produto
async function saveNewProduct() {
    const cod = parseInt(document.getElementById('new-product-cod')?.value, 10);
    const client = document.getElementById('new-product-client')?.value?.trim();
    const name = document.getElementById('new-product-name')?.value?.trim();
    const cavities = parseInt(document.getElementById('new-product-cavities')?.value, 10);
    const cycle = parseFloat(document.getElementById('new-product-cycle')?.value);
    const weight = parseFloat(document.getElementById('new-product-weight')?.value);
    const pph = parseInt(document.getElementById('new-product-pph')?.value, 10);
    const mp = document.getElementById('new-product-mp')?.value || '';
    
    // Validações
    if (!cod || cod <= 0) {
        showNewProductFeedback('⚠️ Informe um código válido para o produto.', 'error');
        document.getElementById('new-product-cod')?.focus();
        return;
    }
    
    if (!client) {
        showNewProductFeedback('⚠️ Selecione o cliente.', 'error');
        document.getElementById('new-product-client')?.focus();
        return;
    }
    
    if (!name) {
        showNewProductFeedback('⚠️ Informe o nome do produto.', 'error');
        document.getElementById('new-product-name')?.focus();
        return;
    }
    
    if (!cavities || cavities <= 0) {
        showNewProductFeedback('⚠️ Informe um número válido de cavidades.', 'error');
        document.getElementById('new-product-cavities')?.focus();
        return;
    }
    
    if (!cycle || cycle <= 0) {
        showNewProductFeedback('⚠️ Informe um tempo de ciclo válido.', 'error');
        document.getElementById('new-product-cycle')?.focus();
        return;
    }
    
    if (!weight || weight <= 0) {
        showNewProductFeedback('⚠️ Informe um peso válido.', 'error');
        document.getElementById('new-product-weight')?.focus();
        return;
    }
    
    if (!pph || pph <= 0) {
        showNewProductFeedback('⚠️ Informe a meta de peças/hora. Use o botão Calcular.', 'error');
        document.getElementById('new-product-pph')?.focus();
        return;
    }
    
    try {
        showNewProductFeedback('ó Verificando código do produto...', 'info');
        
        // Verificar se o código já existe no Firestore
        const existingSnapshot = await db.collection('products')
            .where('cod', '==', cod)
            .get();
        
        if (!existingSnapshot.empty) {
            showNewProductFeedback(`❌ Já existe um produto com o código ${cod}.`, 'error');
            return;
        }
        
        showNewProductFeedback('ó Salvando produto...', 'info');
        
        // Criar objeto do produto
        const newProduct = {
            cod: cod,
            client: client,
            name: name,
            cavities: cavities,
            cycle: cycle,
            weight: weight,
            pieces_per_hour_goal: pph,
            mp: mp,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            createdBy: window.authSystem?.getCurrentUser?.()?.name || 'Sistema',
            source: 'manual_cadastro'
        };
        
        // Salvar no Firestore
        const docRef = await db.collection('products').add(newProduct);
        
        console.log('[PRODUTO] Novo produto cadastrado:', { id: docRef.id, ...newProduct });
        
        // Também adicionar ao productDatabase local se existir
        if (typeof productDatabase !== 'undefined' && Array.isArray(productDatabase)) {
            productDatabase.push({
                cod: cod,
                client: client,
                name: name,
                cavities: cavities,
                cycle: cycle,
                weight: weight,
                pieces_per_hour_goal: pph,
                mp: mp
            });
        }
        
        showNewProductFeedback(`✅ Produto ${cod} - ${name} cadastrado com sucesso!`, 'success');
        
        // Notificação de sucesso
        if (typeof showNotification === 'function') {
            showNotification(`Produto ${cod} cadastrado com sucesso!`, 'success');
        }
        
        // Fechar modal após 2 segundos
        setTimeout(() => {
            closeNewProductModal();
        }, 2000);
        
    } catch (error) {
        console.error('[PRODUTO] Erro ao salvar:', error);
        showNewProductFeedback(`❌ Erro ao salvar: ${error.message}`, 'error');
    }
}

// Expor funções globalmente
window.openNewProductModal = openNewProductModal;
window.closeNewProductModal = closeNewProductModal;
window.calcularMetaPPH = calcularMetaPPH;
window.saveNewProduct = saveNewProduct;

// ====== FUNÇÕES DE DIAGNÓSTICO E CORREÇÃO ======

// Listar TODAS as ordens no Firebase (para diagnóstico)
window.listarTodasOrdens = async function() {
    console.log('📍 Buscando TODAS as ordens no Firebase...');
    try {
        const snapshot = await db.collection('production_orders').get();
        console.log(`📋 Total de ordens no banco: ${snapshot.size}`);
        
        const orders = [];
        snapshot.forEach(doc => {
            const data = doc.data();
            orders.push({
                id: doc.id,
                order_number: data.order_number,
                product: data.product || data.part_name || data.part_code,
                machine_id: data.machine_id,
                status: data.status,
                lot_size: data.lot_size,
                import_source: data.import_source || 'manual',
                createdAt: data.createdAt
            });
        });
        
        console.table(orders);
        return orders;
    } catch (error) {
        console.error('❌ Erro ao buscar ordens:', error);
        return [];
    }
};

// Excluir ordens importadas (para limpar e reimportar)
window.excluirOrdensImportadas = async function() {
    if (!confirm('Deseja excluir TODAS as ordens importadas do Excel? Esta ação não pode ser desfeita!')) {
        return;
    }
    
    console.log('🗑️ Excluindo ordens importadas...');
    try {
        const snapshot = await db.collection('production_orders')
            .where('import_source', '==', 'excel_erp')
            .get();
        
        if (snapshot.empty) {
            console.log('ℹ️ Nenhuma ordem importada encontrada.');
            alert('Nenhuma ordem importada encontrada.');
            return;
        }
        
        console.log(`🗑️ Encontradas ${snapshot.size} ordens importadas para excluir...`);
        
        const batch = db.batch();
        snapshot.forEach(doc => {
            batch.delete(doc.ref);
        });
        
        await batch.commit();
        console.log(`✅ ${snapshot.size} ordens importadas excluídas com sucesso!`);
        alert(`${snapshot.size} ordens importadas foram excluídas. Atualize a página e importe novamente.`);
        
        // Limpar cache
        productionOrdersCache = null;
        
    } catch (error) {
        console.error('❌ Erro ao excluir ordens:', error);
        alert('Erro ao excluir ordens: ' + error.message);
    }
};

// Forçar atualização das ordens
window.forcarAtualizacaoOrdens = async function() {
    console.log('🔄 Forçando atualização da lista de ordens...');
    productionOrdersCache = null;
    
    if (typeof loadOrdersAnalysis === 'function') {
        await loadOrdersAnalysis();
        console.log('✅ Lista de ordens atualizada!');
    } else {
        console.error('❌ Função loadOrdersAnalysis não encontrada');
    }
};

// Excluir ordens específicas por índices da lista
window.excluirOrdensPorIndices = async function(indices) {
    if (!indices || !Array.isArray(indices) || indices.length === 0) {
        console.error('❌ Forneça um array de índices. Ex: excluirOrdensPorIndices([4, 26, 39, 50])');
        return;
    }
    
    console.log(`📍 Buscando ordens nos índices: ${indices.join(', ')}...`);
    
    try {
        const snapshot = await db.collection('production_orders').get();
        const allOrders = [];
        snapshot.forEach(doc => {
            allOrders.push({ id: doc.id, ref: doc.ref, data: doc.data() });
        });
        
        const ordersToDelete = indices.map(idx => allOrders[idx]).filter(o => o);
        
        if (ordersToDelete.length === 0) {
            console.error('❌ Nenhuma ordem encontrada nos índices especificados.');
            return;
        }
        
        console.log('📋 Ordens que serão excluídas:');
        ordersToDelete.forEach((o, i) => {
            console.log(`  ${indices[i]}: OP ${o.data.order_number} - ${o.data.product || o.data.part_code} (${o.data.machine_id})`);
        });
        
        if (!confirm(`Deseja excluir estas ${ordersToDelete.length} ordens? Esta ação não pode ser desfeita!`)) {
            console.log('❌ Operação cancelada pelo usuário.');
            return;
        }
        
        const batch = db.batch();
        ordersToDelete.forEach(o => batch.delete(o.ref));
        
        await batch.commit();
        console.log(`✅ ${ordersToDelete.length} ordens excluídas com sucesso!`);
        alert(`${ordersToDelete.length} ordens excluídas com sucesso! Agora você pode reimportar.`);
        
        // Limpar cache
        productionOrdersCache = null;
        
    } catch (error) {
        console.error('❌ Erro ao excluir ordens:', error);
        alert('Erro ao excluir ordens: ' + error.message);
    }
};

// Configurar drag and drop para o modal de importação
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const uploadArea = document.getElementById('import-upload-area');
        if (uploadArea) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.add('border-indigo-500', 'bg-indigo-50');
                }, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.remove('border-indigo-500', 'bg-indigo-50');
                }, false);
            });
            
            uploadArea.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.match(/\.(xlsx|xls)$/i)) {
                        document.getElementById('import-file-input').files = files;
                        handleImportFileSelect({ target: { files: [file] } });
                    } else {
                        alert('Por favor, selecione um arquivo Excel (.xlsx ou .xls)');
                    }
                }
            }, false);
        }
    }, 1000);
});

// ===== Importador de Ordens em Lote (Excel) =====

function parseImportNumber(value) {
    if (value === null || value === undefined || value === '') return null;

    if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
    }

    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return null;

        const normalized = trimmed
            .replace(/\s+/g, '')
            .replace(/\./g, '')
            .replace(',', '.');

        const parsed = Number(normalized);
        return Number.isFinite(parsed) ? parsed : null;
    }

    const fallback = Number(value);
    return Number.isFinite(fallback) ? fallback : null;
}

// Converter data do Excel para formato ISO
function excelDateToISO(excelDate) {
    if (!excelDate) return new Date().toISOString().split('T')[0];
    
    // Se for número (data do Excel)
    if (typeof excelDate === 'number') {
        const date = new Date((excelDate - 25569) * 86400 * 1000);
        return date.toISOString().split('T')[0];
    }
    
    // Se for string
    if (typeof excelDate === 'string') {
        const parsed = new Date(excelDate);
        if (!isNaN(parsed)) {
            return parsed.toISOString().split('T')[0];
        }
    }
    
    return new Date().toISOString().split('T')[0];
}

// Mapear nomes de colunas flexíveis
function mapColumnValue(row, possibleNames) {
    for (const name of possibleNames) {
        if (row[name] !== undefined && row[name] !== null && row[name] !== '') {
            return String(row[name]).trim();
        }
    }
    return '';
}

async function handleProductionOrdersImport(file) {
    if (!file) {
        alert('Selecione um arquivo.');
        return;
    }

    const statusElement = document.getElementById('import-orders-status');
    if (statusElement) {
        statusElement.textContent = 'Lendo arquivo Excel...';
        statusElement.className = 'text-sm font-semibold text-blue-600';
    }

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            
            // Pegar primeira planilha
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            // Converter para JSON
            const jsonData = XLSX.utils.sheet_to_json(worksheet);
            
            if (jsonData.length === 0) {
                alert('Arquivo vazio ou sem dados.');
                if (statusElement) statusElement.textContent = '';
                return;
            }

            // Processar linhas de dados
            const orders = [];
            for (let i = 0; i < jsonData.length; i++) {
                const row = jsonData[i];
                
                // Mapeamento flexível de colunas (aceita diferentes nomes)
                const numeroOP = mapColumnValue(row, ['numero_op', 'Numero_OP', 'Número OP', 'OP', 'op', 'ordem', 'Ordem', 'numero', 'Numero']);
                const codProduto = mapColumnValue(row, ['cod_produto', 'Cod_Produto', 'Código Produto', 'codigo_produto', 'produto', 'Produto', 'cod', 'Cod']);
                const codMP = mapColumnValue(row, ['cod_mp', 'Cod_MP', 'MP', 'mp', 'materia_prima', 'Matéria Prima', 'Materia Prima']);
                const maquina = mapColumnValue(row, ['maquina', 'Maquina', 'Máquina', 'machine', 'Machine']);
                const cliente = mapColumnValue(row, ['cliente', 'Cliente', 'customer', 'Customer']);
                const tamLote = mapColumnValue(row, ['tam_lote', 'Tam_Lote', 'Lote', 'lote', 'quantidade', 'Quantidade', 'qtd', 'Qtd', 'lot_size']);
                const numeroLote = mapColumnValue(row, ['numero_lote', 'Numero_Lote', 'batch', 'Batch', 'lote_numero']);
                const dataOrdem = row['data'] || row['Data'] || row['date'] || row['Date'] || '';
                
                // Validar campos obrigatórios
                if (!numeroOP || !codProduto || !maquina || !tamLote) {
                    console.warn(`Linha ${i + 2} incompleta (faltam campos obrigatórios), pulando...`);
                    continue;
                }

                orders.push({
                    order_number: numeroOP.toUpperCase().trim(),
                    part_code: codProduto.trim(),
                    raw_material: codMP.trim(),
                    machine_id: maquina.trim(),
                    customer: cliente.trim(),
                    lot_size: parseImportNumber(tamLote),
                    batch_number: numeroLote.trim(),
                    date: excelDateToISO(dataOrdem),
                    status: 'planejada'
                });
            }

            if (orders.length === 0) {
                alert('Nenhuma ordem válida encontrada no arquivo. Verifique se as colunas estão corretas.');
                if (statusElement) statusElement.textContent = '';
                return;
            }

            if (statusElement) {
                statusElement.textContent = `${orders.length} ordem(s) encontrada(s). Verificando...`;
            }

            // Mostrar prévia em modal
            showImportPreview(orders);
        } catch (error) {
            console.error('Erro ao processar arquivo Excel:', error);
            alert('Erro ao processar arquivo. Verifique se é um arquivo Excel válido (.xlsx)');
            if (statusElement) statusElement.textContent = '';
        }
    };
    reader.readAsArrayBuffer(file);
}

function showImportPreview(orders) {
    const previewContent = `
        <div class="space-y-4">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                <p class="text-sm text-blue-700"><strong>Total de ordens:</strong> ${orders.length}</p>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 border border-gray-300 text-xs">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="px-3 py-2 text-left font-semibold">OP Nú</th>
                            <th class="px-3 py-2 text-left font-semibold">Produto</th>
                            <th class="px-3 py-2 text-left font-semibold">MP</th>
                            <th class="px-3 py-2 text-left font-semibold">Máquina</th>
                            <th class="px-3 py-2 text-left font-semibold">Cliente</th>
                            <th class="px-3 py-2 text-right font-semibold">Lote</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${orders.slice(0, 10).map(o => `
                            <tr class="border-t hover:bg-gray-50">
                                <td class="px-3 py-2">${o.order_number}</td>
                                <td class="px-3 py-2">${o.part_code}</td>
                                <td class="px-3 py-2">${o.raw_material}</td>
                                <td class="px-3 py-2">${o.machine_id}</td>
                                <td class="px-3 py-2">${o.customer}</td>
                                <td class="px-3 py-2 text-right">${o.lot_size}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                ${orders.length > 10 ? `<p class="text-xs text-gray-500 mt-2">... e mais ${orders.length - 10} ordens</p>` : ''}
            </div>
        </div>
    `;

    // Criar modal simples
    const modal = document.createElement('div');
    modal.id = 'import-preview-modal';
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
    modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-lg max-w-2xl w-full max-h-96 overflow-y-auto p-6">
            <h3 class="text-lg font-bold text-gray-900 mb-4">Prévia da Importação</h3>
            ${previewContent}
            <div class="mt-6 flex gap-3">
                <button id="confirm-import-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg">
                    Confirmar Importação
                </button>
                <button id="cancel-import-btn" class="flex-1 bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg">
                    Cancelar
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    document.getElementById('confirm-import-btn').addEventListener('click', () => {
        confirmImportOrders(orders);
        modal.remove();
    });

    document.getElementById('cancel-import-btn').addEventListener('click', () => {
        modal.remove();
    });
}

async function confirmImportOrders(orders) {
    const statusElement = document.getElementById('import-orders-status');
    if (!statusElement) return;

    statusElement.textContent = 'Importando ordens...';
    statusElement.className = 'text-sm font-semibold text-blue-600';

    let successCount = 0;
    let errorCount = 0;

    for (const order of orders) {
        try {
            // Buscar produto para extrair dados usando função helper
            const product = getProductByCode(order.part_code);

            const docData = {
                order_number: order.order_number,
                order_number_original: order.order_number,
                part_code: order.part_code,
                product_cod: order.part_code,
                product: product?.name || '',
                customer: order.customer || (product?.client || ''),
                client: order.customer || (product?.client || ''),
                raw_material: order.raw_material,
                lot_size: parseImportNumber(order.lot_size),
                batch_number: order.batch_number,
                machine_id: order.machine_id || null,
                status: 'planejada',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            if (product) {
                docData.product_snapshot = {
                    cod: product.cod || order.part_code,
                    client: product.client || '',
                    name: product.name || '',
                    cavities: parseImportNumber(product.cavities),
                    cycle: parseImportNumber(product.cycle),
                    weight: parseImportNumber(product.weight),
                    mp: product.mp || order.raw_material
                };
            }

            // Verificar duplicação de número de OP
            const existing = await db.collection('production_orders')
                .where('order_number', '==', order.order_number)
                .limit(1)
                .get();

            if (!existing.empty) {
                console.warn(`OP ${order.order_number} já existe, pulando...`);
                errorCount++;
                continue;
            }

            const docRef = await db.collection('production_orders').add(docData);
            successCount++;
            
            // Registrar log de importação
            registrarLogSistema('IMPORTAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                orderId: docRef.id,
                orderNumber: order.order_number,
                product: docData.product,
                lotSize: docData.lot_size
            });
        } catch (error) {
            console.error(`Erro ao importar OP ${order.order_number}:`, error);
            errorCount++;
        }
    }

    statusElement.textContent = `Importação concluída: ${successCount} ordens importadas, ${errorCount} erros.`;
    statusElement.className = errorCount === 0 ? 'text-sm font-semibold text-green-600' : 'text-sm font-semibold text-orange-600';

    // Atualizar lista de ordens
    setTimeout(() => {
        loadProductionOrders();
        document.getElementById('import-orders-file').value = '';
        statusElement.textContent = '';
    }, 2000);
}

// Download template Excel
function downloadExcelTemplate() {
    const headers = ['numero_op', 'cod_produto', 'cod_mp', 'maquina', 'cliente', 'tam_lote', 'numero_lote', 'data'];
    const exampleRows = [
        ['OP-001', 'PROD001', 'MP001', 'H-01', 'Cliente A', 5000, 'LOTE-001', '2025-11-27'],
        ['OP-002', 'PROD002', 'MP002', 'H-05', 'Cliente B', 3000, 'LOTE-002', '2025-11-27'],
        ['OP-003', 'PROD001', 'MP001', 'H-11', 'Cliente A', 7500, 'LOTE-003', '2025-11-27']
    ];
    
    // Criar workbook e worksheet
    const ws = XLSX.utils.aoa_to_sheet([headers, ...exampleRows]);
    
    // Formatar largura das colunas
    ws['!cols'] = [
        { wch: 12 }, // numero_op
        { wch: 12 }, // cod_produto
        { wch: 10 }, // cod_mp
        { wch: 10 }, // maquina
        { wch: 15 }, // cliente
        { wch: 10 }, // tam_lote
        { wch: 12 }, // numero_lote
        { wch: 12 }  // data
    ];
    
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Ordens');
    
    // Salvar arquivo
    XLSX.writeFile(wb, 'template_ordens.xlsx');
}

// Event listeners para importação
document.addEventListener('DOMContentLoaded', () => {
    const importBtn = document.getElementById('btn-import-orders');
    const importFile = document.getElementById('import-orders-file');
    const downloadTemplateBtn = document.getElementById('download-excel-template');

    if (importBtn && importFile) {
        importBtn.addEventListener('click', () => {
            const file = importFile.files[0];
            if (file) {
                handleProductionOrdersImport(file);
            } else {
                alert('Selecione um arquivo Excel (.xlsx).');
            }
        });
    }

    if (downloadTemplateBtn) {
        downloadTemplateBtn.addEventListener('click', downloadExcelTemplate);
    }
});

// ====================================
// DEBUG/TESTE - Disponível via console
// ====================================
// As funções de debug estão expostas dentro do DOMContentLoaded principal
// Use window._syncDebug para acessar funções de diagnóstico

document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('traceability-refresh-btn');
    if (!refreshBtn) return;

    refreshBtn.dataset.defaultLabel = refreshBtn.innerHTML;

    refreshBtn.addEventListener('click', async () => {
        if (!window.traceabilitySystem) {
            console.warn('[TRACEABILITY] Sistema não inicializado');
            return;
        }

        refreshBtn.disabled = true;
        refreshBtn.classList.add('opacity-60', 'cursor-not-allowed');
        refreshBtn.innerHTML = '<span class="flex items-center gap-2"><i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i>Atualizando...</span>';
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }

        try {
            await window.traceabilitySystem.initialize();
        } catch (error) {
            console.error('[TRACEABILITY] Erro ao atualizar via botão:', error);
        } finally {
            refreshBtn.disabled = false;
            refreshBtn.classList.remove('opacity-60', 'cursor-not-allowed');
            refreshBtn.innerHTML = refreshBtn.dataset.defaultLabel;
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
    });
});


// =====================================
// 📊 MÓDULO DE RELATÓRIOS
// =====================================
const ReportsModule = (function() {
    'use strict';

    // Estado do módulo
    let currentPage = 1;
    let itemsPerPage = 20;
    let currentData = [];
    let currentReportType = 'producao';
    let charts = {
        shift: null,
        reason: null,
        timeline: null
    };

    // Helper para acessar o Firestore
    function getDB() {
        const db = window.db || (typeof db !== 'undefined' ? db : null);
        if (!db) {
            console.warn('[REPORTS] Banco de dados não iniciado. Tentando novamente em 500ms...');
            // Se não estiver pronto, aguardar e tentar novamente
            return null;
        }
        return db;
    }

    // Helper para mostrar toast
    function showReportToast(message, type = 'info') {
        // Tentar usar a função global showNotification
        if (typeof showNotification === 'function') {
            showNotification(message, type);
        } else if (typeof window.showNotification === 'function') {
            window.showNotification(message, type);
        } else {
            // Fallback simples usando console
            console.log(`[REPORTS ${type.toUpperCase()}] ${message}`);
            alert(message); // Se tudo falhar, usar alert
        }
    }

    // Inicialização do módulo
    function initialize() {
        console.log('[REPORTS] Inicializando módulo de relatórios...');
        
        // Verificar se os elementos existem
        const generateBtn = document.getElementById('report-generate-btn');
        const periodSelect = document.getElementById('report-period');
        const machineSelect = document.getElementById('report-machine');
        
        console.log('[REPORTS] Elementos encontrados:', {
            generateBtn: !!generateBtn,
            periodSelect: !!periodSelect,
            machineSelect: !!machineSelect
        });
        
        setupEventListeners();
        populateReportMachines();
        
        // Atualizar datas após um pequeno delay para garantir que o DOM está pronto
        setTimeout(() => {
            updateDatesFromPeriod();
        }, 100);
        
        console.log('[REPORTS] Módulo inicializado com sucesso');
    }

    // Popular máquinas no filtro de relatórios
    function populateReportMachines() {
        const machineSelect = document.getElementById('report-machine');
        if (!machineSelect) {
            console.warn('[REPORTS] Select de máquinas não encontrado');
            return;
        }
        
        // Limpar opções existentes, mantendo "Todas"
        machineSelect.innerHTML = '<option value="all">Todas Máquinas</option>';
        
        // Usar machineDatabase do databaseModule
        const machines = window.databaseModule?.machineDatabase || 
                        (typeof machineDatabase !== 'undefined' ? machineDatabase : null);
        
        if (machines && Array.isArray(machines)) {
            console.log('[REPORTS] Carregando', machines.length, 'máquinas no filtro');
            machines.forEach(machine => {
                const opt = document.createElement('option');
                opt.value = machine.id;
                opt.textContent = machine.id;
                machineSelect.appendChild(opt);
            });
        } else {
            console.warn('[REPORTS] machineDatabase não disponível');
        }
    }

    // Configurar listeners
    function setupEventListeners() {
        const generateBtn = document.getElementById('report-generate-btn');
        const exportExcelBtn = document.getElementById('report-export-excel');
        const exportPdfBtn = document.getElementById('report-export-pdf');
        const prevPageBtn = document.getElementById('report-prev-page');
        const nextPageBtn = document.getElementById('report-next-page');
        const reportTypeSelect = document.getElementById('report-type');
        const periodSelect = document.getElementById('report-period');

        if (generateBtn) {
            generateBtn.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('[REPORTS] Botão Gerar Relatório clicado');
                generateReport();
            });
            console.log('[REPORTS] Listener adicionado ao botão Gerar Relatório');
        } else {
            console.warn('[REPORTS] Botão report-generate-btn não encontrado');
        }
        
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', exportToExcel);
        }
        if (exportPdfBtn) {
            exportPdfBtn.addEventListener('click', exportToPDF);
        }
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => changePage(-1));
        }
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => changePage(1));
        }
        if (reportTypeSelect) {
            reportTypeSelect.addEventListener('change', (e) => {
                currentReportType = e.target.value;
            });
        }
        if (periodSelect) {
            periodSelect.addEventListener('change', handlePeriodChange);
        }
        
        // Sincronizar radio buttons com select hidden
        setupReportTypeCards();
    }

    // Configurar cards de tipo de relatório
    function setupReportTypeCards() {
        const radioButtons = document.querySelectorAll('input[name="report-type-radio"]');
        const hiddenSelect = document.getElementById('report-type');
        
        radioButtons.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked && hiddenSelect) {
                    hiddenSelect.value = e.target.value;
                    currentReportType = e.target.value;
                    
                    // Esconder mensagem inicial quando mudar tipo
                    const initialMsg = document.getElementById('report-initial');
                    if (initialMsg) {
                        // Manter visível até gerar relatório
                    }
                }
            });
        });
    }

    // Manipular mudança de período
    function handlePeriodChange() {
        const periodSelect = document.getElementById('report-period');
        const customDatesDiv = document.getElementById('report-custom-dates');
        
        if (periodSelect?.value === 'custom') {
            customDatesDiv?.classList.remove('hidden');
        } else {
            customDatesDiv?.classList.add('hidden');
            updateDatesFromPeriod();
        }
    }

    // Calcular datas baseado no período selecionado
    function updateDatesFromPeriod() {
        const periodSelect = document.getElementById('report-period');
        const startInput = document.getElementById('report-date-start');
        const endInput = document.getElementById('report-date-end');
        
        console.log('[REPORTS] updateDatesFromPeriod - elementos:', {
            periodSelect: !!periodSelect,
            startInput: !!startInput,
            endInput: !!endInput,
            period: periodSelect?.value
        });
        
        if (!periodSelect || !startInput || !endInput) {
            console.warn('[REPORTS] Elementos de data não encontrados');
            return;
        }
        
        const period = periodSelect.value;
        const today = new Date();
        let startDate = new Date();
        let endDate = new Date();
        
        switch (period) {
            case 'today':
                startDate = new Date(today);
                endDate = new Date(today);
                break;
            case 'yesterday':
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - 1);
                endDate = new Date(startDate);
                break;
            case '7days':
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - 7);
                endDate = new Date(today);
                break;
            case '30days':
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - 30);
                endDate = new Date(today);
                break;
            case 'month':
                startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                endDate = new Date(today);
                break;
            case 'lastmonth':
                startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                endDate = new Date(today.getFullYear(), today.getMonth(), 0);
                break;
            case 'custom':
                // Manter valores atuais
                return;
        }
        
        startInput.value = formatDateInput(startDate);
        endInput.value = formatDateInput(endDate);
    }

    function formatDateInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    // Gerar relatório
    async function generateReport() {
        console.log('[REPORTS] ========== INICIANDO GERAÇÃO DE RELATÓRIO ==========');
        
        // Mostrar loading imediatamente
        showLoading(true);
        
        // Esconder mensagem inicial
        const initialMsg = document.getElementById('report-initial');
        if (initialMsg) {
            initialMsg.classList.add('hidden');
            console.log('[REPORTS] Mensagem inicial escondida');
        }
        
        // Atualizar datas antes de gerar
        const periodSelect = document.getElementById('report-period');
        if (periodSelect && periodSelect.value !== 'custom') {
            updateDatesFromPeriod();
            console.log('[REPORTS] Datas atualizadas para período:', periodSelect.value);
        }
        
        // Pequeno delay para garantir que as datas foram atualizadas
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Verificar Firestore - usar window.db diretamente
        let firestore = window.db;
        if (!firestore) {
            console.log('[REPORTS] window.db não disponível, tentando retries...');
            let retries = 0;
            while (!firestore && retries < 3) {
                await new Promise(resolve => setTimeout(resolve, 300));
                firestore = window.db;
                retries++;
            }
        }
        
        console.log('[REPORTS] Firestore verificado:', { disponivel: !!firestore });
        
        if (!firestore) {
            showReportToast('Erro: Banco de dados não disponível. Tente novamente em alguns segundos.', 'error');
            console.error('[REPORTS] Firestore não disponível após retries:', { windowDb: !!window.db, globalDb: typeof db });
            showLoading(false);
            return;
        }

        // Obter tipo de relatório do radio button ou select
        const selectedRadio = document.querySelector('input[name="report-type-radio"]:checked');
        const reportType = selectedRadio?.value || document.getElementById('report-type')?.value || 'producao';
        
        // Obter datas - calcular diretamente se não estiverem definidas
        let startDate = document.getElementById('report-date-start')?.value;
        let endDate = document.getElementById('report-date-end')?.value;
        
        // Se as datas estiverem vazias, calcular baseado no período selecionado
        if (!startDate || !endDate) {
            const period = document.getElementById('report-period')?.value || '7days';
            const today = new Date();
            let calcStartDate = new Date();
            let calcEndDate = new Date();
            
            switch (period) {
                case 'today':
                    calcStartDate = new Date(today);
                    calcEndDate = new Date(today);
                    break;
                case 'yesterday':
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 1);
                    calcEndDate = new Date(calcStartDate);
                    break;
                case '7days':
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 7);
                    calcEndDate = new Date(today);
                    break;
                case '30days':
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 30);
                    calcEndDate = new Date(today);
                    break;
                case 'month':
                    calcStartDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    calcEndDate = new Date(today);
                    break;
                case 'lastmonth':
                    calcStartDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    calcEndDate = new Date(today.getFullYear(), today.getMonth(), 0);
                    break;
                default:
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 7);
                    calcEndDate = new Date(today);
            }
            
            // Formatar datas como YYYY-MM-DD
            const formatDate = (d) => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            startDate = formatDate(calcStartDate);
            endDate = formatDate(calcEndDate);
            console.log('[REPORTS] Datas calculadas automaticamente:', { period, startDate, endDate });
        }
        
        const machine = document.getElementById('report-machine')?.value || 'all';
        const shift = document.getElementById('report-shift')?.value || 'all';

        console.log('[REPORTS] Filtros finais:', { reportType, startDate, endDate, machine, shift });

        if (!startDate || !endDate) {
            showReportToast('Por favor, selecione as datas do período.', 'error');
            console.warn('[REPORTS] Datas ainda inválidas:', { startDate, endDate });
            showLoading(false);
            return;
        }

        hideResults();
        console.log('[REPORTS] Iniciando busca de dados...');

        try {
            let data = [];

            switch (reportType) {
                case 'producao':
                    data = await fetchProductionData(startDate, endDate, machine, shift);
                    break;
                case 'paradas':
                    data = await fetchDowntimeData(startDate, endDate, machine, shift);
                    break;
                case 'perdas':
                    data = await fetchLossesData(startDate, endDate, machine, shift);
                    break;
                case 'consolidado':
                    data = await fetchConsolidatedData(startDate, endDate, machine, shift);
                    break;
            }

            console.log('[REPORTS] Dados encontrados:', data.length);

            currentData = data;
            currentPage = 1;
            currentReportType = reportType;

            if (data.length === 0) {
                showEmptyState(true);
                showReportToast('Nenhum registro encontrado para o período selecionado.', 'warning');
            } else {
                updateKPIs(data, reportType);
                renderTable(data, reportType);
                updateCharts(data, reportType);
                showResults();
                showReportToast(`Relatório gerado: ${data.length} registros encontrados.`, 'success');
            }
        } catch (error) {
            console.error('[REPORTS] Erro ao gerar relatório:', error);
            showReportToast('Erro ao gerar relatório. Tente novamente.', 'error');
        } finally {
            showLoading(false);
        }
    }

    // Buscar dados de produção
    async function fetchProductionData(startDate, endDate, machine, shift) {
        const entries = [];
        const firestore = window.db;
        if (!firestore) {
            console.error('[REPORTS] Firestore não disponível em fetchProductionData');
            return entries;
        }
        
        try {
            console.log('[REPORTS] Buscando produção:', { startDate, endDate, machine, shift });
            
            // Buscar sem orderBy para evitar problemas de índice
            let query = firestore.collection('production_entries')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate);

            console.log('[REPORTS] Executando query de produção...');
            const snapshot = await query.get();
            
            console.log('[REPORTS] Produção - documentos encontrados:', snapshot.size);
            
            snapshot.forEach(doc => {
                const d = doc.data();
                
                // Filtro de máquina
                if (machine !== 'all' && d.machine !== machine) return;
                
                // Filtro de turno - campo é 'turno' não 'shift'
                if (shift !== 'all' && String(d.turno) !== shift) return;
                
                entries.push({
                    id: doc.id,
                    data: d.data || '',
                    turno: d.turno || '',
                    maquina: d.machine || '',
                    ordem: d.orderId || d.order_id || '',
                    produto: d.mp || d.productCode || '',
                    produzido: d.produzido || d.produced || d.quantity || 0,
                    operador: d.registradoPorNome || d.registradoPor || d.operator || '',
                    hora: d.timestamp?.toDate?.()?.toLocaleTimeString?.('pt-BR', {hour: '2-digit', minute: '2-digit'}) || ''
                });
            });
            console.log('[REPORTS] Produção - registros após filtros:', entries.length);
        } catch (error) {
            console.error('[REPORTS] Erro ao buscar produção:', error);
            showReportToast(`Erro ao buscar dados de produção: ${error.message}`, 'error');
        }
        
        return entries;
    }

    // Buscar dados de paradas
    async function fetchDowntimeData(startDate, endDate, machine, shift) {
        const entries = [];
        const firestore = window.db;
        if (!firestore) return entries;
        
        try {
            console.log('[REPORTS] Buscando paradas:', { startDate, endDate, machine, shift });
            
            // Buscar por campo 'data'
            let query = firestore.collection('downtime_entries')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate);

            console.log('[REPORTS] Executando query de paradas...');
            const snapshot = await query.get();
            
            console.log('[REPORTS] Paradas - documentos encontrados:', snapshot.size);
            
            snapshot.forEach(doc => {
                const d = doc.data();
                
                // Filtro de máquina
                if (machine !== 'all' && d.machine !== machine) return;
                
                // Filtro de turno
                const docTurno = d.turno || d.shift;
                if (shift !== 'all' && String(docTurno) !== shift) return;
                
                entries.push({
                    id: doc.id,
                    data: d.data || d.date || '',
                    turno: docTurno || '',
                    maquina: d.machine || '',
                    tipo: d.downtime_type || d.type || d.tipo || '',
                    motivo: d.reason || d.motivo || '',
                    duracao: d.duration || d.duracao || 0,
                    inicio: d.start_time || d.inicio || '',
                    fim: d.end_time || d.fim || '',
                    operador: d.registradoPorNome || d.operator || d.created_by || ''
                });
            });
            console.log('[REPORTS] Paradas - registros após filtros:', entries.length);
        } catch (error) {
            console.error('[REPORTS] Erro ao buscar paradas:', error);
            showReportToast(`Erro ao buscar dados de paradas: ${error.message}`, 'error');
        }
        
        return entries;
    }

    // Buscar dados de perdas/refugos
    async function fetchLossesData(startDate, endDate, machine, shift) {
        const entries = [];
        const firestore = window.db;
        if (!firestore) return entries;
        
        try {
            console.log('[REPORTS] Buscando perdas:', { startDate, endDate, machine, shift });
            
            // Buscar refugos de produção - usando campo 'data'
            let query = firestore.collection('production_entries')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate);

            console.log('[REPORTS] Executando query de perdas...');
            const snapshot = await query.get();
            
            console.log('[REPORTS] Perdas (produção) - documentos:', snapshot.size);
            
            snapshot.forEach(doc => {
                const d = doc.data();
                
                // Filtro de data se fallback
                if (d.data && (d.data < startDate || d.data > endDate)) return;
                
                // Só incluir se tiver refugo
                const refugoKg = d.refugo_kg || d.scrap || d.rejected || d.refugo || 0;
                if (!refugoKg || refugoKg <= 0) return;
                
                // Filtro de máquina
                if (machine !== 'all' && d.machine !== machine) return;
                
                // Filtro de turno
                if (shift !== 'all' && String(d.turno) !== shift) return;
                
                entries.push({
                    id: doc.id,
                    data: d.data || '',
                    turno: d.turno || '',
                    maquina: d.machine || '',
                    ordem: d.orderId || '',
                    produto: d.mp || '',
                    tipo: 'Refugo Produção',
                    quantidade: refugoKg,
                    motivo: d.perdas || d.scrap_reason || '-',
                    operador: d.registradoPorNome || ''
                });
            });

            // Buscar retrabalhos
            try {
                console.log('[REPORTS] Buscando retrabalhos...');
                const reworkQuery = firestore.collection('rework_entries')
                    .where('data', '>=', startDate)
                    .where('data', '<=', endDate);

                const reworkSnapshot = await reworkQuery.get();
                
                console.log('[REPORTS] Retrabalhos - documentos:', reworkSnapshot.size);
                
                reworkSnapshot.forEach(doc => {
                    const d = doc.data();
                    
                    // Filtro de máquina
                    if (machine !== 'all' && d.machine !== machine) return;
                    
                    // Filtro de turno
                    const docTurno = d.turno || d.shift;
                    if (shift !== 'all' && String(docTurno) !== shift) return;
                    
                    entries.push({
                        id: doc.id,
                        data: d.data || d.date || '',
                        turno: docTurno || '',
                        maquina: d.machine || '',
                        ordem: d.orderId || d.orderNumber || '',
                        produto: d.mp || d.productCode || '',
                        tipo: 'Retrabalho',
                        quantidade: d.quantidade || d.quantity || 0,
                        motivo: d.motivo || d.reason || '-',
                        operador: d.registradoPorNome || d.operator || ''
                    });
                });
            } catch (reworkError) {
                console.warn('[REPORTS] Erro ao buscar retrabalhos:', reworkError.message);
            }
            
            console.log('[REPORTS] Perdas - total de registros:', entries.length);

        } catch (error) {
            console.error('[REPORTS] Erro ao buscar perdas:', error);
            showReportToast(`Erro ao buscar dados de perdas: ${error.message}`, 'error');
        }
        
        // Ordenar por data
        entries.sort((a, b) => b.data.localeCompare(a.data));
        
        return entries;
    }

    // Buscar dados consolidados
    async function fetchConsolidatedData(startDate, endDate, machine, shift) {
        const consolidated = {};
        
        try {
            // Buscar produção
            const productionData = await fetchProductionData(startDate, endDate, machine, shift);
            
            // Buscar paradas
            const downtimeData = await fetchDowntimeData(startDate, endDate, machine, shift);
            
            // Buscar perdas
            const lossesData = await fetchLossesData(startDate, endDate, machine, shift);
            
            // Agrupar por data
            productionData.forEach(item => {
                const key = item.data;
                if (!consolidated[key]) {
                    consolidated[key] = {
                        data: key,
                        producao: 0,
                        tempoParado: 0,
                        perdas: 0,
                        lancamentos: 0,
                        paradas: 0,
                        maquinas: new Set()
                    };
                }
                consolidated[key].producao += item.produzido;
                consolidated[key].lancamentos++;
                consolidated[key].maquinas.add(item.maquina);
            });
            
            downtimeData.forEach(item => {
                const key = item.data;
                if (!consolidated[key]) {
                    consolidated[key] = {
                        data: key,
                        producao: 0,
                        tempoParado: 0,
                        perdas: 0,
                        lancamentos: 0,
                        paradas: 0,
                        maquinas: new Set()
                    };
                }
                consolidated[key].tempoParado += item.duracao;
                consolidated[key].paradas++;
                consolidated[key].maquinas.add(item.maquina);
            });
            
            lossesData.forEach(item => {
                const key = item.data;
                if (!consolidated[key]) {
                    consolidated[key] = {
                        data: key,
                        producao: 0,
                        tempoParado: 0,
                        perdas: 0,
                        lancamentos: 0,
                        paradas: 0,
                        maquinas: new Set()
                    };
                }
                consolidated[key].perdas += item.quantidade;
            });
            
        } catch (error) {
            console.error('[REPORTS] Erro ao buscar consolidado:', error);
        }
        
        // Converter para array e calcular eficiência
        const result = Object.values(consolidated).map(item => ({
            data: item.data,
            producao: item.producao,
            tempoParado: item.tempoParado,
            perdas: item.perdas,
            lancamentos: item.lancamentos,
            paradas: item.paradas,
            maquinas: item.maquinas.size,
            eficiencia: item.producao > 0 ? Math.round((item.producao / (item.producao + item.perdas)) * 100) : 0
        }));
        
        // Ordenar por data
        result.sort((a, b) => b.data.localeCompare(a.data));
        
        return result;
    }

    // Atualizar KPIs
    function updateKPIs(data, reportType) {
        const kpisContainer = document.getElementById('report-kpis');
        if (!kpisContainer) return;

        let totalProduced = 0;
        let totalDowntime = 0;
        let totalLosses = 0;
        let avgEfficiency = 0;

        switch (reportType) {
            case 'producao':
                totalProduced = data.reduce((sum, item) => sum + (item.produzido || 0), 0);
                break;
            case 'paradas':
                totalDowntime = data.reduce((sum, item) => sum + (item.duracao || 0), 0);
                break;
            case 'perdas':
                totalLosses = data.reduce((sum, item) => sum + (item.quantidade || 0), 0);
                break;
            case 'consolidado':
                totalProduced = data.reduce((sum, item) => sum + (item.producao || 0), 0);
                totalDowntime = data.reduce((sum, item) => sum + (item.tempoParado || 0), 0);
                totalLosses = data.reduce((sum, item) => sum + (item.perdas || 0), 0);
                const efficiencies = data.filter(item => item.eficiencia > 0).map(item => item.eficiencia);
                avgEfficiency = efficiencies.length > 0 ? Math.round(efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length) : 0;
                break;
        }

        // Atualizar elementos
        const kpiProduced = document.getElementById('report-kpi-produced');
        const kpiDowntime = document.getElementById('report-kpi-downtime');
        const kpiLosses = document.getElementById('report-kpi-losses');
        const kpiEfficiency = document.getElementById('report-kpi-efficiency');

        if (kpiProduced) kpiProduced.textContent = totalProduced.toLocaleString('pt-BR');
        if (kpiDowntime) kpiDowntime.textContent = formatDuration(totalDowntime);
        if (kpiLosses) kpiLosses.textContent = totalLosses.toLocaleString('pt-BR');
        if (kpiEfficiency) kpiEfficiency.textContent = `${avgEfficiency}%`;

        kpisContainer.classList.remove('hidden');
    }

    function formatDuration(minutes) {
        if (!minutes || minutes <= 0) return '0min';
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        if (hours > 0) {
            return `${hours}h ${mins}min`;
        }
        return `${mins}min`;
    }

    // Renderizar tabela
    function renderTable(data, reportType) {
        const thead = document.getElementById('report-table-head');
        const tbody = document.getElementById('report-table-body');
        const titleEl = document.getElementById('report-results-title');
        const countEl = document.getElementById('report-results-count');

        if (!thead || !tbody) return;

        // Definir colunas por tipo
        let columns = [];
        let title = '';

        switch (reportType) {
            case 'producao':
                title = 'Relatório de Produção';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'turno', label: 'Turno' },
                    { key: 'maquina', label: 'Máquina' },
                    { key: 'ordem', label: 'Ordem' },
                    { key: 'produto', label: 'Produto' },
                    { key: 'produzido', label: 'Produzido' },
                    { key: 'operador', label: 'Operador' },
                    { key: 'hora', label: 'Hora' }
                ];
                break;
            case 'paradas':
                title = 'Relatório de Paradas';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'turno', label: 'Turno' },
                    { key: 'maquina', label: 'Máquina' },
                    { key: 'tipo', label: 'Tipo' },
                    { key: 'motivo', label: 'Motivo' },
                    { key: 'duracao', label: 'Duração (min)' },
                    { key: 'inicio', label: 'Início' },
                    { key: 'fim', label: 'Fim' },
                    { key: 'operador', label: 'Operador' }
                ];
                break;
            case 'perdas':
                title = 'Relatório de Perdas/Refugos';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'turno', label: 'Turno' },
                    { key: 'maquina', label: 'Máquina' },
                    { key: 'ordem', label: 'Ordem' },
                    { key: 'produto', label: 'Produto' },
                    { key: 'tipo', label: 'Tipo' },
                    { key: 'quantidade', label: 'Quantidade' },
                    { key: 'motivo', label: 'Motivo' },
                    { key: 'operador', label: 'Operador' }
                ];
                break;
            case 'consolidado':
                title = 'Relatório Consolidado';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'maquinas', label: 'Máquinas' },
                    { key: 'lancamentos', label: 'Lançamentos' },
                    { key: 'producao', label: 'Produção Total' },
                    { key: 'paradas', label: 'Qtd Paradas' },
                    { key: 'tempoParado', label: 'Tempo Parado' },
                    { key: 'perdas', label: 'Perdas' },
                    { key: 'eficiencia', label: 'Eficiência' }
                ];
                break;
        }

        if (titleEl) titleEl.textContent = title;
        if (countEl) countEl.textContent = `${data.length} registros`;

        // Renderizar cabeçalho
        thead.innerHTML = `
            <tr>
                ${columns.map(col => `<th class="text-left px-4 py-3 text-sm font-semibold text-gray-700">${col.label}</th>`).join('')}
            </tr>
        `;

        // Paginação
        const startIdx = (currentPage - 1) * itemsPerPage;
        const endIdx = startIdx + itemsPerPage;
        const pageData = data.slice(startIdx, endIdx);

        // Renderizar dados
        tbody.innerHTML = pageData.map(item => `
            <tr class="hover:bg-gray-50 transition-colors">
                ${columns.map(col => {
                    let value = item[col.key];
                    
                    // Formatação especial
                    if (col.key === 'turno') {
                        value = `Turno ${value}`;
                    } else if (col.key === 'produzido' || col.key === 'producao' || col.key === 'quantidade' || col.key === 'perdas') {
                        value = (value || 0).toLocaleString('pt-BR');
                    } else if (col.key === 'tempoParado') {
                        value = formatDuration(value);
                    } else if (col.key === 'eficiencia') {
                        value = `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${value >= 80 ? 'bg-green-100 text-green-800' : value >= 60 ? 'bg-yellow-100 text-yellow-800' : 'bg-red-100 text-red-800'}">${value}%</span>`;
                    } else if (col.key === 'tipo' && item.tipo) {
                        const typeColors = {
                            'Refugo Produção': 'bg-red-100 text-red-800',
                            'Retrabalho': 'bg-orange-100 text-orange-800'
                        };
                        value = `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${typeColors[item.tipo] || 'bg-gray-100 text-gray-800'}">${item.tipo}</span>`;
                    }
                    
                    return `<td class="px-4 py-3 text-sm text-gray-600">${value || '-'}</td>`;
                }).join('')}
            </tr>
        `).join('');

        // Atualizar paginação
        updatePagination(data.length);
    }

    // Atualizar paginação
    function updatePagination(totalItems) {
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        const infoEl = document.getElementById('report-pagination-info');
        const pageInfoEl = document.getElementById('report-page-info');
        const prevBtn = document.getElementById('report-prev-page');
        const nextBtn = document.getElementById('report-next-page');

        const startIdx = (currentPage - 1) * itemsPerPage + 1;
        const endIdx = Math.min(currentPage * itemsPerPage, totalItems);

        if (infoEl) infoEl.textContent = `Mostrando ${startIdx}-${endIdx} de ${totalItems}`;
        if (pageInfoEl) pageInfoEl.textContent = `Página ${currentPage} de ${totalPages}`;

        if (prevBtn) prevBtn.disabled = currentPage <= 1;
        if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
    }

    // Mudar página
    function changePage(direction) {
        const totalPages = Math.ceil(currentData.length / itemsPerPage);
        const newPage = currentPage + direction;

        if (newPage >= 1 && newPage <= totalPages) {
            currentPage = newPage;
            renderTable(currentData, currentReportType);
        }
    }

    // Atualizar gráficos
    function updateCharts(data, reportType) {
        const chartsContainer = document.getElementById('report-charts');
        if (!chartsContainer || typeof Chart === 'undefined') {
            console.log('[REPORTS] Chart.js não disponível');
            return;
        }

        // Destruir gráficos anteriores
        Object.values(charts).forEach(chart => {
            if (chart) chart.destroy();
        });

        if (data.length === 0) {
            chartsContainer.classList.add('hidden');
            return;
        }

        chartsContainer.classList.remove('hidden');

        // Gráfico de distribuição por turno
        const shiftData = {};
        data.forEach(item => {
            const shift = item.turno || 'N/A';
            const key = `Turno ${shift}`;
            shiftData[key] = (shiftData[key] || 0) + 1;
        });

        const shiftCtx = document.getElementById('report-chart-shift')?.getContext('2d');
        if (shiftCtx) {
            charts.shift = new Chart(shiftCtx, {
                type: 'bar',
                data: {
                    labels: Object.keys(shiftData),
                    datasets: [{
                        label: 'Registros por Turno',
                        data: Object.values(shiftData),
                        backgroundColor: ['#3b82f6', '#10b981', '#f59e0b'],
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        // Gráfico de distribuição por motivo (apenas para paradas)
        if (reportType === 'paradas' || reportType === 'perdas') {
            const reasonData = {};
            data.forEach(item => {
                const reason = item.motivo || item.tipo || 'Não especificado';
                reasonData[reason] = (reasonData[reason] || 0) + 1;
            });

            const reasonCtx = document.getElementById('report-chart-reason')?.getContext('2d');
            if (reasonCtx) {
                const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899'];
                charts.reason = new Chart(reasonCtx, {
                    type: 'doughnut',
                    data: {
                        labels: Object.keys(reasonData).slice(0, 7),
                        datasets: [{
                            data: Object.values(reasonData).slice(0, 7),
                            backgroundColor: colors
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'right' }
                        }
                    }
                });
            }
        }

        // Gráfico de evolução diária
        const timelineData = {};
        data.forEach(item => {
            const date = item.data;
            if (!timelineData[date]) {
                timelineData[date] = 0;
            }
            timelineData[date] += item.produzido || item.duracao || item.quantidade || item.producao || 1;
        });

        // Ordenar por data
        const sortedDates = Object.keys(timelineData).sort();
        const timelineValues = sortedDates.map(d => timelineData[d]);

        const timelineCtx = document.getElementById('report-chart-timeline')?.getContext('2d');
        if (timelineCtx && sortedDates.length > 0) {
            charts.timeline = new Chart(timelineCtx, {
                type: 'line',
                data: {
                    labels: sortedDates.map(d => {
                        const [year, month, day] = d.split('-');
                        return `${day}/${month}`;
                    }),
                    datasets: [{
                        label: 'Evolução Diária',
                        data: timelineValues,
                        borderColor: '#6366f1',
                        backgroundColor: 'rgba(99, 102, 241, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
        }
    }

    // Exportar para Excel
    function exportToExcel() {
        if (currentData.length === 0) {
            showReportToast('Nenhum dado para exportar. Gere um relatório primeiro.', 'warning');
            return;
        }

        try {
            // Converter dados para CSV
            const headers = Object.keys(currentData[0]).filter(k => k !== 'id');
            let csv = headers.join(';') + '\n';
            
            currentData.forEach(item => {
                const row = headers.map(h => {
                    let val = item[h];
                    if (typeof val === 'number') {
                        val = val.toString().replace('.', ',');
                    }
                    return val || '';
                });
                csv += row.join(';') + '\n';
            });

            // BOM para UTF-8
            const BOM = '\uFEFF';
            const blob = new Blob([BOM + csv], { type: 'text/csv;charset=utf-8;' });
            
            const link = document.createElement('a');
            const reportType = document.getElementById('report-type')?.value || 'relatorio';
            const date = new Date().toISOString().split('T')[0];
            link.download = `relatorio_${reportType}_${date}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();

            showReportToast('Relatório exportado com sucesso!', 'success');
        } catch (error) {
            console.error('[REPORTS] Erro ao exportar:', error);
            showReportToast('Erro ao exportar relatório.', 'error');
        }
    }

    // Exportar para PDF
    function exportToPDF() {
        if (currentData.length === 0) {
            showReportToast('Nenhum dado para exportar. Gere um relatório primeiro.', 'warning');
            return;
        }

        try {
            // Usar window.print() como fallback simples
            const reportType = document.getElementById('report-type')?.value || 'relatorio';
            const titles = {
                'producao': 'Relatório de Produção',
                'paradas': 'Relatório de Paradas',
                'perdas': 'Relatório de Perdas/Refugos',
                'consolidado': 'Relatório Consolidado'
            };

            const printWindow = window.open('', '_blank');
            const headers = Object.keys(currentData[0]).filter(k => k !== 'id');

            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${titles[reportType] || 'Relatório'}</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { color: #333; border-bottom: 2px solid #6366f1; padding-bottom: 10px; }
                        table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 12px; }
                        th { background: #6366f1; color: white; padding: 10px; text-align: left; }
                        td { border: 1px solid #ddd; padding: 8px; }
                        tr:nth-child(even) { background: #f9f9f9; }
                        .date { color: #666; font-size: 12px; margin-bottom: 20px; }
                    </style>
                </head>
                <body>
                    <h1>${titles[reportType] || 'Relatório'}</h1>
                    <p class="date">Gerado em: ${new Date().toLocaleString('pt-BR')}</p>
                    <table>
                        <thead>
                            <tr>
                                ${headers.map(h => `<th>${h}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${currentData.slice(0, 100).map(item => `
                                <tr>
                                    ${headers.map(h => `<td>${item[h] || '-'}</td>`).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    ${currentData.length > 100 ? '<p><em>Exibindo primeiros 100 registros de ' + currentData.length + ' total.</em></p>' : ''}
                </body>
                </html>
            `);

            printWindow.document.close();
            printWindow.print();

            showReportToast('PDF aberto para impressão!', 'success');
        } catch (error) {
            console.error('[REPORTS] Erro ao gerar PDF:', error);
            showReportToast('Erro ao gerar PDF.', 'error');
        }
    }

    // Helpers de UI
    function showLoading(show) {
        const loading = document.getElementById('report-loading');
        if (loading) {
            loading.classList.toggle('hidden', !show);
        }
    }

    function showResults() {
        const results = document.getElementById('report-results');
        const empty = document.getElementById('report-empty');
        if (results) results.classList.remove('hidden');
        if (empty) empty.classList.add('hidden');
    }

    function hideResults() {
        const results = document.getElementById('report-results');
        const kpis = document.getElementById('report-kpis');
        const charts = document.getElementById('report-charts');
        const empty = document.getElementById('report-empty');
        if (results) results.classList.add('hidden');
        if (kpis) kpis.classList.add('hidden');
        if (charts) charts.classList.add('hidden');
        if (empty) empty.classList.add('hidden');
    }

    function showEmptyState(show) {
        const empty = document.getElementById('report-empty');
        if (empty) empty.classList.toggle('hidden', !show);
    }

    // Retornar API pública
    return {
        initialize,
        generateReport,
        exportToExcel,
        exportToPDF,
        populateReportMachines
    };
})();

// Expor globalmente
window.ReportsModule = ReportsModule;

// Inicializar módulo de relatórios quando DOM estiver pronto
document.addEventListener('DOMContentLoaded', () => {
    ReportsModule.initialize();
    
    // Popular máquinas também na inicialização global
    setTimeout(() => {
        const machineSelect = document.getElementById('report-machine');
        if (machineSelect && machineSelect.options.length <= 1) {
            const machines = window.databaseModule?.machineDatabase;
            if (machines && Array.isArray(machines)) {
                machines.forEach(machine => {
                    const opt = document.createElement('option');
                    opt.value = machine.id;
                    opt.textContent = machine.id;
                    machineSelect.appendChild(opt);
                });
                console.log('[REPORTS] Máquinas carregadas via fallback:', machines.length);
            }
        }
    }, 500);
});

// ============================================================
// MÓDULO: Aba Ordens (Nova Interface Centralizada)
// ============================================================
const OrdersPageModule = (function() {
    'use strict';
    
    let ordersCache = [];
    let currentView = 'cards';
    let isInitialized = false;
    
    // Elementos do DOM
    const elements = {};
    
    function cacheElements() {
        elements.grid = document.getElementById('orders-page-grid');
        elements.tableBody = document.getElementById('orders-page-table-body');
        elements.cardsContainer = document.getElementById('orders-page-cards-container');
        elements.tableContainer = document.getElementById('orders-page-table-container');
        elements.emptyState = document.getElementById('orders-page-empty');
        elements.resultsCount = document.getElementById('orders-page-results-count');
        elements.searchInput = document.getElementById('orders-page-search');
        elements.statusFilter = document.getElementById('orders-page-status-filter');
        elements.machineFilter = document.getElementById('orders-page-machine-filter');
        elements.sortSelect = document.getElementById('orders-page-sort');
        elements.clearFiltersBtn = document.getElementById('orders-page-clear-filters');
        elements.refreshBtn = document.getElementById('orders-page-refresh');
        elements.addBtn = document.getElementById('orders-page-add-btn');
        elements.addFirstBtn = document.getElementById('orders-page-add-first');
        elements.viewCardsBtn = document.getElementById('orders-page-view-cards');
        elements.viewTableBtn = document.getElementById('orders-page-view-table');
        elements.kpiTotal = document.getElementById('orders-page-kpi-total');
        elements.kpiPlanned = document.getElementById('orders-page-kpi-planned');
        elements.kpiActive = document.getElementById('orders-page-kpi-active');
        elements.kpiCompleted = document.getElementById('orders-page-kpi-completed');
        
        // Debug: verificar quais elementos foram encontrados
        console.log('[OrdersPage] Elementos encontrados:', {
            grid: !!elements.grid,
            tableBody: !!elements.tableBody,
            cardsContainer: !!elements.cardsContainer,
            resultsCount: !!elements.resultsCount,
            kpiTotal: !!elements.kpiTotal
        });
    }
    
    function setupEventListeners() {
        if (elements.searchInput) {
            elements.searchInput.addEventListener('input', debounce(renderOrders, 300));
            elements.searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') renderOrders();
            });
        }
        
        if (elements.statusFilter) {
            elements.statusFilter.addEventListener('change', renderOrders);
        }
        
        if (elements.machineFilter) {
            elements.machineFilter.addEventListener('change', renderOrders);
        }
        
        if (elements.sortSelect) {
            elements.sortSelect.addEventListener('change', renderOrders);
        }
        
        if (elements.clearFiltersBtn) {
            elements.clearFiltersBtn.addEventListener('click', clearFilters);
        }
        
        if (elements.refreshBtn) {
            elements.refreshBtn.addEventListener('click', refreshOrders);
        }
        
        if (elements.addBtn) {
            elements.addBtn.addEventListener('click', () => openOrderFormModal());
        }
        
        if (elements.addFirstBtn) {
            elements.addFirstBtn.addEventListener('click', () => openOrderFormModal());
        }
        
        if (elements.viewCardsBtn) {
            elements.viewCardsBtn.addEventListener('click', () => switchView('cards'));
        }
        
        if (elements.viewTableBtn) {
            elements.viewTableBtn.addEventListener('click', () => switchView('table'));
        }
        
        // Formulário do modal
        const formModal = document.getElementById('order-form-modal-form');
        if (formModal) {
            formModal.addEventListener('submit', handleFormSubmit);
        }
    }
    
    function switchView(view) {
        currentView = view;
        
        if (view === 'cards') {
            elements.cardsContainer?.classList.remove('hidden');
            elements.tableContainer?.classList.add('hidden');
            elements.viewCardsBtn?.classList.add('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewCardsBtn?.classList.remove('text-gray-500');
            elements.viewTableBtn?.classList.remove('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewTableBtn?.classList.add('text-gray-500');
        } else {
            elements.cardsContainer?.classList.add('hidden');
            elements.tableContainer?.classList.remove('hidden');
            elements.viewTableBtn?.classList.add('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewTableBtn?.classList.remove('text-gray-500');
            elements.viewCardsBtn?.classList.remove('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewCardsBtn?.classList.add('text-gray-500');
        }
        
        renderOrders();
    }
    
    function clearFilters() {
        if (elements.searchInput) elements.searchInput.value = '';
        if (elements.statusFilter) elements.statusFilter.value = '';
        if (elements.machineFilter) elements.machineFilter.value = '';
        if (elements.sortSelect) elements.sortSelect.value = 'recent';
        renderOrders();
    }
    
    async function refreshOrders() {
        const icon = elements.refreshBtn?.querySelector('i');
        icon?.classList.add('animate-spin');
        ordersCache = [];
        await loadOrders();
        icon?.classList.remove('animate-spin');
        showNotification('Ordens atualizadas!', 'success');
    }
    
    async function loadOrders() {
        try {
            console.log('📋 [OrdersPage] Carregando ordens...');
            const snapshot = await db.collection('production_orders').get();
            ordersCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log('[OrdersPage] ' + ordersCache.length + ' ordens carregadas');
            
            populateMachineFilter();
            updateKPIs();
            renderOrders();
            
        } catch (error) {
            console.error('[OrdersPage] Erro ao carregar ordens:', error);
            showNotification('Erro ao carregar ordens', 'error');
        }
    }
    
    function populateMachineFilter() {
        if (!elements.machineFilter) return;
        
        const machines = [...new Set(ordersCache.map(o => o.machine_id).filter(m => m))].sort();
        
        elements.machineFilter.innerHTML = '<option value="">Todas Máquinas</option>';
        machines.forEach(m => {
            const machineInfo = window.databaseModule?.machineById?.get(m);
            const label = machineInfo ? m + ' - ' + machineInfo.model : m;
            elements.machineFilter.innerHTML += '<option value="' + m + '">' + label + '</option>';
        });
    }
    
    function updateKPIs() {
        const total = ordersCache.length;
        const planned = ordersCache.filter(o => (o.status || '').toLowerCase() === 'planejada').length;
        const active = ordersCache.filter(o => ['ativa', 'em_andamento'].includes((o.status || '').toLowerCase())).length;
        const completed = ordersCache.filter(o => ['concluida', 'finalizada'].includes((o.status || '').toLowerCase())).length;
        
        if (elements.kpiTotal) elements.kpiTotal.textContent = total.toLocaleString('pt-BR');
        if (elements.kpiPlanned) elements.kpiPlanned.textContent = planned.toLocaleString('pt-BR');
        if (elements.kpiActive) elements.kpiActive.textContent = active.toLocaleString('pt-BR');
        if (elements.kpiCompleted) elements.kpiCompleted.textContent = completed.toLocaleString('pt-BR');
    }
    
    function getFilteredOrders() {
        let filtered = [...ordersCache];
        
        // Filtro de busca
        const searchQuery = (elements.searchInput?.value || '').toLowerCase().trim();
        if (searchQuery) {
            filtered = filtered.filter(o => 
                (o.order_number || '').toLowerCase().includes(searchQuery) ||
                (o.product || '').toLowerCase().includes(searchQuery) ||
                (o.part_code || '').toLowerCase().includes(searchQuery) ||
                (o.customer || '').toLowerCase().includes(searchQuery)
            );
        }
        
        // Filtro de status
        const statusFilter = elements.statusFilter?.value || '';
        if (statusFilter) {
            filtered = filtered.filter(o => {
                const status = (o.status || '').toLowerCase();
                if (statusFilter === 'concluida') return ['concluida', 'finalizada'].includes(status);
                return status === statusFilter;
            });
        }
        
        // Filtro de máquina
        const machineFilter = elements.machineFilter?.value || '';
        if (machineFilter) {
            filtered = filtered.filter(o => o.machine_id === machineFilter);
        }
        
        // Ordenação
        const sortBy = elements.sortSelect?.value || 'recent';
        filtered.sort((a, b) => {
            switch (sortBy) {
                case 'recent':
                    return (b.createdAt?.toDate?.() || new Date(0)) - (a.createdAt?.toDate?.() || new Date(0));
                case 'oldest':
                    return (a.createdAt?.toDate?.() || new Date(0)) - (b.createdAt?.toDate?.() || new Date(0));
                case 'op-asc':
                    return (a.order_number || '').localeCompare(b.order_number || '');
                case 'op-desc':
                    return (b.order_number || '').localeCompare(a.order_number || '');
                case 'lot-desc':
                    return (Number(b.lot_size) || 0) - (Number(a.lot_size) || 0);
                case 'lot-asc':
                    return (Number(a.lot_size) || 0) - (Number(b.lot_size) || 0);
                default:
                    return 0;
            }
        });
        
        return filtered;
    }
    
    function renderOrders() {
        const filtered = getFilteredOrders();
        
        // Atualizar contador
        if (elements.resultsCount) {
            elements.resultsCount.textContent = filtered.length + ' ordem' + (filtered.length !== 1 ? 's' : '') + ' encontrada' + (filtered.length !== 1 ? 's' : '');
        }
        
        // Mostrar empty state se não houver ordens
        if (filtered.length === 0) {
            if (elements.grid) elements.grid.innerHTML = '';
            if (elements.tableBody) elements.tableBody.innerHTML = '';
            elements.emptyState?.classList.remove('hidden');
            elements.emptyState?.classList.add('flex');
            return;
        }
        
        elements.emptyState?.classList.add('hidden');
        elements.emptyState?.classList.remove('flex');
        
        if (currentView === 'cards') {
            renderCardsView(filtered);
        } else {
            renderTableView(filtered);
        }
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function renderCardsView(orders) {
        if (!elements.grid) return;
        
        const html = orders.map(order => {
            const status = (order.status || 'planejada').toLowerCase();
            const lotSize = Number(order.lot_size) || 0;
            const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
            const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
            
            const statusConfig = {
                'planejada': { bg: 'bg-slate-100', text: 'text-slate-700', border: 'border-slate-200', label: 'Planejada', icon: 'calendar' },
                'ativa': { bg: 'bg-blue-100', text: 'text-blue-700', border: 'border-blue-200', label: 'Ativa', icon: 'zap' },
                'em_andamento': { bg: 'bg-amber-100', text: 'text-amber-700', border: 'border-amber-200', label: 'Em Andamento', icon: 'play-circle' },
                'concluida': { bg: 'bg-emerald-100', text: 'text-emerald-700', border: 'border-emerald-200', label: 'Concluída', icon: 'check-circle-2' },
                'finalizada': { bg: 'bg-emerald-100', text: 'text-emerald-700', border: 'border-emerald-200', label: 'Finalizada', icon: 'check-circle-2' },
                'cancelada': { bg: 'bg-red-100', text: 'text-red-700', border: 'border-red-200', label: 'Cancelada', icon: 'x-circle' }
            };
            
            const sc = statusConfig[status] || statusConfig['planejada'];
            const progressColor = progress >= 100 ? 'bg-emerald-500' : progress >= 50 ? 'bg-blue-500' : 'bg-amber-500';
            const isActive = ['ativa', 'em_andamento'].includes(status);
            const canActivate = status === 'planejada';
            const canReactivate = ['concluida', 'finalizada'].includes(status);
            
            const machineInfo = window.databaseModule?.machineById?.get(order.machine_id);
            const machineLabel = machineInfo ? order.machine_id + ' - ' + machineInfo.model : (order.machine_id || 'N/A');
            
            return '<div class="bg-white rounded-xl border ' + (isActive ? 'border-blue-300 ring-2 ring-blue-100' : 'border-gray-200') + ' shadow-sm hover:shadow-md transition-all overflow-hidden">' +
                '<div class="p-4 border-b border-gray-100 ' + (isActive ? 'bg-blue-50' : 'bg-gray-50') + '">' +
                    '<div class="flex items-start justify-between gap-2">' +
                        '<div class="flex-1 min-w-0">' +
                            '<h4 class="font-bold text-gray-800 truncate">OP ' + escapeHtml(order.order_number || '') + '</h4>' +
                            '<p class="text-sm text-gray-600 truncate">' + escapeHtml(order.product || order.part_code || 'Produto não definido') + '</p>' +
                        '</div>' +
                        '<span class="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ' + sc.bg + ' ' + sc.text + ' ' + sc.border + ' border">' +
                            '<i data-lucide="' + sc.icon + '" class="w-3 h-3"></i>' +
                            sc.label +
                        '</span>' +
                    '</div>' +
                '</div>' +
                '<div class="p-4 space-y-3">' +
                    '<div class="grid grid-cols-2 gap-2 text-sm">' +
                        '<div class="flex items-center gap-2 text-gray-600">' +
                            '<i data-lucide="user" class="w-4 h-4 text-gray-400"></i>' +
                            '<span class="truncate">' + escapeHtml(order.customer || 'N/A') + '</span>' +
                        '</div>' +
                        '<div class="flex items-center gap-2 text-gray-600">' +
                            '<i data-lucide="settings" class="w-4 h-4 text-gray-400"></i>' +
                            '<span class="truncate">' + escapeHtml(machineLabel) + '</span>' +
                        '</div>' +
                    '</div>' +
                    '<div class="bg-gray-50 rounded-lg p-3">' +
                        '<div class="flex items-center justify-between text-xs text-gray-500 mb-1">' +
                            '<span>Progresso</span>' +
                            '<span class="font-semibold">' + Math.round(progress) + '%</span>' +
                        '</div>' +
                        '<div class="w-full bg-gray-200 rounded-full h-2">' +
                            '<div class="' + progressColor + ' h-2 rounded-full transition-all" style="width: ' + progress + '%"></div>' +
                        '</div>' +
                        '<div class="flex justify-between text-xs text-gray-500 mt-1">' +
                            '<span>' + produced.toLocaleString('pt-BR') + ' prod.</span>' +
                            '<span>' + lotSize.toLocaleString('pt-BR') + ' plan.</span>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="px-4 pb-4 flex gap-2">' +
                    (canActivate ? '<button onclick="OrdersPageModule.activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="play" class="w-4 h-4"></i>Ativar</button>' : '') +
                    (canReactivate ? '<button onclick="OrdersPageModule.reactivateOrder(\'' + order.id + '\')" class="flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="rotate-ccw" class="w-4 h-4"></i>Reativar</button>' : '') +
                    '<button onclick="OrdersPageModule.editOrder(\'' + order.id + '\')" class="' + ((canActivate || canReactivate) ? 'flex-1' : 'w-full') + ' flex items-center justify-center gap-1.5 px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg text-sm font-medium transition"><i data-lucide="edit-3" class="w-4 h-4"></i>Editar</button>' +
                '</div>' +
            '</div>';
        }).join('');
        
        elements.grid.innerHTML = html;
    }
    
    function renderTableView(orders) {
        if (!elements.tableBody) return;
        
        const html = orders.map(order => {
            const status = (order.status || 'planejada').toLowerCase();
            const lotSize = Number(order.lot_size) || 0;
            const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
            const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
            
            const statusConfig = {
                'planejada': { bg: 'bg-slate-100', text: 'text-slate-700', label: 'Planejada' },
                'ativa': { bg: 'bg-blue-100', text: 'text-blue-700', label: 'Ativa' },
                'em_andamento': { bg: 'bg-amber-100', text: 'text-amber-700', label: 'Em Andamento' },
                'concluida': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Concluída' },
                'finalizada': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Finalizada' },
                'cancelada': { bg: 'bg-red-100', text: 'text-red-700', label: 'Cancelada' }
            };
            
            const sc = statusConfig[status] || statusConfig['planejada'];
            const progressColor = progress >= 100 ? 'bg-emerald-500' : progress >= 50 ? 'bg-blue-500' : 'bg-amber-500';
            const canActivate = status === 'planejada';
            const canReactivate = ['concluida', 'finalizada'].includes(status);
            
            return '<tr class="hover:bg-gray-50">' +
                '<td class="px-4 py-3 font-medium text-gray-800">' + escapeHtml(order.order_number || '') + '</td>' +
                '<td class="px-4 py-3 text-gray-600">' + escapeHtml(order.product || order.part_code || 'N/A') + '</td>' +
                '<td class="px-4 py-3 text-gray-600">' + escapeHtml(order.customer || 'N/A') + '</td>' +
                '<td class="px-4 py-3 text-gray-600">' + escapeHtml(order.machine_id || 'N/A') + '</td>' +
                '<td class="px-4 py-3 text-center text-gray-700">' + lotSize.toLocaleString('pt-BR') + '</td>' +
                '<td class="px-4 py-3 text-center text-gray-700">' + produced.toLocaleString('pt-BR') + '</td>' +
                '<td class="px-4 py-3"><div class="flex items-center gap-2"><div class="flex-1 bg-gray-200 rounded-full h-2"><div class="' + progressColor + ' h-2 rounded-full" style="width: ' + progress + '%"></div></div><span class="text-xs font-medium text-gray-600">' + Math.round(progress) + '%</span></div></td>' +
                '<td class="px-4 py-3 text-center"><span class="px-2 py-1 rounded-full text-xs font-medium ' + sc.bg + ' ' + sc.text + '">' + sc.label + '</span></td>' +
                '<td class="px-4 py-3"><div class="flex items-center justify-center gap-1">' +
                    (canActivate ? '<button onclick="OrdersPageModule.activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="p-1.5 text-emerald-600 hover:bg-emerald-50 rounded transition" title="Ativar"><i data-lucide="play" class="w-4 h-4"></i></button>' : '') +
                    (canReactivate ? '<button onclick="OrdersPageModule.reactivateOrder(\'' + order.id + '\')" class="p-1.5 text-blue-600 hover:bg-blue-50 rounded transition" title="Reativar"><i data-lucide="rotate-ccw" class="w-4 h-4"></i></button>' : '') +
                    '<button onclick="OrdersPageModule.editOrder(\'' + order.id + '\')" class="p-1.5 text-gray-600 hover:bg-gray-100 rounded transition" title="Editar"><i data-lucide="edit-3" class="w-4 h-4"></i></button>' +
                    '<button onclick="OrdersPageModule.deleteOrder(\'' + order.id + '\')" class="p-1.5 text-red-600 hover:bg-red-50 rounded transition" title="Excluir"><i data-lucide="trash-2" class="w-4 h-4"></i></button>' +
                '</div></td>' +
            '</tr>';
        }).join('');
        
        elements.tableBody.innerHTML = html;
    }
    
    // Ações das ordens
    async function activateOrder(orderId, machineId) {
        if (!machineId) {
            showNotification('Esta ordem não tem máquina definida. Edite a ordem primeiro.', 'warning');
            return;
        }
        
        if (!confirm('Deseja ativar esta ordem na máquina ' + machineId + '?')) return;
        
        try {
            await db.collection('production_orders').doc(orderId).update({
                status: 'ativa',
                activatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            showNotification('Ordem ativada com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('ATIVAÇÃO DE ORDEM', 'ordem', {
                orderId: orderId,
                machine: machineId
            });
            
            await refreshOrders();
        } catch (error) {
            console.error('Erro ao ativar ordem:', error);
            showNotification('Erro ao ativar ordem', 'error');
        }
    }
    
    async function reactivateOrder(orderId) {
        if (!confirm('Deseja reativar esta ordem?')) return;
        
        try {
            await db.collection('production_orders').doc(orderId).update({ status: 'ativa' });
            showNotification('Ordem reativada com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('REATIVAÇÃO DE ORDEM', 'ordem', {
                orderId: orderId
            });
            
            await refreshOrders();
        } catch (error) {
            console.error('Erro ao reativar ordem:', error);
            showNotification('Erro ao reativar ordem', 'error');
        }
    }
    
    async function deleteOrder(orderId) {
        if (!confirm('Deseja excluir esta ordem? Esta ação não pode ser desfeita.')) return;
        
        try {
            const order = ordersCache.find(o => o.id === orderId);
            await db.collection('production_orders').doc(orderId).delete();
            showNotification('Ordem excluída com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE ORDEM', 'ordem', {
                orderId: orderId,
                orderNumber: order?.order_number || 'N/A'
            });
            
            await refreshOrders();
        } catch (error) {
            console.error('Erro ao excluir ordem:', error);
            showNotification('Erro ao excluir ordem', 'error');
        }
    }
    
    function editOrder(orderId) {
        const order = ordersCache.find(o => o.id === orderId);
        if (!order) {
            showNotification('Ordem não encontrada', 'error');
            return;
        }
        openOrderFormModal(order);
    }
    
    // Modal de formulário
    function openOrderFormModal(order) {
        const modal = document.getElementById('order-form-modal');
        if (!modal) return;
        
        const title = document.getElementById('order-form-title');
        const idInput = document.getElementById('order-form-id');
        const numberInput = document.getElementById('order-form-number');
        const partCodeInput = document.getElementById('order-form-part-code');
        const productInput = document.getElementById('order-form-product');
        const lotSizeInput = document.getElementById('order-form-lot-size');
        const batchInput = document.getElementById('order-form-batch');
        const packagingInput = document.getElementById('order-form-packaging');
        const customerInput = document.getElementById('order-form-customer');
        const machineSelect = document.getElementById('order-form-machine');
        const mpSelect = document.getElementById('order-form-mp');
        
        // Atualizar título
        if (title) {
            title.textContent = order ? 'Editar Ordem de Produção' : 'Nova Ordem de Produção';
        }
        
        // Popular select de máquinas
        if (machineSelect) {
            machineSelect.innerHTML = '<option value="">Selecione uma máquina</option>';
            if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
                machineDatabase.forEach(function(machine) {
                    const mid = typeof normalizeMachineId === 'function' ? normalizeMachineId(machine.id) : machine.id;
                    machineSelect.innerHTML += '<option value="' + mid + '">' + mid + ' - ' + machine.model + '</option>';
                });
            }
        }
        
        // Popular select de matéria-prima
        if (mpSelect) {
            mpSelect.innerHTML = '<option value="">Selecione a MP...</option>';
            if (typeof materiaPrimaDatabase !== 'undefined' && materiaPrimaDatabase.length > 0) {
                materiaPrimaDatabase.forEach(function(mp) {
                    mpSelect.innerHTML += '<option value="' + mp.codigo + '">' + mp.codigo + ' - ' + mp.descricao + '</option>';
                });
            }
        }
        
        // Popular datalist de produtos
        var productList = document.getElementById('order-form-product-list');
        if (productList && typeof productDatabase !== 'undefined') {
            productList.innerHTML = '';
            productDatabase.forEach(function(prod) {
                productList.innerHTML += '<option value="' + prod.cod + '">' + prod.name + '</option>';
            });
        }
        
        // Preencher formulário
        if (idInput) idInput.value = order?.id || '';
        if (numberInput) numberInput.value = order?.order_number || '';
        if (partCodeInput) partCodeInput.value = order?.part_code || '';
        if (productInput) productInput.value = order?.product || '';
        if (lotSizeInput) lotSizeInput.value = order?.lot_size || '';
        if (batchInput) batchInput.value = order?.batch_number || '';
        if (packagingInput) packagingInput.value = order?.packaging_qty || '';
        if (customerInput) customerInput.value = order?.customer || '';
        if (machineSelect) machineSelect.value = order?.machine_id || '';
        if (mpSelect) mpSelect.value = order?.raw_material || '';
        
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function closeOrderFormModal() {
        var modal = document.getElementById('order-form-modal');
        if (modal) modal.classList.add('hidden');
    }
    
    async function handleFormSubmit(e) {
        e.preventDefault();
        
        var id = document.getElementById('order-form-id')?.value;
        var orderData = {
            order_number: document.getElementById('order-form-number')?.value.trim() || '',
            part_code: document.getElementById('order-form-part-code')?.value.trim() || '',
            product: document.getElementById('order-form-product')?.value.trim() || '',
            lot_size: Number(document.getElementById('order-form-lot-size')?.value) || 0,
            batch_number: document.getElementById('order-form-batch')?.value.trim() || '',
            packaging_qty: Number(document.getElementById('order-form-packaging')?.value) || 0,
            customer: document.getElementById('order-form-customer')?.value.trim() || '',
            machine_id: document.getElementById('order-form-machine')?.value || '',
            raw_material: document.getElementById('order-form-mp')?.value || ''
        };
        
        if (!orderData.order_number) {
            showNotification('Informe o número da OP', 'warning');
            return;
        }
        
        if (!orderData.lot_size || orderData.lot_size <= 0) {
            showNotification('Informe o tamanho do lote', 'warning');
            return;
        }
        
        try {
            if (id) {
                await db.collection('production_orders').doc(id).update(orderData);
                showNotification('Ordem atualizada com sucesso!', 'success');
                
                // Registrar log de edição
                registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            } else {
                orderData.status = 'planejada';
                orderData.total_produced = 0;
                orderData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                const docRef = await db.collection('production_orders').add(orderData);
                showNotification('Ordem cadastrada com sucesso!', 'success');
                
                // Registrar log de criação
                registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: docRef.id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            }
            
            closeOrderFormModal();
            await refreshOrders();
            
        } catch (error) {
            console.error('Erro ao salvar ordem:', error);
            showNotification('Erro ao salvar ordem', 'error');
        }
    }
    
    // Inicialização
    function initialize() {
        if (isInitialized) return;
        
        console.log('[OrdersPage] Inicializando módulo...');
        cacheElements();
        setupEventListeners();
        loadOrders();
        isInitialized = true;
    }
    
    // API Pública
    return {
        initialize: initialize,
        refreshOrders: refreshOrders,
        loadOrders: loadOrders,
        activateOrder: activateOrder,
        reactivateOrder: reactivateOrder,
        deleteOrder: deleteOrder,
        editOrder: editOrder,
        openOrderFormModal: openOrderFormModal,
        closeOrderFormModal: closeOrderFormModal
    };
})();

// ============================================================
// FINALIZADOR DE PARADAS - Ativa downtime finalization
// ============================================================
// ============================================================
// Expor funções globalmente
window.OrdersPageModule = OrdersPageModule;
window.openOrderFormModal = function() { OrdersPageModule.openOrderFormModal(); };
window.closeOrderFormModal = function() { OrdersPageModule.closeOrderFormModal(); };

// =====================================================
// FUNÇÕES DE ADMINISTRAÇÃO - LIMPEZA DE DUPLICATAS
// =====================================================

/**
 * Função para detectar e remover planejamentos duplicados
 * Uso no console: await window.cleanDuplicatePlanning('2026-01-06', ['H-05', 'H-28', 'H-12'])
 */
window.cleanDuplicatePlanning = async function(date, machines = null) {
    console.log('🔍 Iniciando busca por planejamentos duplicados...');
    
    if (!date) {
        const hoje = new Date();
        date = hoje.getFullYear() + '-' + 
               String(hoje.getMonth() + 1).padStart(2, '0') + '-' + 
               String(hoje.getDate()).padStart(2, '0');
    }
    
    try {
        let query = db.collection('planning').where('date', '==', date);
        const snapshot = await query.get();
        
        if (snapshot.empty) {
            console.log('Nenhum planejamento encontrado para', date);
            return { found: 0, duplicates: [] };
        }
        
        const plansByMachineAndOrder = {};
        const allPlans = [];
        
        snapshot.docs.forEach(doc => {
            const data = { id: doc.id, ...doc.data() };
            allPlans.push(data);
            
            // Filtrar por máquinas específicas se fornecidas
            if (machines && !machines.includes(data.machine)) return;
            
            const key = `${data.machine}||${data.order_number || 'SEM_OP'}`;
            if (!plansByMachineAndOrder[key]) {
                plansByMachineAndOrder[key] = [];
            }
            plansByMachineAndOrder[key].push(data);
        });
        
        const duplicates = [];
        const toDelete = [];
        
        for (const [key, plans] of Object.entries(plansByMachineAndOrder)) {
            if (plans.length > 1) {
                console.log(`⚠️ DUPLICATA: ${key} - ${plans.length} registros`);
                plans.forEach((p, idx) => {
                    console.log(`   ${idx + 1}. ID: ${p.id} | Produto: ${p.product} | OP: ${p.order_number || '-'} | Criado: ${p.createdAt?.toDate?.() || 'N/A'}`);
                });
                
                // Ordenar por data de criação (manter o mais antigo)
                plans.sort((a, b) => {
                    const aTime = a.createdAt?.toMillis?.() || a.createdAt?._seconds * 1000 || 0;
                    const bTime = b.createdAt?.toMillis?.() || b.createdAt?._seconds * 1000 || 0;
                    return aTime - bTime;
                });
                
                // Marcar todos exceto o primeiro para exclusão
                for (let i = 1; i < plans.length; i++) {
                    toDelete.push(plans[i]);
                    duplicates.push({
                        machine: plans[i].machine,
                        order_number: plans[i].order_number,
                        product: plans[i].product,
                        id: plans[i].id
                    });
                }
            }
        }
        
        console.log(`\n📊 Resumo: ${duplicates.length} duplicatas encontradas para exclusão`);
        
        if (duplicates.length > 0) {
            console.log('\n🗑️ Duplicatas a serem removidas:');
            duplicates.forEach((d, i) => {
                console.log(`   ${i + 1}. ${d.machine} | OP: ${d.order_number} | ${d.product} | ID: ${d.id}`);
            });
            
            const confirm = window.confirm(`Deseja remover ${duplicates.length} planejamentos duplicados?\n\nMáquinas afetadas: ${[...new Set(duplicates.map(d => d.machine))].join(', ')}`);
            
            if (confirm) {
                console.log('\n🔄 Removendo duplicatas...');
                for (const plan of toDelete) {
                    await db.collection('planning').doc(plan.id).delete();
                    console.log(`   ✅ Removido: ${plan.machine} | OP: ${plan.order_number} | ID: ${plan.id}`);
                }
                console.log('\n✅ Limpeza concluída! Recarregue a página para ver as alterações.');
                
                // Forçar atualização dos cards
                if (typeof populateMachineSelector === 'function') {
                    await populateMachineSelector();
                }
            } else {
                console.log('❌ Operação cancelada pelo usuário.');
            }
        }
        
        return { found: allPlans.length, duplicates: duplicates };
        
    } catch (error) {
        console.error('❌ Erro ao buscar duplicatas:', error);
        return { error: error.message };
    }
};

/**
 * Função rápida para limpar duplicatas de hoje
 * Uso no console: await window.cleanTodayDuplicates()
 */
window.cleanTodayDuplicates = async function() {
    const hoje = new Date();
    const date = hoje.getFullYear() + '-' + 
           String(hoje.getMonth() + 1).padStart(2, '0') + '-' + 
           String(hoje.getDate()).padStart(2, '0');
    return await window.cleanDuplicatePlanning(date);
};

/**
 * Função para limpar duplicatas de máquinas específicas hoje
 * Uso no console: await window.cleanMachineDuplicates(['H-05', 'H-28', 'H-12'])
 */
window.cleanMachineDuplicates = async function(machines) {
    const hoje = new Date();
    const date = hoje.getFullYear() + '-' + 
           String(hoje.getMonth() + 1).padStart(2, '0') + '-' + 
           String(hoje.getDate()).padStart(2, '0');
    return await window.cleanDuplicatePlanning(date, machines);
};

console.log('🛠️ Ferramentas de admin carregadas. Use window.cleanTodayDuplicates() ou window.cleanMachineDuplicates([...]) no console.');

// ================================
// MÓDULO: LIDERANÇA PRODUÇÃO
// Escala de máquinas por operador
// ================================

let liderancaProducaoInitialized = false;
let escalaEmEdicao = null; // Armazena o ID da escala sendo editada

// Função auxiliar para obter data de produção (considera turno noturno)
function getLiderancaDateString(date = new Date()) {
    const dateObj = date instanceof Date ? date : new Date(date);
    const hour = dateObj.getHours();
    const minute = dateObj.getMinutes();
    
    // Se for antes das 6h30, pertence ao dia de trabalho anterior
    if (hour < 6 || (hour === 6 && minute < 30)) {
        const prevDay = new Date(dateObj);
        prevDay.setDate(prevDay.getDate() - 1);
        return new Date(prevDay.getTime() - (prevDay.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
    }
    
    return new Date(dateObj.getTime() - (dateObj.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
}

// Função auxiliar de debounce para o módulo
function liderancaDebounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Função auxiliar para obter nome do usuário atual
function getLiderancaCurrentUserName() {
    if (window.authSystem && window.authSystem.getCurrentUser()) {
        return window.authSystem.getCurrentUser().name || 'Sistema';
    }
    return 'Sistema';
}

// Função auxiliar para mostrar notificações/toast
function liderancaShowToast(message, type = 'info') {
    // Tentar usar a função global showNotification
    if (typeof showNotification === 'function') {
        showNotification(message, type);
    } else if (typeof window.showNotification === 'function') {
        window.showNotification(message, type);
    } else {
        // Criar toast visual simples
        const toast = document.createElement('div');
        const bgColor = type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500';
        toast.className = `fixed bottom-4 right-4 ${bgColor} text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all transform translate-y-0 opacity-100`;
        toast.innerHTML = `<div class="flex items-center gap-2"><span>${message}</span></div>`;
        document.body.appendChild(toast);
        
        // Remover após 4 segundos
        setTimeout(() => {
            toast.classList.add('opacity-0', 'translate-y-4');
            setTimeout(() => toast.remove(), 300);
        }, 4000);
        
        console.log(`[Liderança ${type.toUpperCase()}] ${message}`);
    }
}

function setupLiderancaProducaoPage() {
    if (liderancaProducaoInitialized) {
        console.log('[Liderança] Página já inicializada');
        loadEscalas();
        return;
    }

    console.log('[Liderança] Inicializando página...');

    // Definir data padrão como hoje
    const escalaDataInput = document.getElementById('escala-data');
    if (escalaDataInput) {
        escalaDataInput.value = getLiderancaDateString();
    }

    // Botão Nova Escala
    const btnNovaEscala = document.getElementById('btn-nova-escala');
    if (btnNovaEscala) {
        btnNovaEscala.addEventListener('click', openNovaEscalaModal);
    }

    // Botão Buscar
    const btnBuscarEscalas = document.getElementById('btn-buscar-escalas');
    if (btnBuscarEscalas) {
        btnBuscarEscalas.addEventListener('click', loadEscalas);
    }

    // Modal Nova Escala
    setupNovaEscalaModal();

    // Carregar escalas do dia
    loadEscalas();

    liderancaProducaoInitialized = true;
    
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }

    console.log('[Liderança] Página inicializada com sucesso');
}

function setupNovaEscalaModal() {
    const modal = document.getElementById('nova-escala-modal');
    const form = document.getElementById('nova-escala-form');
    const closeBtn = document.getElementById('nova-escala-close');
    const cancelBtn = document.getElementById('nova-escala-cancel');
    const saveBtn = document.getElementById('nova-escala-save');
    const saveContinueBtn = document.getElementById('nova-escala-save-continue');
    const codOperadorInput = document.getElementById('nova-escala-cod-operador');
    const selectAllBtn = document.getElementById('nova-escala-select-all');
    const clearAllBtn = document.getElementById('nova-escala-clear-all');

    // Popular grid de máquinas
    populateNovaEscalaMaquinasGrid();

    // Buscar operador ao digitar código
    if (codOperadorInput) {
        codOperadorInput.addEventListener('input', liderancaDebounce(buscarOperadorEscala, 300));
        codOperadorInput.addEventListener('change', buscarOperadorEscala);
    }

    // Fechar modal
    if (closeBtn) closeBtn.addEventListener('click', closeNovaEscalaModal);
    if (cancelBtn) cancelBtn.addEventListener('click', closeNovaEscalaModal);

    // Salvar escala (fechar após salvar)
    if (saveBtn) saveBtn.addEventListener('click', () => salvarNovaEscala(false));
    
    // Salvar e continuar adicionando
    if (saveContinueBtn) saveContinueBtn.addEventListener('click', () => salvarNovaEscala(true));

    // Selecionar/Limpar todas
    if (selectAllBtn) {
        selectAllBtn.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#nova-escala-maquinas-grid input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            updateMaquinasCount();
        });
    }
    if (clearAllBtn) {
        clearAllBtn.addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('#nova-escala-maquinas-grid input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            updateMaquinasCount();
        });
    }

    // Fechar ao clicar fora
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeNovaEscalaModal();
        });
    }
}

function populateNovaEscalaMaquinasGrid() {
    const grid = document.getElementById('nova-escala-maquinas-grid');
    if (!grid) return;

    // Usar machineDatabase do database.js
    const machines = window.machineDatabase || [];
    
    grid.innerHTML = machines.map(machine => `
        <label class="flex items-center gap-2 p-2 bg-white rounded-lg border border-gray-200 hover:border-violet-400 hover:bg-violet-50 cursor-pointer transition-all">
            <input type="checkbox" name="escala-maquina" value="${machine.id}" 
                   class="rounded border-gray-300 text-violet-600 focus:ring-violet-500"
                   onchange="updateMaquinasCount()">
            <span class="text-sm font-medium text-gray-700">${machine.id}</span>
        </label>
    `).join('');
}

function updateMaquinasCount() {
    const countEl = document.getElementById('nova-escala-count');
    if (!countEl) return;
    
    const checkboxes = document.querySelectorAll('#nova-escala-maquinas-grid input[type="checkbox"]:checked');
    countEl.textContent = `${checkboxes.length} máquinas selecionadas`;
}

function buscarOperadorEscala() {
    const codInput = document.getElementById('nova-escala-cod-operador');
    const nomeInput = document.getElementById('nova-escala-nome-operador');
    const infoEl = document.getElementById('nova-escala-operador-info');
    const erroEl = document.getElementById('nova-escala-operador-erro');

    if (!codInput || !nomeInput || !infoEl || !erroEl) return;

    const codigo = parseInt(codInput.value);
    
    if (isNaN(codigo)) {
        nomeInput.value = '';
        infoEl.classList.add('hidden');
        erroEl.classList.add('hidden');
        return;
    }

    // Buscar no userDatabase
    const users = window.userDatabase || [];
    const operador = users.find(u => u.cod === codigo);

    if (operador) {
        nomeInput.value = operador.nomeCompleto || operador.nomeUsuario;
        infoEl.classList.remove('hidden');
        erroEl.classList.add('hidden');
    } else {
        nomeInput.value = '';
        infoEl.classList.add('hidden');
        erroEl.classList.remove('hidden');
    }
}

// Contador de escalas adicionadas na sessão
let escalasAdicionadasSessao = 0;

function openNovaEscalaModal() {
    const modal = document.getElementById('nova-escala-modal');
    if (!modal) return;

    // Limpar modo de edição e resetar contador
    escalaEmEdicao = null;
    escalasAdicionadasSessao = 0;
    atualizarContadorEscalasSessao();
    
    // Atualizar título do modal
    const modalTitle = modal.querySelector('h3');
    if (modalTitle) modalTitle.textContent = 'Nova Escala de Operador';

    // Definir data padrão
    const dataInput = document.getElementById('nova-escala-data');
    const escalaDataInput = document.getElementById('escala-data');
    if (dataInput) {
        dataInput.value = escalaDataInput?.value || getLiderancaDateString();
    }

    // Limpar form
    const form = document.getElementById('nova-escala-form');
    if (form) form.reset();
    
    // Limpar seleção de máquinas
    const checkboxes = document.querySelectorAll('#nova-escala-maquinas-grid input[type="checkbox"]');
    checkboxes.forEach(cb => cb.checked = false);
    updateMaquinasCount();

    // Limpar info do operador
    const nomeInput = document.getElementById('nova-escala-nome-operador');
    const infoEl = document.getElementById('nova-escala-operador-info');
    const erroEl = document.getElementById('nova-escala-operador-erro');
    if (nomeInput) nomeInput.value = '';
    if (infoEl) infoEl.classList.add('hidden');
    if (erroEl) erroEl.classList.add('hidden');

    // Re-setar data após reset
    if (dataInput) {
        dataInput.value = escalaDataInput?.value || getLiderancaDateString();
    }

    modal.classList.remove('hidden');
    
    // Focar no campo de código do operador
    setTimeout(() => {
        document.getElementById('nova-escala-cod-operador')?.focus();
    }, 100);
    
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// Função para atualizar o contador de escalas na sessão
function atualizarContadorEscalasSessao() {
    const infoEl = document.getElementById('nova-escala-sessao-info');
    const contadorEl = document.getElementById('nova-escala-contador');
    
    if (infoEl && contadorEl) {
        if (escalasAdicionadasSessao > 0) {
            infoEl.classList.remove('hidden');
            contadorEl.textContent = escalasAdicionadasSessao;
        } else {
            infoEl.classList.add('hidden');
        }
    }
}

// Função para limpar apenas operador e máquinas (fluxo contínuo)
function limparFormularioParaProximaEscala() {
    // Limpar código e nome do operador
    const codInput = document.getElementById('nova-escala-cod-operador');
    const nomeInput = document.getElementById('nova-escala-nome-operador');
    const infoEl = document.getElementById('nova-escala-operador-info');
    const erroEl = document.getElementById('nova-escala-operador-erro');
    const obsInput = document.getElementById('nova-escala-obs');
    
    if (codInput) codInput.value = '';
    if (nomeInput) nomeInput.value = '';
    if (infoEl) infoEl.classList.add('hidden');
    if (erroEl) erroEl.classList.add('hidden');
    if (obsInput) obsInput.value = '';
    
    // Limpar seleção de máquinas
    const checkboxes = document.querySelectorAll('#nova-escala-maquinas-grid input[type="checkbox"]');
    checkboxes.forEach(cb => cb.checked = false);
    updateMaquinasCount();
    
    // Focar no campo de código
    setTimeout(() => {
        document.getElementById('nova-escala-cod-operador')?.focus();
    }, 100);
}

// Função para editar uma escala existente
async function editarEscala(escalaId) {
    const modal = document.getElementById('nova-escala-modal');
    if (!modal) return;

    try {
        // Buscar dados da escala no Firestore
        const db = firebase.firestore();
        const doc = await db.collection('escalas_operadores').doc(escalaId).get();
        
        if (!doc.exists) {
            liderancaShowToast('Escala não encontrada', 'error');
            return;
        }

        const escala = doc.data();
        escalaEmEdicao = escalaId;

        // Atualizar título do modal
        const modalTitle = modal.querySelector('h3');
        if (modalTitle) modalTitle.textContent = 'Editar Escala de Operador';

        // Preencher campos do formulário
        const dataInput = document.getElementById('nova-escala-data');
        const turnoInput = document.getElementById('nova-escala-turno');
        const codOperadorInput = document.getElementById('nova-escala-cod-operador');
        const nomeOperadorInput = document.getElementById('nova-escala-nome-operador');
        const obsInput = document.getElementById('nova-escala-obs');

        if (dataInput) dataInput.value = escala.data;
        if (turnoInput) turnoInput.value = escala.turno;
        if (codOperadorInput) codOperadorInput.value = escala.operadorCod;
        if (nomeOperadorInput) nomeOperadorInput.value = escala.operadorNome || escala.operadorUser;
        if (obsInput) obsInput.value = escala.observacoes || '';

        // Mostrar info do operador
        const infoEl = document.getElementById('nova-escala-operador-info');
        const erroEl = document.getElementById('nova-escala-operador-erro');
        if (infoEl) infoEl.classList.remove('hidden');
        if (erroEl) erroEl.classList.add('hidden');

        // Marcar máquinas selecionadas
        const checkboxes = document.querySelectorAll('#nova-escala-maquinas-grid input[type="checkbox"]');
        checkboxes.forEach(cb => {
            cb.checked = (escala.maquinas || []).includes(cb.value);
        });
        updateMaquinasCount();

        modal.classList.remove('hidden');
        
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }

    } catch (error) {
        console.error('[Liderança] Erro ao carregar escala para edição:', error);
        liderancaShowToast('Erro ao carregar escala', 'error');
    }
}

// Expor função globalmente para onclick
window.editarEscala = editarEscala;

function closeNovaEscalaModal() {
    const modal = document.getElementById('nova-escala-modal');
    if (modal) modal.classList.add('hidden');
    escalaEmEdicao = null; // Limpar modo de edição ao fechar
    
    // Se adicionou escalas, atualizar a lista
    if (escalasAdicionadasSessao > 0) {
        loadEscalas();
    }
    escalasAdicionadasSessao = 0;
}

async function salvarNovaEscala(continuarAdicionando = false) {
    const dataInput = document.getElementById('nova-escala-data');
    const turnoInput = document.getElementById('nova-escala-turno');
    const codOperadorInput = document.getElementById('nova-escala-cod-operador');
    const nomeOperadorInput = document.getElementById('nova-escala-nome-operador');
    const obsInput = document.getElementById('nova-escala-obs');

    // Validações
    if (!dataInput?.value) {
        liderancaShowToast('Selecione a data da escala', 'error');
        return;
    }
    if (!turnoInput?.value) {
        liderancaShowToast('Selecione o turno', 'error');
        return;
    }
    if (!codOperadorInput?.value) {
        liderancaShowToast('Informe o código do operador', 'error');
        return;
    }

    const codigo = parseInt(codOperadorInput.value);
    const users = window.userDatabase || [];
    const operador = users.find(u => u.cod === codigo);

    if (!operador) {
        liderancaShowToast('Operador não encontrado no sistema', 'error');
        return;
    }

    // Pegar máquinas selecionadas
    const maquinasSelecionadas = Array.from(
        document.querySelectorAll('#nova-escala-maquinas-grid input[type="checkbox"]:checked')
    ).map(cb => cb.value);

    if (maquinasSelecionadas.length === 0) {
        liderancaShowToast('Selecione pelo menos uma máquina', 'error');
        return;
    }

    // Preparar dados
    const escalaData = {
        data: dataInput.value,
        turno: parseInt(turnoInput.value),
        operadorCod: operador.cod,
        operadorNome: operador.nomeCompleto || operador.nomeUsuario,
        operadorUser: operador.nomeUsuario,
        maquinas: maquinasSelecionadas,
        observacoes: obsInput?.value || '',
        atualizadoEm: firebase.firestore.FieldValue.serverTimestamp()
    };

    // Se não é edição, adicionar campos de criação
    if (!escalaEmEdicao) {
        escalaData.criadoPor = getLiderancaCurrentUserName();
        escalaData.criadoEm = firebase.firestore.FieldValue.serverTimestamp();
    } else {
        escalaData.editadoPor = getLiderancaCurrentUserName();
    }

    try {
        const db = firebase.firestore();
        
        if (escalaEmEdicao) {
            // Modo edição - atualizar documento existente
            await db.collection('escalas_operadores').doc(escalaEmEdicao).update(escalaData);
            liderancaShowToast(`Escala atualizada com sucesso! ${operador.nomeUsuario} → ${maquinasSelecionadas.join(', ')}`, 'success');
            
            // Registrar no histórico
            if (typeof registrarHistorico === 'function') {
                registrarHistorico({
                    tipo: 'escala',
                    acao: 'Edição de Escala',
                    detalhes: `Escala do operador ${operador.nomeUsuario} (${operador.cod}) atualizada. Máquinas: ${maquinasSelecionadas.join(', ')} - Turno ${turnoInput.value}`,
                    usuario: getLiderancaCurrentUserName(),
                    data: dataInput.value
                });
            }
            closeNovaEscalaModal();
            loadEscalas();
        } else {
            // Modo criação - adicionar novo documento
            await db.collection('escalas_operadores').add(escalaData);
            
            // Incrementar contador da sessão
            escalasAdicionadasSessao++;
            atualizarContadorEscalasSessao();
            
            liderancaShowToast(`✓ Escala salva! ${operador.nomeUsuario} → ${maquinasSelecionadas.join(', ')}`, 'success');
            
            // Registrar no histórico
            if (typeof registrarHistorico === 'function') {
                registrarHistorico({
                    tipo: 'escala',
                    acao: 'Cadastro de Escala',
                    detalhes: `Operador ${operador.nomeUsuario} (${operador.cod}) atribuído às máquinas: ${maquinasSelecionadas.join(', ')} - Turno ${turnoInput.value}`,
                    usuario: getLiderancaCurrentUserName(),
                    data: dataInput.value
                });
            }
            
            // Fluxo contínuo ou fechar
            if (continuarAdicionando) {
                limparFormularioParaProximaEscala();
            } else {
                closeNovaEscalaModal();
                loadEscalas();
            }
        }

    } catch (error) {
        console.error('[Liderança] Erro ao salvar escala:', error);
        liderancaShowToast('Erro ao salvar escala: ' + error.message, 'error');
    }
}

async function loadEscalas() {
    const dataInput = document.getElementById('escala-data');
    const turnoSelect = document.getElementById('escala-turno');
    const fluxogramaEl = document.getElementById('escala-fluxograma');
    const listaEl = document.getElementById('escala-lista');

    const data = dataInput?.value || getLiderancaDateString();
    const turnoFiltro = turnoSelect?.value || '';

    console.log('[Liderança] Carregando escalas:', { data, turno: turnoFiltro });

    try {
        const db = firebase.firestore();
        let query = db.collection('escalas_operadores').where('data', '==', data);

        if (turnoFiltro) {
            query = query.where('turno', '==', parseInt(turnoFiltro));
        }

        const snapshot = await query.get();
        const escalas = [];
        
        snapshot.forEach(doc => {
            escalas.push({ id: doc.id, ...doc.data() });
        });

        console.log('[Liderança] Escalas encontradas:', escalas.length);

        // Atualizar estatísticas
        updateEscalaStats(escalas);

        // Renderizar fluxograma
        renderEscalaFluxograma(escalas);

        // Renderizar lista
        renderEscalaLista(escalas);

    } catch (error) {
        console.error('[Liderança] Erro ao carregar escalas:', error);
        liderancaShowToast('Erro ao carregar escalas', 'error');
    }
}

function updateEscalaStats(escalas) {
    const totalOperadores = document.getElementById('escala-total-operadores');
    const totalMaquinas = document.getElementById('escala-total-maquinas');

    // Operadores únicos
    const operadoresUnicos = new Set(escalas.map(e => e.operadorCod));
    if (totalOperadores) totalOperadores.textContent = operadoresUnicos.size;

    // Máquinas cobertas
    const maquinasCobertas = new Set();
    escalas.forEach(e => {
        if (e.maquinas && Array.isArray(e.maquinas)) {
            e.maquinas.forEach(m => maquinasCobertas.add(m));
        }
    });
    if (totalMaquinas) totalMaquinas.textContent = maquinasCobertas.size;
}

function renderEscalaFluxograma(escalas) {
    const container = document.getElementById('escala-fluxograma');
    if (!container) return;

    if (escalas.length === 0) {
        container.innerHTML = `
            <div class="text-center py-12 text-gray-400 col-span-full">
                <i data-lucide="calendar-search" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                <p>Nenhuma escala cadastrada para esta data</p>
            </div>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    const turnoColors = {
        1: { bg: 'bg-amber-50', border: 'border-amber-300', badge: 'bg-amber-500', text: 'text-amber-700' },
        2: { bg: 'bg-sky-50', border: 'border-sky-300', badge: 'bg-sky-500', text: 'text-sky-700' },
        3: { bg: 'bg-violet-50', border: 'border-violet-300', badge: 'bg-violet-500', text: 'text-violet-700' }
    };

    const turnoLabels = { 1: '1º Turno', 2: '2º Turno', 3: '3º Turno' };

    // Agrupar por operador
    const operadoresMap = {};
    escalas.forEach(escala => {
        const key = `${escala.operadorCod}-${escala.turno}`;
        if (!operadoresMap[key]) {
            operadoresMap[key] = {
                cod: escala.operadorCod,
                nome: escala.operadorNome || escala.operadorUser,
                user: escala.operadorUser,
                turno: escala.turno,
                maquinas: []
            };
        }
        operadoresMap[key].maquinas.push(...(escala.maquinas || []));
    });

    // Remover duplicatas de máquinas e ordenar
    Object.values(operadoresMap).forEach(op => {
        op.maquinas = [...new Set(op.maquinas)].sort((a, b) => {
            const numA = parseInt(a.replace(/\D/g, ''));
            const numB = parseInt(b.replace(/\D/g, ''));
            return numA - numB;
        });
    });

    // Ordenar por turno e depois por nome
    const operadoresOrdenados = Object.values(operadoresMap).sort((a, b) => {
        if (a.turno !== b.turno) return a.turno - b.turno;
        return a.nome.localeCompare(b.nome);
    });

    container.innerHTML = operadoresOrdenados.map(op => {
        const colors = turnoColors[op.turno] || turnoColors[1];
        
        return `
            <div class="p-4 rounded-2xl border-2 ${colors.bg} ${colors.border} transition-all hover:shadow-lg hover:-translate-y-1">
                <div class="flex items-center gap-3 mb-3">
                    <div class="w-12 h-12 rounded-xl ${colors.badge} flex items-center justify-center shadow-md">
                        <i data-lucide="user" class="w-6 h-6 text-white"></i>
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="font-bold text-gray-800 text-base truncate">${op.nome}</div>
                        <div class="flex items-center gap-2">
                            <span class="text-xs text-gray-500">Cód: ${op.cod}</span>
                            <span class="px-2 py-0.5 text-[10px] font-bold rounded-full ${colors.badge} text-white">${turnoLabels[op.turno]}</span>
                        </div>
                    </div>
                </div>
                <div class="flex flex-wrap gap-2">
                    ${op.maquinas.map(maq => `
                        <div class="flex items-center gap-1.5 px-3 py-1.5 bg-white rounded-lg border border-gray-200 shadow-sm">
                            <div class="w-5 h-5 rounded bg-emerald-500 flex items-center justify-center">
                                <i data-lucide="cpu" class="w-3 h-3 text-white"></i>
                            </div>
                            <span class="font-semibold text-gray-700 text-sm">${maq}</span>
                        </div>
                    `).join('')}
                </div>
                <div class="mt-3 pt-2 border-t ${colors.border} border-opacity-50 text-xs ${colors.text} font-medium flex items-center gap-1">
                    <i data-lucide="check-circle" class="w-3.5 h-3.5"></i>
                    ${op.maquinas.length} máquina${op.maquinas.length > 1 ? 's' : ''} atribuída${op.maquinas.length > 1 ? 's' : ''}
                </div>
            </div>
        `;
    }).join('');

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

function renderEscalaLista(escalas) {
    const container = document.getElementById('escala-lista');
    if (!container) return;

    if (escalas.length === 0) {
        container.innerHTML = `
            <div class="text-center py-8 text-gray-400">
                <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                <p>Nenhuma escala cadastrada para esta data</p>
            </div>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    const turnoLabels = {
        1: '1º Turno',
        2: '2º Turno',
        3: '3º Turno'
    };

    const turnoColors = {
        1: 'bg-yellow-100 text-yellow-800',
        2: 'bg-blue-100 text-blue-800',
        3: 'bg-purple-100 text-purple-800'
    };

    container.innerHTML = escalas.map(escala => `
        <div class="p-4 bg-white rounded-xl border border-gray-200 hover:shadow-md transition-all">
            <div class="flex items-start justify-between gap-4">
                <div class="flex-1">
                    <div class="flex items-center gap-3 mb-2">
                        <div class="w-10 h-10 rounded-full bg-violet-100 flex items-center justify-center">
                            <i data-lucide="user" class="w-5 h-5 text-violet-600"></i>
                        </div>
                        <div>
                            <div class="font-semibold text-gray-800">${escala.operadorNome || escala.operadorUser}</div>
                            <div class="text-xs text-gray-500">Código: ${escala.operadorCod}</div>
                        </div>
                    </div>
                    <div class="flex flex-wrap gap-2 mt-3">
                        <span class="px-2 py-1 text-xs font-medium rounded-full ${turnoColors[escala.turno] || 'bg-gray-100 text-gray-700'}">
                            ${turnoLabels[escala.turno] || 'Turno ' + escala.turno}
                        </span>
                        ${(escala.maquinas || []).map(m => `
                            <span class="px-2 py-1 text-xs font-medium bg-green-100 text-green-700 rounded-full">${m}</span>
                        `).join('')}
                    </div>
                    ${escala.observacoes ? `
                        <div class="mt-2 text-xs text-gray-500 italic">${escala.observacoes}</div>
                    ` : ''}
                </div>
                <div class="flex flex-col gap-2">
                    <button onclick="editarEscala('${escala.id}')" class="p-2 text-gray-400 hover:text-blue-600 hover:bg-blue-50 rounded-lg transition-colors" title="Editar escala">
                        <i data-lucide="pencil" class="w-4 h-4"></i>
                    </button>
                    <button onclick="excluirEscala('${escala.id}')" class="p-2 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors" title="Excluir escala">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </div>
            </div>
        </div>
    `).join('');

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

async function excluirEscala(escalaId) {
    if (!confirm('Tem certeza que deseja excluir esta escala?')) return;

    try {
        const db = firebase.firestore();
        await db.collection('escalas_operadores').doc(escalaId).delete();
        
        liderancaShowToast('Escala excluída com sucesso', 'success');
        loadEscalas();

    } catch (error) {
        console.error('[Liderança] Erro ao excluir escala:', error);
        liderancaShowToast('Erro ao excluir escala', 'error');
    }
}

// Expor função globalmente para onclick
window.excluirEscala = excluirEscala;

// ================================
// MÓDULO: ABSENTEÍSMO
// Controle de ausências de operadores
// ================================

let absenteismoInitialized = false;
let absChartTipo = null;
let absChartEvolucao = null;
let absChartTurno = null;
let absChartDiaSemana = null;

// Tipos de ausência com labels e cores
const TIPOS_AUSENCIA = {
    'falta_nao_justificada': { label: 'Falta não justificada', color: '#ef4444', bgColor: 'bg-red-100 text-red-700' },
    'atestado': { label: 'Atestado Médico', color: '#eab308', bgColor: 'bg-yellow-100 text-yellow-700' },
    'hokkaido_day': { label: 'Hokkaido Day', color: '#3b82f6', bgColor: 'bg-blue-100 text-blue-700' },
    'folga_aniversario': { label: 'Folga Aniversário', color: '#a855f7', bgColor: 'bg-purple-100 text-purple-700' },
    'ferias': { label: 'Férias', color: '#10b981', bgColor: 'bg-emerald-100 text-emerald-700' },
    'atraso': { label: 'Atraso', color: '#f97316', bgColor: 'bg-orange-100 text-orange-700' },
    'outros': { label: 'Outros', color: '#6b7280', bgColor: 'bg-gray-100 text-gray-700' }
};

// Usuários autorizados a acessar o módulo de Absenteísmo
const USUARIOS_ABSENTEISMO_AUTORIZADOS = [
    'leandro.camargo', 'leandro camargo', 'leandro de camargo',
    'linaldo',
    'luciano',
    'tiago.oliveira', 'tiago oliveira',
    'michelle.benjamin', 'michelle benjamim', 'michelle benjamin',
    'davi.batista', 'davi batista'
];

// Verificar se usuário tem acesso ao absenteísmo
function verificarAcessoAbsenteismo() {
    try {
        const userSession = localStorage.getItem('synchro_user') || sessionStorage.getItem('synchro_user');
        if (!userSession) return false;
        
        const user = JSON.parse(userSession);
        const userName = (user.name || user.username || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        const userLogin = (user.username || '').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        
        return USUARIOS_ABSENTEISMO_AUTORIZADOS.some(autorizado => {
            const autNorm = autorizado.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
            return userName.includes(autNorm) || userLogin.includes(autNorm) || autNorm.includes(userLogin);
        });
    } catch (e) {
        console.error('[Absenteísmo] Erro ao verificar acesso:', e);
        return false;
    }
}

// Função para alternar tabs principais da Liderança
function switchLiderancaTab(tab) {
    console.log('[Liderança] Alternando para tab:', tab);
    
    // Verificar permissão para aba de absenteísmo
    if (tab === 'absenteismo' && !verificarAcessoAbsenteismo()) {
        liderancaShowToast('Você não tem permissão para acessar o módulo de Absenteísmo', 'error');
        return;
    }
    
    // Remover classes ativas de todas as tabs
    document.querySelectorAll('.lideranca-tab').forEach(t => {
        t.classList.remove('border-violet-600', 'text-violet-600', 'bg-white', '-mb-px', 'border-b-2');
        t.classList.add('text-gray-500');
    });

    // Ocultar todos os conteúdos
    document.querySelectorAll('.lideranca-content').forEach(c => c.classList.add('hidden'));

    // Ativar tab selecionada
    const activeTab = document.getElementById(`tab-${tab}`);
    if (activeTab) {
        activeTab.classList.add('border-b-2', 'border-violet-600', 'text-violet-600', 'bg-white', '-mb-px');
        activeTab.classList.remove('text-gray-500');
    }

    // Mostrar conteúdo selecionado
    const content = document.getElementById(`content-${tab}`);
    if (content) {
        content.classList.remove('hidden');
        console.log('[Liderança] Conteúdo exibido:', content.id);
    } else {
        console.error('[Liderança] Conteúdo não encontrado: content-' + tab);
    }

    // Inicializar absenteísmo se necessário
    if (tab === 'absenteismo' && !absenteismoInitialized) {
        initAbsenteismoModule();
    }

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Função para alternar sub-tabs do Absenteísmo
function switchAbsenteismoSubTab(subtab) {
    console.log('[Absenteísmo] Alternando para sub-tab:', subtab);
    
    // Remover classes ativas
    document.querySelectorAll('.absenteismo-subtab').forEach(t => {
        t.classList.remove('border-orange-500', 'text-orange-600', 'bg-white', '-mb-px', 'border-b-2');
        t.classList.add('text-gray-500');
    });

    // Ocultar conteúdos
    document.querySelectorAll('.absenteismo-subcontent').forEach(c => c.classList.add('hidden'));

    // Ativar sub-tab
    const activeSubTab = document.getElementById(`subtab-${subtab}`);
    if (activeSubTab) {
        activeSubTab.classList.add('border-b-2', 'border-orange-500', 'text-orange-600', 'bg-white', '-mb-px');
        activeSubTab.classList.remove('text-gray-500');
    }

    // Mostrar conteúdo
    const subcontent = document.getElementById(`subcontent-${subtab}`);
    if (subcontent) {
        subcontent.classList.remove('hidden');
    }

    // Carregar dados específicos
    if (subtab === 'historico') {
        initHistoricoFiltros();
    } else if (subtab === 'dashboard') {
        atualizarDashboardAbsenteismo();
    }

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Inicializar módulo de absenteísmo
function initAbsenteismoModule() {
    console.log('[Absenteísmo] Inicializando módulo...');

    // Configurar busca de operador por código
    const codInput = document.getElementById('abs-cod-operador');
    if (codInput) {
        codInput.addEventListener('input', liderancaDebounce(buscarOperadorAbsenteismo, 300));
        codInput.addEventListener('change', buscarOperadorAbsenteismo);
    }

    // Data padrão = hoje
    const dataInput = document.getElementById('abs-data');
    if (dataInput) {
        dataInput.value = getLiderancaDateString();
    }

    // Mostrar/ocultar campo de tempo de atraso e férias
    document.querySelectorAll('input[name="abs-tipo"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            const atrasoContainer = document.getElementById('abs-atraso-container');
            const feriasContainer = document.getElementById('abs-ferias-container');
            const dataContainer = document.getElementById('abs-data')?.parentElement;
            
            if (atrasoContainer) {
                atrasoContainer.classList.toggle('hidden', e.target.value !== 'atraso');
            }
            if (feriasContainer) {
                feriasContainer.classList.toggle('hidden', e.target.value !== 'ferias');
            }
            // Ocultar data individual quando for férias (usa período próprio)
            if (dataContainer) {
                dataContainer.style.opacity = e.target.value === 'ferias' ? '0.5' : '1';
                dataContainer.querySelector('input').disabled = e.target.value === 'ferias';
            }
        });
    });

    // Configurar formulário de registro
    const form = document.getElementById('form-absenteismo');
    if (form) {
        form.addEventListener('submit', async (e) => {
            e.preventDefault();
            await registrarAbsenteismo();
        });

        form.addEventListener('reset', () => {
            const nomeInput = document.getElementById('abs-nome-operador');
            const erroEl = document.getElementById('abs-operador-erro');
            const atrasoContainer = document.getElementById('abs-atraso-container');
            const feriasContainer = document.getElementById('abs-ferias-container');
            const dataContainer = document.getElementById('abs-data')?.parentElement;
            
            if (nomeInput) nomeInput.value = '';
            if (erroEl) erroEl.classList.add('hidden');
            if (atrasoContainer) atrasoContainer.classList.add('hidden');
            if (feriasContainer) feriasContainer.classList.add('hidden');
            if (dataContainer) {
                dataContainer.style.opacity = '1';
                dataContainer.querySelector('input').disabled = false;
            }
        });
    }

    absenteismoInitialized = true;
    console.log('[Absenteísmo] Módulo inicializado');
}

// Buscar operador por código
function buscarOperadorAbsenteismo() {
    const codInput = document.getElementById('abs-cod-operador');
    const nomeInput = document.getElementById('abs-nome-operador');
    const erroEl = document.getElementById('abs-operador-erro');

    if (!codInput || !nomeInput || !erroEl) return;

    const codigo = parseInt(codInput.value);

    if (isNaN(codigo) || codigo <= 0) {
        nomeInput.value = '';
        erroEl.classList.add('hidden');
        return;
    }

    // Buscar no userDatabase
    const users = window.userDatabase || [];
    const operador = users.find(u => u.cod === codigo);

    if (operador) {
        nomeInput.value = operador.nomeCompleto || operador.nomeUsuario;
        erroEl.classList.add('hidden');
    } else {
        nomeInput.value = '';
        erroEl.classList.remove('hidden');
    }
}

// Registrar nova ausência
async function registrarAbsenteismo() {
    const codOperador = parseInt(document.getElementById('abs-cod-operador').value);
    const nomeOperador = document.getElementById('abs-nome-operador').value;
    const data = document.getElementById('abs-data').value;
    const turno = document.getElementById('abs-turno').value;
    const tipoRadio = document.querySelector('input[name="abs-tipo"]:checked');
    const tempoAtraso = document.getElementById('abs-tempo-atraso')?.value;
    const observacoes = document.getElementById('abs-observacoes').value.trim();
    const feriasInicio = document.getElementById('abs-ferias-inicio')?.value;
    const feriasFim = document.getElementById('abs-ferias-fim')?.value;

    // Validações
    if (!codOperador || !nomeOperador) {
        liderancaShowToast('Operador inválido ou não encontrado', 'error');
        return;
    }

    if (!tipoRadio) {
        liderancaShowToast('Selecione o tipo de ausência', 'error');
        return;
    }

    const tipo = tipoRadio.value;

    // Validações específicas para férias
    if (tipo === 'ferias') {
        if (!feriasInicio || !feriasFim) {
            liderancaShowToast('Informe o período de férias (início e fim)', 'error');
            return;
        }
        if (feriasInicio > feriasFim) {
            liderancaShowToast('Data de início deve ser anterior à data de fim', 'error');
            return;
        }
        if (!turno) {
            liderancaShowToast('Selecione o turno', 'error');
            return;
        }
        await registrarFeriasMultiplosDias(codOperador, nomeOperador, turno, feriasInicio, feriasFim, observacoes);
        return;
    }

    // Validação para outros tipos
    if (!data || !turno) {
        liderancaShowToast('Preencha todos os campos obrigatórios', 'error');
        return;
    }

    try {
        const db = firebase.firestore();

        // Verificar se já existe registro para este operador na mesma data/turno
        const existente = await db.collection('absenteismo')
            .where('operadorCod', '==', codOperador)
            .where('data', '==', data)
            .where('turno', '==', parseInt(turno))
            .get();

        if (!existente.empty) {
            liderancaShowToast('Já existe registro de ausência para este operador nesta data/turno', 'error');
            return;
        }

        const registro = {
            operadorCod: codOperador,
            operadorNome: nomeOperador,
            data: data,
            turno: parseInt(turno),
            tipo: tipo,
            tipoLabel: TIPOS_AUSENCIA[tipo]?.label || tipo,
            tempoAtraso: tipo === 'atraso' ? (parseInt(tempoAtraso) || 0) : null,
            observacoes: observacoes || null,
            registradoPor: getLiderancaCurrentUserName(),
            criadoEm: firebase.firestore.FieldValue.serverTimestamp(),
            atualizadoEm: firebase.firestore.FieldValue.serverTimestamp()
        };

        await db.collection('absenteismo').add(registro);

        liderancaShowToast('Ausência registrada com sucesso!', 'success');

        // Limpar formulário
        document.getElementById('form-absenteismo').reset();
        document.getElementById('abs-data').value = getLiderancaDateString();

    } catch (error) {
        console.error('[Absenteísmo] Erro ao registrar:', error);
        liderancaShowToast('Erro ao registrar ausência', 'error');
    }
}

// Registrar férias para múltiplos dias
async function registrarFeriasMultiplosDias(codOperador, nomeOperador, turno, dataInicio, dataFim, observacoes) {
    try {
        const db = firebase.firestore();
        const batch = db.batch();
        
        const inicio = new Date(dataInicio + 'T00:00:00');
        const fim = new Date(dataFim + 'T00:00:00');
        const diasRegistrados = [];
        const diasExistentes = [];
        
        const currentDate = new Date(inicio);
        
        while (currentDate <= fim) {
            // Pular fins de semana (0 = domingo, 6 = sábado)
            const diaSemana = currentDate.getDay();
            if (diaSemana !== 0 && diaSemana !== 6) {
                const dataStr = currentDate.toISOString().split('T')[0];
                
                // Verificar se já existe registro
                const existente = await db.collection('absenteismo')
                    .where('operadorCod', '==', codOperador)
                    .where('data', '==', dataStr)
                    .where('turno', '==', parseInt(turno))
                    .get();
                
                if (existente.empty) {
                    const docRef = db.collection('absenteismo').doc();
                    batch.set(docRef, {
                        operadorCod: codOperador,
                        operadorNome: nomeOperador,
                        data: dataStr,
                        turno: parseInt(turno),
                        tipo: 'ferias',
                        tipoLabel: TIPOS_AUSENCIA['ferias'].label,
                        feriasInicio: dataInicio,
                        feriasFim: dataFim,
                        observacoes: observacoes || `Férias de ${formatarDataBR(dataInicio)} a ${formatarDataBR(dataFim)}`,
                        registradoPor: getLiderancaCurrentUserName(),
                        criadoEm: firebase.firestore.FieldValue.serverTimestamp(),
                        atualizadoEm: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    diasRegistrados.push(dataStr);
                } else {
                    diasExistentes.push(dataStr);
                }
            }
            
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        if (diasRegistrados.length > 0) {
            await batch.commit();
        }
        
        // Feedback
        let mensagem = '';
        if (diasRegistrados.length > 0) {
            mensagem = `Férias registradas para ${diasRegistrados.length} dia(s) útil(eis)`;
        }
        if (diasExistentes.length > 0) {
            mensagem += mensagem ? '. ' : '';
            mensagem += `${diasExistentes.length} dia(s) já possuíam registro`;
        }
        
        if (diasRegistrados.length > 0) {
            liderancaShowToast(mensagem, 'success');
        } else {
            liderancaShowToast('Nenhum dia foi registrado (todos já possuem registro)', 'warning');
        }

        // Limpar formulário
        document.getElementById('form-absenteismo').reset();
        document.getElementById('abs-data').value = getLiderancaDateString();
        document.getElementById('abs-ferias-container')?.classList.add('hidden');

    } catch (error) {
        console.error('[Absenteísmo] Erro ao registrar férias:', error);
        liderancaShowToast('Erro ao registrar férias', 'error');
    }
}

// Formatar data para BR
function formatarDataBR(dataStr) {
    if (!dataStr) return '';
    const [ano, mes, dia] = dataStr.split('-');
    return `${dia}/${mes}/${ano}`;
}

// Inicializar filtros do histórico
function initHistoricoFiltros() {
    const dataInicio = document.getElementById('abs-hist-data-inicio');
    const dataFim = document.getElementById('abs-hist-data-fim');

    if (dataInicio && dataFim) {
        const hoje = new Date();
        const trintaDiasAtras = new Date();
        trintaDiasAtras.setDate(hoje.getDate() - 30);

        dataFim.value = getLiderancaDateString(hoje);
        dataInicio.value = getLiderancaDateString(trintaDiasAtras);
    }
}

// Buscar histórico de absenteísmo
async function buscarHistoricoAbsenteismo() {
    const dataInicio = document.getElementById('abs-hist-data-inicio').value;
    const dataFim = document.getElementById('abs-hist-data-fim').value;
    const tipo = document.getElementById('abs-hist-tipo').value;
    const codOperador = document.getElementById('abs-hist-cod').value;

    if (!dataInicio || !dataFim) {
        liderancaShowToast('Selecione o período', 'error');
        return;
    }

    try {
        const db = firebase.firestore();
        let query = db.collection('absenteismo')
            .where('data', '>=', dataInicio)
            .where('data', '<=', dataFim)
            .orderBy('data', 'desc');

        const snapshot = await query.get();
        let registros = [];

        snapshot.forEach(doc => {
            const data = { id: doc.id, ...doc.data() };
            
            // Filtrar por tipo (client-side)
            if (tipo && data.tipo !== tipo) return;
            
            // Filtrar por código (client-side)
            if (codOperador && data.operadorCod !== parseInt(codOperador)) return;
            
            registros.push(data);
        });

        // Atualizar estatísticas
        atualizarEstatisticasHistorico(registros);

        // Renderizar lista
        renderizarListaHistorico(registros);

    } catch (error) {
        console.error('[Absenteísmo] Erro ao buscar histórico:', error);
        liderancaShowToast('Erro ao buscar histórico', 'error');
    }
}

// Atualizar estatísticas do histórico
function atualizarEstatisticasHistorico(registros) {
    const stats = {
        falta: 0,
        atestado: 0,
        hokkaido: 0,
        aniversario: 0,
        atraso: 0,
        total: registros.length
    };

    registros.forEach(r => {
        switch (r.tipo) {
            case 'falta_nao_justificada': stats.falta++; break;
            case 'atestado': stats.atestado++; break;
            case 'hokkaido_day': stats.hokkaido++; break;
            case 'folga_aniversario': stats.aniversario++; break;
            case 'atraso': stats.atraso++; break;
        }
    });

    document.getElementById('abs-stat-falta').textContent = stats.falta;
    document.getElementById('abs-stat-atestado').textContent = stats.atestado;
    document.getElementById('abs-stat-hokkaido').textContent = stats.hokkaido;
    document.getElementById('abs-stat-aniversario').textContent = stats.aniversario;
    document.getElementById('abs-stat-atraso').textContent = stats.atraso;
    document.getElementById('abs-stat-total').textContent = stats.total;
}

// Renderizar lista do histórico
function renderizarListaHistorico(registros) {
    const tbody = document.getElementById('abs-historico-lista');
    if (!tbody) return;

    if (registros.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="6" class="text-center py-12 text-gray-400">
                    <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                    <p>Nenhum registro encontrado para o período</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    const turnoLabels = { 1: '1º Turno', 2: '2º Turno', 3: '3º Turno' };

    tbody.innerHTML = registros.map(r => {
        const tipoInfo = TIPOS_AUSENCIA[r.tipo] || { label: r.tipo, bgColor: 'bg-gray-100 text-gray-700' };
        const dataFormatada = r.data.split('-').reverse().join('/');
        
        return `
            <tr class="border-b border-gray-100 hover:bg-gray-50">
                <td class="p-3 font-medium">${dataFormatada}</td>
                <td class="p-3">
                    <div class="font-medium text-gray-800">${r.operadorNome}</div>
                    <div class="text-xs text-gray-500">Cód: ${r.operadorCod}</div>
                </td>
                <td class="p-3 text-sm">${turnoLabels[r.turno] || r.turno}</td>
                <td class="p-3">
                    <span class="px-2 py-1 text-xs font-medium rounded-full ${tipoInfo.bgColor}">
                        ${tipoInfo.label}
                    </span>
                    ${r.tipo === 'atraso' && r.tempoAtraso ? `<span class="ml-1 text-xs text-gray-500">(${r.tempoAtraso} min)</span>` : ''}
                </td>
                <td class="p-3 text-sm text-gray-600 max-w-xs truncate">${r.observacoes || '-'}</td>
                <td class="p-3 text-center">
                    <button onclick="excluirAbsenteismo('${r.id}')" class="p-1.5 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded transition" title="Excluir">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </td>
            </tr>
        `;
    }).join('');

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Excluir registro de absenteísmo
async function excluirAbsenteismo(id) {
    if (!confirm('Tem certeza que deseja excluir este registro?')) return;

    try {
        const db = firebase.firestore();
        await db.collection('absenteismo').doc(id).delete();
        
        liderancaShowToast('Registro excluído com sucesso', 'success');
        buscarHistoricoAbsenteismo();

    } catch (error) {
        console.error('[Absenteísmo] Erro ao excluir:', error);
        liderancaShowToast('Erro ao excluir registro', 'error');
    }
}

// Atualizar dashboard de absenteísmo
async function atualizarDashboardAbsenteismo() {
    const periodoSelect = document.getElementById('abs-dash-periodo')?.value;
    const filtroTurno = document.getElementById('abs-dash-turno')?.value;
    const filtroTipo = document.getElementById('abs-dash-tipo')?.value;
    
    let dataInicioStr, dataFimStr;
    let periodo;
    
    // Período personalizado ou predefinido
    if (periodoSelect === 'custom') {
        dataInicioStr = document.getElementById('abs-dash-custom-inicio')?.value;
        dataFimStr = document.getElementById('abs-dash-custom-fim')?.value;
        
        if (!dataInicioStr || !dataFimStr) {
            liderancaShowToast('Selecione as datas do período personalizado', 'error');
            return;
        }
        
        const inicio = new Date(dataInicioStr);
        const fim = new Date(dataFimStr);
        periodo = Math.ceil((fim - inicio) / (1000 * 60 * 60 * 24)) + 1;
    } else {
        periodo = parseInt(periodoSelect || 30);
        const dataFim = new Date();
        const dataInicio = new Date();
        dataInicio.setDate(dataInicio.getDate() - periodo);
        
        dataInicioStr = getLiderancaDateString(dataInicio);
        dataFimStr = getLiderancaDateString(dataFim);
    }

    try {
        const db = firebase.firestore();
        const snapshot = await db.collection('absenteismo')
            .where('data', '>=', dataInicioStr)
            .where('data', '<=', dataFimStr)
            .orderBy('data', 'asc')
            .get();

        let registros = [];
        snapshot.forEach(doc => registros.push({ id: doc.id, ...doc.data() }));

        // Aplicar filtro por turno (client-side)
        if (filtroTurno) {
            registros = registros.filter(r => r.turno === parseInt(filtroTurno));
        }
        
        // Aplicar filtro por tipo (client-side)
        if (filtroTipo) {
            registros = registros.filter(r => r.tipo === filtroTipo);
        }

        // Calcular métricas
        const totalOperadores = (window.userDatabase || []).length;
        const colaboradoresAfetados = new Set(registros.map(r => r.operadorCod)).size;
        const totalOcorrencias = registros.length;
        const mediaDiaria = periodo > 0 ? (totalOcorrencias / periodo).toFixed(1) : 0;
        const taxaAbsenteismo = totalOperadores > 0 ? ((colaboradoresAfetados / totalOperadores) * 100).toFixed(1) : 0;

        // Atualizar cards
        document.getElementById('abs-dash-taxa').textContent = `${taxaAbsenteismo}%`;
        document.getElementById('abs-dash-total').textContent = totalOcorrencias;
        document.getElementById('abs-dash-colaboradores').textContent = colaboradoresAfetados;
        document.getElementById('abs-dash-media').textContent = mediaDiaria;

        // Gerar gráficos
        gerarGraficoPorTipo(registros);
        gerarGraficoEvolucao(registros, periodo, dataInicioStr);
        gerarGraficoPorTurno(registros);
        gerarGraficoDiaSemana(registros);
        gerarTopOperadores(registros);

    } catch (error) {
        console.error('[Absenteísmo] Erro ao atualizar dashboard:', error);
        liderancaShowToast('Erro ao carregar dashboard', 'error');
    }
}

// Toggle período personalizado
function togglePeriodoPersonalizado() {
    const periodo = document.getElementById('abs-dash-periodo')?.value;
    const inicioContainer = document.getElementById('abs-dash-custom-inicio-container');
    const fimContainer = document.getElementById('abs-dash-custom-fim-container');
    
    const isCustom = periodo === 'custom';
    
    if (inicioContainer) inicioContainer.classList.toggle('hidden', !isCustom);
    if (fimContainer) fimContainer.classList.toggle('hidden', !isCustom);
    
    // Auto-atualizar se não for personalizado
    if (!isCustom) {
        atualizarDashboardAbsenteismo();
    }
}
window.togglePeriodoPersonalizado = togglePeriodoPersonalizado;

// Gráfico de pizza - Distribuição por tipo
function gerarGraficoPorTipo(registros) {
    const ctx = document.getElementById('abs-chart-tipo');
    if (!ctx) return;

    // Contar por tipo
    const contagem = {};
    Object.keys(TIPOS_AUSENCIA).forEach(tipo => contagem[tipo] = 0);
    registros.forEach(r => {
        if (contagem.hasOwnProperty(r.tipo)) contagem[r.tipo]++;
    });

    const labels = [];
    const data = [];
    const colors = [];

    Object.entries(TIPOS_AUSENCIA).forEach(([key, info]) => {
        if (contagem[key] > 0) {
            labels.push(info.label);
            data.push(contagem[key]);
            colors.push(info.color);
        }
    });

    // Destruir gráfico existente
    if (absChartTipo) absChartTipo.destroy();

    if (data.length === 0) {
        ctx.parentElement.innerHTML = '<div class="h-64 flex items-center justify-center text-gray-400">Sem dados para o período</div>';
        return;
    }

    absChartTipo = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: labels,
            datasets: [{
                data: data,
                backgroundColor: colors,
                borderWidth: 2,
                borderColor: '#fff'
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    position: 'right',
                    labels: { font: { size: 11 } }
                }
            }
        }
    });
}

// Gráfico de linha - Evolução temporal
function gerarGraficoEvolucao(registros, periodo, dataInicioStr = null) {
    const ctx = document.getElementById('abs-chart-evolucao');
    if (!ctx) return;

    // Agrupar por data
    const contagemDiaria = {};
    registros.forEach(r => {
        contagemDiaria[r.data] = (contagemDiaria[r.data] || 0) + 1;
    });

    // Gerar labels para o período
    const labels = [];
    const data = [];
    
    const startDate = dataInicioStr ? new Date(dataInicioStr + 'T00:00:00') : (() => {
        const d = new Date();
        d.setDate(d.getDate() - periodo + 1);
        return d;
    })();
    
    for (let i = 0; i < periodo; i++) {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + i);
        const dateStr = getLiderancaDateString(date);
        const displayDate = date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
        labels.push(displayDate);
        data.push(contagemDiaria[dateStr] || 0);
    }

    if (absChartEvolucao) absChartEvolucao.destroy();

    absChartEvolucao = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Ausências',
                data: data,
                borderColor: '#8b5cf6',
                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                fill: true,
                tension: 0.3,
                pointRadius: periodo > 30 ? 0 : 3,
                pointHoverRadius: 5
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    ticks: {
                        maxTicksLimit: 15,
                        font: { size: 10 }
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: { stepSize: 1 }
                }
            },
            plugins: {
                legend: { display: false }
            }
        }
    });
}

// Gráfico de barras - Por turno
function gerarGraficoPorTurno(registros) {
    const ctx = document.getElementById('abs-chart-turno');
    if (!ctx) return;

    const contagem = { 1: 0, 2: 0, 3: 0 };
    registros.forEach(r => {
        if (contagem.hasOwnProperty(r.turno)) contagem[r.turno]++;
    });

    if (absChartTurno) absChartTurno.destroy();

    absChartTurno = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: ['1º Turno', '2º Turno', '3º Turno'],
            datasets: [{
                label: 'Ausências',
                data: [contagem[1], contagem[2], contagem[3]],
                backgroundColor: ['#fbbf24', '#3b82f6', '#8b5cf6'],
                borderRadius: 8
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: { stepSize: 1 }
                }
            },
            plugins: {
                legend: { display: false }
            }
        }
    });
}

// Gráfico de barras - Por dia da semana
function gerarGraficoDiaSemana(registros) {
    const ctx = document.getElementById('abs-chart-diasemana');
    if (!ctx) return;

    const diasSemana = ['Domingo', 'Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado'];
    const contagem = [0, 0, 0, 0, 0, 0, 0];

    registros.forEach(r => {
        const [ano, mes, dia] = r.data.split('-').map(Number);
        const date = new Date(ano, mes - 1, dia);
        const diaSemana = date.getDay();
        contagem[diaSemana]++;
    });

    if (absChartDiaSemana) absChartDiaSemana.destroy();

    absChartDiaSemana = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: diasSemana,
            datasets: [{
                label: 'Ausências',
                data: contagem,
                backgroundColor: [
                    '#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899'
                ],
                borderRadius: 6
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: { stepSize: 1 }
                }
            },
            plugins: {
                legend: { display: false }
            }
        }
    });
}

// Gerar tabela top operadores
function gerarTopOperadores(registros) {
    const table = document.getElementById('abs-top-operadores');
    if (!table) return;

    // Filtrar registros - EXCLUIR FÉRIAS do top de ausências
    // Férias é um direito do trabalhador, não deve ser contabilizado como "ausência problemática"
    const registrosSemFerias = registros.filter(r => r.tipo !== 'ferias');

    // Contar por operador (sem férias)
    const contagem = {};
    registrosSemFerias.forEach(r => {
        const key = r.operadorCod;
        if (!contagem[key]) {
            contagem[key] = { cod: r.operadorCod, nome: r.operadorNome, total: 0 };
        }
        contagem[key].total++;
    });

    // Ordenar e pegar top 10
    const ranking = Object.values(contagem)
        .sort((a, b) => b.total - a.total)
        .slice(0, 10);

    const tbody = table.querySelector('tbody');
    if (!tbody) return;

    if (ranking.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" class="text-center py-8 text-gray-400">Sem dados para o período</td></tr>';
        return;
    }

    tbody.innerHTML = ranking.map((op, idx) => `
        <tr class="border-b border-gray-100 hover:bg-gray-50">
            <td class="p-2 font-bold ${idx < 3 ? 'text-red-500' : 'text-gray-500'}">${idx + 1}º</td>
            <td class="p-2">
                <div class="font-medium text-gray-800">${op.nome}</div>
                <div class="text-xs text-gray-500">Cód: ${op.cod}</div>
            </td>
            <td class="p-2 text-center">
                <span class="px-3 py-1 bg-red-100 text-red-700 font-bold rounded-full">${op.total}</span>
            </td>
        </tr>
    `).join('');
}

// Expor funções globalmente para onclick
window.switchLiderancaTab = switchLiderancaTab;
window.switchAbsenteismoSubTab = switchAbsenteismoSubTab;
window.buscarHistoricoAbsenteismo = buscarHistoricoAbsenteismo;
window.excluirAbsenteismo = excluirAbsenteismo;
window.atualizarDashboardAbsenteismo = atualizarDashboardAbsenteismo;
window.togglePeriodoPersonalizado = togglePeriodoPersonalizado;
window.verificarAcessoAbsenteismo = verificarAcessoAbsenteismo;

// Ocultar aba de absenteísmo para usuários não autorizados
function ocultarAbaAbsenteismoNaoAutorizado() {
    const tabAbsenteismo = document.getElementById('tab-absenteismo');
    if (tabAbsenteismo && !verificarAcessoAbsenteismo()) {
        tabAbsenteismo.style.display = 'none';
        console.log('[Absenteísmo] Aba ocultada - usuário sem permissão');
    }
}

// Inicializar verificação de acesso ao absenteísmo quando DOM estiver pronto
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(ocultarAbaAbsenteismoNaoAutorizado, 500);
});

// ================================
// FIM DO MÓDULO LIDERANÇA PRODUÇÃO
// ================================

// =========================================
// INÍCIO DO MÓDULO SETUP DE MÁQUINAS
// =========================================

let setupEmEdicao = null;

// Função auxiliar para mostrar toast
function setupShowToast(message, type = 'info') {
    if (typeof showToast === 'function') {
        showToast(message, type);
    } else if (window.authSystem && typeof window.authSystem.showToast === 'function') {
        window.authSystem.showToast(message, type);
    } else {
        const toast = document.createElement('div');
        toast.className = `fixed bottom-4 right-4 px-4 py-3 rounded-lg shadow-lg z-[9999] text-white font-medium ${
            type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500'
        }`;
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }
}

// Função para obter data no formato ISO
function getSetupDateString(date) {
    const d = date || new Date();
    const year = d.getFullYear();
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const day = String(d.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Função para obter usuário atual
function getSetupCurrentUserName() {
    if (window.authSystem && window.authSystem.currentUser) {
        return window.authSystem.currentUser.nome || window.authSystem.currentUser.usuario || 'Sistema';
    }
    const userData = localStorage.getItem('userSession');
    if (userData) {
        try {
            const user = JSON.parse(userData);
            return user.nome || user.usuario || 'Sistema';
        } catch (e) {}
    }
    return 'Sistema';
}

// Inicializar página de Setup
function setupSetupMaquinasPage() {
    console.log('[Setup] Inicializando módulo de Setup de Máquinas');
    
    const page = document.getElementById('setup-maquinas-page');
    if (!page) return;

    // Definir data padrão nos filtros (últimos 7 dias)
    const dataInicio = document.getElementById('setup-data-inicio');
    const dataFim = document.getElementById('setup-data-fim');
    
    if (dataInicio && dataFim) {
        const hoje = new Date();
        const seteDiasAtras = new Date();
        seteDiasAtras.setDate(hoje.getDate() - 7);
        
        dataFim.value = getSetupDateString(hoje);
        dataInicio.value = getSetupDateString(seteDiasAtras);
    }

    // Popular select de máquinas
    popularSelectMaquinas();

    // Configurar modal
    setupNovoSetupModal();

    // Configurar botão buscar
    const btnBuscar = document.getElementById('btn-buscar-setups');
    if (btnBuscar) {
        btnBuscar.addEventListener('click', loadSetups);
    }

    // Carregar setups iniciais
    loadSetups();
}

// Popular select de máquinas
function popularSelectMaquinas() {
    const selectModal = document.getElementById('novo-setup-maquina');
    const selectFiltro = document.getElementById('setup-filtro-maquina');
    const machines = window.machineDatabase || [];

    const options = machines.map(m => `<option value="${m.id}">${m.id} - ${m.model}</option>`).join('');

    if (selectModal) {
        selectModal.innerHTML = '<option value="">Selecione a máquina</option>' + options;
    }
    if (selectFiltro) {
        selectFiltro.innerHTML = '<option value="">Todas as máquinas</option>' + options;
    }
}

// Configurar modal de novo setup
function setupNovoSetupModal() {
    const modal = document.getElementById('novo-setup-modal');
    const btnNovo = document.getElementById('btn-novo-setup');
    const btnClose = document.getElementById('novo-setup-close');
    const btnCancel = document.getElementById('novo-setup-cancel');
    const btnSave = document.getElementById('novo-setup-save');
    const horaInicio = document.getElementById('novo-setup-hora-inicio');
    const horaFim = document.getElementById('novo-setup-hora-fim');

    if (!modal) return;

    // Abrir modal
    if (btnNovo) {
        btnNovo.addEventListener('click', () => {
            setupEmEdicao = null;
            document.getElementById('setup-modal-titulo').textContent = 'Novo Registro de Setup';
            document.getElementById('novo-setup-form').reset();
            document.getElementById('novo-setup-data').value = getSetupDateString();
            document.getElementById('novo-setup-duracao').textContent = '';
            modal.classList.remove('hidden');
            if (typeof lucide !== 'undefined') lucide.createIcons();
        });
    }

    // Fechar modal
    const fecharModal = () => {
        modal.classList.add('hidden');
        setupEmEdicao = null;
    };

    if (btnClose) btnClose.addEventListener('click', fecharModal);
    if (btnCancel) btnCancel.addEventListener('click', fecharModal);
    
    modal.addEventListener('click', (e) => {
        if (e.target === modal) fecharModal();
    });

    // Calcular duração
    const calcularDuracao = () => {
        const inicio = horaInicio?.value;
        const fim = horaFim?.value;
        const duracaoSpan = document.getElementById('novo-setup-duracao');
        
        if (inicio && fim && duracaoSpan) {
            const [hI, mI] = inicio.split(':').map(Number);
            const [hF, mF] = fim.split(':').map(Number);
            
            let minutos = (hF * 60 + mF) - (hI * 60 + mI);
            if (minutos < 0) minutos += 24 * 60; // Passou da meia-noite
            
            const horas = Math.floor(minutos / 60);
            const mins = minutos % 60;
            
            if (horas > 0) {
                duracaoSpan.textContent = `Duração: ${horas}h ${mins}min`;
            } else {
                duracaoSpan.textContent = `Duração: ${mins} minutos`;
            }
        }
    };

    if (horaInicio) horaInicio.addEventListener('change', calcularDuracao);
    if (horaFim) horaFim.addEventListener('change', calcularDuracao);

    // Salvar
    if (btnSave) {
        btnSave.addEventListener('click', salvarSetup);
    }
}

// Salvar setup
async function salvarSetup() {
    const data = document.getElementById('novo-setup-data')?.value;
    const maquina = document.getElementById('novo-setup-maquina')?.value;
    const molde = document.getElementById('novo-setup-molde')?.value?.trim();
    const tipo = document.querySelector('input[name="setup-tipo"]:checked')?.value;
    const horaInicio = document.getElementById('novo-setup-hora-inicio')?.value;
    const horaFim = document.getElementById('novo-setup-hora-fim')?.value;
    const observacao = document.getElementById('novo-setup-obs')?.value?.trim() || '';

    // Validações
    if (!data || !maquina || !molde || !tipo || !horaInicio || !horaFim) {
        setupShowToast('Preencha todos os campos obrigatórios', 'error');
        return;
    }

    // Calcular duração em minutos
    const [hI, mI] = horaInicio.split(':').map(Number);
    const [hF, mF] = horaFim.split(':').map(Number);
    let duracaoMinutos = (hF * 60 + mF) - (hI * 60 + mI);
    if (duracaoMinutos < 0) duracaoMinutos += 24 * 60;

    try {
        const db = firebase.firestore();
        const dadosSetup = {
            data,
            maquina,
            molde,
            tipo,
            horaInicio,
            horaFim,
            duracaoMinutos,
            observacao,
            criadoPor: getSetupCurrentUserName(),
            atualizadoEm: firebase.firestore.FieldValue.serverTimestamp()
        };

        if (setupEmEdicao) {
            // Atualizar
            await db.collection('setups_maquinas').doc(setupEmEdicao).update(dadosSetup);
            setupShowToast('Setup atualizado com sucesso!', 'success');
        } else {
            // Criar novo
            dadosSetup.criadoEm = firebase.firestore.FieldValue.serverTimestamp();
            await db.collection('setups_maquinas').add(dadosSetup);
            setupShowToast('Setup registrado com sucesso!', 'success');
        }

        document.getElementById('novo-setup-modal').classList.add('hidden');
        setupEmEdicao = null;
        loadSetups();

    } catch (error) {
        console.error('[Setup] Erro ao salvar:', error);
        setupShowToast('Erro ao salvar setup', 'error');
    }
}

// Carregar setups
async function loadSetups() {
    const dataInicio = document.getElementById('setup-data-inicio')?.value;
    const dataFim = document.getElementById('setup-data-fim')?.value;
    const filtroMaquina = document.getElementById('setup-filtro-maquina')?.value;
    const filtroTipo = document.getElementById('setup-filtro-tipo')?.value;

    if (!dataInicio || !dataFim) {
        setupShowToast('Selecione o período para buscar', 'error');
        return;
    }

    try {
        const db = firebase.firestore();
        let query = db.collection('setups_maquinas')
            .where('data', '>=', dataInicio)
            .where('data', '<=', dataFim)
            .orderBy('data', 'desc');

        const snapshot = await query.get();
        let setups = [];

        snapshot.forEach(doc => {
            const data = doc.data();
            // Aplicar filtros adicionais
            if (filtroMaquina && data.maquina !== filtroMaquina) return;
            if (filtroTipo && data.tipo !== filtroTipo) return;
            
            setups.push({ id: doc.id, ...data });
        });

        // Ordenar por data e hora
        setups.sort((a, b) => {
            if (a.data !== b.data) return b.data.localeCompare(a.data);
            return b.horaInicio.localeCompare(a.horaInicio);
        });

        renderSetupStats(setups);
        renderSetupTabela(setups);

    } catch (error) {
        console.error('[Setup] Erro ao carregar:', error);
        setupShowToast('Erro ao carregar setups', 'error');
    }
}

// Renderizar estatísticas
function renderSetupStats(setups) {
    const totalEl = document.getElementById('setup-total');
    const planejadosEl = document.getElementById('setup-planejados');
    const naoPlanejadosEl = document.getElementById('setup-nao-planejados');
    const tempoMedioEl = document.getElementById('setup-tempo-medio');

    const planejados = setups.filter(s => s.tipo === 'planejado');
    const naoPlanejados = setups.filter(s => s.tipo === 'nao_planejado');
    
    const tempoTotal = setups.reduce((acc, s) => acc + (s.duracaoMinutos || 0), 0);
    const tempoMedio = setups.length > 0 ? Math.round(tempoTotal / setups.length) : 0;

    if (totalEl) totalEl.textContent = setups.length;
    if (planejadosEl) planejadosEl.textContent = planejados.length;
    if (naoPlanejadosEl) naoPlanejadosEl.textContent = naoPlanejados.length;
    if (tempoMedioEl) tempoMedioEl.textContent = `${tempoMedio}min`;
}

// Renderizar tabela
function renderSetupTabela(setups) {
    const tbody = document.getElementById('setup-tabela-body');
    if (!tbody) return;

    if (setups.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="9" class="text-center py-12 text-gray-400">
                    <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                    <p>Nenhum registro de setup encontrado</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }

    tbody.innerHTML = setups.map(setup => {
        const dataFormatada = setup.data ? setup.data.split('-').reverse().join('/') : '';
        const tipoLabel = setup.tipo === 'planejado' ? 'Planejado' : 'Não Planejado';
        const tipoClass = setup.tipo === 'planejado' 
            ? 'bg-green-100 text-green-800' 
            : 'bg-red-100 text-red-800';
        
        // Formatar duração
        const horas = Math.floor((setup.duracaoMinutos || 0) / 60);
        const mins = (setup.duracaoMinutos || 0) % 60;
        const duracaoFormatada = horas > 0 ? `${horas}h ${mins}min` : `${mins}min`;

        return `
            <tr class="hover:bg-gray-50 transition-colors">
                <td class="px-4 py-3 text-sm font-medium text-gray-800">${dataFormatada}</td>
                <td class="px-4 py-3">
                    <span class="inline-flex items-center gap-1.5 px-2 py-1 bg-blue-100 text-blue-800 rounded-lg text-xs font-bold">
                        <i data-lucide="cpu" class="w-3 h-3"></i>
                        ${setup.maquina}
                    </span>
                </td>
                <td class="px-4 py-3 text-sm text-gray-700">${setup.molde || '-'}</td>
                <td class="px-4 py-3 text-center">
                    <span class="px-2 py-1 rounded-full text-xs font-semibold ${tipoClass}">${tipoLabel}</span>
                </td>
                <td class="px-4 py-3 text-center text-sm font-medium text-gray-700">${setup.horaInicio || '-'}</td>
                <td class="px-4 py-3 text-center text-sm font-medium text-gray-700">${setup.horaFim || '-'}</td>
                <td class="px-4 py-3 text-center">
                    <span class="px-2 py-1 bg-orange-100 text-orange-700 rounded-lg text-xs font-bold">${duracaoFormatada}</span>
                </td>
                <td class="px-4 py-3 text-sm text-gray-600 max-w-xs truncate" title="${setup.observacao || ''}">${setup.observacao || '-'}</td>
                <td class="px-4 py-3 text-center">
                    <div class="flex items-center justify-center gap-1">
                        <button onclick="editarSetup('${setup.id}')" class="p-1.5 text-blue-600 hover:bg-blue-100 rounded-lg transition" title="Editar">
                            <i data-lucide="pencil" class="w-4 h-4"></i>
                        </button>
                        <button onclick="excluirSetup('${setup.id}')" class="p-1.5 text-red-600 hover:bg-red-100 rounded-lg transition" title="Excluir">
                            <i data-lucide="trash-2" class="w-4 h-4"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');

    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Editar setup
async function editarSetup(setupId) {
    try {
        const db = firebase.firestore();
        const doc = await db.collection('setups_maquinas').doc(setupId).get();
        
        if (!doc.exists) {
            setupShowToast('Setup não encontrado', 'error');
            return;
        }

        const setup = doc.data();
        setupEmEdicao = setupId;

        // Preencher formulário
        document.getElementById('setup-modal-titulo').textContent = 'Editar Registro de Setup';
        document.getElementById('novo-setup-data').value = setup.data || '';
        document.getElementById('novo-setup-maquina').value = setup.maquina || '';
        document.getElementById('novo-setup-molde').value = setup.molde || '';
        document.getElementById('novo-setup-hora-inicio').value = setup.horaInicio || '';
        document.getElementById('novo-setup-hora-fim').value = setup.horaFim || '';
        document.getElementById('novo-setup-obs').value = setup.observacao || '';

        // Selecionar tipo
        const tipoRadio = document.querySelector(`input[name="setup-tipo"][value="${setup.tipo}"]`);
        if (tipoRadio) tipoRadio.checked = true;

        // Calcular duração
        const horas = Math.floor((setup.duracaoMinutos || 0) / 60);
        const mins = (setup.duracaoMinutos || 0) % 60;
        const duracaoSpan = document.getElementById('novo-setup-duracao');
        if (duracaoSpan) {
            duracaoSpan.textContent = horas > 0 ? `Duração: ${horas}h ${mins}min` : `Duração: ${mins} minutos`;
        }

        // Abrir modal
        document.getElementById('novo-setup-modal').classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();

    } catch (error) {
        console.error('[Setup] Erro ao carregar para edição:', error);
        setupShowToast('Erro ao carregar setup', 'error');
    }
}

// Excluir setup
async function excluirSetup(setupId) {
    if (!confirm('Tem certeza que deseja excluir este registro de setup?')) return;

    try {
        const db = firebase.firestore();
        await db.collection('setups_maquinas').doc(setupId).delete();
        
        setupShowToast('Setup excluído com sucesso', 'success');
        loadSetups();

    } catch (error) {
        console.error('[Setup] Erro ao excluir:', error);
        setupShowToast('Erro ao excluir setup', 'error');
    }
}

// Expor funções globalmente
window.editarSetup = editarSetup;
window.excluirSetup = excluirSetup;
window.setupSetupMaquinasPage = setupSetupMaquinasPage;

// =========================================
// FIM DO MÓDULO SETUP DE MÁQUINAS
// =========================================

// =========================================
// MÓDULO FERRAMENTARIA - CONTROLE DE MOLDES
// =========================================

// Estado do módulo
let ferramentariaState = {
    moldes: [],
    manutencoes: [],
    filtros: {
        cliente: '',
        status: '',
        busca: ''
    },
    initialized: false
};

// =====================================================
// ============ SETUP: Página PCP =====================
// =====================================================

// Estado global da página PCP
let pcpState = {
    initialized: false,
    currentDate: null,
    data: [],
    machinePriorities: {} // Armazenar prioridades das máquinas
};

// Função auxiliar para obter data de produção (considera turno noturno até 6:30)
function getPCPProductionDateString(date = new Date()) {
    const d = date instanceof Date ? date : new Date(date);
    const hour = d.getHours();
    const minute = d.getMinutes();
    
    // Se for antes das 6:30, considera como dia anterior (turno noturno)
    if (hour < 6 || (hour === 6 && minute < 30)) {
        d.setDate(d.getDate() - 1);
    }
    
    return d.toISOString().split('T')[0];
}

function setupPCPPage() {
    console.log('[PCP] Inicializando página de Planejamento e Controle da Produção...');
    
    try {
        // Verificar se o usuário tem permissão
        const user = window.authSystem?.getCurrentUser?.();
        const allowedUsers = ['leandro camargo', 'roberto fernandes', 'elaine', 'daniel rocha'];
        const userNameLower = (user?.name || '').toLowerCase().trim();
        
        if (!allowedUsers.includes(userNameLower)) {
            console.warn('[PCP] Acesso não autorizado para este usuário');
            return;
        }
        
        // Configurar data inicial (data de produção atual)
        const dateSelector = document.getElementById('pcp-date-selector');
        if (dateSelector) {
            const today = getPCPProductionDateString();
            dateSelector.value = today;
            pcpState.currentDate = today;
            
            // Event listener para mudança de data
            dateSelector.addEventListener('change', (e) => {
                pcpState.currentDate = e.target.value;
                const shiftFilter = document.getElementById('pcp-shift-selector')?.value || 'current';
                loadPCPData(e.target.value, shiftFilter);
            });
        }
        
        // Configurar filtro de turno
        const shiftSelector = document.getElementById('pcp-shift-selector');
        if (shiftSelector) {
            // Definir turno atual como padrão
            pcpState.currentShift = 'current';
            
            // Event listener para mudança de turno
            shiftSelector.addEventListener('change', (e) => {
                pcpState.currentShift = e.target.value;
                const date = document.getElementById('pcp-date-selector')?.value || getProductionDateString();
                loadPCPData(date, e.target.value);
            });
        }
        
        // Configurar botão de atualização
        const btnRefresh = document.getElementById('btn-pcp-refresh');
        if (btnRefresh) {
            btnRefresh.addEventListener('click', () => {
                console.log('[PCP] Atualizando dados...');
                const date = document.getElementById('pcp-date-selector')?.value || getProductionDateString();
                const shiftFilter = document.getElementById('pcp-shift-selector')?.value || 'current';
                loadPCPData(date, shiftFilter);
            });
        }
        
        // Configurar botão de exportar Excel
        const btnExportExcel = document.getElementById('btn-pcp-export-excel');
        if (btnExportExcel) {
            btnExportExcel.addEventListener('click', () => {
                console.log('[PCP] Exportando para Excel...');
                exportPCPToExcel();
            });
        }
        
        // Configurar botão de prioridade
        const btnPriority = document.getElementById('btn-pcp-priority');
        if (btnPriority) {
            btnPriority.addEventListener('click', () => {
                openPCPPriorityModal();
            });
        }
        
        // Configurar modal de prioridade
        setupPCPPriorityModal();
        
        // Carregar prioridades salvas
        loadMachinePriorities();
        
        // Renderizar ícones lucide
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
        
        // Carregar dados iniciais
        const initialShiftFilter = document.getElementById('pcp-shift-selector')?.value || 'current';
        loadPCPData(pcpState.currentDate || getPCPProductionDateString(), initialShiftFilter);
        
        pcpState.initialized = true;
        console.log('[PCP] Página inicializada com sucesso!');
    } catch (e) {
        console.error('[PCP] Erro ao inicializar página:', e);
    }
}

// Função auxiliar para determinar o turno atual
function getCurrentShift() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes();
    const currentMinutes = hours * 60 + minutes;
    
    // Turno 1: 06:30 às 15:00 (390 a 900)
    // Turno 2: 15:00 às 23:30 (900 a 1410)
    // Turno 3: 23:30 às 06:30 (1410 a 390)
    if (currentMinutes >= 390 && currentMinutes < 900) return '1';
    if (currentMinutes >= 900 && currentMinutes < 1410) return '2';
    return '3';
}

// ============ SISTEMA DE PRIORIDADE DE MÁQUINAS =====================

// Carregar prioridades das máquinas do Firestore
async function loadMachinePriorities() {
    try {
        console.log('[PCP] Carregando prioridades das máquinas...');
        const snapshot = await db.collection('machine_priorities').get();
        
        pcpState.machinePriorities = {};
        snapshot.forEach(doc => {
            pcpState.machinePriorities[doc.id] = doc.data().priority || 0;
        });
        
        console.log('[PCP] Prioridades carregadas:', Object.keys(pcpState.machinePriorities).length, 'máquinas');
    } catch (error) {
        console.error('[PCP] Erro ao carregar prioridades:', error);
        pcpState.machinePriorities = {};
    }
}

// Salvar prioridade de uma máquina no Firestore
async function saveMachinePriority(machineId, priority) {
    try {
        console.log('[PCP] Salvando prioridade:', machineId, '=', priority);
        
        await db.collection('machine_priorities').doc(machineId).set({
            priority: priority,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
            updatedBy: window.authSystem?.getCurrentUser?.()?.name || 'Sistema'
        }, { merge: true });
        
        // Atualizar estado local
        pcpState.machinePriorities[machineId] = priority;
        
        console.log('[PCP] Prioridade salva com sucesso!');
        return true;
    } catch (error) {
        console.error('[PCP] Erro ao salvar prioridade:', error);
        return false;
    }
}

// Obter prioridade de uma máquina
function getMachinePriority(machineId) {
    return pcpState.machinePriorities[machineId];
}

// Configurar modal de prioridade
function setupPCPPriorityModal() {
    const modal = document.getElementById('modal-pcp-priority');
    if (!modal) return;
    
    // Botões de fechar
    const btnClose = document.getElementById('btn-close-priority-modal');
    const btnCancel = document.getElementById('btn-cancel-priority');
    const btnSave = document.getElementById('btn-save-priority');
    
    if (btnClose) {
        btnClose.addEventListener('click', closePCPPriorityModal);
    }
    if (btnCancel) {
        btnCancel.addEventListener('click', closePCPPriorityModal);
    }
    
    // Botões de prioridade
    const priorityBtns = modal.querySelectorAll('.priority-btn');
    priorityBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            // Remover seleção anterior
            priorityBtns.forEach(b => {
                b.classList.remove('border-amber-500', 'bg-amber-50');
                b.classList.add('border-gray-200');
            });
            // Selecionar atual
            btn.classList.remove('border-gray-200');
            btn.classList.add('border-amber-500', 'bg-amber-50');
            
            // Atualizar valor
            document.getElementById('pcp-priority-value').value = btn.dataset.priority;
        });
    });
    
    // Botão salvar
    if (btnSave) {
        btnSave.addEventListener('click', async () => {
            const machineSelect = document.getElementById('pcp-priority-machine');
            const priorityValue = document.getElementById('pcp-priority-value').value;
            
            if (!machineSelect.value) {
                alert('Selecione uma máquina!');
                return;
            }
            if (priorityValue === '') {
                alert('Selecione uma prioridade!');
                return;
            }
            
            btnSave.disabled = true;
            btnSave.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i> Salvando...';
            
            const success = await saveMachinePriority(machineSelect.value, parseInt(priorityValue));
            
            if (success) {
                closePCPPriorityModal();
                // Recarregar dados da tabela
                const date = document.getElementById('pcp-date-selector')?.value || getProductionDateString();
                const shiftFilter = document.getElementById('pcp-shift-selector')?.value || 'current';
                loadPCPData(date, shiftFilter);
            } else {
                alert('Erro ao salvar prioridade. Tente novamente.');
            }
            
            btnSave.disabled = false;
            btnSave.innerHTML = '<i data-lucide="save" class="w-4 h-4"></i> Salvar';
            if (typeof lucide !== 'undefined') lucide.createIcons();
        });
    }
    
    // Fechar ao clicar fora
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closePCPPriorityModal();
        }
    });
}

// Abrir modal de prioridade
function openPCPPriorityModal() {
    const modal = document.getElementById('modal-pcp-priority');
    if (!modal) return;
    
    // Preencher select de máquinas com as máquinas do database
    const machineSelect = document.getElementById('pcp-priority-machine');
    if (machineSelect) {
        // Gerar lista de máquinas (H01 a H32), excluindo desativadas
        let optionsHTML = '<option value="">-- Selecione uma máquina --</option>';
        for (let i = 1; i <= 32; i++) {
            const machineId = `H${i.toString().padStart(2, '0')}`;
            // Ignorar máquinas desativadas
            if (DISABLED_MACHINES.includes(machineId)) continue;
            const currentPriority = getMachinePriority(machineId);
            const priorityLabel = currentPriority > 0 ? ` (Prioridade: ${currentPriority})` : '';
            optionsHTML += `<option value="${machineId}">${machineId}${priorityLabel}</option>`;
        }
        machineSelect.innerHTML = optionsHTML;
    }
    
    // Resetar seleção de prioridade
    const priorityBtns = modal.querySelectorAll('.priority-btn');
    priorityBtns.forEach(btn => {
        btn.classList.remove('border-amber-500', 'bg-amber-50');
        btn.classList.add('border-gray-200');
    });
    document.getElementById('pcp-priority-value').value = '';
    
    // Mostrar modal
    modal.classList.remove('hidden');
    
    // Renderizar ícones
    if (typeof lucide !== 'undefined') {
        lucide.createIcons();
    }
}

// Fechar modal de prioridade
function closePCPPriorityModal() {
    const modal = document.getElementById('modal-pcp-priority');
    if (modal) {
        modal.classList.add('hidden');
    }
}

// Renderizar badge de prioridade (0 = mais alta, 5 = mais baixa)
function renderPriorityBadge(priority) {
    const priorityNum = parseInt(priority);
    
    // Se não tem prioridade definida (null, undefined, NaN)
    if (isNaN(priorityNum)) {
        return '';
    }
    
    // Cores baseadas na prioridade (INVERTIDO: 0 = urgente, 5 = baixa)
    let bgColor, textColor, borderColor, label;
    if (priorityNum === 0) {
        bgColor = 'bg-red-100';
        textColor = 'text-red-700';
        borderColor = 'border-red-300';
        label = 'URGENTE';
    } else if (priorityNum === 1) {
        bgColor = 'bg-orange-100';
        textColor = 'text-orange-700';
        borderColor = 'border-orange-300';
        label = 'Alta';
    } else if (priorityNum === 2) {
        bgColor = 'bg-amber-100';
        textColor = 'text-amber-700';
        borderColor = 'border-amber-300';
        label = 'Média-Alta';
    } else if (priorityNum === 3) {
        bgColor = 'bg-yellow-100';
        textColor = 'text-yellow-700';
        borderColor = 'border-yellow-300';
        label = 'Média';
    } else if (priorityNum === 4) {
        bgColor = 'bg-lime-100';
        textColor = 'text-lime-700';
        borderColor = 'border-lime-300';
        label = 'Baixa';
    } else {
        bgColor = 'bg-gray-100';
        textColor = 'text-gray-600';
        borderColor = 'border-gray-300';
        label = 'Mínima';
    }
    
    return `<span class="inline-flex items-center justify-center px-2 py-0.5 rounded border ${bgColor} ${textColor} ${borderColor} font-semibold text-sm" title="Prioridade ${priorityNum} - ${label}">${priorityNum}</span>`;
}

// ============ FIM SISTEMA DE PRIORIDADE =====================

// Carregar dados do PCP
async function loadPCPData(date, shiftFilter = 'current') {
    console.log('[PCP] Carregando dados para:', date, 'Turno:', shiftFilter);
    
    const loadingEl = document.getElementById('pcp-loading');
    const tableContainer = document.getElementById('pcp-table-container');
    const emptyState = document.getElementById('pcp-empty-state');
    const tableBody = document.getElementById('pcp-table-body');
    
    // Mostrar loading
    if (loadingEl) loadingEl.classList.remove('hidden');
    if (tableContainer) tableContainer.classList.add('hidden');
    if (emptyState) emptyState.classList.add('hidden');
    
    try {
        // Determinar turno efetivo para filtro
        const effectiveShift = shiftFilter === 'current' ? getCurrentShift() : shiftFilter;
        console.log('[PCP] Turno efetivo para filtro:', effectiveShift);
        
        // 0. Carregar observações salvas para esta data
        await loadPCPObservations(date);
        
        // 1. Buscar planejamentos da data
        const planningSnapshot = await db.collection('planning')
            .where('date', '==', date)
            .get();
        
        // CORREÇÃO MULTI-PRODUTO: Manter TODOS os planejamentos por máquina (não agrupar)
        // Isso permite mostrar múltiplos produtos em moldes multi-produto
        const planningByMachine = new Map(); // Map<machineId, Array<planning>>
        const machinesWithPlanning = new Set();
        
        planningSnapshot.forEach(doc => {
            const data = { id: doc.id, ...doc.data() };
            const machineId = (data.machine || '').toUpperCase().trim();
            if (!machineId) return;
            
            // Ignorar máquinas desativadas
            if (DISABLED_MACHINES.includes(machineId)) {
                console.log(`[PCP] Ignorando máquina desativada: ${machineId}`);
                return;
            }
            
            machinesWithPlanning.add(machineId);
            
            // Determinar o turno do planejamento
            const planShift = String(data.shift || data.turno || '1');
            
            // Inicializar array se não existe
            if (!planningByMachine.has(machineId)) {
                planningByMachine.set(machineId, []);
            }
            
            // Se filtro é "all", adicionar todos os planejamentos
            // Se filtro é um turno específico, adicionar se for do turno ou como fallback
            if (shiftFilter === 'all') {
                planningByMachine.get(machineId).push(data);
            } else {
                // Filtrar: adicionar se for do turno selecionado
                if (planShift === effectiveShift) {
                    // Marcar como planejamento do turno correto
                    planningByMachine.get(machineId).push({ ...data, _isCorrectShift: true });
                } else {
                    // Guardar como fallback se não existir nenhum do turno correto
                    planningByMachine.get(machineId).push({ ...data, _isFallback: true });
                }
            }
        });
        
        // Converter para array mantendo TODOS os planejamentos (multi-produto)
        // Se houver planejamentos do turno correto, remover os fallbacks
        const planningItems = [];
        const addedPlanKeys = new Set(); // Rastrear planejamentos já adicionados para evitar duplicatas
        
        planningByMachine.forEach((plans, machineId) => {
            // Verificar se tem planejamento do turno correto
            const correctShiftPlans = plans.filter(p => p._isCorrectShift);
            const fallbackPlans = plans.filter(p => p._isFallback);
            const normalPlans = plans.filter(p => !p._isCorrectShift && !p._isFallback);
            
            // Função para adicionar plano evitando duplicatas
            const addPlanIfNotDuplicate = (plan) => {
                // Chave única: máquina + turno + código do produto
                const planShift = String(plan.shift || plan.turno || '1');
                const productCode = plan.product_code || plan.productCode || plan.product || plan.product_cod || '';
                const key = `${machineId}_T${planShift}_${productCode}`;
                
                if (!addedPlanKeys.has(key)) {
                    addedPlanKeys.add(key);
                    planningItems.push(plan);
                    return true;
                } else {
                    console.log(`[PCP] Ignorando planejamento duplicado: ${key} (id: ${plan.id})`);
                    return false;
                }
            };
            
            if (shiftFilter === 'all') {
                // CORREÇÃO: Para visualização "Todos os turnos", adicionar todos mas evitar duplicatas
                normalPlans.forEach(p => addPlanIfNotDuplicate(p));
            } else if (correctShiftPlans.length > 0) {
                // Tem planejamentos do turno correto - usar esses (evitando duplicatas)
                correctShiftPlans.forEach(p => addPlanIfNotDuplicate(p));
            } else if (fallbackPlans.length > 0) {
                // CORREÇÃO: Só tem fallback - usar apenas UM como referência (o mais recente/primeiro)
                // Não adicionar todos os fallbacks para evitar duplicação incorreta
                console.log(`[PCP] Máquina ${machineId} não tem planejamento para turno ${effectiveShift}, usando 1 fallback de ${fallbackPlans.length} disponíveis`);
                addPlanIfNotDuplicate(fallbackPlans[0]); // Usar apenas o primeiro fallback
            }
        });
        
        console.log('[PCP] Planejamentos após processamento:', planningItems.length, 'máquinas únicas:', machinesWithPlanning.size, 'chaves únicas:', addedPlanKeys.size);
        
        // 2. Buscar paradas ativas (active_downtimes) - PRIORIDADE 1
        const activeDowntimesSnapshot = await db.collection('active_downtimes').get();
        const activeDowntimes = new Map();
        activeDowntimesSnapshot.forEach(doc => {
            const data = doc.data();
            // IMPORTANTE: Verificar se isActive === true
            if (data && data.isActive === true) {
                const machineId = doc.id.toUpperCase().trim();
                // Ignorar máquinas desativadas
                if (DISABLED_MACHINES.includes(machineId)) return;
                activeDowntimes.set(machineId, { ...data, source: 'active_live' });
            }
        });
        
        console.log('[PCP] Paradas ativas (active_downtimes):', activeDowntimes.size, [...activeDowntimes.keys()]);
        
        // 3. Buscar extended_downtime_logs ativos - PRIORIDADE 2
        const extendedSnapshot = await db.collection('extended_downtime_logs')
            .where('status', '==', 'active')
            .get();
        
        const extendedDowntimes = new Map();
        extendedSnapshot.forEach(doc => {
            const data = doc.data();
            const machineId = (data.machine || data.machine_id || '').toUpperCase().trim();
            if (machineId) {
                // Ignorar máquinas desativadas
                if (DISABLED_MACHINES.includes(machineId)) return;
                extendedDowntimes.set(machineId, { ...data, source: 'extended' });
            }
        });
        
        console.log('[PCP] Paradas longas ativas (extended_downtime_logs):', extendedDowntimes.size, [...extendedDowntimes.keys()]);
        
        // 4. Buscar downtime_entries do dia - PRIORIDADE 3
        // Paradas normais que ainda estão em andamento (sem endTime ou endTime ainda não passou)
        const downtimeEntriesSnapshot = await db.collection('downtime_entries')
            .where('date', '==', date)
            .get();
        
        const now = new Date();
        const currentTime = now.toTimeString().slice(0, 5); // HH:MM
        const normalDowntimes = new Map();
        downtimeEntriesSnapshot.forEach(doc => {
            const data = doc.data();
            const machineId = (data.machine || '').toUpperCase().trim();
            if (!machineId) return;
            
            // Ignorar máquinas desativadas
            if (DISABLED_MACHINES.includes(machineId)) return;
            
            // Verificar se a parada está em andamento
            const hasNoEndTime = !data.endTime || data.endTime === '';
            const endTimeNotPassed = data.endTime && currentTime < data.endTime;
            
            if (hasNoEndTime || endTimeNotPassed) {
                normalDowntimes.set(machineId, { ...data, source: 'downtime_entries' });
            }
        });
        
        console.log('[PCP] Paradas normais em andamento (downtime_entries):', normalDowntimes.size, [...normalDowntimes.keys()]);
        
        // Coletar máquinas com paradas mas sem planejamento para buscar dados
        const machinesNeedingData = new Set();
        activeDowntimes.forEach((_, machineId) => {
            if (!machinesWithPlanning.has(machineId)) machinesNeedingData.add(machineId);
        });
        extendedDowntimes.forEach((_, machineId) => {
            if (!machinesWithPlanning.has(machineId)) machinesNeedingData.add(machineId);
        });
        normalDowntimes.forEach((_, machineId) => {
            if (!machinesWithPlanning.has(machineId)) machinesNeedingData.add(machineId);
        });
        
        // Buscar último planejamento de cada máquina sem planejamento no dia para obter cavidade/ciclo
        const lastPlanningByMachine = new Map();
        if (machinesNeedingData.size > 0) {
            // Buscar planejamentos recentes (últimos 30 dias) para essas máquinas
            const machineArray = [...machinesNeedingData];
            console.log('[PCP] Buscando último planejamento para máquinas:', machineArray);
            
            for (const machineId of machineArray) {
                try {
                    const lastPlanSnapshot = await db.collection('planning')
                        .where('machine', '==', machineId)
                        .orderBy('date', 'desc')
                        .limit(1)
                        .get();
                    
                    if (!lastPlanSnapshot.empty) {
                        const planData = lastPlanSnapshot.docs[0].data();
                        const productCode = planData.product_code || planData.productCode || planData.product || '';
                        const productInfo = productByCode?.get(productCode) || {};
                        
                        // Buscar valores REAIS do painel de lançamento (prioridade)
                        let realCavidades = null;
                        let realCiclo = null;
                        for (const shiftKey of ['t1', 't2', 't3']) {
                            if (realCavidades === null) {
                                const cavValue = Number(planData[`active_cavities_${shiftKey}`]) || 
                                                 Number(planData[`active_cavities_${shiftKey.toUpperCase()}`]);
                                if (cavValue > 0) realCavidades = cavValue;
                            }
                            if (realCiclo === null) {
                                const cycleValue = Number(planData[`real_cycle_${shiftKey}`]) || 
                                                   Number(planData[`real_cycle_${shiftKey.toUpperCase()}`]);
                                if (cycleValue > 0) realCiclo = cycleValue;
                            }
                            if (realCavidades !== null && realCiclo !== null) break;
                        }
                        
                        lastPlanningByMachine.set(machineId, {
                            cavidades: realCavidades || Number(planData.cavities) || Number(planData.cavidade) || Number(productInfo.cavidades) || 0,
                            ciclo: realCiclo || Number(planData.cycle) || Number(planData.cycle_time) || Number(productInfo.ciclo) || 0,
                            cliente: planData.client || planData.cliente || productInfo.cliente || '-',
                            produto: planData.product_name || planData.productName || productInfo.descricao || productCode || '-'
                        });
                    }
                } catch (e) {
                    console.warn('[PCP] Erro ao buscar último planejamento para', machineId, e);
                }
            }
            console.log('[PCP] Últimos planejamentos encontrados:', lastPlanningByMachine.size);
        }
        
        // Verificar se há dados para mostrar
        if (planningItems.length === 0 && activeDowntimes.size === 0 && extendedDowntimes.size === 0 && normalDowntimes.size === 0) {
            if (loadingEl) loadingEl.classList.add('hidden');
            if (emptyState) emptyState.classList.remove('hidden');
            updatePCPKPIs([], []);
            return;
        }
        
        // 5. Buscar produção do dia
        const productionSnapshot = await db.collection('production_entries')
            .where('workDay', '==', date)
            .get();
        
        const productionByPlan = new Map();
        productionSnapshot.forEach(doc => {
            const data = doc.data();
            const planId = data.planId;
            if (planId) {
                const current = productionByPlan.get(planId) || 0;
                productionByPlan.set(planId, current + (Number(data.produzido) || 0));
            }
        });
        
        // 5. Processar dados para a tabela - MÁQUINAS COM PLANEJAMENTO
        const tableData = planningItems.map(plan => {
            const machineId = (plan.machine || '').toUpperCase().trim();
            
            // Buscar dados do produto no database local
            const productCode = plan.product_code || plan.productCode || plan.product || '';
            const productInfo = productByCode?.get(productCode) || {};
            
            // Verificar status da máquina
            let status = 'Produzindo';
            let downtimeReason = '-';
            
            // PRIORIDADE 1: Parada ativa (active_downtimes)
            const activeDowntime = activeDowntimes.get(machineId);
            if (activeDowntime) {
                status = 'Parada';
                downtimeReason = activeDowntime.motivo || activeDowntime.reason || 'Não informado';
            }
            
            // PRIORIDADE 2: Parada longa (extended_downtime_logs)
            const extendedDowntime = extendedDowntimes.get(machineId);
            if (extendedDowntime && !activeDowntime) {
                status = 'Parada Longa';
                downtimeReason = extendedDowntime.motivo || extendedDowntime.reason || 'Não informado';
            }
            
            // PRIORIDADE 3: Parada normal (downtime_entries) em andamento
            const normalDowntime = normalDowntimes.get(machineId);
            if (normalDowntime && !activeDowntime && !extendedDowntime) {
                status = 'Parada';
                downtimeReason = normalDowntime.reason || normalDowntime.motivo || 'Não informado';
            }
            
            // Determinar turno atual para buscar ciclo/cavidades reais
            const now = new Date();
            const hours = now.getHours();
            const minutes = now.getMinutes();
            const currentMinutes = hours * 60 + minutes;
            
            // Turno 1: 06:30 às 15:00 (390 a 900)
            // Turno 2: 15:00 às 23:30 (900 a 1410)
            // Turno 3: 23:30 às 06:30 (1410 a 390)
            let currentShiftKey = 't3';
            if (currentMinutes >= 390 && currentMinutes < 900) currentShiftKey = 't1';
            else if (currentMinutes >= 900 && currentMinutes < 1410) currentShiftKey = 't2';
            
            // Calcular valores - PRIORIZAR valores REAIS do painel de lançamento
            // Tentar buscar do turno atual primeiro, depois dos outros turnos
            const shiftKeys = [currentShiftKey, 't1', 't2', 't3'];
            let realCavidades = null;
            let realCiclo = null;
            
            for (const shiftKey of shiftKeys) {
                if (realCavidades === null) {
                    // Tentar diferentes variações dos nomes dos campos
                    const cavValue = Number(plan[`active_cavities_${shiftKey}`]) || 
                                     Number(plan[`active_cavities_${shiftKey.toUpperCase()}`]) ||
                                     Number(plan[`activeCavities${shiftKey.toUpperCase()}`]);
                    if (cavValue > 0) realCavidades = cavValue;
                }
                if (realCiclo === null) {
                    // Tentar diferentes variações dos nomes dos campos
                    const cycleValue = Number(plan[`real_cycle_${shiftKey}`]) || 
                                       Number(plan[`real_cycle_${shiftKey.toUpperCase()}`]) ||
                                       Number(plan[`realCycle${shiftKey.toUpperCase()}`]);
                    if (cycleValue > 0) realCiclo = cycleValue;
                }
                if (realCavidades !== null && realCiclo !== null) break;
            }
            
            // DEBUG: Log para verificar os valores encontrados
            console.log(`[PCP] Máquina ${machineId}: realCav=${realCavidades}, realCiclo=${realCiclo}`);
            console.log(`[PCP] Máquina ${machineId} campos:`, {
                active_cavities_t1: plan.active_cavities_t1,
                active_cavities_t2: plan.active_cavities_t2,
                active_cavities_t3: plan.active_cavities_t3,
                real_cycle_t1: plan.real_cycle_t1,
                real_cycle_t2: plan.real_cycle_t2,
                real_cycle_t3: plan.real_cycle_t3,
                cavities: plan.cavities,
                mold_cavities: plan.mold_cavities,
                cycle: plan.cycle,
                budgeted_cycle: plan.budgeted_cycle
            });
            
            // Se não encontrou valores reais, usar valores planejados
            // CORREÇÃO: Usar budgeted_cycle e mold_cavities que são os campos corretos do planejamento
            const cavidadesPlanejadas = Number(plan.mold_cavities) || Number(plan.cavities) || Number(plan.cavidade) || Number(productInfo.cavidades) || 0;
            const cicloPlanejado = Number(plan.budgeted_cycle) || Number(plan.cycle) || Number(plan.cycle_time) || Number(productInfo.ciclo) || 0;
            
            // Valores a exibir (reais se disponíveis, senão planejados)
            const cavidades = realCavidades || cavidadesPlanejadas;
            const ciclo = realCiclo || cicloPlanejado;
            
            const planejado = Number(plan.planned_quantity) || Number(plan.planned_qty) || Number(plan.quantity) || 0;
            const executado = productionByPlan.get(plan.id) || Number(plan.total_produzido) || 0;
            const faltante = Math.max(0, planejado - executado);
            
            // Cliente
            const cliente = plan.client || plan.cliente || productInfo.cliente || '-';
            
            // Produto (descrição)
            const produto = plan.product_name || plan.productName || productInfo.descricao || productCode || '-';
            
            // DEBUG: Log para comparação ciclo/cavidades
            console.log(`[PCP] ${machineId} - Ciclo: real=${realCiclo}, planejado=${cicloPlanejado}, exibido=${ciclo}`);
            console.log(`[PCP] ${machineId} - Cavidades: real=${realCavidades}, planejadas=${cavidadesPlanejadas}, exibido=${cavidades}`);
            
            // Turno do planejamento
            const planShift = String(plan.shift || plan.turno || '1');
            
            return {
                machine: machineId,
                turno: planShift,
                cavidades: cavidades,
                ciclo: ciclo,
                cavidadesPlanejadas: cavidadesPlanejadas,
                cicloPlanejado: cicloPlanejado,
                isRealCavidades: realCavidades !== null,
                isRealCiclo: realCiclo !== null,
                status: status,
                cliente: cliente,
                produto: produto,
                motivoParada: downtimeReason,
                planejado: planejado,
                executado: executado,
                faltante: faltante,
                hasPlanning: true
            };
        });
        
        // 6. Adicionar máquinas com paradas ativas que NÃO têm planejamento
        // Paradas ativas (active_downtimes)
        activeDowntimes.forEach((downtimeData, machineId) => {
            if (!machinesWithPlanning.has(machineId)) {
                const reason = downtimeData.motivo || downtimeData.reason || 'Não informado';
                const lastPlan = lastPlanningByMachine.get(machineId) || {};
                tableData.push({
                    machine: machineId,
                    turno: '-',
                    cavidades: lastPlan.cavidades || '-',
                    ciclo: lastPlan.ciclo || '-',
                    status: 'Parada',
                    cliente: lastPlan.cliente || '-',
                    produto: lastPlan.produto || '-',
                    motivoParada: reason,
                    planejado: 0,
                    executado: 0,
                    faltante: 0,
                    hasPlanning: false
                });
            }
        });
        
        // Paradas longas (extended_downtime_logs)
        extendedDowntimes.forEach((downtimeData, machineId) => {
            // Só adiciona se não tem planejamento E não foi adicionada como parada ativa
            if (!machinesWithPlanning.has(machineId) && !activeDowntimes.has(machineId)) {
                const reason = downtimeData.motivo || downtimeData.reason || 'Não informado';
                const lastPlan = lastPlanningByMachine.get(machineId) || {};
                tableData.push({
                    machine: machineId,
                    turno: '-',
                    cavidades: lastPlan.cavidades || '-',
                    ciclo: lastPlan.ciclo || '-',
                    status: 'Parada Longa',
                    cliente: lastPlan.cliente || '-',
                    produto: lastPlan.produto || '-',
                    motivoParada: reason,
                    planejado: 0,
                    executado: 0,
                    faltante: 0,
                    hasPlanning: false
                });
            }
        });
        
        // Paradas normais em andamento (downtime_entries) - PRIORIDADE 3
        normalDowntimes.forEach((downtimeData, machineId) => {
            // Só adiciona se não tem planejamento E não foi adicionada como parada ativa ou longa
            if (!machinesWithPlanning.has(machineId) && !activeDowntimes.has(machineId) && !extendedDowntimes.has(machineId)) {
                const reason = downtimeData.reason || downtimeData.motivo || 'Não informado';
                const lastPlan = lastPlanningByMachine.get(machineId) || {};
                tableData.push({
                    machine: machineId,
                    turno: '-',
                    cavidades: lastPlan.cavidades || '-',
                    ciclo: lastPlan.ciclo || '-',
                    status: 'Parada',
                    cliente: lastPlan.cliente || '-',
                    produto: lastPlan.produto || '-',
                    motivoParada: reason,
                    planejado: 0,
                    executado: 0,
                    faltante: 0,
                    hasPlanning: false
                });
            }
        });
        
        // Ordenar por máquina
        tableData.sort((a, b) => a.machine.localeCompare(b.machine, undefined, { numeric: true }));
        
        // Atualizar KPIs
        updatePCPKPIs(tableData, activeDowntimes);
        
        // Carregar fila de ordens por máquina ANTES de renderizar a tabela
        // para que a coluna "Fila" tenha os dados disponíveis
        if (window.MachineQueue && typeof window.MachineQueue.load === 'function') {
            await window.MachineQueue.load().catch(err => console.error('[PCP] Erro ao carregar fila:', err));
        }
        
        // Renderizar tabela (agora com dados da fila disponíveis)
        renderPCPTable(tableData);
        
        // Esconder loading e mostrar tabela
        if (loadingEl) loadingEl.classList.add('hidden');
        if (tableContainer) tableContainer.classList.remove('hidden');
        
        // Renderizar ícones
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
        
    } catch (error) {
        console.error('[PCP] Erro ao carregar dados:', error);
        if (loadingEl) loadingEl.classList.add('hidden');
        if (emptyState) {
            emptyState.classList.remove('hidden');
            emptyState.querySelector('h3').textContent = 'Erro ao carregar dados';
            emptyState.querySelector('p').textContent = error.message;
        }
    }
}

// Atualizar KPIs do PCP
function updatePCPKPIs(tableData, activeDowntimes) {
    // Contar máquinas ÚNICAS (não linhas, para suportar multi-produto)
    const uniqueMachines = new Set(tableData.map(d => d.machine));
    const totalMachines = uniqueMachines.size;
    
    // Contar máquinas paradas (considerar que se qualquer produto da máquina está parado, a máquina está parada)
    const stoppedMachinesSet = new Set();
    tableData.forEach(d => {
        if (d.status !== 'Produzindo') {
            stoppedMachinesSet.add(d.machine);
        }
    });
    const stoppedMachines = stoppedMachinesSet.size;
    const producingMachines = totalMachines - stoppedMachines;
    
    document.getElementById('pcp-kpi-machines').textContent = totalMachines.toLocaleString('pt-BR');
    document.getElementById('pcp-kpi-producing').textContent = producingMachines.toLocaleString('pt-BR');
    document.getElementById('pcp-kpi-stopped').textContent = stoppedMachines.toLocaleString('pt-BR');
}

// Renderizar tabela do PCP
// Cache local de observações PCP carregadas do Firebase
let pcpObservationsCache = {};
let pcpObservationsLoaded = false;

/**
 * Carrega observações salvas do Firebase para a data do PCP
 */
async function loadPCPObservations(date) {
    try {
        const docRef = db.collection('pcp_observations').doc(date);
        const doc = await docRef.get();
        if (doc.exists) {
            pcpObservationsCache = doc.data().machines || {};
        } else {
            pcpObservationsCache = {};
        }
        pcpObservationsLoaded = true;
        console.log('[PCP] Observações carregadas:', Object.keys(pcpObservationsCache).length, 'máquinas');
    } catch (err) {
        console.error('[PCP] Erro ao carregar observações:', err);
        pcpObservationsCache = {};
    }
}

/**
 * Salva observação de uma máquina no Firebase (doc por data)
 */
async function savePCPObservation(machineId, text) {
    try {
        const dateEl = document.getElementById('pcp-date-selector');
        const date = dateEl ? dateEl.value : new Date().toISOString().split('T')[0];
        
        pcpObservationsCache[machineId] = text;
        
        const docRef = db.collection('pcp_observations').doc(date);
        await docRef.set({
            machines: pcpObservationsCache,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        }, { merge: true });
        
        console.log(`[PCP] Observação salva: ${machineId} = "${text}"`);
    } catch (err) {
        console.error('[PCP] Erro ao salvar observação:', err);
        if (typeof showNotification === 'function') showNotification('Erro ao salvar observação', 'error');
    }
}

// Expor globalmente para uso inline
window.savePCPObservation = savePCPObservation;

/**
 * Escapa texto para uso seguro em atributos HTML (value="...")
 */
function escapeHtmlAttr(str) {
    if (!str) return '';
    return String(str).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function renderPCPTable(data) {
    const tableBody = document.getElementById('pcp-table-body');
    if (!tableBody) return;
    
    // Obter contagem de filas de ordens por máquina (do módulo MachineQueue)
    const queueCounts = (window.MachineQueue && typeof window.MachineQueue.getQueueCounts === 'function')
        ? window.MachineQueue.getQueueCounts() : {};
    
    // CORREÇÃO: Agrupar dados por máquina E turno para identificar multi-produto REAL
    // Multi-produto só ocorre quando há PRODUTOS DIFERENTES no MESMO TURNO na mesma máquina
    // Planejamentos em turnos diferentes NÃO são multi-produto
    const machineShiftProducts = new Map(); // Map<machineId_turno, Set<produto>>
    const machineShiftCount = new Map(); // Map<machineId_turno, count>
    
    data.forEach(row => {
        const key = `${row.machine}_${row.turno || '1'}`;
        
        // Contar entradas por máquina+turno
        const count = machineShiftCount.get(key) || 0;
        machineShiftCount.set(key, count + 1);
        
        // Rastrear produtos únicos por máquina+turno
        if (!machineShiftProducts.has(key)) {
            machineShiftProducts.set(key, new Set());
        }
        machineShiftProducts.get(key).add(row.produto || '-');
    });
    
    // Rastrear qual índice de produto para cada máquina+turno (para multi-produto)
    const machineShiftIndex = new Map();
    
    // DEBUG: Log das máquinas que serão marcadas como multi-produto
    machineShiftProducts.forEach((products, key) => {
        const count = machineShiftCount.get(key) || 0;
        if (count > 1 || products.size > 1) {
            console.log(`[PCP-MULTI] ${key}: ${count} entradas, ${products.size} produtos únicos: [${[...products].join(', ')}] -> ${count > 1 && products.size > 1 ? 'MULTI-PRODUTO' : 'NÃO é multi-produto'}`);
        }
    });
    
    tableBody.innerHTML = data.map(row => {
        // Determinar cor do status baseado no motivo (igual ao Dashboard TV)
        const statusColors = getPCPStatusColor(row.status, row.motivoParada);
        
        // CORREÇÃO: Verificar se é molde multi-produto REAL (produtos diferentes no MESMO turno)
        const key = `${row.machine}_${row.turno || '1'}`;
        const productSet = machineShiftProducts.get(key) || new Set();
        const productCount = machineShiftCount.get(key) || 1;
        
        // Só é multi-produto se há mais de uma entrada E mais de um produto único no mesmo turno
        const isMultiProduct = productCount > 1 && productSet.size > 1;
        
        const currentIndex = (machineShiftIndex.get(key) || 0) + 1;
        machineShiftIndex.set(key, currentIndex);
        
        // Formatar ciclo (pode ser número ou '-')
        const cicloDisplay = (typeof row.ciclo === 'number' && row.ciclo > 0) ? row.ciclo.toFixed(1) : '-';
        const cavidadesDisplay = (typeof row.cavidades === 'number' && row.cavidades > 0) ? row.cavidades : '-';
        
        // Verificar se ciclo está fora do planejado
        // Ciclo real > ciclo planejado = ruim (máquina mais lenta)
        const cicloNum = typeof row.ciclo === 'number' ? row.ciclo : 0;
        const cicloPlanNum = typeof row.cicloPlanejado === 'number' ? row.cicloPlanejado : 0;
        
        // DEBUG para verificar valores
        console.log(`[PCP-RENDER] ${row.machine}: ciclo=${cicloNum}, planejado=${cicloPlanNum}, isReal=${row.isRealCiclo}`);
        
        let cicloClass = 'text-gray-700';
        if (cicloNum > 0 && cicloPlanNum > 0) {
            const diferenca = cicloNum - cicloPlanNum;
            const percentualDiferenca = (diferenca / cicloPlanNum) * 100;
            
            if (percentualDiferenca > 10) {
                // Ciclo mais de 10% acima do planejado = vermelho (máquina muito lenta)
                cicloClass = 'text-red-600 font-bold';
            } else if (percentualDiferenca > 0) {
                // Ciclo entre 0-10% acima = amarelo (um pouco lento)
                cicloClass = 'text-amber-600 font-semibold';
            } else {
                // Ciclo igual ou menor que planejado = verde (ok ou mais rápido)
                cicloClass = 'text-green-600 font-semibold';
            }
        }
        
        // Verificar se cavidades está fora do planejado
        // Cavidades real < cavidades planejado = ruim (menos produção)
        const cavNum = typeof row.cavidades === 'number' ? row.cavidades : 0;
        const cavPlanNum = typeof row.cavidadesPlanejadas === 'number' ? row.cavidadesPlanejadas : 0;
        
        console.log(`[PCP-RENDER] ${row.machine}: cavidades=${cavNum}, planejadas=${cavPlanNum}, isReal=${row.isRealCavidades}`);
        
        let cavidadesClass = 'text-gray-700';
        if (cavNum > 0 && cavPlanNum > 0) {
            if (cavNum < cavPlanNum) {
                // Cavidades abaixo do planejado = vermelho
                cavidadesClass = 'text-red-600 font-bold';
            } else {
                // Cavidades igual ou acima do planejado = verde
                cavidadesClass = 'text-green-600 font-semibold';
            }
        }
        
        // Tooltip com informação do planejado
        const cicloTitle = cicloPlanNum > 0 ? `Planejado: ${cicloPlanNum.toFixed(1)}s | Atual: ${cicloNum > 0 ? cicloNum.toFixed(1) + 's' : '-'}` : '';
        const cavTitle = cavPlanNum > 0 ? `Planejado: ${cavPlanNum} | Atual: ${cavNum > 0 ? cavNum : '-'}` : '';
        
        // Obter prioridade da máquina
        const machinePriority = getMachinePriority(row.machine);
        const priorityBadge = renderPriorityBadge(machinePriority);
        
        // Estilo especial para linhas multi-produto
        const multiProductStyle = isMultiProduct ? 'bg-purple-50' : '';
        const multiProductBadge = isMultiProduct 
            ? `<span class="ml-1 px-1 py-0.5 text-[9px] font-bold bg-purple-200 text-purple-700 rounded">${currentIndex}/${productCount}</span>` 
            : '';
        
        // Para o primeiro produto da máquina multi-produto, mostrar indicação especial
        const machineDisplay = isMultiProduct && currentIndex === 1
            ? `${row.machine} <span class="text-purple-600 text-xs font-semibold">(Multi)</span>`
            : row.machine;
        
        return `
            <tr class="border-b border-gray-200 hover:bg-gray-100 ${multiProductStyle}">
                <td class="px-2 py-2 text-center font-bold text-gray-900 whitespace-nowrap border border-gray-300">${machineDisplay}</td>
                <td class="px-2 py-2 text-center border border-gray-300">${priorityBadge}</td>
                <td class="px-2 py-2 text-center border border-gray-300 ${cavidadesClass}" title="${cavTitle}">${cavidadesDisplay}</td>
                <td class="px-2 py-2 text-center border border-gray-300 ${cicloClass}" title="${cicloTitle}">${cicloDisplay}</td>
                <td class="px-2 py-2 text-center font-semibold border border-gray-300" style="background-color: ${statusColors.bg}; color: ${statusColors.text}; border-color: ${statusColors.border};">
                    ${statusColors.label}
                </td>
                <td class="px-2 py-2 text-left text-gray-700 whitespace-nowrap border border-gray-300">${row.cliente}</td>
                <td class="px-2 py-2 text-left text-gray-700 border border-gray-300">${row.produto}${multiProductBadge}</td>
                <td class="px-2 py-2 text-left border border-gray-300 ${row.status !== 'Produzindo' ? 'text-red-600 font-semibold' : 'text-gray-500'}">${row.motivoParada}</td>
                <td class="px-2 py-2 text-center border border-gray-300">${(() => {
                    const machId = (row.machine || '').toUpperCase().trim();
                    const count = queueCounts[machId] || 0;
                    if (count === 0) return '<span class="text-gray-300">-</span>';
                    const color = count >= 5 ? 'bg-red-100 text-red-700 border-red-200' : count >= 3 ? 'bg-amber-100 text-amber-700 border-amber-200' : 'bg-blue-100 text-blue-700 border-blue-200';
                    return '<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-bold border ' + color + '">' + count + ' <span class="text-[9px] font-normal">OPs</span></span>';
                })()}</td>
                <td class="px-1 py-1 border border-gray-300">
                    <input type="text" 
                        class="w-full px-2 py-1 text-xs border border-gray-200 rounded focus:ring-1 focus:ring-blue-400 focus:border-blue-400 bg-white hover:bg-gray-50 transition placeholder-gray-300"
                        placeholder="Escrever obs..."
                        value="${escapeHtmlAttr(pcpObservationsCache[(row.machine || '').toUpperCase().trim()] || '')}"
                        data-machine="${(row.machine || '').toUpperCase().trim()}"
                        onchange="window.savePCPObservation(this.dataset.machine, this.value)"
                    />
                </td>
            </tr>
        `;
    }).join('');
}

// Função para determinar cor do status igual ao Dashboard TV
function getPCPStatusColor(status, motivoParada) {
    // Se está produzindo
    if (status === 'Produzindo') {
        return { bg: 'rgba(34, 197, 94, 0.3)', text: '#16A34A', border: '#22C55E', label: 'Produzindo' };
    }
    
    // Se não está produzindo, analisar o motivo
    const reason = (motivoParada || '').toLowerCase();
    
    // Preparação de Material = Rosa
    if (reason.includes('preparação') || reason.includes('preparacao') || 
        reason.includes('estufagem') || reason.includes('fora de cor') || reason.includes('teste de cor')) {
        return { bg: 'rgba(233, 30, 99, 0.25)', text: '#E91E63', border: '#E91E63', label: 'Preparação' };
    }
    
    // Setup = Azul Claro
    if (reason.includes('setup') || reason.includes('instalação') || reason.includes('instalacao') ||
        reason.includes('retirada de molde') || reason.includes('aguardando setup')) {
        return { bg: 'rgba(3, 169, 244, 0.25)', text: '#03A9F4', border: '#03A9F4', label: 'Setup' };
    }
    
    // Compras = Marrom
    if (reason.includes('compra') || 
        (reason.includes('falta') && (reason.includes('matéria') || reason.includes('materia') || 
        reason.includes('prima') || reason.includes('saco') || reason.includes('caixa') || reason.includes('master')))) {
        return { bg: 'rgba(121, 85, 72, 0.25)', text: '#795548', border: '#795548', label: 'Compras' };
    }
    
    // Ferramentaria = Laranja
    if (reason.includes('ferramentaria') || reason.includes('corretiva de molde') || 
        reason.includes('preventiva de molde') || reason.includes('troca de versão') || reason.includes('versão')) {
        return { bg: 'rgba(255, 152, 0, 0.25)', text: '#FF9800', border: '#FF9800', label: 'Ferrament.' };
    }
    
    // Processo = Roxo
    if (reason.includes('processo') || reason.includes('ajuste') || reason.includes('cavidade') || 
        reason.includes('try out') || reason.includes('prendendo')) {
        return { bg: 'rgba(156, 39, 176, 0.25)', text: '#9C27B0', border: '#9C27B0', label: 'Processo' };
    }
    
    // Manutenção = Amarelo
    if (reason.includes('manutenção') || reason.includes('manutencao') || reason.includes('maintenance')) {
        return { bg: 'rgba(255, 235, 59, 0.3)', text: '#F59E0B', border: '#FFEB3B', label: 'Manutenção' };
    }
    
    // Qualidade = Vermelho
    if (reason.includes('qualidade') || reason.includes('liberação') || reason.includes('aguardando cliente') || 
        reason.includes('aguardando fornecedor') || reason.includes('disposição')) {
        return { bg: 'rgba(244, 67, 54, 0.25)', text: '#F44336', border: '#F44336', label: 'Qualidade' };
    }
    
    // Produção = Verde Claro
    if (reason.includes('operador') || reason.includes('troca de cor') || 
        reason.includes('revezamento') || reason.includes('almoço') || reason.includes('janta') ||
        reason.includes('inicio') || reason.includes('reinicio')) {
        return { bg: 'rgba(187, 247, 208, 0.5)', text: '#064e3b', border: '#86EFAC', label: 'Produção' };
    }
    
    // Comercial = Cinza
    if (reason.includes('comercial') || reason.includes('sem pedido')) {
        return { bg: 'rgba(97, 97, 97, 0.3)', text: '#616161', border: '#616161', label: 'Comercial' };
    }
    
    // PCP = Preto
    if (reason.includes('pcp') || reason.includes('estratégia') || reason.includes('estrategia') || 
        reason.includes('sem programação') || reason.includes('sem programacao')) {
        return { bg: 'rgba(33, 33, 33, 0.8)', text: '#BDBDBD', border: '#212121', label: 'PCP' };
    }
    
    // Administrativo = Branco/Cinza claro
    if (reason.includes('energia') || reason.includes('falta de água') || reason.includes('queda') || reason.includes('análise administrativa')) {
        return { bg: 'rgba(158, 158, 158, 0.3)', text: '#424242', border: '#9E9E9E', label: 'Admin.' };
    }
    
    // Default = Outros (Cinza)
    return { bg: 'rgba(120, 144, 156, 0.25)', text: '#78909C', border: '#78909C', label: 'Outros' };
}

// Função para exportar PCP Dashboard para Excel com formatação de cores
function exportPCPToExcel() {
    const table = document.getElementById('pcp-table');
    if (!table) {
        alert('Tabela não encontrada!');
        return;
    }
    
    const date = document.getElementById('pcp-date-selector')?.value || getProductionDateString();
    const shiftFilter = document.getElementById('pcp-shift-selector')?.value || 'current';
    
    // Determinar nome do turno para o arquivo
    let shiftName = 'Atual';
    if (shiftFilter === 'all') shiftName = 'Todos';
    else if (shiftFilter === '1') shiftName = 'T1';
    else if (shiftFilter === '2') shiftName = 'T2';
    else if (shiftFilter === '3') shiftName = 'T3';
    else if (shiftFilter === 'current') {
        const currentShift = getCurrentShift();
        shiftName = `T${currentShift}`;
    }
    
    // KPIs do dashboard
    const totalMachines = document.getElementById('pcp-kpi-machines')?.textContent || '0';
    const producingMachines = document.getElementById('pcp-kpi-producing')?.textContent || '0';
    const stoppedMachines = document.getElementById('pcp-kpi-stopped')?.textContent || '0';
    
    // Criar HTML com estilos para Excel
    let html = `
    <html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">
    <head>
        <meta charset="UTF-8">
        <!--[if gte mso 9]>
        <xml>
            <x:ExcelWorkbook>
                <x:ExcelWorksheets>
                    <x:ExcelWorksheet>
                        <x:Name>PCP Dashboard</x:Name>
                        <x:WorksheetOptions>
                            <x:DisplayGridlines/>
                        </x:WorksheetOptions>
                    </x:ExcelWorksheet>
                </x:ExcelWorksheets>
            </x:ExcelWorkbook>
        </xml>
        <![endif]-->
        <style>
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #333; padding: 8px; text-align: center; }
            th { background-color: #334155; color: white; font-weight: bold; }
            .title { font-size: 16px; font-weight: bold; background-color: #1e293b; color: white; }
            .kpi-header { background-color: #f1f5f9; font-weight: bold; }
            .kpi-value { font-weight: bold; }
            .kpi-machines { color: #2563eb; }
            .kpi-producing { color: #16a34a; }
            .kpi-stopped { color: #dc2626; }
            .text-left { text-align: left; }
            .text-red { color: #dc2626; font-weight: bold; }
            .text-green { color: #16a34a; font-weight: bold; }
            .text-amber { color: #d97706; font-weight: bold; }
        </style>
    </head>
    <body>
        <table>
            <tr>
                <td colspan="10" class="title">PCP Dashboard - Produção | Data: ${date} | Turno: ${shiftName}</td>
            </tr>
            <tr>
                <td colspan="3" class="kpi-header">Máquinas Planejadas</td>
                <td colspan="3" class="kpi-header">Produzindo</td>
                <td colspan="4" class="kpi-header">Paradas</td>
            </tr>
            <tr>
                <td colspan="3" class="kpi-value kpi-machines">${totalMachines}</td>
                <td colspan="3" class="kpi-value kpi-producing">${producingMachines}</td>
                <td colspan="4" class="kpi-value kpi-stopped">${stoppedMachines}</td>
            </tr>
            <tr><td colspan="10"></td></tr>
            <tr>
                <th>Máquina</th>
                <th>Prioridade</th>
                <th>Cavidade</th>
                <th>Ciclo (s)</th>
                <th>Status</th>
                <th>Cliente</th>
                <th>Produto</th>
                <th>Motivo Parada</th>
                <th>Fila</th>
                <th>Observação</th>
            </tr>`;
    
    // Dados da tabela
    const tbody = table.querySelector('tbody');
    if (tbody) {
        const trs = tbody.querySelectorAll('tr');
        trs.forEach(tr => {
            const tds = tr.querySelectorAll('td');
            if (tds.length >= 8) {
                const maquina = tds[0].textContent.trim();
                const prioridade = tds[1].textContent.trim();
                const cavidade = tds[2].textContent.trim();
                const ciclo = tds[3].textContent.trim();
                const statusCell = tds[4];
                const statusText = statusCell.textContent.trim();
                const cliente = tds[5].textContent.trim();
                const produto = tds[6].textContent.trim();
                const motivoParada = tds[7].textContent.trim();
                
                // Novas colunas: Fila e Observação
                const fila = tds[8] ? tds[8].textContent.trim().replace('OPs', '').trim() : '-';
                const observacaoInput = tds[9] ? tds[9].querySelector('input') : null;
                const observacao = observacaoInput ? observacaoInput.value.trim() : (tds[9] ? tds[9].textContent.trim() : '');
                
                // Obter cores do status da célula original
                const bgColor = statusCell.style.backgroundColor || 'transparent';
                const textColor = statusCell.style.color || '#000';
                
                // Verificar classes de cor nas células de cavidade e ciclo
                const cavClass = tds[2].classList.contains('text-red-600') ? 'text-red' : 
                                 tds[2].classList.contains('text-green-600') ? 'text-green' : '';
                const cicloClass = tds[3].classList.contains('text-red-600') ? 'text-red' : 
                                   tds[3].classList.contains('text-amber-600') ? 'text-amber' :
                                   tds[3].classList.contains('text-green-600') ? 'text-green' : '';
                
                // Cor para prioridade (INVERTIDO: 0 = urgente, 5 = mínima)
                const prioridadeNum = parseInt(prioridade);
                let prioridadeStyle = '';
                if (prioridadeNum === 0) prioridadeStyle = 'background-color: #FEE2E2; color: #B91C1C; font-weight: bold;';
                else if (prioridadeNum === 1) prioridadeStyle = 'background-color: #FFEDD5; color: #C2410C; font-weight: bold;';
                else if (prioridadeNum === 2) prioridadeStyle = 'background-color: #FEF3C7; color: #B45309; font-weight: bold;';
                else if (prioridadeNum === 3) prioridadeStyle = 'background-color: #FEF9C3; color: #A16207; font-weight: bold;';
                else if (prioridadeNum === 4) prioridadeStyle = 'background-color: #ECFCCB; color: #65A30D;';
                else if (prioridadeNum === 5) prioridadeStyle = 'background-color: #F3F4F6; color: #6B7280;';
                
                // Classe para motivo de parada
                const motivoClass = tds[7].classList.contains('text-red-600') ? 'text-red' : '';
                
                html += `
            <tr>
                <td style="font-weight: bold;">${maquina}</td>
                <td style="${prioridadeStyle}">${prioridade || '-'}</td>
                <td class="${cavClass}">${cavidade}</td>
                <td class="${cicloClass}">${ciclo}</td>
                <td style="background-color: ${bgColor}; color: ${textColor}; font-weight: bold;">${statusText}</td>
                <td class="text-left">${cliente}</td>
                <td class="text-left">${produto}</td>
                <td class="text-left ${motivoClass}">${motivoParada}</td>
                <td style="text-align: center;">${fila}</td>
                <td class="text-left">${observacao}</td>
            </tr>`;
            }
        });
    }
    
    html += `
        </table>
        <br/>
        <table>
            <tr><td colspan="10" style="font-size: 10px; color: #666;">Legenda de Status:</td></tr>
            <tr>
                <td style="background-color: rgba(34, 197, 94, 0.3); color: #16A34A; font-weight: bold;">Produzindo</td>
                <td style="background-color: rgba(233, 30, 99, 0.25); color: #E91E63; font-weight: bold;">Preparação</td>
                <td style="background-color: rgba(3, 169, 244, 0.25); color: #03A9F4; font-weight: bold;">Setup</td>
                <td style="background-color: rgba(255, 152, 0, 0.25); color: #FF9800; font-weight: bold;">Ferramentaria</td>
                <td style="background-color: rgba(156, 39, 176, 0.25); color: #9C27B0; font-weight: bold;">Processo</td>
                <td style="background-color: rgba(255, 235, 59, 0.3); color: #F59E0B; font-weight: bold;">Manutenção</td>
                <td style="background-color: rgba(244, 67, 54, 0.25); color: #F44336; font-weight: bold;">Qualidade</td>
                <td></td>
            </tr>
            <tr>
                <td style="background-color: rgba(187, 247, 208, 0.5); color: #064e3b; font-weight: bold;">Produção</td>
                <td style="background-color: rgba(121, 85, 72, 0.25); color: #795548; font-weight: bold;">Compras</td>
                <td style="background-color: rgba(97, 97, 97, 0.3); color: #616161; font-weight: bold;">Comercial</td>
                <td style="background-color: rgba(33, 33, 33, 0.8); color: #BDBDBD; font-weight: bold;">PCP</td>
                <td style="background-color: rgba(158, 158, 158, 0.3); color: #424242; font-weight: bold;">Admin.</td>
                <td style="background-color: rgba(120, 144, 156, 0.25); color: #78909C; font-weight: bold;">Outros</td>
                <td colspan="4"></td>
            </tr>
        </table>
        <br/>
        <table>
            <tr><td colspan="10" style="font-size: 10px; color: #666;">Legenda de Prioridade:</td></tr>
            <tr>
                <td style="background-color: #FEE2E2; color: #B91C1C; font-weight: bold;">5 - Urgência Máxima</td>
                <td style="background-color: #FFEDD5; color: #C2410C; font-weight: bold;">4 - Alta</td>
                <td style="background-color: #FEF3C7; color: #B45309; font-weight: bold;">3 - Média</td>
                <td style="background-color: #FEF9C3; color: #A16207; font-weight: bold;">2 - Baixa</td>
                <td style="background-color: #F3F4F6; color: #4B5563;">1 - Mínima</td>
                <td style="color: #9CA3AF;">0 - Sem prioridade</td>
                <td colspan="4"></td>
            </tr>
        </table>
        <br/>
        <p style="font-size: 10px; color: #666;">Exportado em: ${new Date().toLocaleString('pt-BR')}</p>
    </body>
    </html>`;
    
    // Criar Blob e download
    const blob = new Blob([html], { type: 'application/vnd.ms-excel;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `PCP_Dashboard_${date}_${shiftName}.xls`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    console.log('[PCP] Excel exportado com formatação:', `PCP_Dashboard_${date}_${shiftName}.xls`);
}

// Inicializar página de Ferramentaria
function setupFerramentariaPage() {
    console.log('[Ferramentaria] Inicializando módulo...');
    
    // Carregar moldes do Firebase e combinar com database local
    carregarMoldesFerramentaria();
    
    // Configurar filtros
    const filtroCliente = document.getElementById('ferram-filtro-cliente');
    const filtroStatus = document.getElementById('ferram-filtro-status');
    const buscaMolde = document.getElementById('ferram-busca-molde');
    const btnBuscar = document.getElementById('btn-buscar-moldes');
    
    if (filtroCliente) {
        // Popular dropdown de clientes
        popularClientesFerramentaria();
        filtroCliente.addEventListener('change', () => {
            ferramentariaState.filtros.cliente = filtroCliente.value;
        });
    }
    
    if (filtroStatus) {
        filtroStatus.addEventListener('change', () => {
            ferramentariaState.filtros.status = filtroStatus.value;
        });
    }
    
    if (buscaMolde) {
        buscaMolde.addEventListener('input', () => {
            ferramentariaState.filtros.busca = buscaMolde.value;
        });
    }
    
    if (btnBuscar) {
        btnBuscar.addEventListener('click', () => {
            renderizarTabelaMoldes();
        });
    }
    
    // Configurar botões
    const btnNovoMolde = document.getElementById('btn-novo-molde');
    const btnRegistrarManutencao = document.getElementById('btn-registrar-manutencao');
    
    if (btnNovoMolde) {
        btnNovoMolde.addEventListener('click', abrirModalNovoMolde);
    }
    
    if (btnRegistrarManutencao) {
        btnRegistrarManutencao.addEventListener('click', abrirModalManutencao);
    }
    
    // Configurar modais
    setupModalNovoMolde();
    setupModalManutencao();
    
    ferramentariaState.initialized = true;
    console.log('[Ferramentaria] Módulo inicializado com sucesso!');
}

// Popular dropdown de clientes
function popularClientesFerramentaria() {
    const select = document.getElementById('ferram-filtro-cliente');
    if (!select || !window.ferramentariaDatabase) return;
    
    // Obter clientes únicos
    const clientes = [...new Set(window.ferramentariaDatabase.map(m => m.client))].sort();
    
    select.innerHTML = '<option value="">Todos os clientes</option>';
    clientes.forEach(cliente => {
        const opt = document.createElement('option');
        opt.value = cliente;
        opt.textContent = cliente;
        select.appendChild(opt);
    });
}

// Carregar moldes do Firebase combinando com database local
async function carregarMoldesFerramentaria() {
    console.log('[Ferramentaria] Carregando moldes...');
    
    try {
        // Inicializar array de moldes a partir do ferramentariaDatabase
        if (!window.ferramentariaDatabase) {
            console.warn('[Ferramentaria] ferramentariaDatabase não encontrado!');
            return;
        }
        
        // Mapear moldes locais
        ferramentariaState.moldes = window.ferramentariaDatabase.map((m, index) => ({
            id: `local_${index}`,
            client: m.client,
            molde: m.molde,
            batidas_preventiva: m.batidas_preventiva,
            batidas_atuais: 0,
            ultima_manutencao: null
        }));
        
        // Carregar dados de batidas e manutenções do Firebase
        if (typeof db !== 'undefined') {
            // Carregar estado dos moldes (batidas atuais)
            const moldesSnapshot = await db.collection('ferramentaria_moldes').get();
            
            moldesSnapshot.forEach(doc => {
                const data = doc.data();
                // Encontrar molde correspondente pelo nome
                const moldeLocal = ferramentariaState.moldes.find(m => 
                    m.molde.toLowerCase() === data.molde?.toLowerCase()
                );
                
                if (moldeLocal) {
                    moldeLocal.id = doc.id;
                    moldeLocal.batidas_atuais = data.batidas_atuais || 0;
                    moldeLocal.ultima_manutencao = data.ultima_manutencao || null;
                }
            });
            
            // Carregar histórico de manutenções
            const manutencoesSnapshot = await db.collection('ferramentaria_manutencoes')
                .orderBy('data', 'desc')
                .limit(20)
                .get();
            
            ferramentariaState.manutencoes = manutencoesSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
        }
        
        // Renderizar tabela
        renderizarTabelaMoldes();
        renderizarHistoricoManutencoes();
        
    } catch (error) {
        console.error('[Ferramentaria] Erro ao carregar moldes:', error);
        showNotification('Erro ao carregar moldes', 'error');
    }
}

// Renderizar tabela de moldes
function renderizarTabelaMoldes() {
    const tbody = document.getElementById('ferram-tabela-body');
    if (!tbody) return;
    
    let moldesFiltrados = [...ferramentariaState.moldes];
    
    // Aplicar filtros
    if (ferramentariaState.filtros.cliente) {
        moldesFiltrados = moldesFiltrados.filter(m => m.client === ferramentariaState.filtros.cliente);
    }
    
    if (ferramentariaState.filtros.busca) {
        const busca = ferramentariaState.filtros.busca.toLowerCase();
        moldesFiltrados = moldesFiltrados.filter(m => 
            m.molde.toLowerCase().includes(busca) || 
            m.client.toLowerCase().includes(busca)
        );
    }
    
    // Calcular status de cada molde
    moldesFiltrados = moldesFiltrados.map(m => {
        const progresso = (m.batidas_atuais / m.batidas_preventiva) * 100;
        let status = 'ok';
        if (progresso >= 90) status = 'critico';
        else if (progresso >= 70) status = 'atencao';
        return { ...m, progresso, status };
    });
    
    // Filtrar por status
    if (ferramentariaState.filtros.status) {
        moldesFiltrados = moldesFiltrados.filter(m => m.status === ferramentariaState.filtros.status);
    }
    
    // Ordenar por progresso (críticos primeiro)
    moldesFiltrados.sort((a, b) => b.progresso - a.progresso);
    
    // Atualizar estatísticas
    const totalMoldes = ferramentariaState.moldes.length;
    const criticos = ferramentariaState.moldes.filter(m => (m.batidas_atuais / m.batidas_preventiva) >= 0.9).length;
    const atencao = ferramentariaState.moldes.filter(m => {
        const p = m.batidas_atuais / m.batidas_preventiva;
        return p >= 0.7 && p < 0.9;
    }).length;
    const normais = totalMoldes - criticos - atencao;
    
    document.getElementById('ferram-total-moldes').textContent = totalMoldes;
    document.getElementById('ferram-moldes-criticos').textContent = criticos;
    document.getElementById('ferram-moldes-atencao').textContent = atencao;
    document.getElementById('ferram-moldes-ok').textContent = normais;
    
    // Renderizar linhas
    if (moldesFiltrados.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="8" class="text-center py-12 text-gray-400">
                    <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-2 opacity-50"></i>
                    <p>Nenhum molde encontrado com os filtros aplicados</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }
    
    tbody.innerHTML = moldesFiltrados.map(m => {
        // Determinar cor do status
        let statusClass = 'bg-green-100 text-green-700';
        let statusText = 'Normal';
        let statusIcon = 'check-circle';
        let progressColor = 'bg-green-500';
        
        if (m.status === 'critico') {
            statusClass = 'bg-red-100 text-red-700';
            statusText = 'Crítico';
            statusIcon = 'alert-triangle';
            progressColor = 'bg-red-500';
        } else if (m.status === 'atencao') {
            statusClass = 'bg-yellow-100 text-yellow-700';
            statusText = 'Atenção';
            statusIcon = 'alert-circle';
            progressColor = 'bg-yellow-500';
        }
        
        const ultimaManutencao = m.ultima_manutencao 
            ? new Date(m.ultima_manutencao).toLocaleDateString('pt-BR')
            : '-';
        
        return `
            <tr class="hover:bg-gray-50 transition-colors">
                <td class="px-4 py-3 text-gray-700 font-medium">${m.client}</td>
                <td class="px-4 py-3 text-gray-900 font-semibold">${m.molde}</td>
                <td class="px-4 py-3 text-center font-mono text-gray-700">${m.batidas_atuais.toLocaleString('pt-BR')}</td>
                <td class="px-4 py-3 text-center font-mono text-gray-500">${m.batidas_preventiva.toLocaleString('pt-BR')}</td>
                <td class="px-4 py-3">
                    <div class="w-full bg-gray-200 rounded-full h-4 overflow-hidden">
                        <div class="${progressColor} h-4 rounded-full transition-all flex items-center justify-end pr-1" style="width: ${Math.min(m.progresso, 100).toFixed(1)}%">
                            <span class="text-[10px] text-white font-bold">${m.progresso.toFixed(1)}%</span>
                        </div>
                    </div>
                </td>
                <td class="px-4 py-3 text-center">
                    <span class="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-semibold ${statusClass}">
                        <i data-lucide="${statusIcon}" class="w-3 h-3"></i>
                        ${statusText}
                    </span>
                </td>
                <td class="px-4 py-3 text-center text-gray-600 text-sm">${ultimaManutencao}</td>
                <td class="px-4 py-3 text-center">
                    <div class="flex justify-center gap-1">
                        <button onclick="registrarManutencaoMolde('${m.molde}')" class="p-1.5 text-green-600 hover:bg-green-50 rounded-lg transition" title="Registrar Manutenção">
                            <i data-lucide="check-circle" class="w-4 h-4"></i>
                        </button>
                        <button onclick="editarMolde('${m.id}')" class="p-1.5 text-blue-600 hover:bg-blue-50 rounded-lg transition" title="Editar">
                            <i data-lucide="edit-2" class="w-4 h-4"></i>
                        </button>
                        <button onclick="adicionarBatidasManual('${m.molde}')" class="p-1.5 text-orange-600 hover:bg-orange-50 rounded-lg transition" title="Adicionar Batidas">
                            <i data-lucide="plus" class="w-4 h-4"></i>
                        </button>
                    </div>
                </td>
            </tr>
        `;
    }).join('');
    
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Renderizar histórico de manutenções
function renderizarHistoricoManutencoes() {
    const container = document.getElementById('ferram-historico');
    if (!container) return;
    
    if (ferramentariaState.manutencoes.length === 0) {
        container.innerHTML = `
            <div class="text-center py-6 text-gray-400">
                <i data-lucide="clipboard-list" class="w-8 h-8 mx-auto mb-2 opacity-50"></i>
                <p class="text-sm">Nenhuma manutenção registrada</p>
            </div>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        return;
    }
    
    container.innerHTML = ferramentariaState.manutencoes.map(m => {
        const data = m.data ? new Date(m.data).toLocaleDateString('pt-BR') : '-';
        const tipoClass = m.tipo === 'preventiva' ? 'bg-blue-100 text-blue-700' : 
                          m.tipo === 'corretiva' ? 'bg-orange-100 text-orange-700' : 
                          'bg-purple-100 text-purple-700';
        
        return `
            <div class="flex items-center gap-3 p-3 bg-gray-50 rounded-lg border border-gray-100">
                <div class="p-2 bg-green-100 rounded-full">
                    <i data-lucide="check" class="w-4 h-4 text-green-600"></i>
                </div>
                <div class="flex-1 min-w-0">
                    <p class="font-semibold text-gray-800 truncate">${m.molde || '-'}</p>
                    <p class="text-xs text-gray-500">${m.responsavel || '-'} • ${data}</p>
                </div>
                <span class="px-2 py-1 rounded text-xs font-semibold ${tipoClass}">${(m.tipo || 'preventiva').toUpperCase()}</span>
            </div>
        `;
    }).join('');
    
    if (typeof lucide !== 'undefined') lucide.createIcons();
}

// Setup Modal Novo Molde
function setupModalNovoMolde() {
    const modal = document.getElementById('novo-molde-modal');
    const btnClose = document.getElementById('novo-molde-close');
    const btnCancel = document.getElementById('novo-molde-cancel');
    const btnSave = document.getElementById('novo-molde-save');
    
    if (btnClose) btnClose.addEventListener('click', fecharModalNovoMolde);
    if (btnCancel) btnCancel.addEventListener('click', fecharModalNovoMolde);
    if (btnSave) btnSave.addEventListener('click', salvarMolde);
    
    // Fechar ao clicar fora
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) fecharModalNovoMolde();
        });
    }
}

// Setup Modal Manutenção
function setupModalManutencao() {
    const modal = document.getElementById('manutencao-molde-modal');
    const btnClose = document.getElementById('manutencao-molde-close');
    const btnCancel = document.getElementById('manutencao-molde-cancel');
    const btnSave = document.getElementById('manutencao-molde-save');
    const selectMolde = document.getElementById('manutencao-molde-select');
    
    if (btnClose) btnClose.addEventListener('click', fecharModalManutencao);
    if (btnCancel) btnCancel.addEventListener('click', fecharModalManutencao);
    if (btnSave) btnSave.addEventListener('click', salvarManutencao);
    
    if (selectMolde) {
        selectMolde.addEventListener('change', () => {
            atualizarInfoMoldeManutencao(selectMolde.value);
        });
    }
    
    // Fechar ao clicar fora
    if (modal) {
        modal.addEventListener('click', (e) => {
            if (e.target === modal) fecharModalManutencao();
        });
    }
}

// Abrir modal de novo molde
function abrirModalNovoMolde() {
    const modal = document.getElementById('novo-molde-modal');
    const titulo = document.getElementById('novo-molde-titulo');
    const form = document.getElementById('novo-molde-form');
    
    if (titulo) titulo.textContent = 'Cadastrar Novo Molde';
    if (form) form.reset();
    document.getElementById('edit-molde-id').value = '';
    
    if (modal) {
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Fechar modal de novo molde
function fecharModalNovoMolde() {
    const modal = document.getElementById('novo-molde-modal');
    if (modal) modal.classList.add('hidden');
}

// Abrir modal de manutenção
function abrirModalManutencao(moldeNome = null) {
    const modal = document.getElementById('manutencao-molde-modal');
    const form = document.getElementById('manutencao-molde-form');
    const selectMolde = document.getElementById('manutencao-molde-select');
    const dataInput = document.getElementById('manutencao-data');
    
    if (form) form.reset();
    
    // Popular dropdown de moldes
    if (selectMolde) {
        selectMolde.innerHTML = '<option value="">Selecione o molde</option>';
        ferramentariaState.moldes.forEach(m => {
            const opt = document.createElement('option');
            opt.value = m.molde;
            opt.textContent = `${m.client} - ${m.molde}`;
            selectMolde.appendChild(opt);
        });
        
        if (moldeNome) {
            selectMolde.value = moldeNome;
            atualizarInfoMoldeManutencao(moldeNome);
        }
    }
    
    // Data padrão: hoje
    if (dataInput) {
        dataInput.value = new Date().toISOString().split('T')[0];
    }
    
    if (modal) {
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Fechar modal de manutenção
function fecharModalManutencao() {
    const modal = document.getElementById('manutencao-molde-modal');
    if (modal) modal.classList.add('hidden');
}

// Atualizar info do molde no modal de manutenção
function atualizarInfoMoldeManutencao(moldeNome) {
    const infoContainer = document.getElementById('manutencao-info-molde');
    const molde = ferramentariaState.moldes.find(m => m.molde === moldeNome);
    
    if (!molde || !infoContainer) {
        if (infoContainer) infoContainer.classList.add('hidden');
        return;
    }
    
    const progresso = (molde.batidas_atuais / molde.batidas_preventiva) * 100;
    let progressoClass = 'text-green-600';
    if (progresso >= 90) progressoClass = 'text-red-600 font-bold';
    else if (progresso >= 70) progressoClass = 'text-yellow-600';
    
    document.getElementById('manutencao-info-cliente').textContent = molde.client;
    document.getElementById('manutencao-info-batidas').textContent = molde.batidas_atuais.toLocaleString('pt-BR');
    document.getElementById('manutencao-info-limite').textContent = molde.batidas_preventiva.toLocaleString('pt-BR');
    
    const progressoEl = document.getElementById('manutencao-info-progresso');
    progressoEl.textContent = `${progresso.toFixed(1)}%`;
    progressoEl.className = `font-semibold ml-1 ${progressoClass}`;
    
    infoContainer.classList.remove('hidden');
}

// Salvar novo molde
async function salvarMolde() {
    const cliente = document.getElementById('novo-molde-cliente').value.trim();
    const nome = document.getElementById('novo-molde-nome').value.trim();
    const batidasLimite = parseInt(document.getElementById('novo-molde-batidas-limite').value) || 0;
    const batidasAtuais = parseInt(document.getElementById('novo-molde-batidas-atuais').value) || 0;
    const editId = document.getElementById('edit-molde-id').value;
    
    if (!cliente || !nome || batidasLimite < 1000) {
        showNotification('Preencha todos os campos obrigatórios', 'warning');
        return;
    }
    
    try {
        const dados = {
            client: cliente,
            molde: nome,
            batidas_preventiva: batidasLimite,
            batidas_atuais: batidasAtuais,
            atualizado_em: new Date().toISOString()
        };
        
        if (typeof db !== 'undefined') {
            if (editId && !editId.startsWith('local_')) {
                await db.collection('ferramentaria_moldes').doc(editId).update(dados);
                showNotification('Molde atualizado com sucesso!', 'success');
            } else {
                await db.collection('ferramentaria_moldes').add(dados);
                showNotification('Molde cadastrado com sucesso!', 'success');
            }
        }
        
        fecharModalNovoMolde();
        carregarMoldesFerramentaria();
        
    } catch (error) {
        console.error('[Ferramentaria] Erro ao salvar molde:', error);
        showNotification('Erro ao salvar molde', 'error');
    }
}

// Salvar manutenção
async function salvarManutencao() {
    const moldeNome = document.getElementById('manutencao-molde-select').value;
    const data = document.getElementById('manutencao-data').value;
    const tipo = document.getElementById('manutencao-tipo').value;
    const responsavel = document.getElementById('manutencao-responsavel').value.trim();
    const obs = document.getElementById('manutencao-obs').value.trim();
    
    if (!moldeNome || !data || !responsavel) {
        showNotification('Preencha todos os campos obrigatórios', 'warning');
        return;
    }
    
    const molde = ferramentariaState.moldes.find(m => m.molde === moldeNome);
    if (!molde) {
        showNotification('Molde não encontrado', 'error');
        return;
    }
    
    try {
        if (typeof db !== 'undefined') {
            // Registrar manutenção
            await db.collection('ferramentaria_manutencoes').add({
                molde: moldeNome,
                cliente: molde.client,
                data: data,
                tipo: tipo,
                responsavel: responsavel,
                observacao: obs,
                batidas_zeradas: molde.batidas_atuais,
                registrado_em: new Date().toISOString()
            });
            
            // Zerar contador do molde
            const moldesRef = db.collection('ferramentaria_moldes');
            const query = await moldesRef.where('molde', '==', moldeNome).get();
            
            if (query.empty) {
                // Criar documento se não existir
                await moldesRef.add({
                    client: molde.client,
                    molde: moldeNome,
                    batidas_preventiva: molde.batidas_preventiva,
                    batidas_atuais: 0,
                    ultima_manutencao: data
                });
            } else {
                // Atualizar documento existente
                query.forEach(async (doc) => {
                    await doc.ref.update({
                        batidas_atuais: 0,
                        ultima_manutencao: data
                    });
                });
            }
            
            showNotification('Manutenção registrada! Contador zerado.', 'success');
        }
        
        fecharModalManutencao();
        carregarMoldesFerramentaria();
        
    } catch (error) {
        console.error('[Ferramentaria] Erro ao salvar manutenção:', error);
        showNotification('Erro ao registrar manutenção', 'error');
    }
}

// Função para registrar manutenção via botão da tabela
function registrarManutencaoMolde(moldeNome) {
    abrirModalManutencao(moldeNome);
}

// Editar molde
function editarMolde(moldeId) {
    const molde = ferramentariaState.moldes.find(m => m.id === moldeId);
    if (!molde) return;
    
    document.getElementById('edit-molde-id').value = moldeId;
    document.getElementById('novo-molde-cliente').value = molde.client;
    document.getElementById('novo-molde-nome').value = molde.molde;
    document.getElementById('novo-molde-batidas-limite').value = molde.batidas_preventiva;
    document.getElementById('novo-molde-batidas-atuais').value = molde.batidas_atuais;
    
    const titulo = document.getElementById('novo-molde-titulo');
    if (titulo) titulo.textContent = 'Editar Molde';
    
    const modal = document.getElementById('novo-molde-modal');
    if (modal) {
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Adicionar batidas manualmente
async function adicionarBatidasManual(moldeNome) {
    const quantidade = prompt(`Quantas batidas deseja adicionar ao molde "${moldeNome}"?`, '1000');
    
    if (!quantidade || isNaN(parseInt(quantidade))) return;
    
    const batidas = parseInt(quantidade);
    if (batidas <= 0) {
        showNotification('Quantidade deve ser maior que zero', 'warning');
        return;
    }
    
    try {
        const molde = ferramentariaState.moldes.find(m => m.molde === moldeNome);
        if (!molde) return;
        
        const novasBatidas = molde.batidas_atuais + batidas;
        
        if (typeof db !== 'undefined') {
            const moldesRef = db.collection('ferramentaria_moldes');
            const query = await moldesRef.where('molde', '==', moldeNome).get();
            
            if (query.empty) {
                await moldesRef.add({
                    client: molde.client,
                    molde: moldeNome,
                    batidas_preventiva: molde.batidas_preventiva,
                    batidas_atuais: novasBatidas,
                    ultima_manutencao: null
                });
            } else {
                query.forEach(async (doc) => {
                    await doc.ref.update({ batidas_atuais: novasBatidas });
                });
            }
        }
        
        showNotification(`${batidas.toLocaleString('pt-BR')} batidas adicionadas!`, 'success');
        carregarMoldesFerramentaria();
        
    } catch (error) {
        console.error('[Ferramentaria] Erro ao adicionar batidas:', error);
        showNotification('Erro ao adicionar batidas', 'error');
    }
}

/**
 * =====================================================
 * INTEGRAÇÃO AUTOMÁTICA - BATIDAS POR PRODUÇÃO
 * =====================================================
 * Quando uma produção é registrada, esta função calcula
 * automaticamente as batidas e atualiza o molde no Firebase.
 * 
 * Fórmula: batidas = quantidade_produzida / cavidades_molde
 */
async function atualizarBatidasPorProducao(productCod, quantidadeProduzida) {
    try {
        // 1. Verificar se temos o código do produto
        if (!productCod || !quantidadeProduzida || quantidadeProduzida <= 0) {
            console.log('[Ferramentaria] Código do produto ou quantidade inválidos');
            return { success: false, reason: 'dados_invalidos' };
        }
        
        // 2. Verificar se o produto está mapeado para um molde
        if (!window.moldePorProduto) {
            console.warn('[Ferramentaria] moldePorProduto não carregado');
            return { success: false, reason: 'mapeamento_nao_carregado' };
        }
        
        const nomeMolde = window.moldePorProduto[productCod];
        if (!nomeMolde) {
            console.log(`[Ferramentaria] Produto ${productCod} não está mapeado para nenhum molde`);
            return { success: false, reason: 'produto_nao_mapeado' };
        }
        
        // 3. Obter cavidades do produto no productDatabase
        let cavidades = 1; // Padrão se não encontrar
        if (window.productDatabase) {
            const produto = window.productDatabase.find(p => p.cod == productCod);
            if (produto && produto.cavities && produto.cavities > 0) {
                cavidades = produto.cavities;
            } else {
                console.warn(`[Ferramentaria] Produto ${productCod} sem cavidades definidas, usando 1`);
            }
        }
        
        // 4. Calcular batidas
        const batidasNovas = Math.round(quantidadeProduzida / cavidades);
        
        if (batidasNovas <= 0) {
            console.log('[Ferramentaria] Nenhuma batida calculada');
            return { success: false, reason: 'batidas_zero' };
        }
        
        console.log(`[Ferramentaria] Calculando batidas: ${quantidadeProduzida} peças / ${cavidades} cavidades = ${batidasNovas} batidas para molde "${nomeMolde}"`);
        
        // 5. Buscar/Atualizar molde no Firebase
        if (typeof db === 'undefined') {
            console.warn('[Ferramentaria] Firebase não disponível');
            return { success: false, reason: 'firebase_indisponivel' };
        }
        
        // Buscar molde existente
        const moldesRef = db.collection('ferramentaria_moldes');
        const query = await moldesRef.where('molde', '==', nomeMolde).get();
        
        if (!query.empty) {
            // Molde existe - atualizar batidas
            const doc = query.docs[0];
            const dadosMolde = doc.data();
            const batidasAtuais = dadosMolde.batidas_atuais || 0;
            const novoTotalBatidas = batidasAtuais + batidasNovas;
            
            await doc.ref.update({
                batidas_atuais: novoTotalBatidas,
                ultima_atualizacao: firebase.firestore.FieldValue.serverTimestamp(),
                ultima_producao: {
                    product_cod: productCod,
                    quantidade: quantidadeProduzida,
                    batidas: batidasNovas,
                    data: new Date().toISOString()
                }
            });
            
            console.log(`[Ferramentaria] ✅ Molde "${nomeMolde}" atualizado: ${batidasAtuais} → ${novoTotalBatidas} batidas (+${batidasNovas})`);
            
            // Verificar se atingiu limite para alerta
            const moldeLocal = window.ferramentariaDatabase?.find(m => m.molde === nomeMolde);
            if (moldeLocal) {
                const percentual = (novoTotalBatidas / moldeLocal.batidas_preventiva) * 100;
                if (percentual >= 90) {
                    console.warn(`[Ferramentaria] ⚠️ ALERTA CRÍTICO: Molde "${nomeMolde}" em ${percentual.toFixed(1)}% do limite!`);
                } else if (percentual >= 70) {
                    console.warn(`[Ferramentaria] ⚠️ ATENÇÃO: Molde "${nomeMolde}" em ${percentual.toFixed(1)}% do limite`);
                }
            }
            
            return { 
                success: true, 
                molde: nomeMolde, 
                batidasAdicionadas: batidasNovas, 
                totalBatidas: novoTotalBatidas,
                cavidades: cavidades
            };
            
        } else {
            // Molde não existe no Firebase - criar com os dados locais
            const moldeLocal = window.ferramentariaDatabase?.find(m => m.molde === nomeMolde);
            
            if (moldeLocal) {
                await moldesRef.add({
                    client: moldeLocal.client,
                    molde: nomeMolde,
                    batidas_preventiva: moldeLocal.batidas_preventiva,
                    batidas_atuais: batidasNovas,
                    ultima_manutencao: null,
                    criado_em: firebase.firestore.FieldValue.serverTimestamp(),
                    ultima_atualizacao: firebase.firestore.FieldValue.serverTimestamp(),
                    ultima_producao: {
                        product_cod: productCod,
                        quantidade: quantidadeProduzida,
                        batidas: batidasNovas,
                        data: new Date().toISOString()
                    }
                });
                
                console.log(`[Ferramentaria] ✅ Molde "${nomeMolde}" criado no Firebase com ${batidasNovas} batidas iniciais`);
                
                return { 
                    success: true, 
                    molde: nomeMolde, 
                    batidasAdicionadas: batidasNovas, 
                    totalBatidas: batidasNovas,
                    cavidades: cavidades,
                    novo: true
                };
            } else {
                console.warn(`[Ferramentaria] Molde "${nomeMolde}" não encontrado no ferramentariaDatabase`);
                return { success: false, reason: 'molde_nao_encontrado' };
            }
        }
        
    } catch (error) {
        console.error('[Ferramentaria] Erro ao atualizar batidas:', error);
        return { success: false, reason: 'erro', error: error.message };
    }
}

// Expor funções globalmente
window.setupFerramentariaPage = setupFerramentariaPage;
window.registrarManutencaoMolde = registrarManutencaoMolde;
window.editarMolde = editarMolde;
window.adicionarBatidasManual = adicionarBatidasManual;
window.atualizarBatidasPorProducao = atualizarBatidasPorProducao;

// =========================================
// FIM DO MÓDULO FERRAMENTARIA
// =========================================

// Inicializar módulo de ordens quando página carregar
document.addEventListener('DOMContentLoaded', function() {
    // Pré-carregar ordens em background para ter dados prontos quando abrir a aba
    setTimeout(function() {
        if (window.OrdersPageModule && typeof window.OrdersPageModule.loadOrders === 'function') {
            console.log('[OrdersPage] Pré-carregando ordens em background...');
            // Só inicializa os elementos quando a aba for aberta
        }
    }, 2000);
});

// =========================================
// INICIALIZAÇÃO PARADA EM LOTE (GLOBAL)
// =========================================
document.addEventListener('DOMContentLoaded', function() {
    console.log('[PARADA-LOTE-GLOBAL] Iniciando setup de parada em lote...');
    
    // Aguardar para garantir que o DOM está completamente carregado
    setTimeout(function() {
        const btnAbrir = document.getElementById('btn-parada-em-lote');
        const container = document.getElementById('parada-lote-container');
        
        console.log('[PARADA-LOTE-GLOBAL] Elementos encontrados:', {
            btnAbrir: !!btnAbrir,
            container: !!container
        });
        
        if (!btnAbrir || !container) {
            console.error('[PARADA-LOTE-GLOBAL] Elementos não encontrados!');
            return;
        }
        
        // Já tem listener? Verificar
        if (btnAbrir.dataset.paradaLoteInit) {
            console.log('[PARADA-LOTE-GLOBAL] Já inicializado, pulando...');
            return;
        }
        btnAbrir.dataset.paradaLoteInit = 'true';
        
        const gridMaquinas = document.getElementById('maquinas-lote-grid');
        const countEl = document.getElementById('maquinas-selecionadas-count');
        const btnSelecionarTodas = document.getElementById('btn-selecionar-todas');
        const btnLimparSelecao = document.getElementById('btn-limpar-selecao');
        const categoriaSelect = document.getElementById('parada-lote-categoria');
        const motivoSelect = document.getElementById('parada-lote-motivo');
        const dataInput = document.getElementById('parada-lote-data');
        const horaInput = document.getElementById('parada-lote-hora');
        const btnUsarAgora = document.getElementById('parada-lote-usar-agora');
        const btnFechar = document.getElementById('btn-fechar-parada-lote');
        const form = document.getElementById('parada-lote-form');
        
        // Lista de máquinas válidas (26 máquinas)
        const validMachines = ['H01', 'H02', 'H03', 'H04', 'H05', 'H06', 'H07', 'H08', 'H09', 'H10', 
                               'H12', 'H13', 'H14', 'H15', 'H16', 'H17', 'H18', 'H19', 'H20', 
                               'H26', 'H27', 'H28', 'H29', 'H30', 'H31', 'H32'];
        
        // Motivos por categoria
        const motivosPorCategoria = {
            'ADMINISTRATIVO': [ 'QUEDA DE ENERGIA'],
            'MANUTENÇÃO': ['MANUTENÇÃO PREVENTIVA GERAL', 'PARADA PROGRAMADA', 'MANUTENÇÃO DE INFRAESTRUTURA'],
            'COMPRAS': ['FALTA DE MATÉRIA PRIMA GERAL', 'ATRASO NO FORNECEDOR'],
            'PCP': ['SEM PROGRAMAÇÃO', 'SEM PROGRAMAÇÃO-FIM DE SEMANA', 'ESTRATÉGIA PCP'],
            'COMERCIAL': ['SEM PEDIDO', 'BAIXA DEMANDA']
        };
        
        // Renderizar grid de máquinas
        function renderMaquinasGrid() {
            if (!gridMaquinas) return;
            gridMaquinas.innerHTML = validMachines.map(m => `
                <label class="flex items-center justify-center p-2 border-2 border-gray-200 rounded-lg cursor-pointer hover:bg-orange-50 hover:border-orange-300 transition-all maquina-lote-item" data-machine="${m}">
                    <input type="checkbox" name="maquinas-lote" value="${m}" class="sr-only maquina-lote-checkbox">
                    <span class="text-sm font-bold text-gray-700">${m}</span>
                </label>
            `).join('');
            
            // Event listeners nos checkboxes
            gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                item.addEventListener('click', () => {
                    const checkbox = item.querySelector('.maquina-lote-checkbox');
                    checkbox.checked = !checkbox.checked;
                    if (checkbox.checked) {
                        item.classList.add('bg-orange-100', 'border-orange-500');
                        item.querySelector('span').classList.add('text-orange-700');
                    } else {
                        item.classList.remove('bg-orange-100', 'border-orange-500');
                        item.querySelector('span').classList.remove('text-orange-700');
                    }
                    updateCount();
                });
            });
        }
        
        // Atualizar contagem
        function updateCount() {
            if (!gridMaquinas || !countEl) return;
            const count = gridMaquinas.querySelectorAll('.maquina-lote-checkbox:checked').length;
            countEl.textContent = `${count} máquina${count !== 1 ? 's' : ''} selecionada${count !== 1 ? 's' : ''}`;
        }
        
        // Atualizar motivos baseado na categoria
        function updateMotivos() {
            if (!motivoSelect || !categoriaSelect) return;
            const categoria = categoriaSelect.value;
            const motivos = motivosPorCategoria[categoria] || [];
            motivoSelect.innerHTML = '<option value="">Selecione o motivo...</option>' + 
                motivos.map(m => `<option value="${m}">${m}</option>`).join('');
        }
        
        // Definir data/hora atual
        function setCurrentDateTime() {
            const now = new Date();
            if (dataInput) dataInput.value = now.toISOString().split('T')[0];
            if (horaInput) horaInput.value = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
        }
        
        // ========== EVENT LISTENERS ==========
        
        // Botão abrir
        btnAbrir.addEventListener('click', function(e) {
            e.preventDefault();
            console.log('[PARADA-LOTE-GLOBAL] Botão clicado!');
            container.classList.toggle('hidden');
            if (!container.classList.contains('hidden')) {
                console.log('[PARADA-LOTE-GLOBAL] Abrindo container...');
                renderMaquinasGrid();
                setCurrentDateTime();
                updateMotivos();
                if (typeof lucide !== 'undefined') {
                    setTimeout(() => lucide.createIcons(), 100);
                }
            }
        });
        
        // Botão fechar
        if (btnFechar) {
            btnFechar.addEventListener('click', () => {
                container.classList.add('hidden');
            });
        }
        
        // Selecionar todas
        if (btnSelecionarTodas) {
            btnSelecionarTodas.addEventListener('click', () => {
                gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                    const checkbox = item.querySelector('.maquina-lote-checkbox');
                    checkbox.checked = true;
                    item.classList.add('bg-orange-100', 'border-orange-500');
                    item.querySelector('span').classList.add('text-orange-700');
                });
                updateCount();
            });
        }
        
        // Limpar seleção
        if (btnLimparSelecao) {
            btnLimparSelecao.addEventListener('click', () => {
                gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                    const checkbox = item.querySelector('.maquina-lote-checkbox');
                    checkbox.checked = false;
                    item.classList.remove('bg-orange-100', 'border-orange-500');
                    item.querySelector('span').classList.remove('text-orange-700');
                });
                updateCount();
            });
        }
        
        // Mudar categoria
        if (categoriaSelect) {
            categoriaSelect.addEventListener('change', updateMotivos);
        }
        
        // Usar agora
        if (btnUsarAgora) {
            btnUsarAgora.addEventListener('click', () => {
                setCurrentDateTime();
                if (typeof showNotification === 'function') {
                    showNotification('✅ Data e hora atualizados', 'success');
                }
            });
        }
        
        // Submit do formulário
        if (form && !form.dataset.listenerAttached) {
            form.dataset.listenerAttached = 'true';
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const statusDiv = document.getElementById('parada-lote-status');
                const submitBtn = document.getElementById('parada-lote-submit');
                
                // Coletar máquinas selecionadas
                const maquinasSelecionadas = [];
                gridMaquinas.querySelectorAll('.maquina-lote-checkbox:checked').forEach(cb => {
                    maquinasSelecionadas.push(cb.value);
                });
                
                const categoria = categoriaSelect.value;
                const motivo = motivoSelect.value;
                const data = dataInput.value;
                const hora = horaInput.value;
                
                // Validações
                if (maquinasSelecionadas.length === 0) {
                    if (statusDiv) {
                        statusDiv.textContent = '⚠️ Selecione ao menos uma máquina!';
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
                    }
                    return;
                }
                
                if (!categoria || !motivo || !data || !hora) {
                    if (statusDiv) {
                        statusDiv.textContent = '⚠️ Preencha todos os campos!';
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
                    }
                    return;
                }
                
                try {
                    if (submitBtn) submitBtn.disabled = true;
                    if (statusDiv) {
                        statusDiv.textContent = `Registrando paradas para ${maquinasSelecionadas.length} máquinas...`;
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-blue-600';
                    }
                    
                    const startDateTime = new Date(`${data}T${hora}:00`);
                    const userName = typeof getActiveUser === 'function' ? (getActiveUser()?.name || 'Sistema') : 'Sistema';
                    const batch = db.batch();
                    const batchId = Date.now().toString();
                    
                    // Criar documento para cada máquina
                    maquinasSelecionadas.forEach(machineId => {
                        const docRef = db.collection('extended_downtime_logs').doc();
                        batch.set(docRef, {
                            machine_id: machineId,
                            category: categoria,
                            type: motivo,
                            reason: motivo,
                            start_date: data,
                            start_time: hora,
                            start_datetime: firebase.firestore.Timestamp.fromDate(startDateTime),
                            end_date: null,
                            end_time: null,
                            end_datetime: null,
                            status: 'active',
                            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                            createdBy: userName,
                            shift: typeof getCurrentShift === 'function' ? getCurrentShift(startDateTime) : 'N/A',
                            date: data,
                            batch_id: batchId
                        });
                    });
                    
                    await batch.commit();
                    
                    console.log('[PARADA-LOTE-GLOBAL] ✅ Paradas registradas:', maquinasSelecionadas.length, 'máquinas');
                    
                    if (statusDiv) {
                        statusDiv.textContent = `✅ Parada registrada para ${maquinasSelecionadas.length} máquinas!`;
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-green-600';
                    }
                    
                    // Limpar formulário
                    gridMaquinas.querySelectorAll('.maquina-lote-item').forEach(item => {
                        const checkbox = item.querySelector('.maquina-lote-checkbox');
                        checkbox.checked = false;
                        item.classList.remove('bg-orange-100', 'border-orange-500');
                        item.querySelector('span').classList.remove('text-orange-700');
                    });
                    updateCount();
                    categoriaSelect.value = '';
                    motivoSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
                    
                    // Fechar após 2 segundos
                    setTimeout(() => {
                        container.classList.add('hidden');
                        if (statusDiv) statusDiv.textContent = '';
                    }, 2000);
                    
                } catch (error) {
                    console.error('[PARADA-LOTE-GLOBAL] Erro:', error);
                    if (statusDiv) {
                        statusDiv.textContent = `❌ Erro: ${error.message}`;
                        statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
                    }
                } finally {
                    if (submitBtn) submitBtn.disabled = false;
                }
            });
        }
        
        console.log('[PARADA-LOTE-GLOBAL] ✅ Inicialização completa!');
        
    }, 1000); // Aguardar 1 segundo para garantir que DOM está pronto
});