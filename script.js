// Popular o select de MP no cadastro de ordem de produção
document.addEventListener('DOMContentLoaded', async function() {
    // Ocultar subaba Analytics IA para todos, exceto usuários autorizados (Leandro Camargo ou role 'suporte')
    setTimeout(() => {
        try {
            const user = window.authSystem?.getCurrentUser?.();
            const analyticsBtn = document.querySelector('.analysis-tab-btn[data-view="predictive"]');
            const isAuthorizedUser = user && (
                user.name === 'Leandro Camargo' || user.username === 'leandro.camargo' ||
                user.role === 'suporte'
            );
            if (analyticsBtn && !isAuthorizedUser) {
                analyticsBtn.style.display = 'none';
            }
            
            // Mostrar filtro de data no lançamento para Leandro Camargo ou perfis de suporte
            const lancamentoDateFilter = document.getElementById('lancamento-date-filter');
            const isLeandro = user && (
                user.name === 'Leandro Camargo' || user.username === 'leandro.camargo' ||
                user.email === 'leandro@hokkaido.com.br'
            );
            const isSuporte = user?.role === 'suporte';
            if (lancamentoDateFilter && (isLeandro || isSuporte)) {
                lancamentoDateFilter.classList.remove('hidden');
                setupLancamentoDateFilter();
            }
            
            // Mostrar botão de Novo Produto apenas para usuários autorizados (gestores, suporte ou Leandro)
            const btnNewProduct = document.getElementById('btn-new-product');
            const isGestorOrAdmin = user && (
                user.name === 'Leandro Camargo' || user.username === 'leandro.camargo' ||
                user.email === 'leandro@hokkaido.com.br' ||
                user.role === 'suporte' || user.role === 'gestor'
            );
            if (btnNewProduct && !isGestorOrAdmin) {
                btnNewProduct.style.display = 'none';
            }
        } catch (e) {
            console.warn('Não foi possível aplicar restrição da subaba Analytics IA:', e);
        }
    }, 300);
    
    // Configurar filtro de data do lançamento
    function setupLancamentoDateFilter() {
        const dateInput = document.getElementById('lancamento-date-input');
        const applyBtn = document.getElementById('lancamento-date-apply');
        const resetBtn = document.getElementById('lancamento-date-reset');
        const indicator = document.getElementById('lancamento-date-indicator');
        const dateLabel = document.getElementById('lancamento-date-label');
        
        if (!dateInput) return;
        
        // Definir data atual como padrão
        const today = new Date();
        const hour = today.getHours();
        if (hour < 7) today.setDate(today.getDate() - 1);
        const todayStr = today.toISOString().split('T')[0];
        dateInput.value = todayStr;
        
        // Variável global para data selecionada no lançamento
        window.lancamentoFilterDate = null;
        
        applyBtn?.addEventListener('click', () => {
            const selectedDate = dateInput.value;
            if (!selectedDate) return;
            
            window.lancamentoFilterDate = selectedDate;
            
            // Mostrar indicador
            if (indicator) indicator.classList.remove('hidden');
            if (dateLabel) {
                const dateObj = new Date(selectedDate + 'T12:00:00');
                const formatted = dateObj.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: '2-digit' });
                dateLabel.textContent = `Visualizando: ${formatted}`;
            }
            
            // Recarregar dados com a nova data
            if (typeof populateMachineSelector === 'function') {
                populateMachineSelector(selectedDate);
            }
            if (typeof loadTodayStats === 'function') {
                loadTodayStats(selectedDate);
            }
            if (typeof loadRecentEntries === 'function') {
                loadRecentEntries(false, selectedDate);
            }
            
            console.log('[FILTRO DATA] Aplicado:', selectedDate);
        });
        
        resetBtn?.addEventListener('click', () => {
            window.lancamentoFilterDate = null;
            dateInput.value = todayStr;
            
            // Ocultar indicador
            if (indicator) indicator.classList.add('hidden');
            
            // Recarregar dados do dia atual
            if (typeof populateMachineSelector === 'function') {
                populateMachineSelector();
            }
            if (typeof loadTodayStats === 'function') {
                loadTodayStats();
            }
            if (typeof loadRecentEntries === 'function') {
                loadRecentEntries(false);
            }
            
            console.log('[FILTRO DATA] Resetado para hoje');
        });
        
        // Renderizar ícones
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
    
    function popularSelectMPOrdem() {
        const select = document.getElementById('order-raw-material');
        if (!select) return;
        select.innerHTML = '<option value="">Selecione a matéria-prima...</option>';
        materiaPrimaDatabase.forEach(mp => {
            const opt = document.createElement('option');
            opt.value = mp.codigo;
            opt.textContent = `${mp.codigo} - ${mp.descricao}`;
            select.appendChild(opt);
        });
    }
    carregarBancoMateriaPrima(popularSelectMPOrdem);
});
// Utilitário para obter descrição da MP pelo código
function getDescricaoMP(codigo) {
    const cod = Number(codigo);
    const mp = materiaPrimaDatabase.find(mp => Number(mp.codigo) === cod);
    return mp ? mp.descricao : String(codigo);
}

// Exemplo de uso em análises de perda:
// Em qualquer local que exibe ou processa MP de perda, use getDescricaoMP(codigo) para mostrar a descrição padronizada.

// Exemplo para gráficos e relatórios:
// const descricao = getDescricaoMP(loss.mp_codigo);
// Popular o select de MP na tela de planejamento
document.addEventListener('DOMContentLoaded', function() {
    function popularSelectMPPlanejamento() {
        const select = document.getElementById('planning-mp');
        if (!select) return;
        select.innerHTML = '<option value="">Selecione a matéria-prima...</option>';
        materiaPrimaDatabase.forEach(mp => {
            const opt = document.createElement('option');
            opt.value = mp.codigo;
            opt.textContent = `${mp.codigo} - ${mp.descricao}`;
            select.appendChild(opt);
        });
    }
    carregarBancoMateriaPrima(popularSelectMPPlanejamento);
});
// --- Integração do banco de Matéria-prima no modal de edição de ordem ---
// Carregar banco de matéria-prima
function carregarBancoMateriaPrima(callback) {
    if (window.materiaPrimaDatabase && Array.isArray(window.materiaPrimaDatabase)) {
          if (callback) callback(); // Callback to populate the select
    }
}

function popularSelectMP() {
    const select = document.getElementById('edit-order-mp');
    if (!select) return;
    select.innerHTML = '<option value="">Selecione a matéria-prima...</option>';
    materiaPrimaDatabase.forEach(mp => {
          const opt = document.createElement('option');
          opt.value = mp.codigo;
          opt.textContent = `${mp.codigo} - ${mp.descricao}`;
          select.appendChild(opt); // Append option to select
    });
}

// Popular o select de MP ao abrir o modal de edição
document.addEventListener('DOMContentLoaded', function() {
    const editOrderModal = document.getElementById('edit-order-modal');
    // Sempre popular o select de MP ao exibir o modal
    if (editOrderModal) {
        // Usar MutationObserver para detectar exibição do modal
        const observer = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                if (mutation.attributeName === 'class') {
                    const isVisible = !editOrderModal.classList.contains('hidden');
                    if (isVisible) {
                        carregarBancoMateriaPrima(popularSelectMP);
                    }
                }
            });
        });
        observer.observe(editOrderModal, { attributes: true });
    }
    // Fallback: popular ao abrir o modal manualmente
    const btns = document.querySelectorAll('[data-edit-order]');
    btns.forEach(btn => {
        btn.addEventListener('click', function() {
            carregarBancoMateriaPrima(popularSelectMP);
        });
    });
});
// This file contains the full and correct JavaScript code for the Hokkaido Synchro MES application.
// All functionalities, including the new database with product codes, are implemented here.

document.addEventListener('DOMContentLoaded', function() {
    console.log('📍 [DEBUG] script.js DOMContentLoaded iniciado');
    console.log('📍 [DEBUG] window.authSystem disponível?', window.authSystem);
    if (window.authSystem) {
        console.log('📍 [DEBUG] currentUser:', window.authSystem.getCurrentUser?.());
    }
    
    // Firebase Configuration
    if (typeof firebase === 'undefined' || typeof firebase.firestore === 'undefined') {
        alert("Erro Crítico: A biblioteca da base de dados não conseguiu ser carregada.");
        return;
    }

    const firebaseConfig = {
        apiKey: "AIzaSyB1YrMK07_7QROsCJQqE0MFsmJncfjphmI",
        authDomain: "hokkaido-synchro.firebaseapp.com",
        projectId: "hokkaido-synchro",
        storageBucket: "hokkaido-synchro.firebasestorage.app",
        messagingSenderId: "635645564631",
        appId: "1:635645564631:web:1e19be7957e39d1adc8292"
    };

    let db;
    let storage = null;
    
    // Sistema de gerenciamento de listeners Firestore
    const listenerManager = {
        listeners: new Map(),
        
        subscribe(name, query, onSnapshot, onError) {
            // Desinscrever anterior se existir
            this.unsubscribe(name);
            
            try {
                const unsubscribe = query.onSnapshot(
                    snapshot => {
                        try {
                            onSnapshot(snapshot);
                        } catch (error) {
                            console.error(`Erro ao processar snapshot ${name}:`, error);
                        }
                    },
                    error => {
                        console.error(`Erro no listener ${name}:`, error);
                        if (onError) onError(error);
                    }
                );
                
                this.listeners.set(name, unsubscribe);
                console.log(`✅ Listener "${name}" inscrito`);
            } catch (error) {
                console.error(`Erro ao criar listener ${name}:`, error);
                if (onError) onError(error);
            }
        },
        
        unsubscribe(name) {
            const unsubscribe = this.listeners.get(name);
            if (unsubscribe) {
                try {
                    unsubscribe();
                    this.listeners.delete(name);
                    console.log(`✅ Listener "${name}" desinscritos`);
                } catch (error) {
                    console.error(`Erro ao desinscrever listener ${name}:`, error);
                }
            }
        },
        
        unsubscribeAll() {
            for (const name of this.listeners.keys()) {
                this.unsubscribe(name);
            }
        }
    };
    
    // Limpar listeners quando a página está se descarregando
    window.addEventListener('beforeunload', () => {
        listenerManager.unsubscribeAll();
    });
    
    try {
        if (!firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
        
        // Configurações de Firestore para melhorar estabilidade
    db = firebase.firestore();
    window.db = db;
        
        // Tentar desabilitar QUIC se disponível (evita ERR_QUIC_PROTOCOL_ERROR)
        if (db.settings) {
            try {
                db.settings({
                    experimentalForceLongPolling: true
                });
                console.log('✅ Firestore: Long polling forçado (QUIC desabilitado)');
            } catch (e) {
                console.warn('⚠️ Não foi possível configurar long polling:', e.message);
            }
        }
        
        if (typeof firebase.storage === 'function') {
            // Nota: Fotos foram removidas do sistema; Storage não é utilizado.
            console.log('Firebase Storage detectado (não utilizado: fotos removidas)');
        } else {
            console.log('Firebase Storage indisponível (irrelevante: fotos removidas).');
        }
        
        // Firebase inicializado (teste de conexão removido para otimização)
        console.log('Firebase inicializado com sucesso');
        console.log('Firestore instance:', db);
        
    } catch (error) {
        console.error("Erro ao inicializar Firebase: ", error);
        alert("Erro fatal: Não foi possível conectar à base de dados.");
        return;
    }

    // Monitor global para erros de rede (inclui QUIC)
    window.addEventListener('error', (event) => {
        if (event.message && event.message.includes('QUIC')) {
            console.warn('⚠️ QUIC Protocol Error detectado - tentando reconectar...');
            console.warn('Detalhes:', {
                message: event.message,
                filename: event.filename,
                lineno: event.lineno,
                colno: event.colno
            });
        }
    });

    // Monitor para erros não capturados de Promise
    window.addEventListener('unhandledrejection', (event) => {
        if (event.reason && (event.reason.message?.includes('QUIC') || event.reason.code?.includes('QUIC'))) {
            console.warn('⚠️ QUIC Promise Rejection detectada');
            console.warn('Reason:', event.reason);
            // Não preventar o erro - deixar prosseguir normalmente
        }
    });

    // --- Configuration Lists ---
    // Normalização de IDs de máquina: H01, H02, ...
    function normalizeMachineId(id) {
        if (!id) return null;
        const s = String(id).toUpperCase().replace(/\s+/g, '');
        // Aceita H-01, H01, h01 etc.; mantém dois dígitos
        const match = s.match(/^H[-_]?(\d{1,2})$/);
        if (match) {
            return `H${match[1].padStart(2, '0')}`;
        }
        // Se vier apenas dígitos (ex.: 1, 01), prefixa H
        const n = s.match(/^(\d{1,2})$/);
        if (n) {
            return `H${n[1].padStart(2, '0')}`;
        }
        // Fallback: remove hífens e tenta novamente
        const cleaned = s.replace(/-/g, '');
        const m2 = cleaned.match(/^H(\d{1,2})$/);
        if (m2) return `H${m2[1].padStart(2, '0')}`;
        return s; // devolve como veio se não reconhecer
    }

    // ================================
    // FUNÇÕES DE TARA E PESOS - TUDO EM GRAMAS
    // ================================
    
    // Obter peso da tara para uma máquina específica (retorna em GRAMAS)
    function getTareWeightForMachine(machine) {
        if (!machine) return 0;
        
        const normalizedMachine = normalizeMachineId(machine);
        const tareWeightKg = window.databaseModule?.tareByMachine?.get(normalizedMachine);
        
        if (!tareWeightKg) return 0;
        
        // Converter kg para gramas - sempre retornar em gramas!
        return Math.round(tareWeightKg * 1000);
    }
    
    // Converter kg para gramas com validação
    function kgToGrams(kg) {
        const num = parseFloat(kg);
        if (!Number.isFinite(num) || num < 0) return 0;
        return Math.round(num * 1000);
    }
    
    // Converter gramas para kg com precisão
    function gramsToKg(grams) {
        const num = parseFloat(grams);
        if (!Number.isFinite(num) || num < 0) return 0;
        return num / 1000;
    }
    
    // Calcular quantidade de peças baseado em peso em gramas
    // Retorna { quantity: número, remainder: gramas restantes, error: null | string }
    function calculateQuantityFromGrams(weightGrams, pieceWeightGrams) {
        const weight = parseFloat(weightGrams) || 0;
        const pieceWeight = parseFloat(pieceWeightGrams) || 0;
        
        if (weight <= 0 || pieceWeight <= 0) {
            return { quantity: 0, remainder: weight, error: 'Peso da peça ou peso total inválido' };
        }
        
        const quantity = Math.floor(weight / pieceWeight);
        const remainder = weight % pieceWeight;
        
        return { 
            quantity: Math.max(0, quantity), 
            remainder: Math.max(0, remainder),
            error: null 
        };
    }
    
    // Calcular peso total esperado para quantidade de peças em gramas
    function calculateExpectedWeightGrams(quantity, pieceWeightGrams) {
        const qty = parseInt(quantity) || 0;
        const pieceWeight = parseFloat(pieceWeightGrams) || 0;
        
        if (qty < 0 || pieceWeight <= 0) return 0;
        
        return qty * pieceWeight;
    }
    
    // Validar consistência: se tem quantidade E peso, verificar se são coerentes
    // Retorna { valid: boolean, message: string, suggestedQty: number }
    function validateWeightQuantityConsistency(weightGrams, quantity, pieceWeightGrams, tolerancePercent = 5) {
        const weight = parseFloat(weightGrams) || 0;
        const qty = parseInt(quantity) || 0;
        const pieceWeight = parseFloat(pieceWeightGrams) || 0;
        
        if (weight <= 0 || qty <= 0 || pieceWeight <= 0) {
            return { valid: true, message: '', suggestedQty: qty };
        }
        
        const expectedWeight = qty * pieceWeight;
        const tolerance = (expectedWeight * tolerancePercent) / 100;
        const difference = Math.abs(weight - expectedWeight);
        
        const suggestedQty = Math.round(weight / pieceWeight);
        
        if (difference > tolerance) {
            return {
                valid: false,
                message: `⚠️ Inconsistência detectada! Peso: ${(weight/1000).toFixed(3)}kg | Peças: ${qty} | Peso esperado: ${(expectedWeight/1000).toFixed(3)}kg | Sugestão: ${suggestedQty} peças`,
                suggestedQty: suggestedQty
            };
        }
        
        return { valid: true, message: '', suggestedQty: qty };
    }
    
    // Configurar campos de tara nos formulários
    function setupTareControls() {
        // Limpar estados antigos na inicialização
        cleanOldTareStates();
        
        // Formulário de produção rápida
        const quickUseTareCheckbox = document.getElementById('quick-production-use-tare');
        const quickTareInfo = document.getElementById('quick-production-tare-info');
        const quickTareWeight = document.getElementById('quick-production-tare-weight');
        
        if (quickUseTareCheckbox) {
            quickUseTareCheckbox.addEventListener('change', function() {
                updateTareDisplay('quick', this.checked);
                // Salvar estado quando mudado
                if (selectedMachineData?.machine) {
                    saveTareState(selectedMachineData.machine, this.checked);
                }
            });
        }
        
        // Formulário de produção manual
        const manualUseTareCheckbox = document.getElementById('manual-production-use-tare');
        const manualTareInfo = document.getElementById('manual-production-tare-info');
        const manualTareWeight = document.getElementById('manual-production-tare-weight');
        
        if (manualUseTareCheckbox) {
            manualUseTareCheckbox.addEventListener('change', function() {
                updateTareDisplay('manual', this.checked);
                // Salvar estado quando mudado
                if (selectedMachineData?.machine) {
                    saveTareState(selectedMachineData.machine, this.checked);
                }
            });
        }
        
        // Formulário de perdas
        const lossesUseTareCheckbox = document.getElementById('quick-losses-use-tare');
        const lossesTareInfo = document.getElementById('quick-losses-tare-info');
        const lossesTareWeight = document.getElementById('quick-losses-tare-weight');
        
        if (lossesUseTareCheckbox) {
            lossesUseTareCheckbox.addEventListener('change', function() {
                updateTareDisplay('losses', this.checked);
                // Salvar estado quando mudado
                if (selectedMachineData?.machine) {
                    saveTareState(selectedMachineData.machine, this.checked);
                }
            });
        }
    }
    
    // Verificar se a máquina tem tara cadastrada
    function machineHasTare(machine) {
        return getTareWeightForMachine(machine) > 0;
    }
    
    // ================================
    // SISTEMA DE PERSISTÊNCIA DA TARA
    // ================================
    
    // Obter data atual no formato YYYY-MM-DD
    function getCurrentDateString() {
        const today = new Date();
        return today.getFullYear() + '-' + 
               String(today.getMonth() + 1).padStart(2, '0') + '-' + 
               String(today.getDate()).padStart(2, '0');
    }
    
    // Salvar estado da tara para uma máquina específica
    function saveTareState(machine, useTare) {
        if (!machine) return;
        
        const dateKey = getCurrentDateString();
        const storageKey = `tare_state_${dateKey}`;
        
        try {
            let tareStates = JSON.parse(localStorage.getItem(storageKey) || '{}');
            tareStates[machine] = {
                useTare: useTare,
                timestamp: Date.now()
            };
            localStorage.setItem(storageKey, JSON.stringify(tareStates));
            
            console.log(`[TARE] Estado salvo para ${machine}: ${useTare}`);
        } catch (error) {
            console.error('[TARE] Erro ao salvar estado:', error);
        }
    }
    
    // Recuperar estado da tara para uma máquina específica
    function loadTareState(machine) {
        if (!machine) return false;
        
        const dateKey = getCurrentDateString();
        const storageKey = `tare_state_${dateKey}`;
        
        try {
            const tareStates = JSON.parse(localStorage.getItem(storageKey) || '{}');
            const machineState = tareStates[machine];
            
            if (machineState && machineState.useTare !== undefined) {
                console.log(`[TARE] Estado recuperado para ${machine}: ${machineState.useTare}`);
                return machineState.useTare;
            }
        } catch (error) {
            console.error('[TARE] Erro ao carregar estado:', error);
        }
        
        return false;
    }
    
    // Limpar estados de tara de dias anteriores (limpeza automática)
    function cleanOldTareStates() {
        try {
            const currentDate = getCurrentDateString();
            const keysToRemove = [];
            
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith('tare_state_') && !key.includes(currentDate)) {
                    keysToRemove.push(key);
                }
            }
            
            keysToRemove.forEach(key => {
                localStorage.removeItem(key);
                console.log(`[TARE] Estado antigo removido: ${key}`);
            });
        } catch (error) {
            console.error('[TARE] Erro na limpeza de estados antigos:', error);
        }
    }
    
    // Carregar estado persistente da tara para todos os formulários
    function loadTareStateForAllForms(machine) {
        if (!machine) return;
        
        const savedState = loadTareState(machine);
        const hasTare = machineHasTare(machine);
        
        // Aplicar estado salvo apenas se a máquina tem tara cadastrada
        if (hasTare && savedState) {
            const formTypes = ['quick-production', 'manual-production', 'quick-losses'];
            
            formTypes.forEach(formType => {
                const checkbox = document.getElementById(`${formType}-use-tare`);
                if (checkbox) {
                    checkbox.checked = savedState;
                    console.log(`[TARE] Estado restaurado para ${formType}: ${savedState}`);
                }
            });
        }
    }
    
    // Atualizar exibição das informações de tara
    function updateTareDisplay(formType, useTare) {
        // Determinar IDs corretos baseado no tipo de formulário
        const isLosses = formType === 'losses';
        const prefix = isLosses ? 'quick-losses' : `${formType}-production`;
        
        const tareCheckbox = document.getElementById(`${prefix}-use-tare`);
        const tareInfo = document.getElementById(`${prefix}-tare-info`);
        const tareWeightSpan = document.getElementById(`${prefix}-tare-weight`);
        
        if (!tareInfo || !tareWeightSpan || !tareCheckbox) return;
        
        // Mostrar/esconder checkbox baseado na disponibilidade de tara
        const hasTare = selectedMachineData?.machine && machineHasTare(selectedMachineData.machine);
        const tareContainer = tareCheckbox.closest('div');
        
        if (tareContainer) {
            if (hasTare) {
                tareContainer.style.display = 'block';
            } else {
                tareContainer.style.display = 'none';
                tareCheckbox.checked = false;
                useTare = false;
            }
        }
        
        if (useTare && hasTare) {
            const tareWeightGrams = getTareWeightForMachine(selectedMachineData.machine);
            // Exibir em gramas (getTareWeightForMachine retorna gramas)
            tareWeightSpan.textContent = `${tareWeightGrams}`;
            tareInfo.classList.remove('hidden');
        } else {
            tareInfo.classList.add('hidden');
        }
    }

    // Lista de máquinas padronizada via database.js quando disponível
    const machineList = (window.databaseModule && window.databaseModule.machineDatabase)
        ? window.databaseModule.machineDatabase.map(m => normalizeMachineId(m.id))
        : [
            "H01", "H02", "H03", "H04", "H05", "H06", "H07", "H08", "H09", "H10",
            "H11", "H12", "H13", "H14", "H15", "H16", "H17", "H18", "H19", "H20",
            "H26", "H27", "H28", "H29", "H30", "H31", "H32"
        ];

    // Base de dados de máquinas com seus modelos (usa database.js se disponível)
    const machineDatabase = (window.databaseModule && window.databaseModule.machineDatabase) ? window.databaseModule.machineDatabase : [
        { id: "H-01", model: "SANDRETTO OTTO" },
        { id: "H-02", model: "SANDRETTO SERIE 200" },
        { id: "H-03", model: "LS LTE280" },
        { id: "H-04", model: "LS LTE 330" },
        { id: "H-05", model: "LS LTE 170" },
        { id: "H-06", model: "HAITIAN MA2000" },
        { id: "H-07", model: "CHEN HSONG JM 178 A" },
        { id: "H-08", model: "REED 200 TG II" },
        { id: "H-09", model: "REED 200 TG II" },
        { id: "H-10", model: "HAITIAN MA 3200" },
        { id: "H-11", model: "ROMI 300 TGR" },
        { id: "H-12", model: "BORCHE BH 120" },
        { id: "H-13", model: "HAITIAN MA 2000 770G" },
        { id: "H-14", model: "SANDRETTO SB UNO" },
        { id: "H-15", model: "ROMI EN 260 CM 10" },
        { id: "H-16", model: "HAITIAN MA 2000 III" },
        { id: "H-17", model: "ROMI EN 260 CM 10" },
        { id: "H-18", model: "HAITIAN MA 2000 III" },
        { id: "H-19", model: "HAITIAN MA 2000 III" },
        { id: "H-20", model: "HAITIAN PL 200J" },
        { id: "H-26", model: "ROMI PRIMAX CM9" },
        { id: "H-27", model: "ROMI PRIMAX CM8" },
        { id: "H-28", model: "ROMI PRIMAX CM8" },
        { id: "H-29", model: "ROMI PRIMAX CM8" },
        { id: "H-30", model: "ROMI PRIMAX CM8" },
        { id: "H-31", model: "ROMI PRÁTICA CM8" },
        { id: "H-32", model: "ROMI PRÁTICA CM8" }
    ];

    // Motivos de Refugo e Parada: preferir database.js se disponível (senão usa fallback agrupado)
    // Observação: o app usa funções getGrouped* abaixo para popular selects/relatórios

    const preparadores = ['Daniel', 'João', 'Luis', 'Manaus', 'Rafael', 'Stanley', 'Wagner', 'Yohan'].sort();
    
    // Global Variables
    let currentAnalysisView = 'resumo';
    let docIdToDelete = null;
    let collectionToDelete = null;
    let fullDashboardData = { perdas: [] };
    let paretoChartInstance, productionTimelineChartInstance, oeeByShiftChartInstance, oeeTrendChartInstance;
    const gaugeChartInstances = {};
    const gaugeChartStyles = {
        'availability-gauge': {
            color: '#10B981',
            warningColor: '#F59E0B',
            dangerColor: '#EF4444'
        },
        'performance-gauge': {
            color: '#3B82F6',
            warningColor: '#8B5CF6',
            dangerColor: '#EF4444'
        },
        'quality-gauge': {
            color: '#F59E0B',
            warningColor: '#F97316',
            dangerColor: '#EF4444'
        }
    };
    const DEFAULT_DONUT_COLORS = ['#10B981', '#3B82F6', '#F97316', '#8B5CF6', '#F59E0B', '#EC4899', '#14B8A6', '#EF4444'];
    let currentReportData = [];
    
    // Variáveis do novo painel de lançamento
    let selectedMachineData = null;
    let hourlyChartInstance = null;
    let opChartInstance = null;
    // Evitar concorrência/reentrncia na atualização dos gráficos de Lançamento
    let isRefreshingLaunchCharts = false;
    let analysisHourlyChartInstance = null;
    let machineProductionTimelineInstance = null;
    let productionTimer = null;
    let productionTimerBaseSeconds = 0;
    let productionTimerResumeTimestamp = null;
    let currentDowntimeStart = null;
    let downtimeTimer = null;
    let downtimeNotificationSent = false;
    let machineStatus = 'running'; // 'running' ou 'stopped'
    let recentEntriesCache = new Map();
    let allRecentEntries = []; // Armazenar todas as entradas para filtro
    let currentEntryFilter = 'all'; // Filtro atual: 'all', 'production', 'downtime', 'loss'
    let currentEditContext = null;
    let machineCardData = {};
    const machineCardCharts = {};
    let activeMachineCard = null;
    let ajustesPageInitialized = false;
    let pilotTabInitialized = false;
    let isSubmittingPilotReport = false;

    // Timer para atualização automática de paradas longas (a cada 30 minutos)
    let extendedDowntimeUpdateTimer = null;
    const EXTENDED_DOWNTIME_UPDATE_INTERVAL = 30 * 60 * 1000; // 30 minutos em ms

    // Flags de configuração
    const QUALITY_AUTOFILL_ENABLED = false;
    const PIECE_WEIGHT_TOLERANCE_PERCENT = 1;

    // Estados auxiliares
    let quickProductionUpdateFeedback = null;

    function parseWeightInputToGrams(value) {
        if (value === undefined || value === null || value === '') return 0;
        let numValue = parseFloat(String(value).replace(',', '.'));
        if (!Number.isFinite(numValue) || numValue <= 0) return 0;
        // Entrada é sempre em GRAMAS - não faz mais conversão automática
        return Math.round(numValue);
    }

    function parsePieceWeightInput(value) {
        // Parser específico para peso da peça no planejamento
        // Admite que o usuário pode digitar em gramas (como 0,194 ou 194)
        // NÃO converte valores para evitar ambiguidade
        if (value === undefined || value === null || value === '') return 0;
        const normalized = typeof normalizeNumericString === 'function' 
            ? normalizeNumericString(value)
            : String(value).replace(',', '.');
        const parsed = parseFloat(normalized);
        if (!Number.isFinite(parsed) || parsed <= 0) return 0;
        // Retornar como-está (assumir que já está em gramas)
        return parsed;
    }

    function parsePieceWeightGrams(value) {
        if (value === undefined || value === null || value === '') return 0;
        const parsed = parseFloat(value);
        if (!Number.isFinite(parsed) || parsed <= 0) return 0;
        // Retornar diretamente - espera-se que o valor já esteja em GRAMAS
        return parsed;
    }

    function resolvePieceWeightGrams(...sources) {
        for (const source of sources) {
            const grams = parsePieceWeightGrams(source);
            if (grams > 0) {
                return grams;
            }
        }
        return 0;
    }

    function getPlanPieceWeightInfo(machineData = selectedMachineData) {
        const latestMeasured = parsePieceWeightGrams(machineData?.latest_piece_weight_grams);
        if (latestMeasured > 0) {
            return {
                grams: latestMeasured,
                source: 'quality_release',
                label: 'Última liberação da qualidade',
                updatedAt: machineData?.latest_piece_weight_updated_at || null,
                updatedBy: machineData?.latest_piece_weight_user || null
            };
        }

        const planningWeight = resolvePieceWeightGrams(
            machineData?.piece_weight_grams,
            machineData?.piece_weight,
            machineData?.weight,
            machineData?.produto?.weight
        );
        if (planningWeight > 0) {
            return {
                grams: planningWeight,
                source: 'planning',
                label: 'Peso planejado',
                updatedAt: null,
                updatedBy: null
            };
        }

        return { grams: 0, source: 'undefined', label: 'Indefinido', updatedAt: null, updatedBy: null };
    }

    function formatPieceWeightInfo(info) {
        if (!info || !info.grams) return 'Peso da peça não definido';
        const parts = [`${(info.grams).toFixed(3)} g`];
        if (info.source === 'quality_release') {
            parts.push('(Qualidade)');
        } else if (info.source === 'planning') {
            parts.push('(Planejamento)');
        }
        return parts.join(' ');
    }

    function getCatalogPieceWeight(machineData = selectedMachineData) {
        if (!machineData || !window.databaseModule || !(window.databaseModule.productByCode instanceof Map)) {
            return 0;
        }

        const codeCandidates = [
            machineData.product_cod,
            machineData.product_code,
            machineData.part_code,
            machineData.cod,
            machineData.codigo
        ];

        for (const candidate of codeCandidates) {
            if (candidate === undefined || candidate === null || candidate === '') continue;
            const numericCode = Number(candidate);
            const catalogEntry = Number.isFinite(numericCode)
                ? window.databaseModule.productByCode.get(numericCode)
                : window.databaseModule.productByCode.get(candidate);
            if (catalogEntry && catalogEntry.weight !== undefined && catalogEntry.weight !== null) {
                let weightGrams = parseFloat(catalogEntry.weight);
                if (Number.isFinite(weightGrams) && weightGrams > 0) {
                    // Se o peso for menor que 1, considerar como MILIGRAMAS e converter para gramas
                    // Ex: 0.19 no database = 0.19mg = 0.00019g (mas na verdade queremos 0.19g)
                    // Ajuste: valores < 1 já estão em gramas, não precisa converter
                    // Valores >= 1 também estão em gramas
                    // O database.js usa gramas como unidade padrão
                    return weightGrams;
                }
            }
        }

        return 0;
    }

    function getActivePieceWeightGrams(machineData = selectedMachineData) {
        if (!machineData) return 0;

        // Buscar peso do catálogo para comparação/validação
        const catalogWeight = getCatalogPieceWeight(machineData);

        const planInfo = getPlanPieceWeightInfo(machineData);
        if (planInfo.grams > 0) {
            // Se o catálogo tem peso e o planejamento tem peso muito diferente,
            // preferir o catálogo (pode ser erro de unidade no planejamento)
            if (catalogWeight > 0 && planInfo.grams > catalogWeight * 100) {
                console.warn(`[PESO] Peso do planejamento (${planInfo.grams}g) parece muito alto comparado ao catálogo (${catalogWeight}g). Usando catálogo.`);
                return catalogWeight;
            }
            return planInfo.grams;
        }

        const fallbackWeight = resolvePieceWeightGrams(
            machineData.latest_piece_weight_grams,
            machineData.latest_piece_weight,
            machineData.piece_weight_grams,
            machineData.piece_weight,
            machineData.weight,
            machineData.produto?.piece_weight,
            machineData.produto?.peso_unitario,
            machineData.produto?.weight,
            machineData.product?.piece_weight,
            machineData.product?.peso_unitario,
            machineData.product?.weight,
            machineData.order?.piece_weight,
            machineData.order?.peso_unitario,
            machineData.mp_weight
        );
        if (fallbackWeight > 0) {
            // Mesma validação para fallback
            if (catalogWeight > 0 && fallbackWeight > catalogWeight * 100) {
                console.warn(`[PESO] Peso fallback (${fallbackWeight}g) parece muito alto comparado ao catálogo (${catalogWeight}g). Usando catálogo.`);
                return catalogWeight;
            }
            return fallbackWeight;
        }

        if (catalogWeight > 0) {
            return catalogWeight;
        }

        return 0;
    }

    function updateQuickProductionPieceWeightUI({ forceUpdateInput = false } = {}) {
        const info = getPlanPieceWeightInfo();
        const sourceLabel = document.getElementById('quick-production-weight-source');
        const historyInfo = document.getElementById('quick-production-weight-history');

        if (sourceLabel) {
            sourceLabel.textContent = formatPieceWeightInfo(info);
        }

        if (historyInfo) {
            if (info.updatedAt) {
                const updatedDate = typeof info.updatedAt.toDate === 'function'
                    ? info.updatedAt.toDate()
                    : new Date(info.updatedAt);
                historyInfo.textContent = `Atualizado em ${updatedDate.toLocaleString('pt-BR')} por ${info.updatedBy || 'Qualidade'}`;
                historyInfo.classList.remove('hidden');
            } else {
                historyInfo.textContent = '';
                historyInfo.classList.add('hidden');
            }
        }

        if (typeof quickProductionUpdateFeedback === 'function') {
            quickProductionUpdateFeedback();
        }
    }

    let cachedProductionDataset = {
        productionData: [],
        planData: [],
        startDate: null,
        endDate: null,
        shift: 'all',
        machine: 'all'
    };
    let productionRateMode = 'day';

    // Variáveis globais para análise
    let machines = [];
    let currentAnalysisFilters = {};

    let productionOrdersCache = [];
    let filteredProductionOrders = [];
    let currentSelectedOrderForAnalysis = null;
    let currentActiveOrder = null;
    let currentOrderProgress = { executed: 0, planned: 0, expected: 0 };

    // DOM Element Selectors
    const navButtons = document.querySelectorAll('.nav-btn');
    const pageContents = document.querySelectorAll('.page-content');
    const pageTitle = document.getElementById('page-title');
    const confirmModal = document.getElementById('confirm-modal');
    
    const sidebar = document.getElementById('sidebar');
    const sidebarOpenBtn = document.getElementById('sidebar-open-btn');
    const sidebarCloseBtn = document.getElementById('sidebar-close-btn');
    const sidebarToggleBtn = document.getElementById('sidebar-toggle-btn');
    const sidebarOverlay = document.getElementById('sidebar-overlay');

    const planningDateSelector = document.getElementById('planning-date-selector');
    const planningForm = document.getElementById('planning-form');
    const planningOrderSelect = document.getElementById('planning-order-select');
    const planningOrderSearch = document.getElementById('planning-order-search');
    const planningOrderResults = document.getElementById('planning-order-results');
    const planningOrderSearchLoading = document.getElementById('planning-order-search-loading');
    const planningOrderInfo = document.getElementById('planning-order-info');
    const planningTableBody = document.getElementById('planning-table-body');
    const planningMachineSelect = document.getElementById('planning-machine');
    const planningMpInput = document.getElementById('planning-mp');
    const leaderLaunchPanel = document.getElementById('leader-launch-panel');
    const leaderModal = document.getElementById('leader-entry-modal');
    const leaderModalForm = document.getElementById('leader-entry-form');
    const leaderModalTitle = document.getElementById('leader-modal-title');
    
    const launchPanelContainer = document.getElementById('launch-panel-container');
    const productionModal = document.getElementById('production-entry-modal');
    const productionModalForm = document.getElementById('production-entry-form');
    const productionModalTitle = document.getElementById('production-modal-title');
    // Elementos do novo painel de lançamento
    const machineSelector = document.getElementById('machine-selector');
    const machineCardGrid = document.getElementById('machine-card-grid');
    const machineCardEmptyState = document.getElementById('machine-card-empty');
    const productionControlPanel = document.getElementById('production-control-panel');
    const hourlyProductionChart = document.getElementById('hourly-production-chart');
    const opProductionChart = document.getElementById('op-production-chart');
    const launchChartModeHourlyBtn = document.getElementById('launch-chart-mode-hourly');
    const launchChartModeOpBtn = document.getElementById('launch-chart-mode-op');
    let launchChartMode = 'hourly'; // 'hourly' | 'op'
    const analysisHourlyProductionChart = document.getElementById('analysis-hourly-production-chart');
    const analysisMachineProductionTimelineChart = document.getElementById('analysis-machine-production-timeline');
    const currentShiftDisplay = document.getElementById('current-shift-display');
    const machineIcon = document.getElementById('machine-icon');
    const machineName = document.getElementById('machine-name');
    const productName = document.getElementById('product-name');
    const productMp = document.getElementById('product-mp');
    const finalizeOrderBtn = document.getElementById('finalize-order-btn');
    const activateOrderBtn = document.getElementById('activate-order-btn');
    const shiftTarget = document.getElementById('shift-target');
    const productionTimeDisplay = document.getElementById('production-time');
    const producedToday = document.getElementById('produced-today');
    const efficiencyToday = document.getElementById('efficiency-today');
    const lossesToday = document.getElementById('losses-today');
    const downtimeToday = document.getElementById('downtime-today');
    const recentEntriesList = document.getElementById('recent-entries-list');
    const recentEntriesLoading = document.getElementById('recent-entries-loading');
    const recentEntriesEmpty = document.getElementById('recent-entries-empty');
    const refreshRecentEntriesBtn = document.getElementById('refresh-recent-entries');

    // Elementos da aba Teste Piloto
    const pilotReportForm = document.getElementById('pilot-report-form');
    const pilotReportDateInput = document.getElementById('pilot-report-date');
    const pilotReportTitleInput = document.getElementById('pilot-report-title');
    const pilotReportDescriptionInput = document.getElementById('pilot-report-description');
    const pilotReportStatus = document.getElementById('pilot-report-status');
    const pilotReportList = document.getElementById('pilot-report-list');
    const pilotReportEmpty = document.getElementById('pilot-report-empty');
    const pilotReportLoading = document.getElementById('pilot-report-loading');
    const pilotFilterDateInput = document.getElementById('pilot-filter-date');
    const pilotRefreshBtn = document.getElementById('pilot-refresh-btn');
    const pilotReportUserDisplay = document.getElementById('pilot-report-user-display');
    const pilotReportSubmitBtn = document.getElementById('pilot-report-submit');

    // Elementos da aba de Ordens de Produção
    const productionOrderForm = document.getElementById('production-order-form');
    const productionOrderStatusMessage = document.getElementById('production-order-status-message');
    const productionOrderTableBody = document.getElementById('production-order-table-body');
    const productionOrderEmptyState = document.getElementById('production-order-empty');
    const productionOrderCodeInput = document.getElementById('order-part-code');
    const productionOrderCodeDatalist = document.getElementById('order-product-code-list');
    const productionOrderFeedback = document.getElementById('order-product-feedback');
    const productionOrderProductInput = document.getElementById('order-product');
    const productionOrderCustomerInput = document.getElementById('order-customer');
    const productionOrderRawMaterialInput = document.getElementById('order-raw-material');

    // Elementos da aba de Qualidade
    const qualityPlanSelect = document.getElementById('quality-plan-select');
    const qualityDateInput = document.getElementById('quality-date');
    const qualityLoadBtn = document.getElementById('quality-load-btn');
    const qualityStatusMessage = document.getElementById('quality-status-message');
    const qualityInfoGrid = document.getElementById('quality-info-grid');
    const qualitySummaryCards = document.getElementById('quality-summary-cards');
    const qualityOperatorsChip = document.getElementById('quality-operators-chip');
    const qualityShiftTbody = document.getElementById('quality-shift-tbody');
    const qualityShiftEmpty = document.getElementById('quality-shift-empty');
    const qualityHourlyTableBody = document.getElementById('quality-hourly-tbody');
    const qualityHourlyEmpty = document.getElementById('quality-hourly-empty');
    const qualityHourlyTotal = document.getElementById('quality-hourly-total');
    const qualityHourlyContainer = document.getElementById('quality-hourly-container');
    const qualityDowntimeList = document.getElementById('quality-downtime-list');
    const qualityDowntimeEmpty = document.getElementById('quality-downtime-empty');
    const qualityDowntimeTotal = document.getElementById('quality-downtime-total');
    const qualityProcessForm = document.getElementById('quality-process-form');
    const qualityChecklistStatus = document.getElementById('quality-checklist-status');
    const qualityResponsavelInput = document.getElementById('quality-responsavel');
    const qualityNotesInput = document.getElementById('quality-notes');
    const qualityActionsInput = document.getElementById('quality-actions');
    const qualityHistoryList = document.getElementById('quality-history-list');
    const qualityHistoryEmpty = document.getElementById('quality-history-empty');
    const qualityHistoryChip = document.getElementById('quality-history-chip');
    const qualityContextContainer = document.getElementById('quality-context-container');

    // Filtros da aba de Ordens de Produção
    const ordersFilterMachine = document.getElementById('orders-filter-machine');
    const ordersFilterStatus = document.getElementById('orders-filter-status');
    const ordersFilterSearch = document.getElementById('orders-filter-search');
    
    // Elementos da aba Ajustes (restrita)
    const ajustesPage = document.getElementById('ajustes-page');
    const ajustesSearchForm = document.getElementById('ajustes-search-form');
    const ajustesCollectionSelect = document.getElementById('ajustes-collection');
    const ajustesDocIdInput = document.getElementById('ajustes-doc-id');
    const ajustesMachineInput = document.getElementById('ajustes-machine');
    const ajustesWorkdayInput = document.getElementById('ajustes-workday');
    const ajustesRefreshBtn = document.getElementById('ajustes-refresh-btn');
    const ajustesSearchStatus = document.getElementById('ajustes-search-status');
    const ajustesResultsBody = document.getElementById('ajustes-results-body');
    const ajustesEditForm = document.getElementById('ajustes-edit-form');
    const ajustesEditId = document.getElementById('ajustes-edit-id');
    const ajustesEditCollection = document.getElementById('ajustes-edit-collection');
    const ajustesEditOriginal = document.getElementById('ajustes-edit-original');
    const ajustesEditMachine = document.getElementById('ajustes-edit-machine');
    const ajustesEditDate = document.getElementById('ajustes-edit-date');
    const ajustesEditExecuted = document.getElementById('ajustes-edit-executed');
    const ajustesEditPlanned = document.getElementById('ajustes-edit-planned');
    const ajustesEditLossesKg = document.getElementById('ajustes-edit-losses-kg');
    const ajustesEditLossesPcs = document.getElementById('ajustes-edit-losses-pcs');
    const ajustesEditNotes = document.getElementById('ajustes-edit-notes');
    const ajustesEditStatus = document.getElementById('ajustes-edit-status');
    const ajustesCancelBtn = document.getElementById('ajustes-cancel-btn');
    const ajustesLogBody = document.getElementById('ajustes-log-body');

    const AJUSTES_DEFAULT_LIMIT = 25;
    const AJUSTES_LOG_COLLECTION = 'ajustes_logs';
    const AJUSTES_COLLECTIONS = {
        production_entries: {
            key: 'production_entries',
            collection: 'production_entries',
            label: 'Produção Executada',
            machineField: 'machine',
            altMachineFields: ['machine_id', 'maquina'],
            dateFields: ['workDay', 'data'],
            turnoField: 'turno',
            executedField: 'produzido',
            lossesKgField: 'refugo_kg',
            lossesPcsField: 'refugo_qty',
            plannedField: null,
            orderCandidates: ['timestamp', 'createdAt', 'dataHoraInformada'],
            supportsEditing: true,
            editorConfig: { executed: true, planned: false, lossesKg: true, lossesPcs: true },
            fieldLabels: {
                produzido: 'Quantidade executada',
                refugo_kg: 'Perdas (kg)',
                refugo_qty: 'Perdas (peças)'
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.perdas) parts.push(`Motivo: ${data.perdas}`);
                if (data.observacoes) parts.push(data.observacoes);
                if (data.manual) parts.push('Origem: Manual');
                if (data.horaInformada) parts.push(`Hora ${data.horaInformada}`);
                return parts.filter(Boolean).join(' – ') || 'Lançamento de produção';
            }
        },
        losses: {
            key: 'losses',
            collection: 'production_entries',
            label: 'Perdas Registradas',
            machineField: 'machine',
            altMachineFields: ['machine_id', 'maquina'],
            dateFields: ['workDay', 'data'],
            turnoField: 'turno',
            executedField: 'produzido',
            lossesKgField: 'refugo_kg',
            lossesPcsField: 'refugo_qty',
            plannedField: null,
            orderCandidates: ['timestamp', 'createdAt', 'dataHoraInformada'],
            supportsEditing: true,
            editorConfig: { executed: true, planned: false, lossesKg: true, lossesPcs: true },
            fieldLabels: {
                produzido: 'Quantidade executada',
                refugo_kg: 'Perdas (kg)',
                refugo_qty: 'Perdas (peças)'
            },
            filter: (data) => {
                const lossesKg = Number(data?.refugo_kg) || 0;
                const lossesQty = Number(data?.refugo_qty) || 0;
                return lossesKg > 0 || lossesQty > 0 || Boolean((data?.perdas || '').trim());
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.perdas) parts.push(`Motivo: ${data.perdas}`);
                if (data.observacoes) parts.push(data.observacoes);
                if (data.manual) parts.push('Origem: Manual');
                return parts.filter(Boolean).join(' – ') || 'Registro de perda';
            }
        },
        planning: {
            key: 'planning',
            collection: 'planning',
            label: 'Planejamento',
            machineField: 'machine',
            dateFields: ['date'],
            turnoField: null,
            executedField: null,
            lossesKgField: null,
            lossesPcsField: null,
            plannedField: 'planned_quantity',
            orderCandidates: ['updatedAt', 'createdAt'],
            supportsEditing: true,
            editorConfig: { executed: false, planned: true, lossesKg: false, lossesPcs: false },
            fieldLabels: {
                planned_quantity: 'Planejado (un)'
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.product) parts.push(`Produto: ${data.product}`);
                if (data.client) parts.push(`Cliente: ${data.client}`);
                if (data.order_number) parts.push(`OP ${data.order_number}`);
                return parts.filter(Boolean).join(' – ') || 'Item do planejamento';
            }
        },
        production_orders: {
            key: 'production_orders',
            collection: 'production_orders',
            label: 'Ordens de Produção',
            machineField: 'machine_id',
            altMachineFields: ['machine', 'machineId'],
            dateFields: ['planned_start', 'createdAt'],
            turnoField: null,
            executedField: null,
            lossesKgField: null,
            lossesPcsField: null,
            plannedField: 'lot_size',
            orderCandidates: ['updatedAt', 'createdAt'],
            supportsEditing: false,
            editorConfig: { executed: false, planned: false, lossesKg: false, lossesPcs: false },
            fieldLabels: {
                lot_size: 'Quantidade planejada'
            },
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.product) parts.push(`Produto: ${data.product}`);
                if (data.status) parts.push(`Status: ${data.status}`);
                if (data.customer) parts.push(`Cliente: ${data.customer}`);
                return parts.filter(Boolean).join(' – ') || 'Ordem de produção';
            }
        },
        downtime_entries: {
            key: 'downtime_entries',
            collection: 'downtime_entries',
            label: 'Paradas',
            machineField: 'machine',
            dateFields: ['date'],
            turnoField: null,
            executedField: null,
            lossesKgField: null,
            lossesPcsField: null,
            plannedField: null,
            orderCandidates: ['createdAt'],
            supportsEditing: false,
            editorConfig: { executed: false, planned: false, lossesKg: false, lossesPcs: false },
            fieldLabels: {},
            descriptionBuilder: (data) => {
                const parts = [];
                if (data.reason) parts.push(`Motivo: ${data.reason}`);
                if (data.observations) parts.push(data.observations);
                if (data.startTime && data.endTime) parts.push(`${data.startTime} - ${data.endTime}`);
                return parts.filter(Boolean).join(' – ') || 'Registro de parada';
            }
        }
    };

    let currentAjustesResults = [];
    let lastAjustesFilters = null;
    let ajustesSearchInFlight = false;

    // Elementos de controle de processos (tabelas de turno)
    const qualityProcessHeader = document.getElementById('quality-process-header');
    const qualityHeaderProduct = document.getElementById('quality-header-product');
    const qualityHeaderMachine = document.getElementById('quality-header-machine');
    const qualityHeaderOrder = document.getElementById('quality-header-order');
    const qualityProcessTables = document.getElementById('quality-process-tables');
    const qualityObservationsSection = document.getElementById('quality-observations-section');
    const qualityProcessEmpty = document.getElementById('quality-process-empty');
    
    // Elementos de controle de preenchimento
    const qualityControlBar = document.getElementById('quality-control-bar');
    const qualityAutoFillBtn = document.getElementById('quality-auto-fill-btn');
    const qualityManualClearBtn = document.getElementById('quality-manual-clear-btn');
    const qualityClearAllBtn = document.getElementById('quality-clear-all-btn');
    const qualityPrintBtn = document.getElementById('quality-print-btn');
    
    // Elementos de observações
    const qualityProdObsTime = document.getElementById('quality-prod-obs-time');
    const qualityProdObsText = document.getElementById('quality-prod-obs-text');
    const qualityProdObsSave = document.getElementById('quality-prod-obs-save');
    const qualityProdObsList = document.getElementById('quality-prod-obs-list');
    const qualityQualObsTime = document.getElementById('quality-qual-obs-time');
    const qualityQualObsText = document.getElementById('quality-qual-obs-text');
    const qualityQualObsSave = document.getElementById('quality-qual-obs-save');
    const qualityQualObsList = document.getElementById('quality-qual-obs-list');

    // Elementos de dados dinmicos da qualidade
    const qualityCavitiesDisplay = document.getElementById('quality-cavities-display');
    const qualityCavitiesInput = document.getElementById('quality-cavities-input');
    const qualityBagNumberDisplay = document.getElementById('quality-bag-number-display');
    const qualityBagNumberInput = document.getElementById('quality-bag-number-input');
    const qualityCycleDisplay = document.getElementById('quality-cycle-display');
    const qualityCycleInput = document.getElementById('quality-cycle-input');
    const qualityLastMeasurementDisplay = document.getElementById('quality-last-measurement-display');
    const qualityOkCavitiesCheckbox = document.getElementById('quality-ok-cavities');
    const qualityOkCycleCheckbox = document.getElementById('quality-ok-cycle');

    updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
    setRecentEntriesState({ loading: false, empty: true });
    
    const analysisTabButtons = document.querySelectorAll('.analysis-tab-btn');
    const analysisViews = document.querySelectorAll('.analysis-view');
    const resumoDateSelector = document.getElementById('resumo-date-selector');
    const printReportBtn = document.getElementById('print-report-btn');
    const reportQuantBtn = document.getElementById('report-quant-btn');
    const reportEfficBtn = document.getElementById('report-effic-btn');
    const resumoContentContainer = document.getElementById('resumo-content-container');
    const startDateSelector = document.getElementById('start-date-selector');
    const endDateSelector = document.getElementById('end-date-selector');
    const dateRangeButtons = document.querySelectorAll('.date-range-btn');
    const machineFilter = document.getElementById('machine-filter');
    const refreshDashboardBtn = document.getElementById('refresh-dashboard-btn');
    
    const graphMachineFilter = document.getElementById('graph-machine-filter');

    let qualityTabInitialized = false;
    let currentQualityContext = null;
    let qualityPlansCache = {
        lastDate: null,
        plans: []
    };

    // Gerenciador centralizado para garantir que todos os modais fiquem visíveis mesmo com conflitos de CSS.
    const MODAL_FORCE_PROPS = [
        'display',
        'opacity',
        'visibility',
        'pointer-events',
        'position',
        'inset',
        'background-color',
        'z-index',
        'width',
        'height',
        'transform'
    ];
    const MODAL_CONTENT_FORCE_PROPS = [
        'display',
        'opacity',
        'visibility',
        'pointer-events',
        'position',
        'z-index',
        'transform'
    ];

    const modalManager = (() => {
        const rootId = 'global-modal-root';
        let root = document.getElementById(rootId);
        if (!root) {
            root = document.createElement('div');
            root.id = rootId;
            root.style.position = 'relative';
            root.style.zIndex = '2147483600';
            document.body.appendChild(root);
        }

        const portalize = (modal) => {
            if (!modal) return modal;
            if (modal.parentElement !== root) {
                root.appendChild(modal);
            }
            if (!modal.dataset.portalized) {
                modal.dataset.portalized = 'true';
            }
            return modal;
        };

        const applyStyles = (modal) => {
            if (!modal) return;
            const pairs = [
                ['display', 'flex'],
                ['opacity', '1'],
                ['visibility', 'visible'],
                ['pointer-events', 'auto'],
                ['position', 'fixed'],
                ['inset', '0'],
                ['background-color', 'rgba(0, 0, 0, 0.6)'],
                ['z-index', '2147483601'],
                ['width', '100vw'],
                ['height', '100vh'],
                ['transform', 'none']
            ];
            pairs.forEach(([prop, value]) => modal.style.setProperty(prop, value, 'important'));
        };

        const clearStyles = (modal) => {
            if (!modal) return;
            MODAL_FORCE_PROPS.forEach((prop) => modal.style.removeProperty(prop));
        };

        const applyContentStyles = (content) => {
            if (!content) return;
            const pairs = [
                ['display', 'block'],
                ['opacity', '1'],
                ['visibility', 'visible'],
                ['pointer-events', 'auto'],
                ['position', 'relative'],
                ['z-index', '2147483602'],
                ['transform', 'none']
            ];
            pairs.forEach(([prop, value]) => content.style.setProperty(prop, value, 'important'));
        };

        const clearContentStyles = (content) => {
            if (!content) return;
            MODAL_CONTENT_FORCE_PROPS.forEach((prop) => content.style.removeProperty(prop));
        };

        const verify = (modal) => {
            if (!modal) return;
            const computed = window.getComputedStyle(modal);
            const rect = modal.getBoundingClientRect();
            if (computed.visibility !== 'visible' || computed.display === 'none' || rect.width < 1 || rect.height < 1) {
                console.warn('⚠️ [ModalManager] Modal ainda não visível após forçar estilos', {
                    id: modal.id,
                    visibility: computed.visibility,
                    display: computed.display,
                    rect
                });
                modal.style.setProperty('z-index', '2147483647', 'important');
                modal.style.setProperty('visibility', 'visible', 'important');
                modal.style.setProperty('opacity', '1', 'important');
                modal.style.setProperty('pointer-events', 'auto', 'important');
                modal.style.setProperty('transform', 'none', 'important');
            }
        };

        return { root, portalize, applyStyles, clearStyles, applyContentStyles, clearContentStyles, verify };
    })();

    window.__modalManager = modalManager;

    // Portalizar todos os modais logo no carregamento evita que fiquem presos a containers com overflow ou z-index baixo.
    document.querySelectorAll('div[id$="-modal"]').forEach((modal) => {
        modalManager.portalize(modal);
        if (!modal.classList.contains('hidden')) {
            modal.classList.add('hidden');
        }
        modalManager.clearStyles(modal);
        const content = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
        if (content) {
            modalManager.clearContentStyles(content);
        }
    });

    // --- FUNÇÕES UTILITÁRIAS ---

    // Carregar OPs abertas para o cache (usado na busca)
    async function loadPlanningOrders() {
        try {
            const snapshot = await db.collection('production_orders').get();
            const orders = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            // Salvar no cache para uso posterior
            productionOrdersCache = orders;
            
            console.log(`[Planejamento] ${orders.length} OPs carregadas no cache`);
        } catch (err) {
            console.error('Erro ao carregar OPs:', err);
        }
    }

    // Buscar OP pelo número digitado
    function searchPlanningOrder(searchTerm) {
        const resultsContainer = document.getElementById('planning-order-results');
        
        if (!searchTerm || searchTerm.trim() === '') {
            if (resultsContainer) resultsContainer.classList.add('hidden');
            return;
        }

        const term = searchTerm.trim().toLowerCase();
        const blocked = ['concluida','cancelada','finalizada','encerrada'];
        
        console.log(`[Planejamento] Buscando OP com termo: "${term}", cache tem ${productionOrdersCache?.length || 0} OPs`);
        
        // Se o cache está vazio, tentar recarregar
        if (!productionOrdersCache || productionOrdersCache.length === 0) {
            console.warn('[Planejamento] Cache vazio, recarregando OPs...');
            loadPlanningOrders().then(() => {
                searchPlanningOrder(searchTerm);
            });
            return;
        }
        
        // Filtrar OPs abertas que correspondem ao termo de busca
        const matchedOrders = productionOrdersCache.filter(o => {
            if (blocked.includes(String(o.status||'').toLowerCase())) return false;
            
            const orderNum = String(o.order_number || o.order_number_original || o.id || '').toLowerCase();
            const productName = String(o.product || o.product_snapshot?.name || '').toLowerCase();
            const partCode = String(o.part_code || o.product_cod || o.product_snapshot?.cod || '').toLowerCase();
            
            return orderNum.includes(term) || productName.includes(term) || partCode.includes(term);
        });
        
        console.log(`[Planejamento] Encontradas ${matchedOrders.length} OPs`);

        // Ordenar por número da OP
        matchedOrders.sort((a,b) => {
            const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
            return toNum(a.order_number || a.order_number_original || a.id) - toNum(b.order_number || b.order_number_original || b.id);
        });

        // Limitar a 10 resultados
        const limitedResults = matchedOrders.slice(0, 10);

        // Renderizar resultados
        renderPlanningOrderResults(limitedResults);
    }

    // Renderizar resultados da busca de OP
    function renderPlanningOrderResults(orders) {
        const resultsContainer = document.getElementById('planning-order-results');
        if (!resultsContainer) {
            console.error('[Planejamento] Container de resultados não encontrado!');
            return;
        }

        if (orders.length === 0) {
            resultsContainer.innerHTML = `
                <div class="p-3 text-center text-gray-500 text-sm">
                    <i data-lucide="search-x" class="w-5 h-5 mx-auto mb-1 text-gray-400"></i>
                    <p>Nenhuma OP encontrada</p>
                </div>
            `;
            resultsContainer.classList.remove('hidden');
            if (typeof lucide !== 'undefined') lucide.createIcons();
            return;
        }

        const html = orders.map(o => {
            const orderNum = o.order_number || o.order_number_original || o.id;
            const productName = o.product || o.product_snapshot?.name || '';
            const snapshotData = o.product_snapshot || {};
            const lot = Number(o.lot_size)||0;
            
            return `
                <div class="planning-order-result p-2 hover:bg-blue-50 cursor-pointer border-b border-gray-100 last:border-b-0 transition-colors"
                    data-order-id="${o.id}"
                    data-part-code="${o.part_code||o.product_cod||snapshotData.cod||''}"
                    data-product="${o.product||snapshotData.name||''}"
                    data-customer="${o.customer||o.client||snapshotData.client||''}"
                    data-lot-size="${lot > 0 ? lot : ''}"
                    data-order-number="${orderNum}"
                    data-machine-id="${o.machine_id||o.machine||''}"
                    data-raw-material="${o.raw_material || snapshotData.mp || ''}"
                    data-mp-type="${o.mp_type || ''}">
                    <div class="flex items-center justify-between">
                        <div>
                            <span class="font-bold text-blue-600 text-sm">${orderNum}</span>
                            <span class="text-gray-400 mx-1">–</span>
                            <span class="text-gray-700 text-xs">${productName || 'Sem produto'}</span>
                        </div>
                        ${lot > 0 ? `<span class="text-xs text-gray-500 bg-gray-100 px-2 py-0.5 rounded">${lot.toLocaleString('pt-BR')} pcs</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        resultsContainer.innerHTML = html;
        resultsContainer.classList.remove('hidden');
        
        console.log(`[Planejamento] Renderizados ${orders.length} resultados`);

        // Adicionar eventos de clique nos resultados
        resultsContainer.querySelectorAll('.planning-order-result').forEach(item => {
            item.addEventListener('click', () => selectPlanningOrderFromSearch(item));
        });
    }

    // Selecionar OP da lista de resultados
    function selectPlanningOrderFromSearch(item) {
        const dataset = item.dataset;
        const orderId = dataset.orderId;
        const orderNumber = dataset.orderNumber;
        
        const searchInput = document.getElementById('planning-order-search');
        const hiddenSelect = document.getElementById('planning-order-select');
        const resultsContainer = document.getElementById('planning-order-results');
        const machineSelect = document.getElementById('planning-machine');

        console.log('[Planejamento] Dataset do item clicado:', dataset);
        console.log('[Planejamento] orderId:', orderId, 'orderNumber:', orderNumber);

        // Atualizar campo de busca com o número da OP selecionada
        if (searchInput) {
            searchInput.value = orderNumber;
        }

        // Atualizar campo hidden com o ID da OP
        if (hiddenSelect) {
            hiddenSelect.value = orderId;
        }

        // Ocultar resultados
        if (resultsContainer) {
            resultsContainer.classList.add('hidden');
        }

        // Converter dataset para objeto simples (dataset usa camelCase)
        const datasetObj = {
            partCode: dataset.partCode || '',
            product: dataset.product || '',
            customer: dataset.customer || '',
            lotSize: dataset.lotSize || '',
            orderNumber: dataset.orderNumber || '',
            machineId: dataset.machineId || '',
            rawMaterial: dataset.rawMaterial || '',
            mpType: dataset.mpType || ''
        };

        console.log('[Planejamento] OP selecionada via busca:', { orderId, orderNumber, datasetObj });

        const productCodInput = document.getElementById('planning-product-cod');
        if (productCodInput && datasetObj.partCode) {
            if (productCodInput.value !== datasetObj.partCode) {
                productCodInput.value = datasetObj.partCode;
            }
            productCodInput.dispatchEvent(new Event('change', { bubbles: true }));
        }

        if (machineSelect && datasetObj.machineId) {
            const hasOption = Array.from(machineSelect.options).some(opt => opt.value === datasetObj.machineId);
            if (hasOption) machineSelect.value = datasetObj.machineId;
        }

        const selectedOrder = Array.isArray(productionOrdersCache)
            ? productionOrdersCache.find(order => order && order.id === orderId)
            : null;
        
        console.log('[Planejamento] Ordem encontrada no cache:', selectedOrder);

        fillPlanningFormWithOrder(selectedOrder || null, datasetObj);
    }

    // Debounce para busca
    let planningSearchTimeout = null;
    function onPlanningOrderSearchInput(e) {
        const searchTerm = e.target.value;
        const loadingEl = document.getElementById('planning-order-search-loading');
        const resultsContainer = document.getElementById('planning-order-results');
        const hiddenSelect = document.getElementById('planning-order-select');
        
        // Mostrar loading
        if (loadingEl) {
            loadingEl.classList.remove('hidden');
        }

        // Cancelar busca anterior
        if (planningSearchTimeout) {
            clearTimeout(planningSearchTimeout);
        }

        // Se campo vazio, limpar formulário
        if (!searchTerm || searchTerm.trim() === '') {
            if (loadingEl) loadingEl.classList.add('hidden');
            if (resultsContainer) resultsContainer.classList.add('hidden');
            if (hiddenSelect) hiddenSelect.value = '';
            
            const productCodInput = document.getElementById('planning-product-cod');
            if (productCodInput) {
                productCodInput.value = '';
                productCodInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            fillPlanningFormWithOrder(null);
            return;
        }

        // Aguardar 300ms antes de buscar (debounce)
        planningSearchTimeout = setTimeout(() => {
            searchPlanningOrder(searchTerm);
            if (loadingEl) {
                loadingEl.classList.add('hidden');
            }
        }, 300);
    }

    // Fechar resultados ao clicar fora
    function onPlanningOrderSearchBlur(e) {
        const resultsContainer = document.getElementById('planning-order-results');
        // Delay para permitir clique no resultado antes de fechar
        setTimeout(() => {
            if (resultsContainer && !resultsContainer.contains(document.activeElement)) {
                resultsContainer.classList.add('hidden');
            }
        }, 200);
    }

    function onPlanningOrderChange() {
        // Função mantida para compatibilidade, mas agora o fluxo principal é pela busca
        const hiddenSelect = document.getElementById('planning-order-select');
        if (!hiddenSelect || !hiddenSelect.value) {
            const productCodInput = document.getElementById('planning-product-cod');
            if (productCodInput) {
                productCodInput.value = '';
                productCodInput.dispatchEvent(new Event('change', { bubbles: true }));
            }
            fillPlanningFormWithOrder(null);
            return;
        }
        // O preenchimento é feito pela função selectPlanningOrderFromSearch
    }

    function fillPlanningFormWithOrder(order, dataset = {}) {
        const infoElement = planningOrderInfo;
        const productNameDisplay = document.getElementById('product-name-display');
        const productNameText = document.getElementById('product-name-text');
        const orderNumberDisplay = document.getElementById('planning-order-number');
        const orderCustomerDisplay = document.getElementById('planning-order-customer');
        const mpInput = planningMpInput || document.getElementById('planning-mp');
        const mpTypeSelect = document.getElementById('planning-mp-type');
        const cycleInput = document.getElementById('budgeted-cycle');
        const cavitiesInput = document.getElementById('mold-cavities');
        const weightInput = document.getElementById('piece-weight');
        const plannedQtyInput = document.getElementById('planned-quantity');
        const lotSizeInput = document.getElementById('planning-lot-size');

        // Limpar todos os campos se não houver ordem
        if (!order) {
            if (infoElement) {
                infoElement.style.display = 'none';
            }
            if (orderNumberDisplay) orderNumberDisplay.textContent = '-';
            if (orderCustomerDisplay) orderCustomerDisplay.textContent = '-';
            if (mpInput) mpInput.value = '';
            if (mpTypeSelect) mpTypeSelect.value = '';
            if (cycleInput) cycleInput.value = '';
            if (cavitiesInput) cavitiesInput.value = '';
            if (weightInput) weightInput.value = '';
            if (plannedQtyInput) plannedQtyInput.value = '';
            if (lotSizeInput) lotSizeInput.value = '';
            if (productNameDisplay) {
                productNameDisplay.style.display = 'none';
            }
            if (productNameText) productNameText.textContent = '';
            return;
        }

        // === SEÇÃO 1: Dados da OP (do Excel/Firebase) ===
        const resolvedOrderNumber = order.order_number || order.order_number_original || dataset.orderNumber || order.id || '';
        const partCode = dataset.partCode || order.part_code || order.product_cod || '';
        const productName = order.product || dataset.product || order.product_snapshot?.name || '';
        const customer = order.customer || order.client || dataset.customer || order.product_snapshot?.client || '';
        const machineId = dataset.machineId || order.machine_id || order.machine || '';
        
        // Tamanho do lote (da OP)
        const lotSize = (() => {
            if (dataset.lotSize) {
                const dsValue = Number(dataset.lotSize);
                if (Number.isFinite(dsValue) && dsValue > 0) return dsValue;
            }
            const fromOrder = parseOptionalNumber(order.lot_size);
            return typeof fromOrder === 'number' && Number.isFinite(fromOrder) && fromOrder > 0 ? fromOrder : 0;
        })();

        // Preencher campos da OP
        if (lotSizeInput) {
            lotSizeInput.value = lotSize > 0 ? lotSize : '';
        }

        // Exibir info da OP
        if (infoElement) {
            infoElement.style.display = 'block';
        }
        if (orderNumberDisplay) {
            orderNumberDisplay.textContent = resolvedOrderNumber || '-';
        }
        if (orderCustomerDisplay) {
            orderCustomerDisplay.textContent = customer || '-';
        }

        // === SEÇÃO 2: Dados do Produto (do productDatabase via databaseModule) ===
        // Buscar produto no database pelo código usando o índice productByCode
        const partCodeStr = String(partCode || '').trim();
        const productCode = parseInt(partCodeStr, 10);
        let productFromDatabase = null;
        
        console.log(`[Planejamento] Buscando produto com código: "${partCodeStr}" (parseado: ${productCode})`);
        
        // Tentar buscar via productByCode (Map indexado - mais rápido)
        if (window.databaseModule && window.databaseModule.productByCode instanceof Map) {
            productFromDatabase = window.databaseModule.productByCode.get(productCode);
            if (!productFromDatabase) {
                // Tentar como string
                productFromDatabase = window.databaseModule.productByCode.get(partCodeStr);
            }
        }
        
        // Fallback: buscar diretamente no array productDatabase
        if (!productFromDatabase && window.databaseModule && Array.isArray(window.databaseModule.productDatabase)) {
            productFromDatabase = window.databaseModule.productDatabase.find(p => 
                p.cod === productCode || String(p.cod) === partCodeStr
            );
        }
        
        // Fallback final: tentar acessar productDatabase global (se existir)
        if (!productFromDatabase && typeof productDatabase !== 'undefined' && Array.isArray(productDatabase)) {
            productFromDatabase = productDatabase.find(p => 
                p.cod === productCode || String(p.cod) === partCodeStr
            );
        }

        let resolvedCycle = 0;
        let resolvedCavities = 0;
        let resolvedWeight = 0;
        let resolvedProductName = productName;
        let resolvedClient = customer;

        if (productFromDatabase) {
            // Usar dados do database de produtos (prioridade)
            resolvedCycle = Number(productFromDatabase.cycle) || 0;
            resolvedCavities = Number(productFromDatabase.cavities) || 0;
            resolvedWeight = Number(productFromDatabase.weight) || 0;
            resolvedProductName = productFromDatabase.name || productName;
            resolvedClient = productFromDatabase.client || customer;
            
            console.log(`[Planejamento] ✅ Produto encontrado no database:`, {
                codigo: productCode,
                nome: resolvedProductName,
                ciclo: resolvedCycle,
                cavidades: resolvedCavities,
                peso: resolvedWeight,
                cliente: resolvedClient
            });
        } else {
            // Fallback: usar dados do snapshot da OP ou do dataset
            console.warn(`[Planejamento] ⚠️ Produto Cod ${productCode} NÃO encontrado no database. Usando dados da OP.`, {
                partCode,
                productCode,
                databaseModuleExists: !!window.databaseModule,
                productByCodeExists: !!(window.databaseModule?.productByCode),
                productDatabaseLength: window.databaseModule?.productDatabase?.length || 0
            });
            
            resolvedCycle = (() => {
                if (dataset.cycle) {
                    const parsed = Number(dataset.cycle);
                    if (Number.isFinite(parsed) && parsed > 0) return parsed;
                }
                const snapshotCycle = Number(order.product_snapshot?.cycle);
                if (Number.isFinite(snapshotCycle) && snapshotCycle > 0) return snapshotCycle;
                const orderCycle = Number(order.budgeted_cycle);
                if (Number.isFinite(orderCycle) && orderCycle > 0) return orderCycle;
                return 0;
            })();

            resolvedCavities = (() => {
                if (dataset.cavities) {
                    const parsed = Number(dataset.cavities);
                    if (Number.isFinite(parsed) && parsed > 0) return parsed;
                }
                const snapshotCavities = Number(order.product_snapshot?.cavities);
                if (Number.isFinite(snapshotCavities) && snapshotCavities > 0) return snapshotCavities;
                const orderCavities = Number(order.mold_cavities);
                if (Number.isFinite(orderCavities) && orderCavities > 0) return orderCavities;
                return 0;
            })();

            resolvedWeight = (() => {
                if (dataset.weight) {
                    const parsed = Number(dataset.weight);
                    if (Number.isFinite(parsed) && parsed > 0) return parsed;
                }
                const snapshotWeight = Number(order.product_snapshot?.weight);
                if (Number.isFinite(snapshotWeight) && snapshotWeight > 0) return snapshotWeight;
                const orderWeight = Number(order.piece_weight);
                if (Number.isFinite(orderWeight) && orderWeight > 0) return orderWeight;
                return 0;
            })();
            
            if (partCode) {
                console.warn(`[Planejamento] Produto Cod ${partCode} não encontrado no database. Usando dados da OP.`);
            }
        }

        console.log('[Planejamento] Valores resolvidos:', {
            resolvedCycle,
            resolvedCavities,
            resolvedWeight,
            resolvedProductName
        });

        // Preencher campos do produto
        console.log('[Planejamento] Inputs encontrados:', {
            cycleInput: !!cycleInput,
            cavitiesInput: !!cavitiesInput,
            weightInput: !!weightInput
        });

        if (cycleInput) {
            cycleInput.value = resolvedCycle > 0 ? resolvedCycle : '';
            console.log('[Planejamento] Ciclo preenchido:', cycleInput.value);
        }
        if (cavitiesInput) {
            cavitiesInput.value = resolvedCavities > 0 ? resolvedCavities : '';
            console.log('[Planejamento] Cavidades preenchido:', cavitiesInput.value);
        }
        if (weightInput) {
            weightInput.value = resolvedWeight > 0 ? resolvedWeight : '';
            console.log('[Planejamento] Peso preenchido:', weightInput.value);
        }

        // Exibir nome do produto
        if (productNameDisplay && productNameText) {
            const displayName = resolvedProductName || '';
            if (displayName) {
                productNameText.textContent = displayName;
                productNameDisplay.style.display = 'block';
            } else {
                productNameDisplay.style.display = 'none';
            }
        } else if (productNameDisplay) {
            // Fallback para estrutura antiga
            const label = [resolvedProductName, resolvedClient ? `(${resolvedClient})` : ''].filter(Boolean).join(' ');
            productNameDisplay.textContent = label;
            productNameDisplay.style.display = label ? 'block' : 'none';
        }

        // === SEÇÃO 3: Matéria-prima ===
        const rawMaterial = (dataset.rawMaterial || order.raw_material || order.product_snapshot?.mp || '').trim();
        if (mpInput && rawMaterial) {
            mpInput.value = rawMaterial;
        }

        if (mpTypeSelect) {
            const mpTypeValue = dataset.mpType || order.mp_type || '';
            mpTypeSelect.value = mpTypeValue;
        }

        // === Calcular Quantidade Planejada ===
        if (plannedQtyInput) {
            const cycle = resolvedCycle;
            const cavities = resolvedCavities;
            const plannedQty = cycle > 0 && cavities > 0
                ? Math.floor((86400 / cycle) * cavities * 0.85)
                : 0;
            if (plannedQty > 0) {
                plannedQtyInput.value = plannedQty;
            } else {
                plannedQtyInput.value = '';
            }
        }
    }
    
    let cachedResolvedUserName = null;

    // Recupera sessão diretamente do armazenamento (sessionStorage > localStorage)
    function getStoredUserSession() {
        const storageSources = [() => sessionStorage, () => localStorage];
        for (const getStorage of storageSources) {
            try {
                const storage = getStorage();
                if (!storage) continue;
                const data = storage.getItem('synchro_user');
                if (data) {
                    const parsed = JSON.parse(data);
                    if (parsed && typeof parsed === 'object' && typeof parsed.name === 'string') {
                        parsed.name = parsed.name.trim();
                    }
                    console.log('📍 [DEBUG] getStoredUserSession() encontrou:', parsed);
                    return parsed;
                }
            } catch (error) {
                console.warn('⚠️ [DEBUG] Erro ao ler sessão armazenada:', error);
            }
        }
        console.warn('⚠️ [DEBUG] getStoredUserSession() não encontrou dados');
        return null;
    }

    // Obtém usuário ativo com fallback para sessão armazenada
    function getActiveUser() {
        const authUser = window.authSystem?.getCurrentUser?.();
        if (authUser && (authUser.username || authUser.name)) {
            return authUser;
        }

        const storedUser = getStoredUserSession();
        if (storedUser) {
            const sanitizedUser = { ...storedUser };
            if (typeof sanitizedUser.name === 'string') {
                sanitizedUser.name = sanitizedUser.name.trim();
            }
            if (window.authSystem?.setCurrentUser) {
                window.authSystem.setCurrentUser(sanitizedUser);
            } else if (window.authSystem) {
                window.authSystem.currentUser = sanitizedUser;
            }
            return sanitizedUser;
        }

        return {};
    }

    /**
     * Verifica se o usuário atual é gestor, suporte ou tem acesso total (Leandro Camargo)
     * Usada para restringir funções de edição e exclusão
     */
    function isUserGestorOrAdmin() {
        const user = getActiveUser();
        if (!user) return false;
        
        // Usuários com acesso total (Leandro Camargo ou role 'suporte')
        const isAuthorizedAdmin = 
            user.name === 'Leandro Camargo' || user.email === 'leandro@hokkaido.com.br' ||
            user.role === 'suporte';
        if (isAuthorizedAdmin) return true;
        
        // Verificar se é gestor
        return user.role === 'gestor';
    }

    /**
     * Exibe notificação de permissão negada para operações restritas
     */
    function showPermissionDeniedNotification(action = 'realizar esta ação') {
        const message = `⮝ Permissão negada: Apenas gestores podem ${action}.`;
        showNotification(message, 'error');
        return false;
    }

    function deriveNameFromIdentifier(identifier) {
        if (!identifier || typeof identifier !== 'string') return '';
        const trimmed = identifier.trim();
        if (!trimmed) return '';
        const base = trimmed.includes('@') ? trimmed.split('@')[0] : trimmed;
        const sanitized = base.replace(/[^\w�-�.\-_\s]/g, ' ');
        const parts = sanitized.split(/[._\-\s]+/).filter(Boolean);
        if (!parts.length) return '';
        return parts.map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()).join(' ');
    }

    function persistResolvedUserName(name, currentUser) {
        if (!name || typeof name !== 'string') return;
        cachedResolvedUserName = name.trim();
        if (!cachedResolvedUserName) return;
        if (currentUser && typeof currentUser === 'object') {
            const updatedUser = { ...currentUser, name: cachedResolvedUserName };
            if (window.authSystem?.setCurrentUser) {
                window.authSystem.setCurrentUser(updatedUser);
            } else if (window.authSystem) {
                window.authSystem.currentUser = updatedUser;
            }
        }
    }

    // Função para obter o nome do usuário com fallback seguro
    function getCurrentUserName() {
        if (cachedResolvedUserName && cachedResolvedUserName !== 'Desconhecido') {
            return cachedResolvedUserName;
        }

        const currentUser = getActiveUser();
        console.log('📍 [DEBUG] getCurrentUserName() - currentUser:', currentUser);

        const candidateSources = [
            currentUser?.name,
            currentUser?.displayName,
            currentUser?.fullName,
            currentUser?.profile?.name,
            currentUser?.user?.name,
            currentUser?.user?.displayName
        ];

        for (const source of candidateSources) {
            if (typeof source === 'string' && source.trim()) {
                console.log('✅ [DEBUG] Nome obtido de fonte primária:', source.trim());
                persistResolvedUserName(source.trim(), currentUser);
                return cachedResolvedUserName;
            }
        }

        const usernameDerived = deriveNameFromIdentifier(currentUser?.username || currentUser?.user?.username);
        if (usernameDerived) {
            console.log('✅ [DEBUG] Nome derivado do username:', usernameDerived);
            persistResolvedUserName(usernameDerived, currentUser);
            return cachedResolvedUserName;
        }

        const emailDerived = deriveNameFromIdentifier(currentUser?.email || currentUser?.user?.email);
        if (emailDerived) {
            console.log('✅ [DEBUG] Nome derivado do e-mail:', emailDerived);
            persistResolvedUserName(emailDerived, currentUser);
            return cachedResolvedUserName;
        }

        const storedSession = getStoredUserSession();
        if (storedSession && typeof storedSession === 'object') {
            const storedCandidates = [
                storedSession.name,
                storedSession.displayName,
                storedSession.fullName
            ];
            for (const stored of storedCandidates) {
                if (typeof stored === 'string' && stored.trim()) {
                    console.log('✅ [DEBUG] Nome recuperado da sessão armazenada:', stored.trim());
                    persistResolvedUserName(stored.trim(), currentUser || storedSession);
                    return cachedResolvedUserName;
                }
            }

            const fallbackFromIdentifier = deriveNameFromIdentifier(storedSession.username || storedSession.email);
            if (fallbackFromIdentifier) {
                console.log('✅ [DEBUG] Nome derivado da sessão armazenada:', fallbackFromIdentifier);
                persistResolvedUserName(fallbackFromIdentifier, currentUser || storedSession);
                return cachedResolvedUserName;
            }
        }

        console.warn('⚠️ [DEBUG] Nenhum nome encontrado, retornando "Desconhecido"');
        cachedResolvedUserName = 'Desconhecido';
        return cachedResolvedUserName;
    }
    
    // Funções para normalizar datas conforme o ciclo de trabalho (7h a 7h do dia seguinte)
    // Turno 1: 07:00 - 15:00 | Turno 2: 15:00 - 23:00 | Turno 3: 23:00 - 07:00

    function getWorkDay(dateStr, timeStr) {
        if (!dateStr) return null;

        let hours = 12; // padrão neutro (meio-dia)
        if (typeof timeStr === 'string' && timeStr.includes(':')) {
            const [timeHours] = timeStr.split(':').map(Number);
            if (!Number.isNaN(timeHours)) {
                hours = timeHours;
            }
        }

        if (hours >= 7) {
            return dateStr;
        }

        const [year, month, day] = dateStr.split('-').map(Number);
        if ([year, month, day].some(n => Number.isNaN(n))) return dateStr;

        const baseDate = new Date(year, (month || 1) - 1, day || 1);
        baseDate.setDate(baseDate.getDate() - 1);
        return baseDate.toISOString().split('T')[0];
    }

    // Wrapper para compatibilidade com chamadas antigas
    function getWorkDayFromDate(dateStr, timeStr) {
        return getWorkDay(dateStr, timeStr);
    }

    function normalizeToDate(value) {
        if (!value) return null;
        if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? null : value;
        }
        if (value && typeof value.toDate === 'function') {
            const converted = value.toDate();
            return converted instanceof Date && !Number.isNaN(converted.getTime()) ? converted : null;
        }
        const parsed = new Date(value);
        return Number.isNaN(parsed.getTime()) ? null : parsed;
    }

    function resolveProductionDateTime(raw) {
        if (!raw || typeof raw !== 'object') return null;

        const candidates = [];

        if (raw.dataHoraInformada) {
            candidates.push(raw.dataHoraInformada);
        }

        if (raw.horaInformada && (raw.data || raw.date)) {
            candidates.push(`${raw.data || raw.date}T${raw.horaInformada}`);
        }

        if (raw.datetime) {
            candidates.push(raw.datetime);
        }

        candidates.push(raw.timestamp);
        candidates.push(raw.createdAt);
        candidates.push(raw.updatedAt);

        for (const candidate of candidates) {
            const dateObj = normalizeToDate(candidate);
            if (dateObj) {
                return dateObj;
            }
        }

        return null;
    }

    function getWorkDayFromTimestamp(timestamp) {
        const dateObj = normalizeToDate(timestamp);
        if (!(dateObj instanceof Date)) return null;
        if (Number.isNaN(dateObj.getTime())) return null;
        const isoString = new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60000).toISOString();
        const [datePart, timePart] = isoString.split('T');
        return getWorkDay(datePart, timePart?.substring(0, 5));
    }

    const PRODUCTION_DAY_START_HOUR = 7;
    const HOURS_IN_PRODUCTION_DAY = 24;

    const PROGRESS_PALETTE = {
        danger: { start: '#ef4444', end: '#f87171', textClass: 'text-red-600' },
        warning: { start: '#f59e0b', end: '#fbbf24', textClass: 'text-amber-500' },
        success: { start: '#10b981', end: '#34d399', textClass: 'text-emerald-600' }
    };
    const ANALYSIS_LINE_COLORS = [
        { border: '#2563EB', fill: 'rgba(37, 99, 235, 0.15)' },
        { border: '#10B981', fill: 'rgba(16, 185, 129, 0.15)' },
        { border: '#F59E0B', fill: 'rgba(245, 158, 11, 0.15)' },
        { border: '#9333EA', fill: 'rgba(147, 51, 234, 0.15)' },
        { border: '#EC4899', fill: 'rgba(236, 72, 153, 0.15)' },
        { border: '#0EA5E9', fill: 'rgba(14, 165, 233, 0.15)' },
        { border: '#22C55E', fill: 'rgba(34, 197, 94, 0.15)' },
        { border: '#F97316', fill: 'rgba(249, 115, 22, 0.15)' }
    ];

    function hexToRgb(hex) {
        if (!hex) return { r: 0, g: 0, b: 0 };
        const normalized = hex.replace('#', '');
        const expanded = normalized.length === 3
            ? normalized.split('').map((char) => char + char).join('')
            : normalized.padEnd(6, '0');
        const value = parseInt(expanded, 16);
        return {
            r: (value >> 16) & 255,
            g: (value >> 8) & 255,
            b: value & 255
        };
    }

    function rgbToHex({ r, g, b }) {
        const clamp = (value) => Math.max(0, Math.min(255, Math.round(value)));
        const toHex = (value) => clamp(value).toString(16).padStart(2, '0');
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function mixHexColors(hexA, hexB, factor = 0) {
        const ratio = Math.max(0, Math.min(1, factor));
        const colorA = hexToRgb(hexA);
        const colorB = hexToRgb(hexB);
        const mixChannel = (channel) => colorA[channel] + (colorB[channel] - colorA[channel]) * ratio;
        return rgbToHex({
            r: mixChannel('r'),
            g: mixChannel('g'),
            b: mixChannel('b')
        });
    }

    function resolveProgressPalette(percent = 0) {
        const clamped = Math.max(0, percent);
        if (clamped >= 85) {
            return {
                start: PROGRESS_PALETTE.success.start,
                end: PROGRESS_PALETTE.success.end,
                textClass: PROGRESS_PALETTE.success.textClass
            };
        }

        if (clamped <= 60) {
            const ratio = Math.min(clamped / 60, 1);
            return {
                start: mixHexColors(PROGRESS_PALETTE.danger.start, PROGRESS_PALETTE.warning.start, ratio),
                end: mixHexColors(PROGRESS_PALETTE.danger.end, PROGRESS_PALETTE.warning.end, ratio),
                textClass: clamped >= 45 ? PROGRESS_PALETTE.warning.textClass : PROGRESS_PALETTE.danger.textClass
            };
        }

        const transitionRatio = Math.min((clamped - 60) / 25, 1);
        return {
            start: mixHexColors(PROGRESS_PALETTE.warning.start, PROGRESS_PALETTE.success.start, transitionRatio),
            end: mixHexColors(PROGRESS_PALETTE.warning.end, PROGRESS_PALETTE.success.end, transitionRatio),
            textClass: clamped >= 75 ? PROGRESS_PALETTE.success.textClass : PROGRESS_PALETTE.warning.textClass
        };
    }

    function hexWithAlpha(hex, alpha) {
        const { r, g, b } = hexToRgb(hex);
        return `rgba(${r}, ${g}, ${b}, ${Math.max(0, Math.min(1, alpha))})`;
    }

    function formatHourLabel(hourValue) {
        const normalized = ((hourValue % 24) + 24) % 24;
        return `${String(normalized).padStart(2, '0')}:00`;
    }

    function formatShortDateLabel(dateStr) {
        if (!dateStr) return '--';
        const safeValue = String(dateStr).slice(0, 10);
        const parsed = new Date(`${safeValue}T00:00:00`);
        if (!Number.isNaN(parsed.getTime())) {
            return parsed.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
        }
        const parts = safeValue.split('-');
        if (parts.length === 3) {
            return `${parts[2]}/${parts[1]}`;
        }
        return safeValue;
    }

    function getProductionHoursOrder() {
        const ordered = [];
        for (let hour = PRODUCTION_DAY_START_HOUR; hour < 24; hour++) {
            ordered.push(formatHourLabel(hour));
        }
        for (let hour = 0; hour < PRODUCTION_DAY_START_HOUR; hour++) {
            ordered.push(formatHourLabel(hour));
        }
        return ordered;
    }

    function getProductionHourLabel(date = new Date()) {
        return formatHourLabel(date.getHours());
    }

    function getHoursElapsedInProductionDay(date = new Date()) {
        const reference = new Date(date);
        if (Number.isNaN(reference.getTime())) return 0;

        const productionStart = new Date(reference);
        if (productionStart.getHours() < PRODUCTION_DAY_START_HOUR) {
            productionStart.setDate(productionStart.getDate() - 1);
        }
        productionStart.setHours(PRODUCTION_DAY_START_HOUR, 0, 0, 0);

        const diffMs = Math.max(0, reference.getTime() - productionStart.getTime());
        const elapsedHours = Math.floor(diffMs / (60 * 60 * 1000));
        const clamped = Math.min(elapsedHours + 1, HOURS_IN_PRODUCTION_DAY);
        return Math.max(0, clamped);
    }

    function normalizeShiftValue(value) {
        if (value === undefined || value === null) return null;
        if (typeof value === 'number' && Number.isFinite(value)) {
            return `T${value}`;
        }
        const str = String(value).toUpperCase();
        const match = str.match(/T?\s*(\d)/);
        return match ? `T${match[1]}` : null;
    }

    function formatShiftLabel(shiftKey) {
        switch (shiftKey) {
            case 'T1':
                return '1º Turno';
            case 'T2':
                return '2º Turno';
            case 'T3':
                return '3º Turno';
            default:
                return 'Turno atual';
        }
    }

    function getGroupedLossReasons() {
        if (window.databaseModule && window.databaseModule.groupedLossReasons) {
            return window.databaseModule.groupedLossReasons;
        }
        return {
            "PROCESSO": [
                "BOLHA", "CHUPAGEM", "CONTAMINAÇÃO", "DEGRADAÇÃO", "EMPENAMENTO", "FALHA", 
                "FIAPO", "FORA DE COR", "INÍCIO/REÍNICIO", "JUNÇÃO", "MANCHAS", 
                "MEDIDA FORA DO ESPECIFICADO", "MOÍDO", "PEÇAS PERDIDAS", "QUEIMA", "REBARBA"
            ],
            "FERRAMENTARIA": [
                "DEFORMAÇÃO", "GALHO PRESO", "MARCA D'ÁGUA", "MARCA EXTRATOR", "RISCOS", "SUJIDADE"
            ],
            "QUALIDADE": [
                "INSPEÇÃO DE LINHA"
            ]
        };
    }

    function getGroupedDowntimeReasons() {
        if (window.databaseModule && window.databaseModule.groupedDowntimeReasons) {
            return window.databaseModule.groupedDowntimeReasons;
        }
        return {
            "FERRAMENTARIA": ["CORRETIVA DE MOLDE", "PREVENTIVA DE MOLDE", "TROCA DE VERSÃO"],
            "PROCESSO": ["ABERTURA DE CAVIDADE", "AJUSTE DE PROCESSO", "TRY OUT"],
            "COMPRAS": ["FALTA DE INSUMO PLANEJADA", "FALTA DE INSUMO NÃO PLANEJADA"],
            "PREPARAÇÃO": ["AGUARDANDO PREPARAÇÃO DE MATERIAL"],
            "QUALIDADE": ["AGUARDANDO CLIENTE/FORNECEDOR", "LIBERAÇÃO"],
            "MANUTENÇÃO": ["MANUTENÇÃO CORRETIVA", "MANUTENÇÃO PREVENTIVA"],
            "PRODUÇÃO": ["FALTA DE OPERADOR", "TROCA DE COR", "PRENDENDO GALHO"],
            "SETUP": ["INSTALAÇÃO DE MOLDE", "RETIRADA DE MOLDE"],
            "ADMINISTRATIVO": ["FALTA DE ENERGIA"],
            "PCP": ["SEM PROGRAMAÇÃO"],
            "COMERCIAL": ["SEM PEDIDO"]
        };
    }

    function populateLossOptions() {
        const perdasSelect = document.getElementById('production-entry-perdas');
        if (!perdasSelect) return;
        
        const groupedReasons = getGroupedLossReasons();
        let options = '<option value="">Nenhum</option>';
        
        // Adicionar opções agrupadas
        Object.entries(groupedReasons).forEach(([group, reasons]) => {
            options += `<optgroup label="${group}">`;
            reasons.forEach(reason => {
                options += `<option value="${reason}">${reason}</option>`;
            });
            options += `</optgroup>`;
        });
        
        perdasSelect.innerHTML = options;
    }

    function showLoadingState(panel, isLoading, noData = false) {
        const loadingEl = document.getElementById(`${panel}-loading`);
        const noDataEl = document.getElementById(`${panel}-no-data`);
        const contentEl = panel === 'leader-panel' ? leaderLaunchPanel : 
                        panel === 'launch-panel' ? launchPanelContainer : 
                        panel === 'resumo' ? resumoContentContainer :
                        document.getElementById('dashboard-content');

        if (isLoading) {
            if (loadingEl) loadingEl.style.display = 'block';
            if (noDataEl) noDataEl.style.display = 'none';
            if (contentEl) contentEl.style.display = 'none';
        } else {
            if (loadingEl) loadingEl.style.display = 'none';
            if (noData) {
                if (noDataEl) noDataEl.style.display = 'block';
                if (contentEl) contentEl.style.display = 'none';
            } else {
                if (noDataEl) noDataEl.style.display = 'none';
                if (contentEl) {
                    if (panel.includes('dashboard') || panel.includes('resumo') || panel.includes('list')) {
                        contentEl.style.display = 'block';
                    } else {
                        contentEl.style.display = 'grid';
                    }
                }
            }
        }
    }

    function showConfirmModal(id, collection) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir registros');
            return;
        }
        
        docIdToDelete = id;
        collectionToDelete = collection;
        try { console.log('[TRACE][showConfirmModal] target', { id, collection }); } catch(e) { /* noop */ }

        let message = 'Tem a certeza de que deseja excluir este lançamento? Esta ação não pode ser desfeita.';
        if (collection === 'downtime_entries') {
            message = 'Tem a certeza de que deseja excluir este registro de parada? Esta ação não pode ser desfeita.';
        } else if (collection === 'planning') {
            message = 'Tem a certeza de que deseja excluir este planejamento? Todos os lançamentos de produção associados também serão removidos.';
        }

        // Usar confirm nativo para garantir que o usuário consiga confirmar mesmo se o modal customizado falhar
        const userConfirmed = window.confirm(message);
        if (userConfirmed) {
            executeDelete();
        } else {
            hideConfirmModal();
        }
    }
    
    function hideConfirmModal() {
        docIdToDelete = null;
        collectionToDelete = null;
        if (confirmModal) confirmModal.classList.add('hidden');
    }
    
    async function executeDelete() {
        try { console.log('[TRACE][executeDelete] called', { docIdToDelete, collectionToDelete }); } catch(e){}
        if (!docIdToDelete || !collectionToDelete) {
            try { console.warn('[TRACE][executeDelete] missing target', { docIdToDelete, collectionToDelete }); } catch(e){}
            return;
        }
        
        const docRef = db.collection(collectionToDelete).doc(docIdToDelete);

        try {
            console.log('[TRACE][executeDelete] deleting', { id: docIdToDelete, collection: collectionToDelete });
            
            // 🔄 CRÍTICO: Se for production_entries, subtrair o valor da OP antes de excluir
            if (collectionToDelete === 'production_entries') {
                const entryDoc = await docRef.get();
                if (entryDoc.exists) {
                    const entryData = entryDoc.data();
                    const produzido = coerceToNumber(entryData.produzido || entryData.produced || entryData.quantity, 0);
                    const orderId = entryData.orderId || entryData.order_id;
                    const planId = entryData.planId;
                    
                    console.log('[SYNC-DELETE] Subtraindo produção da OP:', { produzido, orderId, planId });
                    
                    // Subtrair da OP (production_orders)
                    if (orderId && produzido > 0) {
                        try {
                            const orderRef = db.collection('production_orders').doc(orderId);
                            const orderSnap = await orderRef.get();
                            if (orderSnap.exists) {
                                const orderData = orderSnap.data() || {};
                                const currentTotal = coerceToNumber(orderData.total_produzido ?? orderData.totalProduced, 0);
                                const newTotal = Math.max(0, currentTotal - produzido);
                                await orderRef.update({
                                    total_produzido: newTotal,
                                    totalProduced: newTotal,
                                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                                });
                                console.log(`[SYNC-DELETE] OP ${orderId} atualizada: total_produzido ${currentTotal} → ${newTotal}`);
                            }
                        } catch (orderErr) {
                            console.warn('[SYNC-DELETE] Falha ao atualizar total da OP:', orderErr);
                        }
                    }
                    
                    // Subtrair do planejamento também
                    if (planId && produzido > 0) {
                        try {
                            const planRef = db.collection('planning').doc(planId);
                            const planSnap = await planRef.get();
                            if (planSnap.exists) {
                                const planData = planSnap.data() || {};
                                const currentPlanTotal = coerceToNumber(planData.total_produzido, 0);
                                const newPlanTotal = Math.max(0, currentPlanTotal - produzido);
                                await planRef.update({
                                    total_produzido: newPlanTotal,
                                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                                });
                                console.log(`[SYNC-DELETE] Plano ${planId} atualizado: total_produzido ${currentPlanTotal} → ${newPlanTotal}`);
                            }
                        } catch (planErr) {
                            console.warn('[SYNC-DELETE] Falha ao atualizar total do plano:', planErr);
                        }
                    }
                }
            }
            
            if (collectionToDelete === 'planning') {
                const prodEntriesSnapshot = await db.collection('production_entries').where('planId', '==', docIdToDelete).get();
                const batch = db.batch();
                prodEntriesSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
            }

            await docRef.delete();
            try { showNotification('Item excluído com sucesso.', 'success'); } catch(e) { /* noop */ }
            
            // Registrar log da exclusão
            registrarLogSistema('EXCLUSÃO DE REGISTRO', collectionToDelete, {
                docId: docIdToDelete,
                collection: collectionToDelete
            });
            
            if (pageTitle && pageTitle.textContent === 'Análise' && currentAnalysisView === 'resumo') {
                loadResumoData();
            }

            if (collectionToDelete === 'production_entries' || collectionToDelete === 'downtime_entries' || collectionToDelete === 'rework_entries') {
                recentEntriesCache.delete(docIdToDelete);
                await loadRecentEntries(false);
                
                // 🔄 Recarregar ordens para atualizar os cards
                if (collectionToDelete === 'production_entries') {
                    productionOrdersCache = null; // Invalidar cache
                    // Se estiver na view de ordens, recarregar
                    if (currentAnalysisView === 'orders') {
                        await loadOrdersAnalysis();
                    }
                }
            }


        } catch (error) {
            console.error("Erro ao excluir: ", error);
            const code = error && (error.code || error.name) || '';
            const msg = code === 'permission-denied'
                ? 'Permissão negada para excluir este item. Verifique seu perfil de acesso.'
                : 'Não foi possível excluir o item e/ou seus dados associados.';
            try { showNotification(msg, 'error'); } catch(e) { /* noop */ }
            alert(msg);
        } finally {
            hideConfirmModal();
        }
    }

    // --- BANCO DE DADOS DE CAIXAS DE TARA ---
    const taraBoxesDatabase = {
        "H-01": { "peso": 0, "descricao": "caixa plastica" },
        "H-02": { "peso": 0, "descricao": "caixa plastica" },
        "H-03": { "peso": 0, "descricao": "caixa plastica" },
        "H-04": { "peso": 0, "descricao": "caixa plastica" },
        "H-05": { "peso": 0, "descricao": "caixa plastica" },
        "H-06": { "peso": 0, "descricao": "caixa plastica" },
        "H-07": { "peso": 0, "descricao": "caixa plastica" },
        "H-08": { "peso": 0, "descricao": "caixa plastica" },
        "H-09": { "peso": 0, "descricao": "caixa plastica" },
        "H-10": { "peso": 0, "descricao": "caixa plastica" },
        "H-11": { "peso": 0, "descricao": "caixa plastica" },
        "H-12": { "peso": 0, "descricao": "caixa plastica" },
        "H-13": { "peso": 0, "descricao": "caixa plastica" },
        "H-14": { "peso": 0, "descricao": "caixa plastica" },
        "H-15": { "peso": 0, "descricao": "caixa plastica" },
        "H-16": { "peso": 0, "descricao": "caixa plastica" },
        "H-17": { "peso": 0, "descricao": "caixa plastica" },
        "H-18": { "peso": 0, "descricao": "caixa plastica" },
        "H-19": { "peso": 0, "descricao": "caixa plastica" },
        "H-20": { "peso": 0, "descricao": "caixa plastica" },
        "H-26": { "peso": 0, "descricao": "caixa plastica" },
        "H-27": { "peso": 0, "descricao": "caixa plastica" },
        "H-28": { "peso": 0, "descricao": "caixa plastica" },
        "H-29": { "peso": 0, "descricao": "caixa plastica" },
        "H-30": { "peso": 0, "descricao": "caixa plastica" },
        "H-31": { "peso": 0, "descricao": "caixa plastica" },
        "H-32": { "peso": 0, "descricao": "caixa plastica" }
    };

    // --- FUNÇÕES DO NOVO SISTEMA DE LANÇAMENTOS POR HORA ---

    // Função para carregar lançamentos por hora
    async function loadHourlyEntries(planId, turno) {
        const entriesRef = db.collection('hourly_production_entries');
        const q = entriesRef.where('planId', '==', planId).where('turno', '==', turno);
        const querySnapshot = await q.get();
        
        const entriesContainer = document.getElementById('hourly-entries-container');
        if (!entriesContainer) return;
        
        entriesContainer.innerHTML = '';
        
        const hours = [
            '08:00', '09:00', '10:00', '11:00', '12:00',
            '13:00', '14:00', '15:00', '16:00', '17:00', '18:00',
            '19:00', '20:00', '21:00', '22:00', '23:00', '00:00',
            '01:00', '02:00', '03:00', '04:00', '05:00', '06:00', '07:00'
        ];
        
        const existingEntries = {};
        querySnapshot.forEach(doc => {
            const data = doc.data();
            existingEntries[data.hora] = { id: doc.id, ...data };
        });
        
        hours.forEach(hora => {
            const entry = existingEntries[hora] || { hora, peso_bruto: '', usar_tara: false, embalagem_fechada: '' };
            const entryElement = createHourlyEntryElement(entry, planId, turno);
            entriesContainer.appendChild(entryElement);
        });
        
        updateTotalCalculation();
        lucide.createIcons();
            // Atualizar aba de análise se estiver aberta
            await refreshAnalysisIfActive();
    }

    // Função para criar elemento de lançamento por hora
    function createHourlyEntryElement(entry, planId, turno) {
        const div = document.createElement('div');
        div.className = 'hourly-entry grid grid-cols-13 gap-2 items-center p-2 border-b text-sm';
        div.innerHTML = `
            <div class="col-span-2 font-medium">${entry.hora}</div>
            <div class="col-span-3">
                <input type="number" step="0.01" 
                       value="${entry.peso_bruto || ''}" 
                       placeholder="Peso bruto (kg)"
                       class="peso-bruto-input w-full p-1 border rounded"
                       data-hora="${entry.hora}">
            </div>
            <div class="col-span-2 flex items-center">
                <input type="checkbox" ${entry.usar_tara ? 'checked' : ''} 
                       class="usar-tara-checkbox mr-1"
                       data-hora="${entry.hora}">
                <span class="text-xs">Usar Tara</span>
            </div>
            <div class="col-span-2">
                <input type="number" 
                       value="${entry.embalagem_fechada || ''}" 
                       placeholder="Embalagens"
                       class="embalagem-fechada-input w-full p-1 border rounded"
                       data-hora="${entry.hora}">
            </div>
            <div class="col-span-3">
                <span class="pecas-calculadas text-sm font-semibold">0 peças</span>
            </div>
            <div class="col-span-1">
                ${entry.id ? 
                    `<button type="button" class="delete-hourly-entry text-red-600 hover:text-red-800" data-id="${entry.id}">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>` : 
                    ''
                }
            </div>
        `;
        return div;
    }

    // Função para buscar peso da peça do planejamento
    async function getPieceWeightFromPlan(planId) {
        try {
            const planDoc = await db.collection('planning').doc(planId).get();
            if (planDoc.exists) {
                return planDoc.data().piece_weight || 0;
            }
        } catch (error) {
            console.error("Erro ao buscar peso da peça:", error);
        }
        return 0;
    }

    // Função para calcular totais
    async function updateTotalCalculation() {
        const planId = document.getElementById('production-entry-plan-id').value;
        const pieceWeight = await getPieceWeightFromPlan(planId);
        const useTara = document.getElementById('use-tara-box').checked;
        const taraWeight = parseFloat(document.getElementById('tara-box-weight').value) || 0;
        
        let totalPesoLiquido = 0;
        let totalPecas = 0;
        
        // Calcular totais de cada hora
        document.querySelectorAll('.hourly-entry').forEach(entry => {
            const pesoBruto = parseFloat(entry.querySelector('.peso-bruto-input').value) || 0;
            const usarTara = entry.querySelector('.usar-tara-checkbox').checked;
            const embalagemFechada = parseInt(entry.querySelector('.embalagem-fechada-input').value) || 0;
            
            const pesoLiquido = usarTara && useTara ? 
                Math.max(0, pesoBruto - taraWeight) : pesoBruto;
            
            // Calcular peças: por peso + por embalagem fechada
            const pecasPorPeso = pieceWeight > 0 ? Math.round((pesoLiquido * 1000) / pieceWeight) : 0;
            const pecasPorEmbalagem = embalagemFechada; // Assumindo 1 embalagem = 1 peça
            
            const pecasTotal = pecasPorPeso + pecasPorEmbalagem;
            
            if (entry.querySelector('.pecas-calculadas')) {
                entry.querySelector('.pecas-calculadas').textContent = `${pecasTotal} peças`;
            }
            
            totalPesoLiquido += pesoLiquido;
            totalPecas += pecasTotal;
        });
        
        // Atualizar totais
        const totalPesoLiquidoEl = document.getElementById('total-peso-liquido');
        const totalPecasEl = document.getElementById('total-pecas');
        const produzidoInput = document.getElementById('production-entry-produzido');
        
        if (totalPesoLiquidoEl) totalPesoLiquidoEl.textContent = `${totalPesoLiquido.toFixed(3)} kg`;
        if (totalPecasEl) totalPecasEl.textContent = totalPecas.toLocaleString('pt-BR');
        if (produzidoInput) produzidoInput.value = totalPecas;
    }

    // Função para salvar lançamentos por hora
    async function saveHourlyEntries(planId, turno) {
        const entries = [];
        
        document.querySelectorAll('.hourly-entry').forEach(entry => {
            const hora = entry.querySelector('.peso-bruto-input').dataset.hora;
            const pesoBruto = parseFloat(entry.querySelector('.peso-bruto-input').value) || 0;
            const usarTara = entry.querySelector('.usar-tara-checkbox').checked;
            const embalagemFechada = parseInt(entry.querySelector('.embalagem-fechada-input').value) || 0;
            
            if (pesoBruto > 0 || embalagemFechada > 0) {
                entries.push({
                    planId,
                    turno,
                    hora,
                    peso_bruto: pesoBruto,
                    usar_tara: usarTara,
                    embalagem_fechada: embalagemFechada,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                });
            }
        });
        
        // Salvar no Firestore
        const batch = db.batch();
        entries.forEach(entry => {
            const docRef = db.collection('hourly_production_entries').doc();
            batch.set(docRef, entry);
        });
        
        await batch.commit();
    }

    // --- INITIALIZATION ---
    function init() {
        // Verificar autenticação primeiro (com pequeno delay para garantir carregamento)
        setTimeout(() => {
            if (!window.authSystem || !window.authSystem.getCurrentUser()) {
                console.warn('⚠️ Autenticação não encontrada. Redirecionando para login...');
                window.location.href = 'login.html';
                return;
            }
            
            console.log('✅ Usuário autenticado. Inicializando interface...');
            
            // Atualizar interface com informações do usuário
            if (window.authSystem && typeof window.authSystem.updateUserInterface === 'function') {
                window.authSystem.updateUserInterface();
            }
            
            setTodayDate();
            restoreSidebarState();
            setupEventListeners();
            setupPlanningTab();
            setupProductionOrdersTab();
            setupLaunchTab();
            setupExtendedDowntimeTab();
            setupAnalysisTab();
            setupQualityTab();
            populateLossOptions();
            
            // Iniciar timer de atualização automática de paradas longas (a cada 30 min)
            startExtendedDowntimeAutoUpdate();
            
            // Inicializar dados básicos
            loadAnalysisMachines();
            populateQuickFormOptions();
            
            // Verificar se os elementos críticos existem
            setTimeout(() => {
                console.log('📍 Verificando elementos críticos...');
                console.log('machine-selector:', !!document.getElementById('machine-selector'));
                console.log('quick-production-form:', !!document.getElementById('quick-production-form'));
                console.log('quick-losses-form:', !!document.getElementById('quick-losses-form'));
                console.log('quick-downtime-form:', !!document.getElementById('quick-downtime-form'));
                console.log('btn-losses:', !!document.getElementById('btn-losses'));
                console.log('btn-downtime:', !!document.getElementById('btn-downtime'));
            }, 1000);
            
            if (productionModalForm && !document.getElementById('production-entry-plan-id')) {
                const planIdInput = document.createElement('input');
                planIdInput.type = 'hidden';
                planIdInput.id = 'production-entry-plan-id';
                planIdInput.name = 'planId';
                productionModalForm.prepend(planIdInput);
            }
            
            // Iniciar atualização automática de OEE em tempo real (a cada 30 minutos - otimizado para economizar quota)
            setInterval(updateRealTimeOeeData, 30 * 60 * 1000);
            
            // Iniciar atualização automática da timeline (a cada 10 minutos - otimizado para economizar quota)
            setInterval(updateTimelineIfVisible, 10 * 60 * 1000);
            
            // Atualizar imediatamente se estivermos na aba de dashboard ou análise
            setTimeout(updateRealTimeOeeData, 2000);
            
            // Adicionar listener para redimensionar gráficos
            window.addEventListener('resize', debounce(handleWindowResize, 250));
            
            // Final da inicialização - carregar aba de lançamento por padrão
            loadLaunchPanel();
            lucide.createIcons();
        }, 300); // Fim do setTimeout da autenticação
    }
    
    // Verificar se a aba está visível (otimização para não fazer refresh em background)
    function isPageVisible() {
        return document.visibilityState === 'visible';
    }
    
    // Função para atualizar dados de OEE em tempo real
    async function updateRealTimeOeeData() {
        try {
            // Otimização: Não atualizar se a aba não estiver visível
            if (!isPageVisible()) {
                console.log('[OEE] Aba não visível, pulando atualização');
                return;
            }
            
            // Verificar se estamos na aba de dashboard ou análise
            const currentPage = document.querySelector('.nav-btn.active')?.dataset.page;
            if (currentPage !== 'analise') {
                return;
            }
            
            // Verificar se estamos visualizando dados de hoje
            const today = getProductionDateString();
            const selectedDate = resumoDateSelector ? resumoDateSelector.value : today;
            
            if (selectedDate !== today) {
                return;
            }
            
            // Recarregar dados apenas se estiver na visualização atual
            const currentView = document.querySelector('.analysis-tab-btn.active')?.dataset.view;
            
            if (currentView === 'dashboard') {
                // Atualizar dados do dashboard sem mostrar loading
                const startDate = startDateSelector ? startDateSelector.value : today;
                const endDate = endDateSelector ? endDateSelector.value : today;
                
                if (startDate === today && endDate === today) {
                    const prodSnapshot = await db.collection('production_entries')
                        .where('data', '==', today)
                        .get();
                    const productions = prodSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    
                    if (productions.length > 0) {
                        const planIds = [...new Set(productions.map(p => p.planId))];
                        const plans = {};
                        
                        for (let i = 0; i < planIds.length; i += 10) {
                            const batchIds = planIds.slice(i, i + 10);
                            if (batchIds.length > 0) {
                                const planBatchSnapshot = await db.collection('planning')
                                    .where(firebase.firestore.FieldPath.documentId(), 'in', batchIds)
                                    .get();
                                planBatchSnapshot.docs.forEach(doc => {
                                    plans[doc.id] = doc.data();
                                });
                            }
                        }
                        
                        const combinedData = productions.filter(prod => plans[prod.planId])
                            .map(prod => ({ ...prod, ...plans[prod.planId] }));
                        
                        fullDashboardData = { perdas: combinedData };
                        processAndRenderDashboard(fullDashboardData);
                    }
                }
            } else if (currentView === 'resumo') {
                // Atualizar dados do resumo silenciosamente
                loadResumoData(false); // false = não mostrar loading
            }
            
        } catch (error) {
            console.error("Erro ao atualizar dados OEE em tempo real: ", error);
        }
    }
    
    // Função para configurar a aba de lançamento
    // Configuração da aba de análise avançada
    function setupAnalysisTab() {
        console.log('🔧 Configurando aba de análise...');
        
        // Event listeners para as abas de análise
        document.querySelectorAll('.analysis-tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const view = e.target.getAttribute('data-view');
                if (view) switchAnalysisView(view);
            });
        });

        // Event listeners para filtros
        const periodSelector = document.getElementById('analysis-period');
        const machineSelector = document.getElementById('analysis-machine');
        const applyFiltersBtn = document.getElementById('apply-analysis-filters');

        if (periodSelector) {
            periodSelector.addEventListener('change', (e) => {
                const customRange = document.getElementById('custom-date-range');
                if (e.target.value === 'custom') {
                    customRange.classList.remove('hidden');
                } else {
                    customRange.classList.add('hidden');
                }
            });
        }

        if (machineSelector) {
            machineSelector.addEventListener('change', updateAnalysisInfoPanel);
        }

        if (applyFiltersBtn) {
            applyFiltersBtn.addEventListener('click', applyAnalysisFilters);
        }

        // Event listeners para comparação
        const generateComparisonBtn = document.getElementById('generate-comparison');
        if (generateComparisonBtn) {
            generateComparisonBtn.addEventListener('click', generateComparison);
        }

        // Event listener para botão de teste
        const testChartsBtn = document.getElementById('test-charts-btn');
        if (testChartsBtn) {
            testChartsBtn.addEventListener('click', () => {
                console.log('🧪 [TEST] Teste manual iniciado');
                testAllCharts();
                diagnosticFirestoreData();
            });
        }

        const rateDayBtn = document.getElementById('production-rate-mode-day');
        const rateShiftBtn = document.getElementById('production-rate-mode-shift');
        if (rateDayBtn && rateShiftBtn) {
            rateDayBtn.addEventListener('click', () => {
                if (productionRateMode === 'day') return;
                productionRateMode = 'day';
                updateProductionRateToggle();
                updateProductionRateDisplay();
            });
            rateShiftBtn.addEventListener('click', () => {
                if (productionRateMode === 'shift') return;
                productionRateMode = 'shift';
                updateProductionRateToggle();
                updateProductionRateDisplay();
            });
            updateProductionRateToggle();
        }

        // Carregar dados iniciais
        loadAnalysisMachines();
        setAnalysisDefaultDates();
        
        // Executar diagnósticos
        diagnosticFirestoreData();
        
        // Carregar dados da view inicial (overview)
        setTimeout(() => {
            loadAnalysisData('overview');
            // Testar todos os gráficos após 2 segundos
            setTimeout(() => {
                testAllCharts();
            }, 2000);
        }, 100);
        
        console.log('✅ Aba de análise configurada');
    }

    // Função para trocar entre views de análise
    function switchAnalysisView(viewName) {
        // Atualizar botões - remover classes active
        document.querySelectorAll('.analysis-tab-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // Adicionar classe active ao botão selecionado
        const activeBtn = document.querySelector(`.analysis-tab-btn[data-view="${viewName}"]`);
        if (activeBtn) {
            activeBtn.classList.add('active');
        }

        // Mostrar/ocultar views
        document.querySelectorAll('.analysis-view').forEach(view => {
            view.classList.add('hidden');
        });
        
        const targetView = document.getElementById(`${viewName}-view`);
        if (targetView) {
            targetView.classList.remove('hidden');
            // Carregar dados específicos da view
            loadAnalysisData(viewName);
        }
    }

    // Função para aplicar filtros de análise
    async function applyAnalysisFilters() {
        const period = document.getElementById('analysis-period').value;
        const machine = document.getElementById('analysis-machine').value;
        const shift = document.getElementById('analysis-shift').value;
        
        const toIsoDate = (dateObj) => new Date(dateObj.getTime() - dateObj.getTimezoneOffset() * 60000).toISOString().split('T')[0];
        let startDate, endDate;
        const workToday = getProductionDateString();
        const baseDate = new Date(`${workToday}T12:00:00`);
        
        switch (period) {
            case 'today':
                startDate = endDate = workToday;
                break;
            case 'yesterday':
                const yesterday = new Date(baseDate);
                yesterday.setDate(yesterday.getDate() - 1);
                startDate = endDate = toIsoDate(yesterday);
                break;
            case '7days':
                const week = new Date(baseDate);
                week.setDate(week.getDate() - 6);
                startDate = toIsoDate(week);
                endDate = workToday;
                break;
            case '30days':
                const month = new Date(baseDate);
                month.setDate(month.getDate() - 29);
                startDate = toIsoDate(month);
                endDate = workToday;
                break;
            case 'month':
                startDate = toIsoDate(new Date(baseDate.getFullYear(), baseDate.getMonth(), 1));
                endDate = workToday;
                break;
            case 'lastmonth':
                const lastMonth = new Date(baseDate.getFullYear(), baseDate.getMonth() - 1, 1);
                const lastMonthEnd = new Date(baseDate.getFullYear(), baseDate.getMonth(), 0);
                startDate = toIsoDate(lastMonth);
                endDate = toIsoDate(lastMonthEnd);
                break;
            case 'custom':
                startDate = document.getElementById('analysis-start-date').value;
                endDate = document.getElementById('analysis-end-date').value;
                break;
        }

        if (!startDate) startDate = workToday;
        if (!endDate) endDate = workToday;

        // Atualizar dados com filtros
        currentAnalysisFilters = { startDate, endDate, machine, shift };
        
        // Recarregar a view atual
        const activeView = document.querySelector('.analysis-tab-btn.active')?.getAttribute('data-view') || 'overview';
        loadAnalysisData(activeView);
    }

    // Função para carregar dados de análise
    async function loadAnalysisData(viewName = 'overview') {
        console.log('[TRACE][loadAnalysisData] start', { viewName, filters: currentAnalysisFilters });
        
        // Garantir que os filtros estejam inicializados
        if (!currentAnalysisFilters.startDate || !currentAnalysisFilters.endDate) {
            console.log('[TRACE][loadAnalysisData] initializing default filters');
            setAnalysisDefaultDates();
        }
        
        showAnalysisLoading(true);
        
        try {
            switch (viewName) {
                case 'overview':
                    await loadOverviewData();
                    break;
                case 'production':
                    await loadProductionAnalysis();
                    break;
                case 'efficiency':
                    await loadEfficiencyAnalysis();
                    break;
                case 'losses':
                    await loadLossesAnalysis();
                    break;
                case 'downtime':
                    await loadDowntimeAnalysis();
                    break;
                case 'comparative':
                    await loadComparativeAnalysis();
                    break;
                case 'orders':
                    await loadOrdersAnalysis();
                    break;
                case 'predictive':
                    await loadPredictiveAnalysis();
                    break;
            }
        } catch (error) {
            console.error('Erro ao carregar dados de análise:', error);
            showAnalysisError();
        } finally {
            showAnalysisLoading(false);
            console.log('[TRACE][loadAnalysisData] end', { viewName });
        }
    }

    function populateOrdersMachineFilter(orders) {
        // Popular filtro na aba Análises/Ordens
        const machineFilter = document.getElementById('analysis-orders-machine-filter');
        if (!machineFilter) return;

        // Preservar valor atual
        const currentValue = machineFilter.value;

        // Recriar opções usando machineDatabase (todas as máquinas do sistema)
        machineFilter.innerHTML = '<option value="">Todas as Máquinas</option>';
        
        if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
            machineDatabase.forEach(function(machine) {
                const mid = normalizeMachineId(machine.id);
                const option = document.createElement('option');
                option.value = mid;
                option.textContent = mid + ' - ' + machine.model;
                machineFilter.appendChild(option);
            });
        }

        // Restaurar valor anterior
        if (currentValue) machineFilter.value = currentValue;
    }

    function computeOrderExecutionMetrics(order, productionTotalsByOrderId) {
        const lotSize = coerceToNumber(order.lot_size, 0);
        const status = (order.status || '').toLowerCase();
        const isFinishedStatus = ['concluida', 'finalizada', 'encerrada'].includes(status);

        const aggregateTotals = productionTotalsByOrderId.get(order.id) || 0;
        const storedTotals = coerceToNumber(order.total_produzido ?? order.totalProduced, 0);

        // CORREÇÃO: Sempre usar o MAIOR valor entre armazenado e agregado
        // Isso garante que novos lançamentos após edição manual sejam contabilizados
        const totalProduced = Math.max(aggregateTotals, storedTotals, 0);

        const computedProgress = lotSize > 0
            ? Math.min((totalProduced / lotSize) * 100, 100)
            : 0;
        const progress = isFinishedStatus && computedProgress < 100 ? 100 : computedProgress;
        const remaining = isFinishedStatus
            ? 0
            : Math.max(0, lotSize - totalProduced);

        return {
            lotSize,
            totalProduced,
            progress,
            remaining,
            isComplete: isFinishedStatus || (lotSize > 0 && totalProduced >= lotSize),
            hasProduction: totalProduced > 0
        };
    }

    async function loadOrdersAnalysis() {
        console.log('📋 Carregando análise de ordens de produção');

        let ordersDataset = Array.isArray(productionOrdersCache) ? [...productionOrdersCache] : [];

        if (ordersDataset.length === 0) {
            try {
                const snapshot = await db.collection('production_orders').orderBy('createdAt', 'desc').get();
                ordersDataset = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                productionOrdersCache = ordersDataset;
                console.log('📋 Ordens carregadas do Firebase:', ordersDataset.length, ordersDataset);
            } catch (error) {
                console.error('Erro ao recuperar ordens de produção para análise:', error);
                // Tentar sem ordenação caso o índice não exista
                try {
                    console.log('📋 Tentando carregar sem ordenação...');
                    const snapshot2 = await db.collection('production_orders').get();
                    ordersDataset = snapshot2.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    productionOrdersCache = ordersDataset;
                    console.log('📋 Ordens carregadas (sem ordem):', ordersDataset.length);
                } catch (err2) {
                    console.error('Erro ao recuperar ordens:', err2);
                }
            }
        } else {
            console.log('📋 Usando cache de ordens:', ordersDataset.length);
        }

        if (!ordersDataset || ordersDataset.length === 0) {
            console.warn('❌ Nenhuma ordem de produção encontrada.');
            showAnalysisNoData('Nenhuma ordem de produção cadastrada.');
            return;
        }

        const ordersGrid = document.getElementById('orders-grid');
        if (!ordersGrid) {
            console.error('❌ Elemento orders-grid não encontrado no DOM');
            return;
        }

        const startDateStr = currentAnalysisFilters.startDate;
        const endDateStr = currentAnalysisFilters.endDate;

        const normalizedOrders = ordersDataset.map(order => ({
            ...order,
            normalizedCode: String(order.part_code || order.product_cod || '').trim()
        }));

        // Mapear produção por ID de ordem (só conta produção para ordens ativas)
        const productionTotalsByOrderId = new Map();

        try {
            const productionSnapshot = await db.collection('production_entries')
                .where('data', '>=', startDateStr)
                .where('data', '<=', endDateStr)
                .get();

            productionSnapshot.docs.forEach(doc => {
                const data = doc.data();
                const orderId = data.order_id || data.orderId;
                
                if (!orderId) return;

                const producedQty = coerceToNumber(data.produzido ?? data.quantity, 0);
                if (!Number.isFinite(producedQty) || producedQty <= 0) {
                    return;
                }

                productionTotalsByOrderId.set(
                    orderId,
                    (productionTotalsByOrderId.get(orderId) || 0) + producedQty
                );
            });
        } catch (error) {
            console.error('Erro ao carregar lançamentos para análise de ordens:', error);
        }

        // Preencher dropdown de máquinas com máquinas usadas nas ordens
        populateOrdersMachineFilter(normalizedOrders);

        const ordersWithProgress = normalizedOrders.map(order => {
            const metrics = computeOrderExecutionMetrics(order, productionTotalsByOrderId);
            return { ...order, ...metrics };
        });

        // Aplicar filtros de status, máquina e pesquisa
        const ordersStatusFilter = document.getElementById('orders-status-filter')?.value || '';
        const ordersMachineFilter = document.getElementById('analysis-orders-machine-filter')?.value || '';
        const ordersSearchQuery = document.getElementById('orders-search')?.value.toLowerCase() || '';
        const ordersSortValue = document.getElementById('orders-sort-filter')?.value || 'recent';

        let filteredOrders = ordersWithProgress;

        // Filtro por status
        if (ordersStatusFilter) {
            filteredOrders = filteredOrders.filter(order => {
                const status = (order.status || '').toLowerCase();
                if (ordersStatusFilter === 'planejada') return status === 'planejada';
                if (ordersStatusFilter === 'em_andamento') return status === 'em_andamento';
                if (ordersStatusFilter === 'ativa') return status === 'ativa';
                if (ordersStatusFilter === 'concluida') return status === 'concluida' || status === 'finalizada';
                if (ordersStatusFilter === 'cancelada') return status === 'cancelada';
                return true;
            });
        }

        // Filtro por máquina
        if (ordersMachineFilter) {
            filteredOrders = filteredOrders.filter(order => {
                return order.machine_id === ordersMachineFilter;
            });
        }

        // Filtro de busca
        if (ordersSearchQuery) {
            filteredOrders = filteredOrders.filter(order => 
                (order.order_number || '').toLowerCase().includes(ordersSearchQuery) ||
                (order.product || '').toLowerCase().includes(ordersSearchQuery) ||
                (order.part_code || '').toLowerCase().includes(ordersSearchQuery) ||
                (order.customer || '').toLowerCase().includes(ordersSearchQuery)
            );
        }

        // Ordenação
        filteredOrders.sort((a, b) => {
            switch (ordersSortValue) {
                case 'recent':
                    const dateA = a.createdAt?.toDate?.() || new Date(a.createdAt) || new Date(0);
                    const dateB = b.createdAt?.toDate?.() || new Date(b.createdAt) || new Date(0);
                    return dateB - dateA;
                case 'oldest':
                    const dateA2 = a.createdAt?.toDate?.() || new Date(a.createdAt) || new Date(0);
                    const dateB2 = b.createdAt?.toDate?.() || new Date(b.createdAt) || new Date(0);
                    return dateA2 - dateB2;
                case 'progress-desc':
                    return (b.progress || 0) - (a.progress || 0);
                case 'progress-asc':
                    return (a.progress || 0) - (b.progress || 0);
                case 'lot-desc':
                    return (Number(b.lot_size) || 0) - (Number(a.lot_size) || 0);
                case 'lot-asc':
                    return (Number(a.lot_size) || 0) - (Number(b.lot_size) || 0);
                case 'alpha':
                case 'name-asc':
                    return (a.order_number || '').localeCompare(b.order_number || '');
                default:
                    return 0;
            }
        });

        // ===== ATUALIZAR KPIs =====
        const totalOrders = ordersWithProgress.length;
        const activeOrders = ordersWithProgress.filter(o => ['ativa', 'em_andamento'].includes((o.status || '').toLowerCase())).length;
        const completedOrders = ordersWithProgress.filter(o => ['concluida', 'finalizada'].includes((o.status || '').toLowerCase())).length;
        const avgProgress = totalOrders > 0 
            ? Math.round(ordersWithProgress.reduce((sum, o) => sum + (o.progress || 0), 0) / totalOrders)
            : 0;

        // Atualizar elementos KPI no DOM
        const kpiTotal = document.getElementById('orders-kpi-total');
        const kpiActive = document.getElementById('orders-kpi-active');
        const kpiCompleted = document.getElementById('orders-kpi-completed');
        const kpiProgress = document.getElementById('orders-kpi-avg-progress');

        if (kpiTotal) kpiTotal.textContent = totalOrders.toLocaleString('pt-BR');
        if (kpiActive) kpiActive.textContent = activeOrders.toLocaleString('pt-BR');
        if (kpiCompleted) kpiCompleted.textContent = completedOrders.toLocaleString('pt-BR');
        if (kpiProgress) kpiProgress.textContent = `${avgProgress}%`;

        // ===== GERAR CARDS DE ORDENS =====
        const ordersHtml = filteredOrders.map(order => {
            const progressPercent = Math.min(order.progress || 0, 100);
            const progressColor = progressPercent >= 100 ? 'bg-emerald-500' : progressPercent >= 70 ? 'bg-blue-500' : progressPercent >= 40 ? 'bg-amber-500' : 'bg-red-500';
            const progressRingColor = progressPercent >= 100 ? 'text-emerald-500' : progressPercent >= 70 ? 'text-blue-500' : progressPercent >= 40 ? 'text-amber-500' : 'text-red-500';
            const lotSizeNumeric = Number(order.lot_size) || 0;
            const status = (order.status || '').toLowerCase();

            // Mapa de cores para status
            const statusColorMap = {
                'planejada': { badge: 'bg-slate-100 text-slate-600 border border-slate-300', icon: 'calendar', label: 'Planejada' },
                'em_andamento': { badge: 'bg-amber-100 text-amber-700 border border-amber-300', icon: 'play-circle', label: 'Em Andamento' },
                'ativa': { badge: 'bg-blue-100 text-blue-700 border border-blue-300', icon: 'zap', label: 'Ativa' },
                'concluida': { badge: 'bg-emerald-100 text-emerald-700 border border-emerald-300', icon: 'check-circle-2', label: 'Concluída' },
                'finalizada': { badge: 'bg-emerald-100 text-emerald-700 border border-emerald-300', icon: 'check-circle-2', label: 'Finalizada' },
                'cancelada': { badge: 'bg-red-100 text-red-700 border border-red-300', icon: 'x-circle', label: 'Cancelada' }
            };

            const statusDisplay = statusColorMap[status] || statusColorMap['planejada'];
            const isActive = status === 'ativa' || status === 'em_andamento';

            // Buscar modelo da máquina
            const machineInfo = window.databaseModule?.machineById?.get(order.machine_id);
            const machineLabel = machineInfo ? `${order.machine_id} - ${machineInfo.model}` : (order.machine_id || 'N/A');

            // Data de criação formatada
            const createdDate = order.createdAt?.toDate?.() || new Date(order.createdAt);
            const formattedDate = createdDate instanceof Date && !isNaN(createdDate) 
                ? createdDate.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' })
                : '';

            // Verificar se pode reativar
            const isReactivatable = ['concluida','finalizada','encerrada'].includes(status);

            return `
                <div class="group bg-white rounded-xl shadow-sm hover:shadow-lg transition-all duration-300 border border-gray-100 overflow-hidden ${isActive ? 'ring-2 ring-blue-400 ring-offset-1' : ''}">
                    <!-- Header do Card -->
                    <div class="p-4 border-b border-gray-50 bg-gradient-to-r ${isActive ? 'from-blue-50 to-white' : 'from-gray-50 to-white'}">
                        <div class="flex items-start justify-between gap-2">
                            <div class="flex-1 min-w-0">
                                <div class="flex items-center gap-2">
                                    <span class="text-lg font-bold text-gray-800 truncate">${escapeHtml(order.order_number)}</span>
                                    ${formattedDate ? `<span class="text-xs text-gray-400">${formattedDate}</span>` : ''}
                                </div>
                                <p class="text-sm text-gray-600 truncate mt-0.5" title="${escapeHtml(order.product || '')}">${escapeHtml(order.product || 'Produto não especificado')}</p>
                            </div>
                            <span class="flex-shrink-0 inline-flex items-center gap-1 px-2.5 py-1 rounded-full text-xs font-medium ${statusDisplay.badge}">
                                <i data-lucide="${statusDisplay.icon}" class="w-3 h-3"></i>
                                ${statusDisplay.label}
                            </span>
                        </div>
                    </div>

                    <!-- Corpo do Card -->
                    <div class="p-4">
                        <!-- Informações principais em grid compacto -->
                        <div class="grid grid-cols-2 gap-3 text-sm mb-4">
                            <div class="flex items-center gap-2">
                                <i data-lucide="user" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(order.customer || '')}">${escapeHtml(order.customer || 'N/A')}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <i data-lucide="cog" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(machineLabel)}">${escapeHtml(machineLabel)}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <i data-lucide="hash" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(order.part_code || '')}">${escapeHtml(order.part_code || 'N/A')}</span>
                            </div>
                            ${order.raw_material ? `
                            <div class="flex items-center gap-2">
                                <i data-lucide="package" class="w-4 h-4 text-gray-400"></i>
                                <span class="text-gray-600 truncate" title="${escapeHtml(order.raw_material)}">${escapeHtml(order.raw_material)}</span>
                            </div>
                            ` : '<div></div>'}
                        </div>

                        <!-- Progresso Visual -->
                        <div class="bg-gray-50 rounded-lg p-3">
                            <div class="flex items-center justify-between mb-2">
                                <span class="text-xs font-medium text-gray-500 uppercase tracking-wide">Progresso da OP</span>
                                <span class="text-sm font-bold ${progressRingColor}">${Math.round(progressPercent)}%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2 mb-2">
                                <div class="${progressColor} h-2 rounded-full transition-all duration-500" style="width: ${progressPercent}%"></div>
                            </div>
                            <div class="flex justify-between text-xs text-gray-500">
                                <span><strong class="text-emerald-600">${order.totalProduced.toLocaleString('pt-BR')}</strong> produzido</span>
                                <span><strong class="text-gray-700">${lotSizeNumeric.toLocaleString('pt-BR')}</strong> planejado</span>
                            </div>
                            ${order.remaining > 0 ? `<div class="text-center mt-1 text-xs text-amber-600">Faltam <strong>${order.remaining.toLocaleString('pt-BR')}</strong> un</div>` : ''}
                        </div>
                    </div>

                    <!-- Footer com Ações -->
                    <div class="px-4 pb-4 flex gap-2">
                        ${status === 'planejada' ? `
                        <button class="activate-order-btn flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg font-medium text-sm transition-colors" data-order-id="${order.id}" data-machine-id="${order.machine_id || ''}">
                            <i data-lucide="play" class="w-4 h-4"></i>
                            Ativar
                        </button>
                        ` : ''}
                        ${isReactivatable ? `
                        <button class="reactivate-order-btn flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium text-sm transition-colors" data-order-id="${order.id}">
                            <i data-lucide="rotate-ccw" class="w-4 h-4"></i>
                            Reativar
                        </button>
                        ` : ''}
                        <button class="edit-order-btn ${(status === 'planejada' || isReactivatable) ? 'flex-1' : 'w-full'} flex items-center justify-center gap-1.5 px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg font-medium text-sm transition-colors" data-order-id="${order.id}">
                            <i data-lucide="edit-3" class="w-4 h-4"></i>
                            Editar
                        </button>
                    </div>
                </div>
            `;
        }).join('');

        if (filteredOrders.length === 0) {
            ordersGrid.innerHTML = `
                <div class="col-span-full flex flex-col items-center justify-center py-16">
                    <div class="w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center mb-4">
                        <i data-lucide="inbox" class="w-8 h-8 text-gray-400"></i>
                    </div>
                    <h3 class="text-lg font-medium text-gray-700 mb-1">Nenhuma ordem encontrada</h3>
                    <p class="text-sm text-gray-500">Tente ajustar os filtros de busca</p>
                </div>
            `;
        } else {
            ordersGrid.innerHTML = ordersHtml;
        }

        try {
            lucide.createIcons();
        } catch (iconError) {
            console.warn('Falha ao renderizar ícones lucide na aba de ordens:', iconError);
        }

        const noDataContainer = document.getElementById('analysis-no-data');
        if (filteredOrders.length > 0 && noDataContainer) {
            noDataContainer.classList.add('hidden');
        }

        // Configurar event listeners para filtros
        const ordersStatusFilterBtn = document.getElementById('orders-status-filter');
        const ordersMachineFilterBtn = document.getElementById('analysis-orders-machine-filter');
        const ordersSearchInput = document.getElementById('orders-search');
        const ordersSortSelect = document.getElementById('orders-sort-filter');
        const ordersClearFiltersBtn = document.getElementById('orders-clear-filters');
        const ordersRefreshBtn = document.getElementById('orders-refresh-btn');
        const ordersResultsCount = document.getElementById('orders-results-count');
        
        // Atualizar contador de resultados
        if (ordersResultsCount) {
            ordersResultsCount.textContent = `${filteredOrders.length} ordem${filteredOrders.length !== 1 ? 'ns' : ''} encontrada${filteredOrders.length !== 1 ? 's' : ''}`;
        }
        
        if (ordersStatusFilterBtn && !ordersStatusFilterBtn.dataset.listenerAttached) {
            ordersStatusFilterBtn.addEventListener('change', () => loadOrdersAnalysis());
            ordersStatusFilterBtn.dataset.listenerAttached = 'true';
        }

        if (ordersMachineFilterBtn && !ordersMachineFilterBtn.dataset.listenerAttached) {
            ordersMachineFilterBtn.addEventListener('change', () => loadOrdersAnalysis());
            ordersMachineFilterBtn.dataset.listenerAttached = 'true';
        }
        
        if (ordersSearchInput && !ordersSearchInput.dataset.listenerAttached) {
            ordersSearchInput.addEventListener('input', debounce(() => loadOrdersAnalysis(), 300));
            ordersSearchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    loadOrdersAnalysis();
                }
            });
            ordersSearchInput.dataset.listenerAttached = 'true';
        }

        // Botão de busca explícito
        const ordersSearchBtn = document.getElementById('orders-search-btn');
        if (ordersSearchBtn && !ordersSearchBtn.dataset.listenerAttached) {
            ordersSearchBtn.addEventListener('click', () => loadOrdersAnalysis());
            ordersSearchBtn.dataset.listenerAttached = 'true';
        }

        if (ordersSortSelect && !ordersSortSelect.dataset.listenerAttached) {
            ordersSortSelect.addEventListener('change', () => loadOrdersAnalysis());
            ordersSortSelect.dataset.listenerAttached = 'true';
        }

        if (ordersClearFiltersBtn && !ordersClearFiltersBtn.dataset.listenerAttached) {
            ordersClearFiltersBtn.addEventListener('click', () => {
                if (ordersStatusFilterBtn) ordersStatusFilterBtn.value = '';
                if (ordersMachineFilterBtn) ordersMachineFilterBtn.value = '';
                if (ordersSearchInput) ordersSearchInput.value = '';
                if (ordersSortSelect) ordersSortSelect.value = 'recent';
                loadOrdersAnalysis();
            });
            ordersClearFiltersBtn.dataset.listenerAttached = 'true';
        }

        if (ordersRefreshBtn && !ordersRefreshBtn.dataset.listenerAttached) {
            ordersRefreshBtn.addEventListener('click', async () => {
                productionOrdersCache = null;
                await loadOrdersAnalysis();
                showNotification('Ordens atualizadas!', 'success');
            });
            ordersRefreshBtn.dataset.listenerAttached = 'true';
        }

        // Toggle de visualização Grid/Lista
        const ordersViewGrid = document.getElementById('orders-view-grid');
        const ordersViewList = document.getElementById('orders-view-list');
        const ordersListContainer = document.getElementById('orders-list');
        
        if (ordersViewGrid && !ordersViewGrid.dataset.listenerAttached) {
            ordersViewGrid.addEventListener('click', () => {
                ordersGrid.classList.remove('hidden');
                if (ordersListContainer) ordersListContainer.classList.add('hidden');
                ordersViewGrid.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                ordersViewGrid.classList.remove('text-gray-500');
                if (ordersViewList) {
                    ordersViewList.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                    ordersViewList.classList.add('text-gray-500');
                }
            });
            ordersViewGrid.dataset.listenerAttached = 'true';
        }

        if (ordersViewList && !ordersViewList.dataset.listenerAttached) {
            ordersViewList.addEventListener('click', () => {
                ordersGrid.classList.add('hidden');
                if (ordersListContainer) {
                    ordersListContainer.classList.remove('hidden');
                    populateOrdersListView(filteredOrders);
                }
                ordersViewList.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                ordersViewList.classList.remove('text-gray-500');
                if (ordersViewGrid) {
                    ordersViewGrid.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                    ordersViewGrid.classList.add('text-gray-500');
                }
            });
            ordersViewList.dataset.listenerAttached = 'true';
        }

        // Função para preencher view de lista (tabela)
        function populateOrdersListView(orders) {
            const listBody = document.getElementById('orders-list-body');
            if (!listBody) return;

            const statusColorMap = {
                'planejada': { badge: 'bg-slate-100 text-slate-600', label: 'Planejada' },
                'em_andamento': { badge: 'bg-amber-100 text-amber-700', label: 'Em Andamento' },
                'ativa': { badge: 'bg-blue-100 text-blue-700', label: 'Ativa' },
                'concluida': { badge: 'bg-emerald-100 text-emerald-700', label: 'Concluída' },
                'finalizada': { badge: 'bg-emerald-100 text-emerald-700', label: 'Finalizada' },
                'cancelada': { badge: 'bg-red-100 text-red-700', label: 'Cancelada' }
            };

            listBody.innerHTML = orders.map(order => {
                const status = (order.status || '').toLowerCase();
                const statusDisplay = statusColorMap[status] || statusColorMap['planejada'];
                const progressPercent = Math.min(order.progress || 0, 100);
                const progressColor = progressPercent >= 100 ? 'bg-emerald-500' : progressPercent >= 70 ? 'bg-blue-500' : progressPercent >= 40 ? 'bg-amber-500' : 'bg-red-500';
                const lotSize = Number(order.lot_size) || 0;
                const machineInfo = window.databaseModule?.machineById?.get(order.machine_id);
                const machineLabel = machineInfo ? `${order.machine_id}` : (order.machine_id || 'N/A');

                return `
                    <tr class="hover:bg-gray-50 transition-colors">
                        <td class="px-4 py-3 text-sm font-semibold text-gray-800">${escapeHtml(order.order_number)}</td>
                        <td class="px-4 py-3 text-sm text-gray-600 max-w-xs truncate" title="${escapeHtml(order.product || '')}">${escapeHtml(order.product || 'N/A')}</td>
                        <td class="px-4 py-3 text-sm text-gray-600">${escapeHtml(machineLabel)}</td>
                        <td class="px-4 py-3">
                            <span class="inline-flex px-2 py-1 rounded-full text-xs font-medium ${statusDisplay.badge}">${statusDisplay.label}</span>
                        </td>
                        <td class="px-4 py-3">
                            <div class="flex items-center gap-2">
                                <div class="flex-1 bg-gray-200 rounded-full h-2 w-20">
                                    <div class="${progressColor} h-2 rounded-full" style="width: ${progressPercent}%"></div>
                                </div>
                                <span class="text-xs font-medium text-gray-600">${Math.round(progressPercent)}%</span>
                            </div>
                        </td>
                        <td class="px-4 py-3 text-sm text-right font-medium text-emerald-600">${order.totalProduced.toLocaleString('pt-BR')}</td>
                        <td class="px-4 py-3 text-sm text-right text-gray-600">${lotSize.toLocaleString('pt-BR')}</td>
                        <td class="px-4 py-3 text-center">
                            <button class="edit-order-btn p-1.5 text-gray-500 hover:text-blue-600 hover:bg-blue-50 rounded transition-colors" data-order-id="${order.id}" title="Editar">
                                <i data-lucide="edit-3" class="w-4 h-4"></i>
                            </button>
                        </td>
                    </tr>
                `;
            }).join('');

            lucide.createIcons();

            // Re-attach listeners para botões de edição na lista
            listBody.querySelectorAll('.edit-order-btn').forEach(btn => {
                if (!btn.dataset.listenerAttached) {
                    btn.addEventListener('click', async () => {
                        const orderId = btn.getAttribute('data-order-id');
                        if (!orderId) return;
                        // Simular click no botão do grid
                        const gridBtn = document.querySelector(`.edit-order-btn[data-order-id="${orderId}"]`);
                        if (gridBtn) gridBtn.click();
                    });
                    btn.dataset.listenerAttached = 'true';
                }
            });
        }

        lucide.createIcons();

        // Adicionar event listener para botões de reativação
        document.querySelectorAll('.reactivate-order-btn').forEach(btn => {
            if (!btn.dataset.listenerAttached) {
                btn.addEventListener('click', async (e) => {
                    const orderId = btn.getAttribute('data-order-id');
                    if (!orderId) return;
                    if (!confirm('Deseja realmente reativar esta ordem? Ela voltará ao status ATIVA.')) return;
                    try {
                        await db.collection('production_orders').doc(orderId).update({ status: 'ativa' });
                        showNotification('Ordem reativada com sucesso!', 'success');
                        await loadOrdersAnalysis();
                    } catch (err) {
                        showNotification('Erro ao reativar ordem. Tente novamente.', 'error');
                        console.error('Erro ao reativar ordem:', err);
                    }
                });
                btn.dataset.listenerAttached = 'true';
            }
        });

        // Adicionar event listener para botões de ativação (ordens planejadas)
        document.querySelectorAll('.activate-order-btn').forEach(btn => {
            if (!btn.dataset.listenerAttached) {
                btn.addEventListener('click', async (e) => {
                    const orderId = btn.getAttribute('data-order-id');
                    const machineId = btn.getAttribute('data-machine-id');
                    if (!orderId) return;
                    
                    // Verificar se há máquina definida
                    if (!machineId) {
                        showNotification('Esta ordem não tem máquina definida. Edite a ordem e selecione uma máquina primeiro.', 'warning');
                        return;
                    }
                    
                    if (!confirm(`Deseja ativar esta ordem na máquina ${machineId}?`)) return;
                    
                    try {
                        // Atualizar status para ativa
                        await db.collection('production_orders').doc(orderId).update({ 
                            status: 'ativa',
                            activatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        showNotification('Ordem ativada com sucesso!', 'success');

                        // Registrar no histórico do sistema
                        if (typeof logSystemAction === 'function') {
                            logSystemAction('ordem_ativada', `Ordem ${orderId} ativada`, {
                                maquina: machineId,
                                orderId: orderId
                            });
                        }
                        
                        // Atualizar cache e recarregar
                        productionOrdersCache = null;
                        await loadOrdersAnalysis();
                    } catch (err) {
                        showNotification('Erro ao ativar ordem. Tente novamente.', 'error');
                        console.error('Erro ao ativar ordem:', err);
                    }
                });
                btn.dataset.listenerAttached = 'true';
            }
        });

        // Adicionar event listener para botões de edição
        document.querySelectorAll('.edit-order-btn').forEach(btn => {
            if (!btn.dataset.listenerAttached) {
                btn.addEventListener('click', async (e) => {
                    const orderId = btn.getAttribute('data-order-id');
                    if (!orderId) return;
                    // Buscar dados da ordem
                    let orderData = null;
                    if (Array.isArray(productionOrdersCache)) {
                        orderData = productionOrdersCache.find(o => o.id === orderId);
                    }
                    if (!orderData) {
                        try {
                            const doc = await db.collection('production_orders').doc(orderId).get();
                            if (doc.exists) orderData = { id: doc.id, ...doc.data() };
                        } catch (err) { orderData = null; }
                    }
                    if (!orderData) {
                        showNotification('Ordem não encontrada.', 'error');
                        return;
                    }
                    // Preencher campos do modal
                    document.getElementById('edit-order-id').value = orderData.id;
                    // Preencher select de produtos
                    const productSelect = document.getElementById('edit-order-product');
                    productSelect.innerHTML = '';
                    if (window.databaseModule && window.databaseModule.productByCode) {
                        const products = Array.from(window.databaseModule.productByCode.values());
                        products.forEach(prod => {
                            const opt = document.createElement('option');
                            opt.value = prod.cod;
                            opt.textContent = `${prod.cod} - ${prod.name} (${prod.client})`;
                            if ((orderData.product_cod || orderData.part_code || orderData.product) == prod.cod || orderData.product == prod.name) opt.selected = true;
                            productSelect.appendChild(opt);
                        });
                    } else {
                        const opt = document.createElement('option');
                        opt.value = orderData.product || '';
                        opt.textContent = orderData.product || '';
                        opt.selected = true;
                        productSelect.appendChild(opt);
                    }

                    // Preencher select de máquinas
                    const machineSelect = document.getElementById('edit-order-machine');
                    machineSelect.innerHTML = '';
                    if (window.databaseModule && window.databaseModule.machineById) {
                        const machines = Array.from(window.databaseModule.machineById.values());
                        machines.forEach(mac => {
                            const opt = document.createElement('option');
                            opt.value = mac.id;
                            opt.textContent = `${mac.id} - ${mac.model}`;
                            if ((orderData.machine_id || orderData.machine) == mac.id) opt.selected = true;
                            machineSelect.appendChild(opt);
                        });
                    } else {
                        const opt = document.createElement('option');
                        opt.value = orderData.machine_id || orderData.machine || '';
                        opt.textContent = orderData.machine_id || orderData.machine || '';
                        opt.selected = true;
                        machineSelect.appendChild(opt);
                    }

                    document.getElementById('edit-order-customer').value = orderData.customer || orderData.client || '';
                    document.getElementById('edit-order-lot').value = orderData.lot || orderData.lot_size || '';
                    document.getElementById('edit-order-planned').value = orderData.lot_size || '';
                    document.getElementById('edit-order-executed').value = orderData.total_produzido || orderData.totalProduced || '';
                    
                    // Mostrar info de última edição
                    const lastAdj = orderData.lastManualAdjustment;
                    if (lastAdj && lastAdj.editedByName) {
                        const adjTime = lastAdj.timestamp?.toDate?.() || new Date();
                        const timeStr = adjTime.toLocaleString('pt-BR');
                        console.log(`[EDIT-ORDER] Última edição: ${lastAdj.editedByName} em ${timeStr}`);
                    }
                    
                    document.getElementById('edit-order-modal').classList.remove('hidden');
                });
                btn.dataset.listenerAttached = 'true';
            }
        });
// Modal de edição de ordem
document.getElementById('close-edit-order-modal').onclick = () => {
    document.getElementById('edit-order-modal').classList.add('hidden');
};
document.getElementById('cancel-edit-order').onclick = () => {
    document.getElementById('edit-order-modal').classList.add('hidden');
};
document.getElementById('edit-order-form').onsubmit = async function(e) {
    e.preventDefault();
    const id = document.getElementById('edit-order-id').value;
    const product = document.getElementById('edit-order-product').value;
    const machine = document.getElementById('edit-order-machine').value;
    const customer = document.getElementById('edit-order-customer').value;
    const lot = document.getElementById('edit-order-lot').value;
    const planned = Number(document.getElementById('edit-order-planned').value);
    const executed = Number(document.getElementById('edit-order-executed').value);
    if (!id) return;
    try {
        const currentUser = getActiveUser();
        
        const updateData = {
            product,
            machine_id: machine,
            customer,
            lot_size: planned,
            total_produzido: executed,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        };
        
        if (executed > 0) {
            updateData.lastManualAdjustment = {
                value: executed,
                editedBy: currentUser?.username || 'desconhecido',
                editedByName: currentUser?.name || 'Desconhecido',
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                reason: 'Edição manual via interface'
            };
            console.log(`[AUDIT] ${currentUser?.name || 'Desconhecido'} editou quantidade da ordem ${id}: ${executed}`);
        }
        
        await db.collection('production_orders').doc(id).update(updateData);
        showNotification('Ordem atualizada com sucesso!', 'success');
        document.getElementById('edit-order-modal').classList.add('hidden');
        
        // CRÍTICO: Invalidar cache de ordens para forçar recarregamento do banco
        productionOrdersCache = null;
        
        // Aguardar Firestore processar E atualizar todas as visualizações
        console.log('[EDIT-ORDER-HANDLER] Iniciando refresh após edição...');
        
        // 1. Recarregar lista de análise de ordens
        await loadOrdersAnalysis();
        console.log('[EDIT-ORDER-HANDLER] loadOrdersAnalysis() concluído');
        
        // 2. CRÍTICO: Recarregar seletor de máquinas (atualiza aba Lançamentos)
        // Usar Promise para aguardar o evento machineDataUpdated
        const machineDataPromise = new Promise((resolve) => {
            const handler = () => {
                console.log('[EDIT-ORDER-HANDLER] Evento machineDataUpdated recebido');
                document.removeEventListener('machineDataUpdated', handler);
                resolve();
            };
            document.addEventListener('machineDataUpdated', handler);
            // Timeout de 3s para segurança
            setTimeout(() => {
                document.removeEventListener('machineDataUpdated', handler);
                console.warn('[EDIT-ORDER-HANDLER] Timeout aguardando machineDataUpdated');
                resolve();
            }, 3000);
        });
        
        await populateMachineSelector(); // Aguardar completamente
        await machineDataPromise; // Aguardar evento
        console.log('[EDIT-ORDER-HANDLER] populateMachineSelector() concluído e dados prontos');
        
        // 3. Recarregar dados atuais da máquina selecionada do machineCardData
        if (selectedMachineData && selectedMachineData.machine) {
            const machineName = selectedMachineData.machine;
            const updatedMachineData = machineCardData[machineName];
            if (updatedMachineData) {
                selectedMachineData = updatedMachineData;
                console.log('[EDIT-ORDER-HANDLER] selectedMachineData atualizado:', { 
                    total: selectedMachineData.total_produzido, 
                    lot: selectedMachineData.lot_size || selectedMachineData.order_lot_size 
                });
            }
            
            // 4. Forçar re-seleção da máquina para atualizar o painel completamente
            if (typeof onMachineSelected === 'function') {
                await onMachineSelected(machineName);
                console.log('[EDIT-ORDER-HANDLER] onMachineSelected() executado para', machineName);
            }
        }
        
        // 5. Forçar atualização visual da aba Lançamentos
        updateMachineInfo();
        console.log('[EDIT-ORDER-HANDLER] updateMachineInfo() concluído');
        
        // 6. Se gráfico OP estiver aberto, atualizar também
        if (launchChartMode === 'op') {
            await loadOpProductionChart();
            console.log('[EDIT-ORDER-HANDLER] loadOpProductionChart() concluído');
        }
        
        // 7. Atualizar estatísticas
        await loadTodayStats();
        console.log('[EDIT-ORDER-HANDLER] ✅ Refresh completo finalizado!');
    } catch (err) {
        showNotification('Erro ao atualizar ordem.', 'error');
        console.error('Erro ao atualizar ordem:', err);
    }
};
    }

    // Função para carregar visão geral
    async function loadOverviewData() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadOverviewData] fetching data', { startDate, endDate, machine, shift });
        
        if (!startDate || !endDate) {
            console.warn('[TRACE][loadOverviewData] missing date filters, initializing defaults');
            setAnalysisDefaultDates();
            return;
        }
        
        // Buscar dados do Firebase (sempre sem filtro de turno para permitir comparação geral)
        const [productionAll, lossesAll, downtimeAll, planData] = await Promise.all([
            getFilteredData('production', startDate, endDate, machine, 'all'),
            getFilteredData('losses', startDate, endDate, machine, 'all'),
            getFilteredData('downtime', startDate, endDate, machine, 'all'),
            getFilteredData('plan', startDate, endDate, machine, 'all')
        ]);

        console.log('[TRACE][loadOverviewData] datasets received', {
            productionCount: productionAll.length,
            lossesCount: lossesAll.length,
            downtimeCount: downtimeAll.length,
            planCount: planData.length,
            productionSample: productionAll.slice(0, 2),
            lossesSample: lossesAll.slice(0, 2),
            downtimeSample: downtimeAll.slice(0, 2)
        });

        // Atualizar informações do produto se uma máquina específica foi selecionada
        if (machine && machine !== 'all' && productionAll.length > 0) {
            const firstProduction = productionAll[0];
            if (firstProduction.product_code) {
                const productInfo = window.databaseModule?.productByCode?.get(Number(firstProduction.product_code)) || 
                                   window.databaseModule?.productByCode?.get(firstProduction.product_code);
                if (productInfo) {
                    updateAnalysisProductInfo(
                        firstProduction.product_code,
                        productInfo.cycle,
                        productInfo.cavities,
                        productInfo.weight,
                        productInfo.name
                    );
                }
            }
        }

        const normalizeShiftFilter = (value) => {
            if (value === undefined || value === null || value === 'all') return 'all';
            const num = Number(value);
            return Number.isFinite(num) ? num : 'all';
        };

        const appliedShift = normalizeShiftFilter(shift);

        const filterByShift = (data) => {
            if (appliedShift === 'all') return data;
            return data.filter(item => Number(item.shift || 0) === appliedShift);
        };

    const productionData = filterByShift(productionAll);
    const lossesData = filterByShift(lossesAll);
    const downtimeData = filterByShift(downtimeAll);
    const planFiltered = filterByShift(planData);

        // Calcular KPIs básicos
        const totalProduction = productionData.reduce((sum, item) => sum + item.quantity, 0);
    const totalLosses = lossesData.reduce((sum, item) => sum + (Number(item.scrapPcs ?? item.quantity ?? 0) || 0), 0);
        const MAX_DOWNTIME_MINUTES = 24 * 60; // 24h
        const totalDowntime = downtimeData.reduce((sum, item) => {
            const rawDuration = Number(item.duration) || 0;
            const cappedDuration = Math.min(rawDuration, MAX_DOWNTIME_MINUTES);
            return sum + cappedDuration;
        }, 0);
        
        // Calcular OEE real usando disponibilidade  x  performance  x  qualidade
        const { overallOee, filteredOee } = calculateOverviewOEE(
            productionAll,
            lossesAll,
            downtimeAll,
            planData,
            appliedShift
        );
        const displayedOee = appliedShift === 'all' ? overallOee : filteredOee;
        
        // Atualizar KPIs na interface
        const overviewOee = document.getElementById('overview-oee');
        const overviewProduction = document.getElementById('overview-production');
        const overviewLosses = document.getElementById('overview-losses');
        const overviewDowntime = document.getElementById('overview-downtime');
        
        if (overviewOee) {
            if (appliedShift === 'all') {
                overviewOee.textContent = `${(overallOee * 100).toFixed(1)}%`;
            } else {
                overviewOee.textContent = `Turno: ${(filteredOee * 100).toFixed(1)}% | Geral: ${(overallOee * 100).toFixed(1)}%`;
            }
        }
        if (overviewProduction) overviewProduction.textContent = totalProduction.toLocaleString();
    if (overviewLosses) overviewLosses.textContent = totalLosses.toLocaleString('pt-BR');
        if (overviewDowntime) overviewDowntime.textContent = `${(totalDowntime / 60).toFixed(1)}h`;

        console.log('[TRACE][loadOverviewData] KPIs calculated', { 
            overallOee: (overallOee * 100).toFixed(1) + '%',
            filteredOee: (filteredOee * 100).toFixed(1) + '%',
            totalProduction, 
            totalLosses, 
            totalDowntime 
        });

        // Gerar gráficos
    await generateOEEDistributionChart(productionData, lossesData, downtimeData);
    await generateMachineRanking(productionData, planFiltered);
    }

    function aggregateOeeMetrics(productionData, lossesData, downtimeData, planData, shiftFilter = 'all') {
        console.log('[TRACE][aggregateOeeMetrics] iniciando com', {
            production: productionData.length,
            losses: lossesData.length,
            downtime: downtimeData.length,
            plan: planData.length,
            shiftFilter
        });

        const toShiftNumber = (value) => {
            if (value === null || value === undefined) return null;
            const num = Number(value);
            return Number.isFinite(num) && num > 0 ? num : null;
        };

        const determineShiftFromTime = (timeStr) => {
            if (!timeStr || typeof timeStr !== 'string') return null;
            const [hoursStr, minutesStr] = timeStr.split(':');
            const hours = Number(hoursStr);
            if (!Number.isFinite(hours)) return null;
            if (hours >= 7 && hours < 15) return 1;
            if (hours >= 15 && hours < 23) return 2;
            return 3;
        };

        const determineShiftFromDate = (dateObj) => {
            if (!(dateObj instanceof Date) || Number.isNaN(dateObj.getTime())) return null;
            const hours = dateObj.getHours();
            return determineShiftFromTime(`${String(hours).padStart(2, '0')}:00`);
        };

        const inferShift = (item) => {
            const candidates = [
                item.shift,
                item?.raw?.shift,
                item?.raw?.turno,
                item?.raw?.Shift,
                item?.raw?.Turno
            ];
            for (const value of candidates) {
                const shiftNum = toShiftNumber(value);
                if (shiftNum) return shiftNum;
            }

            const timeCandidates = [
                item.startTime,
                item.endTime,
                item?.raw?.startTime,
                item?.raw?.endTime,
                item?.raw?.hora,
                item?.raw?.hour,
                item?.raw?.time,
                item?.raw?.horaInformada
            ];
            for (const time of timeCandidates) {
                const shiftNum = determineShiftFromTime(time);
                if (shiftNum) return shiftNum;
            }

            const dateCandidates = [];
            if (item.datetime) {
                const parsed = new Date(item.datetime);
                if (!Number.isNaN(parsed.getTime())) dateCandidates.push(parsed);
            }
            if (item?.raw?.timestamp?.toDate) {
                dateCandidates.push(item.raw.timestamp.toDate());
            }
            if (item?.raw?.createdAt?.toDate) {
                dateCandidates.push(item.raw.createdAt.toDate());
            }
            if (item?.raw?.updatedAt?.toDate) {
                dateCandidates.push(item.raw.updatedAt.toDate());
            }
            const resolvedDate = resolveProductionDateTime(item.raw);
            if (resolvedDate) {
                dateCandidates.push(resolvedDate);
            }
            for (const date of dateCandidates) {
                const shiftNum = determineShiftFromDate(date);
                if (shiftNum) return shiftNum;
            }

            // CORREÇÃO: Se não conseguir inferir o turno, assume turno 1 (padrão) para evitar descarte
            console.log('[TRACE][aggregateOeeMetrics] turno não identificado para item', item.id || 'sem-id', 'assumindo turno 1');
            return 1;
        };

        const inferMachine = (item) => item.machine || item?.raw?.machine || item?.raw?.machineRef || item?.raw?.machine_id || null;

        // CORREÇÃO: Incluir workDay/date no agrupamento para múltiplas datas
        const groupKey = (machine, shift, workDay) => `${machine || 'unknown'}_${shift ?? 'none'}_${workDay || 'nodate'}`;
        const grouped = {};

        const getOrCreateGroup = (item) => {
            const machine = inferMachine(item);
            const shiftNum = inferShift(item);
            const workDay = item.workDay || item.date || 'nodate';
            
            if (!machine) {
                console.log('[TRACE][aggregateOeeMetrics] máquina não identificada para item', item.id || 'sem-id');
                return null;
            }
            
            const key = groupKey(machine, shiftNum, workDay);
            if (!grouped[key]) {
                grouped[key] = {
                    machine,
                    shift: shiftNum,
                    workDay,
                    production: 0,
                    scrapPcs: 0,
                    scrapKg: 0,
                    downtimeMin: 0
                };
            }
            return grouped[key];
        };

        productionData.forEach(item => {
            const group = getOrCreateGroup(item);
            if (!group) return;
            group.production += item.quantity || 0;
        });

        lossesData.forEach(item => {
            const group = getOrCreateGroup(item);
            if (!group) return;
            const scrapPcs = Number(item.scrapPcs ?? item.quantity ?? 0) || 0;
            const scrapKg = Number(item.scrapKg ?? 0) || 0;
            group.scrapPcs += scrapPcs;
            group.scrapKg += scrapKg;
        });

        downtimeData.forEach(item => {
            const group = getOrCreateGroup(item);
            if (!group) return;
            group.downtimeMin += item.duration || 0;
        });

        const clamp01 = (value) => Math.max(0, Math.min(1, value));
        const groupsWithMetrics = [];

        console.log('[TRACE][aggregateOeeMetrics] grupos criados:', Object.keys(grouped).length);

        Object.values(grouped).forEach(group => {
            // CORREÇÃO: Buscar planos por máquina e data também
            const planCandidates = planData.filter(p => p && p.raw && p.machine === group.machine);
            
            if (!planCandidates.length) {
                console.log('[TRACE][aggregateOeeMetrics] sem plano para máquina', group.machine, 'usando valores padrão');
                // CORREÇÃO: Usar valores padrão quando não há plano disponível
                const metrics = calculateShiftOEE(
                    group.production,
                    group.downtimeMin,
                    0, // refugoPcs
                    30, // ciclo padrão de 30 segundos
                    2   // 2 cavidades padrão
                );

                groupsWithMetrics.push({
                    machine: group.machine,
                    shift: group.shift,
                    workDay: group.workDay,
                    disponibilidade: clamp01(metrics.disponibilidade),
                    performance: clamp01(metrics.performance),
                    qualidade: clamp01(metrics.qualidade),
                    oee: clamp01(metrics.oee)
                });
                return;
            }

            // Tentar encontrar plano específico para o turno
            let plan = planCandidates.find(p => {
                const planShift = Number(p.shift || 0);
                return planShift && planShift === group.shift;
            });

            // Se não encontrou plano específico, usar o primeiro disponível
            if (!plan) {
                plan = planCandidates[0];
                console.log('[TRACE][aggregateOeeMetrics] usando plano genérico para máquina', group.machine, 'turno', group.shift);
            }

            if (!plan || !plan.raw) {
                console.log('[TRACE][aggregateOeeMetrics] plano inválido para máquina', group.machine);
                return;
            }

            const shiftKey = `t${group.shift}`;
            const cicloReal = plan.raw[`real_cycle_${shiftKey}`] || plan.raw.budgeted_cycle || 30;
            const cavAtivas = plan.raw[`active_cavities_${shiftKey}`] || plan.raw.mold_cavities || 2;
            const pieceWeight = plan.raw.piece_weight || 0.1; // peso padrão de 100g

            let refugoPcs = Math.round(Math.max(0, group.scrapPcs || 0));
            if (!refugoPcs && group.scrapKg > 0 && pieceWeight > 0) {
                refugoPcs = Math.round((group.scrapKg * 1000) / pieceWeight);
            }

            const metrics = calculateShiftOEE(
                group.production,
                group.downtimeMin,
                refugoPcs,
                cicloReal,
                cavAtivas
            );

            console.log('[TRACE][aggregateOeeMetrics] grupo processado:', {
                machine: group.machine,
                shift: group.shift,
                workDay: group.workDay,
                production: group.production,
                downtimeMin: group.downtimeMin,
                refugoPcs,
                scrapPcs: group.scrapPcs,
                scrapKg: group.scrapKg,
                cicloReal,
                cavAtivas,
                metrics
            });

            groupsWithMetrics.push({
                machine: group.machine,
                shift: group.shift,
                workDay: group.workDay,
                disponibilidade: clamp01(metrics.disponibilidade),
                performance: clamp01(metrics.performance),
                qualidade: clamp01(metrics.qualidade),
                oee: clamp01(metrics.oee)
            });
        });

        const averageMetric = (items, selector) => {
            if (!items.length) return 0;
            const total = items.reduce((sum, item) => sum + selector(item), 0);
            return total / items.length;
        };

        const normalizedShift = shiftFilter === 'all' ? 'all' : toShiftNumber(shiftFilter);
        const filteredGroups = normalizedShift === 'all'
            ? groupsWithMetrics
            : groupsWithMetrics.filter(item => item.shift === normalizedShift);

        console.log('[TRACE][aggregateOeeMetrics] grupos com métricas:', groupsWithMetrics.length);
        console.log('[TRACE][aggregateOeeMetrics] grupos filtrados:', filteredGroups.length);

        const overall = {
            disponibilidade: averageMetric(groupsWithMetrics, item => item.disponibilidade),
            performance: averageMetric(groupsWithMetrics, item => item.performance),
            qualidade: averageMetric(groupsWithMetrics, item => item.qualidade),
            oee: averageMetric(groupsWithMetrics, item => item.oee)
        };

        const filtered = {
            disponibilidade: averageMetric(filteredGroups, item => item.disponibilidade),
            performance: averageMetric(filteredGroups, item => item.performance),
            qualidade: averageMetric(filteredGroups, item => item.qualidade),
            oee: averageMetric(filteredGroups, item => item.oee)
        };

        console.log('[TRACE][aggregateOeeMetrics] resultado final:', {
            overall,
            filtered,
            shiftFilter,
            normalizedShift
        });

        return {
            overall,
            filtered,
            groups: groupsWithMetrics
        };
    }

    // Função para calcular OEE real do overview agregando todos os turnos/máquinas
    function calculateOverviewOEE(productionData, lossesData, downtimeData, planData, shiftFilter = 'all') {
        const { overall, filtered } = aggregateOeeMetrics(
            productionData,
            lossesData,
            downtimeData,
            planData,
            shiftFilter
        );

        // Padrão A: OEE = Disponibilidade  x  Performance  x  Qualidade (produto das médias dos componentes)
        const safeMul = (...vals) => vals.reduce((acc, v) => acc * (Number.isFinite(v) ? v : 0), 1);

        const overallOee = safeMul(
            overall?.disponibilidade || 0,
            overall?.performance || 0,
            overall?.qualidade || 0
        );

        const filteredOee = safeMul(
            filtered?.disponibilidade || 0,
            filtered?.performance || 0,
            filtered?.qualidade || 0
        );

        return { overallOee, filteredOee };
    }

    // Função para carregar análise de produção
    async function loadProductionAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadProductionAnalysis] fetching data', { startDate, endDate, machine, shift });
        
        const productionData = await getFilteredData('production', startDate, endDate, machine, shift);
        const planData = await getFilteredData('plan', startDate, endDate, machine, shift);
        const lossesData = await getFilteredData('losses', startDate, endDate, machine, shift);
        const downtimeData = await getFilteredData('downtime', startDate, endDate, machine, shift);

        console.log('[TRACE][loadProductionAnalysis] datasets received', {
            productionCount: productionData.length,
            planCount: planData.length,
            lossesCount: lossesData.length,
            downtimeCount: downtimeData.length
        });
        
        // Calcular métricas
        const totalProduction = productionData.reduce((sum, item) => sum + item.quantity, 0);
        const totalPlan = planData.reduce((sum, item) => sum + item.quantity, 0);
        const targetVsActual = totalPlan > 0 ? (totalProduction / totalPlan * 100) : 0;
        
        // Encontrar máquina top
        const machineProduction = {};
        productionData.forEach(item => {
            machineProduction[item.machine] = (machineProduction[item.machine] || 0) + item.quantity;
        });
        const topMachine = Object.keys(machineProduction).reduce((a, b) => 
            machineProduction[a] > machineProduction[b] ? a : b, '---'
        );

        cachedProductionDataset = {
            productionData,
            planData,
            startDate,
            endDate,
            shift,
            machine
        };

        // Atualizar interface - KPIs
        const totalProducedKpi = document.getElementById('total-produced-kpi');
        const totalProducedSubtext = document.getElementById('total-produced-subtext');
        if (totalProducedKpi) {
            // Formatar número grande (ex: 1.2M, 500K)
            let formattedTotal;
            if (totalProduction >= 1000000) {
                formattedTotal = (totalProduction / 1000000).toFixed(1) + 'M';
            } else if (totalProduction >= 1000) {
                formattedTotal = (totalProduction / 1000).toFixed(1) + 'K';
            } else {
                formattedTotal = totalProduction.toLocaleString('pt-BR');
            }
            totalProducedKpi.textContent = formattedTotal;
        }
        if (totalProducedSubtext) {
            totalProducedSubtext.textContent = `${totalProduction.toLocaleString('pt-BR')} peças`;
        }
        
        document.getElementById('production-target-vs-actual').textContent = `${targetVsActual.toFixed(1)}%`;
        document.getElementById('top-machine').textContent = topMachine;
        updateProductionRateDisplay();

        // ========== PREENCHER TOP 5 MÁQUINAS (aba Produção) ==========
        const machineRankingProduction = document.getElementById('machine-ranking-production');
        if (machineRankingProduction) {
            const sortedMachines = Object.entries(machineProduction)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5);
            
            if (sortedMachines.length === 0) {
                machineRankingProduction.innerHTML = '<div class="text-center py-4 text-gray-400"><p class="text-xs">Sem dados de produção</p></div>';
            } else {
                const maxProduction = sortedMachines[0][1];
                machineRankingProduction.innerHTML = sortedMachines.map(([mach, qty], index) => {
                    const percentage = maxProduction > 0 ? (qty / maxProduction * 100) : 0;
                    const medalColors = ['bg-amber-500', 'bg-gray-400', 'bg-orange-400', 'bg-blue-400', 'bg-green-400'];
                    const medalColor = medalColors[index] || 'bg-gray-300';
                    return `
                        <div class="flex items-center gap-3 p-2 bg-gray-50 rounded-lg">
                            <div class="w-6 h-6 ${medalColor} text-white rounded-full flex items-center justify-center text-xs font-bold">${index + 1}</div>
                            <div class="flex-1">
                                <div class="flex justify-between items-center mb-1">
                                    <span class="text-sm font-medium text-gray-700">${mach}</span>
                                    <span class="text-sm font-bold text-blue-600">${qty.toLocaleString('pt-BR')}</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-1.5">
                                    <div class="bg-blue-500 h-1.5 rounded-full" style="width: ${percentage.toFixed(1)}%"></div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
        }

        // ========== PREENCHER RESUMO DO DIA ==========
        const totalLosses = lossesData.reduce((sum, item) => sum + (Number(item.scrapPcs ?? item.quantity ?? 0) || 0), 0);
        // Filtrar borra de forma consistente com loadLossesAnalysis
        const borraData = lossesData.filter(item => {
            const reasonStr = (item.reason || item.raw?.perdas || '').toString().toLowerCase();
            const isTagged = (item.raw && item.raw.tipo_lancamento === 'borra');
            return isTagged || reasonStr.includes('borra');
        });
        const totalBorra = borraData.reduce((sum, item) => sum + (Number(item.raw?.refugo_kg ?? item.scrapKg ?? item.weight ?? 0) || 0), 0);
        const totalDowntime = downtimeData.reduce((sum, item) => sum + (Number(item.duration) || 0), 0);
        const goodProduction = totalProduction; // Produção boa é o total de produção (já exclui refugos)

        const summaryGood = document.getElementById('summary-good-production');
        const summaryLosses = document.getElementById('summary-losses');
        const summaryBorra = document.getElementById('summary-borra');
        const summaryDowntime = document.getElementById('summary-downtime');

        if (summaryGood) summaryGood.textContent = goodProduction.toLocaleString('pt-BR');
        if (summaryLosses) summaryLosses.textContent = totalLosses.toLocaleString('pt-BR');
        if (summaryBorra) summaryBorra.textContent = totalBorra.toFixed(2);
        if (summaryDowntime) summaryDowntime.textContent = totalDowntime.toLocaleString('pt-BR');

        // Gerar gráficos
        await generateHourlyProductionChart(productionData, {
            canvas: analysisHourlyProductionChart,
            targetCanvasId: 'analysis-hourly-production-chart',
            chartContext: 'analysis',
            dailyTargetOverride: totalPlan,
            updateTimeline: false
        });
        await generateShiftProductionChart(productionData);
        await generateMachineProductionTimeline(productionData, {
            canvas: analysisMachineProductionTimelineChart,
            targetCanvasId: 'analysis-machine-production-timeline'
        });
    }

    function updateProductionRateToggle() {
        const dayBtn = document.getElementById('production-rate-mode-day');
        const shiftBtn = document.getElementById('production-rate-mode-shift');
        if (!dayBtn || !shiftBtn) return;

        const applyState = (btn, isActive) => {
            btn.classList.remove('bg-green-600', 'text-white', 'bg-white', 'text-green-600', 'hover:bg-green-50');
            if (isActive) {
                btn.classList.add('bg-green-600', 'text-white');
            } else {
                btn.classList.add('bg-white', 'text-green-600', 'hover:bg-green-50');
            }
        };

        applyState(dayBtn, productionRateMode === 'day');
        applyState(shiftBtn, productionRateMode === 'shift');
    }

    function updateProductionRateDisplay() {
        const valueEl = document.getElementById('production-rate-value');
        const subtextEl = document.getElementById('production-rate-subtext');
        if (!valueEl) return;

        const dataset = cachedProductionDataset || {};
        const productionData = dataset.productionData || [];
        const startDate = dataset.startDate;
        const endDate = dataset.endDate;
        const shiftFilterRaw = dataset.shift;
        const shiftFilter = shiftFilterRaw != null ? String(shiftFilterRaw) : 'all';

        if (!productionData.length) {
            valueEl.textContent = '--- pcs/h';
            if (subtextEl) {
                const modeLabel = productionRateMode === 'shift' ? 'Modo turno' : 'Modo dia';
                subtextEl.textContent = `${modeLabel} – Sem registros no período selecionado.`;
            }
            return;
        }

        const totalProduction = productionData.reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);
        const workDaysSet = new Set(productionData.map(item => item.workDay || item.date).filter(Boolean));
        const workDaysCount = workDaysSet.size;

        let effectiveDays = workDaysCount;
        if (!effectiveDays) {
            if (startDate && endDate) {
                const baseStart = new Date(`${startDate}T00:00:00`);
                const baseEnd = new Date(`${endDate}T00:00:00`);
                const diffDays = Math.max(Math.round((baseEnd - baseStart) / (1000 * 60 * 60 * 24)) + 1, 1);
                effectiveDays = diffDays;
            } else {
                effectiveDays = 1;
            }
        }

        if (productionRateMode === 'day') {
            let hoursInPeriod = 0;
            if (startDate && endDate) {
                hoursInPeriod = calculateHoursInPeriod(startDate, endDate);
            }
            if (!hoursInPeriod) {
                hoursInPeriod = effectiveDays * 24;
            }

            const rate = hoursInPeriod > 0 ? totalProduction / hoursInPeriod : 0;
            valueEl.textContent = `${rate.toFixed(1)} pcs/h`;

            if (subtextEl) {
                const daysLabel = effectiveDays > 1 ? `${effectiveDays} dias` : '1 dia';
                const dataDaysLabel = workDaysCount && workDaysCount !== effectiveDays ? `, ${workDaysCount} com lançamentos` : '';
                subtextEl.textContent = `Modo dia – ${totalProduction.toLocaleString('pt-BR')} peças em ${daysLabel}${dataDaysLabel}.`;
            }
            return;
        }

        const hoursPerShift = 8;
        const denominator = Math.max(effectiveDays * hoursPerShift, 1);
        const shiftTotals = { '1': 0, '2': 0, '3': 0 };
        let unknownTotal = 0;

        productionData.forEach(item => {
            const shiftValue = item.shift;
            const normalizedShift = shiftValue != null ? String(shiftValue) : null;
            const qty = Number(item.quantity) || 0;
            if (normalizedShift && Object.prototype.hasOwnProperty.call(shiftTotals, normalizedShift)) {
                shiftTotals[normalizedShift] += qty;
            } else {
                unknownTotal += qty;
            }
        });

        const shiftRates = ['1', '2', '3'].map(shiftKey => {
            const total = shiftTotals[shiftKey] || 0;
            const rate = total > 0 ? total / denominator : 0;
            return { shift: shiftKey, total, rate };
        });

        const selectedShift = shiftFilter !== 'all' ? shiftFilter : 'all';

        if (selectedShift !== 'all' && ['1', '2', '3'].includes(selectedShift)) {
            const selectedData = shiftRates.find(r => r.shift === selectedShift);
            if (selectedData && selectedData.total > 0) {
                valueEl.textContent = `Turno ${selectedData.shift}: ${selectedData.rate.toFixed(1)} pcs/h`;
            } else {
                valueEl.textContent = `Turno ${selectedShift}: -- pcs/h`;
            }
        } else {
            const bestShift = shiftRates.reduce((best, current) => {
                if (current.total <= 0) return best;
                if (!best || current.rate > best.rate) {
                    return current;
                }
                return best;
            }, null);

            if (bestShift) {
                valueEl.textContent = `Melhor turno: T${bestShift.shift} ${bestShift.rate.toFixed(1)} pcs/h`;
            } else {
                valueEl.textContent = 'Sem dados por turno';
            }
        }

        if (subtextEl) {
            const detailParts = shiftRates.map(r => {
                const label = `T${r.shift}`;
                return r.total > 0 ? `${label}: ${r.rate.toFixed(1)} pcs/h` : `${label}: --`;
            });
            if (unknownTotal > 0) {
                detailParts.push(`Sem turno: ${unknownTotal.toLocaleString('pt-BR')} pcs`);
            }
            const daysLabel = effectiveDays > 1 ? `${effectiveDays} dias` : '1 dia';
            subtextEl.textContent = `Modo turno – ${detailParts.join(' – ')} – ${daysLabel} analisado(s).`;
        }
    }

    // Função para debug de eficiência
    async function debugEfficiencyCalculation() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('=== DEBUG EFICIÊNCIA ===');
        console.log('Filtros:', { startDate, endDate, machine, shift });
        
        // Buscar dados raw
        const [productionData, lossesData, downtimeData, planData] = await Promise.all([
            getFilteredData('production', startDate, endDate, machine, 'all'),
            getFilteredData('losses', startDate, endDate, machine, 'all'),
            getFilteredData('downtime', startDate, endDate, machine, 'all'),
            getFilteredData('plan', startDate, endDate, machine, 'all')
        ]);

        console.log('Dados Raw:', {
            production: productionData.length,
            losses: lossesData.length,
            downtime: downtimeData.length,
            plan: planData.length
        });

        console.log('Amostra Production:', productionData.slice(0, 3));
        console.log('Amostra Plan:', planData.slice(0, 3));

        const result = aggregateOeeMetrics(productionData, lossesData, downtimeData, planData, shift);
        console.log('Resultado Agregação:', result);

        alert(`Debug concluído! Verifique o console para detalhes.
        
Production: ${productionData.length} registros
Losses: ${lossesData.length} registros  
Downtime: ${downtimeData.length} registros
Plan: ${planData.length} registros

Disponibilidade: ${(result.filtered.disponibilidade * 100).toFixed(1)}%
Performance: ${(result.filtered.performance * 100).toFixed(1)}%
Qualidade: ${(result.filtered.qualidade * 100).toFixed(1)}%`);
    }

    // Função para carregar análise de eficiência
    async function loadEfficiencyAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadEfficiencyAnalysis] calculating', { startDate, endDate, machine, shift });
        
        const oeeData = await calculateDetailedOEE(startDate, endDate, machine, shift);

        console.log('[TRACE][loadEfficiencyAnalysis] oeeData', oeeData);
        
        // Atualizar gauges dos componentes
        updateGauge('availability-gauge', oeeData.availability);
        updateGauge('performance-gauge', oeeData.performance);
        updateGauge('quality-gauge', oeeData.quality);
        
        document.getElementById('availability-value').textContent = `${oeeData.availability.toFixed(1)}%`;
        document.getElementById('performance-value').textContent = `${oeeData.performance.toFixed(1)}%`;
        document.getElementById('quality-value').textContent = `${oeeData.quality.toFixed(1)}%`;

        // ========== PREENCHER OEE GERAL ==========
        const oeeGeneral = oeeData.oee || ((oeeData.availability * oeeData.performance * oeeData.quality) / 10000);
        const oeeGeneralValue = document.getElementById('oee-general-value');
        const oeeClassification = document.getElementById('oee-classification');
        
        if (oeeGeneralValue) {
            oeeGeneralValue.textContent = `${oeeGeneral.toFixed(1)}%`;
        }
        
        // Atualizar gauge OEE principal
        updateGauge('oee-main-gauge', oeeGeneral);
        
        // Classificação do OEE
        if (oeeClassification) {
            let classification = 'Inaceitável';
            let classColor = 'text-red-600';
            if (oeeGeneral >= 85) {
                classification = 'Classe Mundial';
                classColor = 'text-green-600';
            } else if (oeeGeneral >= 75) {
                classification = 'Excelente';
                classColor = 'text-blue-600';
            } else if (oeeGeneral >= 65) {
                classification = 'Bom';
                classColor = 'text-teal-600';
            } else if (oeeGeneral >= 50) {
                classification = 'Regular';
                classColor = 'text-amber-600';
            }
            oeeClassification.textContent = classification;
            oeeClassification.className = `font-semibold ${classColor}`;
        }

        // ========== PREENCHER RANKING DE OEE POR MÁQUINA ==========
        const machineOeeRanking = document.getElementById('machine-oee-ranking');
        if (machineOeeRanking) {
            try {
                // Calcular OEE por máquina
                const productionData = await getFilteredData('production', startDate, endDate, machine === 'all' ? null : machine, shift);
                const lossesData = await getFilteredData('losses', startDate, endDate, machine === 'all' ? null : machine, shift);
                const planData = await getFilteredData('plan', startDate, endDate, machine === 'all' ? null : machine, shift);
                
                // Agrupar por máquina
                const machineData = {};
                
                productionData.forEach(item => {
                    const m = item.machine || 'N/A';
                    if (!machineData[m]) machineData[m] = { production: 0, losses: 0, planned: 0 };
                    machineData[m].production += Number(item.quantity) || 0;
                });
                
                lossesData.forEach(item => {
                    const m = item.machine || 'N/A';
                    if (!machineData[m]) machineData[m] = { production: 0, losses: 0, planned: 0 };
                    machineData[m].losses += Number(item.scrapPcs ?? item.quantity ?? 0) || 0;
                });
                
                planData.forEach(item => {
                    const m = item.machine || 'N/A';
                    if (!machineData[m]) machineData[m] = { production: 0, losses: 0, planned: 0 };
                    machineData[m].planned += Number(item.quantity) || 0;
                });
                
                // Calcular OEE simplificado por máquina (Performance  x  Qualidade)
                const machineEntries = Object.entries(machineData)
                    .map(([mach, data]) => {
                        const totalOutput = data.production + data.losses;
                        const performance = data.planned > 0 ? Math.min((data.production / data.planned) * 100, 100) : 0;
                        const quality = totalOutput > 0 ? (data.production / totalOutput) * 100 : 100;
                        const oee = (performance * quality) / 100; // OEE simplificado
                        return { machine: mach, oee, production: data.production };
                    })
                    .filter(e => e.production > 0) // Só máquinas com produção
                    .sort((a, b) => b.oee - a.oee)
                    .slice(0, 5);
                
                if (machineEntries.length === 0) {
                    machineOeeRanking.innerHTML = '<div class="text-center py-4 text-gray-400"><p class="text-xs">Sem dados de OEE por máquina</p></div>';
                } else {
                    const getOeeColor = (oee) => {
                        if (oee >= 85) return 'bg-green-500';
                        if (oee >= 75) return 'bg-blue-500';
                        if (oee >= 65) return 'bg-teal-500';
                        if (oee >= 50) return 'bg-amber-500';
                        return 'bg-red-500';
                    };
                    machineOeeRanking.innerHTML = machineEntries.map((e, idx) => `
                        <div class="flex items-center gap-2 p-2 bg-gray-50 rounded-lg">
                            <div class="w-5 h-5 ${getOeeColor(e.oee)} text-white rounded-full flex items-center justify-center text-xs font-bold">${idx + 1}</div>
                            <span class="flex-1 text-sm font-medium text-gray-700">${e.machine}</span>
                            <span class="text-sm font-bold ${e.oee >= 75 ? 'text-green-600' : e.oee >= 50 ? 'text-amber-600' : 'text-red-600'}">${e.oee.toFixed(1)}%</span>
                        </div>
                    `).join('');
                }
            } catch (err) {
                console.error('[loadEfficiencyAnalysis] Erro ao calcular ranking OEE por máquina:', err);
                machineOeeRanking.innerHTML = '<div class="text-center py-4 text-gray-400"><p class="text-xs">Erro ao carregar</p></div>';
            }
        }

        // Gerar gráficos
        await generateOEEComponentsTimeline(startDate, endDate, machine);
        await generateOEEHeatmap(startDate, endDate, machine);
    }

    // Função para carregar análise de perdas
    async function loadLossesAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadLossesAnalysis] fetching data', { startDate, endDate, machine, shift });
        
        const lossesData = await getFilteredData('losses', startDate, endDate, machine, shift);
        const productionData = await getFilteredData('production', startDate, endDate, machine, shift);

        console.log('[TRACE][loadLossesAnalysis] datasets received', {
            lossesCount: lossesData.length,
            productionCount: productionData.length
        });
        
        const totalLosses = lossesData.reduce((sum, item) => sum + item.quantity, 0);
        const totalProduction = productionData.reduce((sum, item) => sum + item.quantity, 0);
        const lossesPercentage = totalProduction > 0 ? (totalLosses / totalProduction * 100) : 0;
        
        // Calcular principal motivo
        const reasonCounts = {};
        lossesData.forEach(item => {
            reasonCounts[item.reason] = (reasonCounts[item.reason] || 0) + item.quantity;
        });
        const mainReason = Object.keys(reasonCounts).reduce((a, b) => 
            reasonCounts[a] > reasonCounts[b] ? a : b, '---'
        );
        
        // Separar dados de borra
        const borraData = lossesData.filter(item => {
            const reasonStr = (item.reason || item.raw?.perdas || '').toString().toLowerCase();
            const isTagged = (item.raw && item.raw.tipo_lancamento === 'borra');
            return isTagged || reasonStr.includes('borra');
        });
        const regularLossesData = lossesData.filter(item => !borraData.includes(item));
        console.log('[TRACE][loadLossesAnalysis] borra split', {
            borraCount: borraData.length,
            regularLossesCount: regularLossesData.length,
            borraSample: borraData.slice(0, 3)
        });
        
        // Calcular total de borra em kg
        const totalBorraKg = borraData.reduce((sum, item) => {
            // Para borra, usar preferencialmente o peso em kg
            const weight = item.raw?.refugo_kg || item.quantity || 0;
            return sum + weight;
        }, 0);
        if (lossesData.length > 0 && borraData.length === 0) {
            console.warn('[TRACE][loadLossesAnalysis] Atenção: há perdas mas nenhuma BORRA detectada. Verifique se os lançamentos de borra possuem tipo_lancamento="borra" ou motivo contendo "borra".');
        }

        // Calcular MP mais perdida
        const materialCounts = {};
        lossesData.forEach(item => {
            const mpType = item.mp_type || 'Não especificado';
            materialCounts[mpType] = (materialCounts[mpType] || 0) + item.quantity;
        });
        const mainMaterialCode = Object.keys(materialCounts).length > 0 
            ? Object.keys(materialCounts).reduce((a, b) => 
                materialCounts[a] > materialCounts[b] ? a : b, '---'
            ) 
            : '---';
        const mainMaterial = mainMaterialCode !== '---' ? getDescricaoMP(mainMaterialCode) : '---';

        // Análise específica de borra
        const borraMPCounts = {};
        const borraReasonCounts = {};
        const borraMachineCounts = {};
        
        borraData.forEach(item => {
            const mpType = item.mp_type || item.raw?.mp_type || 'Não especificado';
            const reason = item.reason || item.raw?.perdas || 'Não especificado';
            const machine = item.machine || 'Não especificado';
            
            borraMPCounts[mpType] = (borraMPCounts[mpType] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
            borraReasonCounts[reason] = (borraReasonCounts[reason] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
            borraMachineCounts[machine] = (borraMachineCounts[machine] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
        });

        const topBorraMP = Object.keys(borraMPCounts).length > 0
            ? Object.keys(borraMPCounts).reduce((a, b) => borraMPCounts[a] > borraMPCounts[b] ? a : b, '---')
            : '---';
            
        const topBorraReason = Object.keys(borraReasonCounts).length > 0
            ? Object.keys(borraReasonCounts).reduce((a, b) => borraReasonCounts[a] > borraReasonCounts[b] ? a : b, '---')
            : '---';
            
        const topBorraMachine = Object.keys(borraMachineCounts).length > 0
            ? Object.keys(borraMachineCounts).reduce((a, b) => borraMachineCounts[a] > borraMachineCounts[b] ? a : b, '---')
            : '---';

        // Atualizar interface
        document.getElementById('total-losses').textContent = totalLosses.toLocaleString();
        document.getElementById('losses-percentage').textContent = `${lossesPercentage.toFixed(1)}%`;
        document.getElementById('total-borra').textContent = `${totalBorraKg.toFixed(3)}`;
        document.getElementById('main-loss-reason').textContent = mainReason;
        document.getElementById('main-loss-material').textContent = mainMaterial;
        
        // Atualizar dados específicos de borra
        const topBorraMPElement = document.getElementById('top-borra-mp');
        const topBorraReasonElement = document.getElementById('top-borra-reason');
        const topBorraMachineElement = document.getElementById('top-borra-machine');
        
        if (topBorraMPElement) topBorraMPElement.textContent = topBorraMP;
        if (topBorraReasonElement) topBorraReasonElement.textContent = topBorraReason.replace('BORRA - ', '');
        if (topBorraMachineElement) topBorraMachineElement.textContent = topBorraMachine;

        // Gerar gráficos
        await generateLossesParetoChart(lossesData);
        await generateLossesByMachineChart(lossesData);
        await generateLossesByMaterialChart(lossesData);
        await generateLossesTrendChart(lossesData, startDate, endDate);
        
        // Gerar gráficos específicos de borra
        await generateBorraByMPChart(borraData);
        await generateBorraByReasonChart(borraData);
        await generateBorraByMachineChart(borraData);
    }

    // Função para carregar análise de paradas
    async function loadDowntimeAnalysis() {
        const { startDate, endDate, machine, shift } = currentAnalysisFilters;
        console.log('[TRACE][loadDowntimeAnalysis] fetching data', { startDate, endDate, machine, shift });
        
        const downtimeSegments = await getFilteredData('downtime', startDate, endDate, machine, shift);
        const downtimeData = consolidateDowntimeEvents(downtimeSegments);

        console.log('[TRACE][loadDowntimeAnalysis] dataset received', {
            segments: downtimeSegments.length,
            events: downtimeData.length
        });
        
        const totalDowntime = downtimeData.reduce((sum, item) => sum + (item.duration || 0), 0);
        const downtimeCount = downtimeData.length;
        const avgDowntime = downtimeCount > 0 ? (totalDowntime / downtimeCount) : 0;
        
        // Calcular MTBF (Mean Time Between Failures)
        const hoursInPeriod = calculateHoursInPeriod(startDate, endDate);
        const mtbf = downtimeCount > 0 ? (hoursInPeriod / downtimeCount) : 0;

        // Atualizar interface
        document.getElementById('total-downtime').textContent = `${(totalDowntime / 60).toFixed(1)}h`;
        document.getElementById('downtime-count').textContent = downtimeCount.toString();
        document.getElementById('avg-downtime').textContent = `${avgDowntime.toFixed(0)}min`;
        document.getElementById('mtbf-value').textContent = `${mtbf.toFixed(1)}h`;

        // Gerar gráficos
        await generateDowntimeReasonsChart(downtimeData);
        await generateDowntimeByMachineChart(downtimeData);
        await generateDowntimeTimelineChart(downtimeData);

        // Carregar paradas longas programadas
        await loadExtendedDowntimeAnalysis(startDate, endDate, machine);
    }

    // Função para carregar paradas longas na análise
    async function loadExtendedDowntimeAnalysis(startDate, endDate, machine) {
        console.log('[EXTENDED-DOWNTIME] Carregando paradas longas para análise', { startDate, endDate, machine });
        
        try {
            // Buscar TODOS os registros da coleção para evitar problemas de filtro
            const allSnap = await db.collection('extended_downtime_logs').get();
            
            let data = [];
            const seenAnalysisIds = new Set();
            
            console.log('[EXTENDED-DOWNTIME] Total de registros na coleção:', allSnap.size);
            
            allSnap.forEach(doc => {
                const d = doc.data();
                if (!doc.id) return;
                if (seenAnalysisIds.has(doc.id)) return;
                
                // Pegar data do registro (pode estar em diferentes campos)
                const recordDate = d.start_date || d.date || '';
                
                // Verificar se está no período OU se está ativa (paradas ativas sempre aparecem)
                const isActive = d.status === 'active';
                const isInPeriod = recordDate >= startDate && recordDate <= endDate;
                
                if (!isActive && !isInPeriod) {
                    return; // Fora do período e não está ativa
                }
                
                // Filtrar por máquina se selecionada
                const machineId = d.machine_id || d.machine || '';
                if (machine && machine !== 'all' && machine !== '' && machineId !== machine) {
                    return;
                }
                
                seenAnalysisIds.add(doc.id);
                data.push({ id: doc.id, ...d, machine_id: machineId }); // Garantir machine_id
                
                // Log para debug
                if (isActive) {
                    console.log('[EXTENDED-DOWNTIME] Incluindo ATIVA:', machineId, recordDate, d.status);
                }
            });

            console.log('[EXTENDED-DOWNTIME] Registros filtrados:', data.length);
            console.log('[EXTENDED-DOWNTIME] Máquinas:', [...new Set(data.map(d => d.machine_id))].join(', '));
            
            // Log detalhado de cada registro
            data.forEach((d, i) => {
                console.log(`[EXTENDED-DOWNTIME] [${i+1}] ${d.machine_id} | ${d.start_date || d.date} | status: ${d.status || 'N/A'} | type: ${d.type}`);
            });

            // Calcular totais por tipo
            const typeHours = {
                weekend: 0,
                maintenance: 0,
                holiday: 0,
                other: 0
            };

            data.forEach(item => {
                // Calcular duração: se parada está finalizada, usar duration_minutes; senão calcular do início até agora
                let hours = 0;
                if (item.status === 'active' && item.start_datetime) {
                    // Parada ativa - calcular tempo desde o início até agora
                    const startTime = item.start_datetime?.toDate?.() || new Date(item.start_date);
                    const now = new Date();
                    const durationMin = Math.floor((now - startTime) / (1000 * 60));
                    hours = durationMin / 60;
                } else {
                    // Parada finalizada - usar duration_minutes
                    hours = (item.duration_minutes || 0) / 60;
                }
                
                const type = item.type || 'other';
                
                if (type === 'weekend') typeHours.weekend += hours;
                else if (type === 'maintenance' || type === 'preventive') typeHours.maintenance += hours;
                else if (type === 'holiday') typeHours.holiday += hours;
                else typeHours.other += hours;
            });

            // Atualizar cards de resumo
            document.getElementById('extended-weekend-hours').textContent = `${typeHours.weekend.toFixed(1)}h`;
            document.getElementById('extended-maintenance-hours').textContent = `${typeHours.maintenance.toFixed(1)}h`;
            document.getElementById('extended-holiday-hours').textContent = `${typeHours.holiday.toFixed(1)}h`;
            document.getElementById('extended-other-hours').textContent = `${typeHours.other.toFixed(1)}h`;
            document.getElementById('extended-downtime-total').textContent = `${data.length} registros`;

            // Renderizar lista
            const listContainer = document.getElementById('extended-downtime-analysis-list');
            if (data.length === 0) {
                listContainer.innerHTML = '<p class="text-sm text-gray-500 text-center py-4">Nenhuma parada longa no período selecionado.</p>';
            } else {
                const typeLabels = {
                    weekend: 'Fim de Semana',
                    maintenance: 'Manutenção Preventiva',
                    preventive: 'Manutenção Preventiva',
                    maintenance_planned: 'Manutenção Programada',
                    holiday: 'Feriado',
                    setup: 'Setup/Troca',
                    other: 'Outro'
                };

                const typeColors = {
                    weekend: 'bg-gray-100 text-gray-700',
                    maintenance: 'bg-blue-100 text-blue-700',
                    preventive: 'bg-blue-100 text-blue-700',
                    maintenance_planned: 'bg-blue-100 text-blue-700',
                    holiday: 'bg-amber-100 text-amber-700',
                    setup: 'bg-purple-100 text-purple-700',
                    other: 'bg-red-100 text-red-700'
                };

                listContainer.innerHTML = data.map(item => {
                    // Calcular duração: se ativa, calcular do início até agora; senão usar duration_minutes
                    let hours;
                    const isActive = item.status === 'active';
                    
                    if (isActive) {
                        // Parada ativa - calcular tempo desde o início até agora
                        let startTime;
                        if (item.start_datetime?.toDate) {
                            startTime = item.start_datetime.toDate();
                        } else if (item.start_date && item.start_time) {
                            startTime = new Date(`${item.start_date}T${item.start_time}`);
                        } else if (item.start_date) {
                            startTime = new Date(item.start_date);
                        } else {
                            startTime = new Date();
                        }
                        const now = new Date();
                        const durationMin = Math.max(0, Math.floor((now - startTime) / (1000 * 60)));
                        hours = (durationMin / 60).toFixed(1);
                    } else {
                        // Parada finalizada - usar duration_minutes
                        hours = ((item.duration_minutes || 0) / 60).toFixed(1);
                    }
                    
                    const typeLabel = typeLabels[item.type] || item.type || 'Outro';
                    const typeColor = typeColors[item.type] || 'bg-gray-100 text-gray-700';
                    
                    // Badge de status - considerar vários valores
                    let statusBadge;
                    if (isActive) {
                        statusBadge = '<span class="text-xs px-2 py-1 rounded bg-red-100 text-red-700 font-semibold">🔴 ATIVA</span>';
                    } else if (item.status === 'inactive' || item.status === 'registered' || item.status === 'finished') {
                        statusBadge = '<span class="text-xs px-2 py-1 rounded bg-green-100 text-green-700 font-semibold">✅ FINALIZADA</span>';
                    } else {
                        statusBadge = `<span class="text-xs px-2 py-1 rounded bg-gray-100 text-gray-700 font-semibold">${item.status || 'N/A'}</span>`;
                    }
                    
                    // Período: se parada ainda está ativa, mostrar apenas data início
                    const periodText = isActive
                        ? `${item.start_date || ''} (em andamento)`
                        : `${item.start_date || ''} → ${item.end_date || ''}`;
                    
                    return `
                        <div class="flex items-center justify-between p-3 ${item.status === 'active' ? 'bg-red-50 border border-red-200' : 'bg-gray-50'} rounded-lg hover:${item.status === 'active' ? 'bg-red-100' : 'bg-gray-100'} transition-colors">
                            <div class="flex-1 flex items-center gap-3">
                                <span class="font-semibold text-sm text-gray-800">${item.machine_id || '-'}</span>
                                <span class="text-xs px-2 py-1 rounded ${typeColor}">${typeLabel}</span>
                                ${statusBadge}
                                <span class="text-xs text-gray-500">${periodText}</span>
                                <span class="text-xs text-gray-400">${item.reason || ''}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="text-sm font-medium text-gray-700">${hours}h</span>
                                <button class="btn-edit-extended-downtime-analysis bg-blue-500 hover:bg-blue-600 text-white px-2 py-1 rounded text-xs font-semibold transition" data-id="${item.id}" data-machine="${item.machine_id}" data-type="${item.type}" data-start-date="${item.start_date}" data-end-date="${item.end_date || ''}" data-reason="${item.reason}" data-start-time="${item.start_time || '00:00'}" data-end-time="${item.end_time || '23:59'}">
                                    <i data-lucide="edit-2" class="w-3 h-3"></i>
                                </button>
                                <button class="btn-delete-extended-downtime-analysis bg-red-500 hover:bg-red-600 text-white px-2 py-1 rounded text-xs font-semibold transition" data-id="${item.id}" data-machine="${item.machine_id}">
                                    <i data-lucide="trash-2" class="w-3 h-3"></i>
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Attach listeners para os botões da análise
                document.querySelectorAll('.btn-edit-extended-downtime-analysis').forEach(btn => {
                    btn.removeEventListener('click', handleEditExtendedDowntimeFromAnalysis);
                    btn.addEventListener('click', handleEditExtendedDowntimeFromAnalysis);
                });
                
                document.querySelectorAll('.btn-delete-extended-downtime-analysis').forEach(btn => {
                    btn.removeEventListener('click', handleDeleteExtendedDowntimeFromAnalysis);
                    btn.addEventListener('click', handleDeleteExtendedDowntimeFromAnalysis);
                });
                
                lucide.createIcons();
            }

        } catch (error) {
            console.error('[EXTENDED-DOWNTIME] Erro ao carregar paradas longas:', error);
        }
    }

    // Handlers para editar/deletar da análise
    async function handleEditExtendedDowntimeFromAnalysis(e) {
        e.stopPropagation();
        
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('editar paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        
        // Navegar para a aba de paradas longas
        const paradas = document.querySelector('[data-page="paradas-longas"]');
        if (paradas) {
            paradas.click();
        }
        
        // Simular click no botão de edição equivalente
        setTimeout(() => {
            const editBtn = document.querySelector(`.btn-edit-extended-downtime[data-id="${btn.dataset.id}"]`);
            if (editBtn) {
                editBtn.click();
            } else {
                // Se não encontrar, popular form manualmente
                handleEditExtendedDowntime.call(btn);
            }
        }, 300);
    }

    async function handleDeleteExtendedDowntimeFromAnalysis(e) {
        e.stopPropagation();
        
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        const machine = btn.dataset.machine;

        if (!confirm(`Tem certeza que deseja excluir a parada da máquina ${machine}?`)) {
            return;
        }

        try {
            btn.disabled = true;
            await db.collection('extended_downtime_logs').doc(recordId).delete();
            
            // Recarregar análise
            const { startDate, endDate, machine } = currentAnalysisFilters;
            await loadExtendedDowntimeAnalysis(startDate, endDate, machine);

        } catch (error) {
            console.error('[EXTENDED-DOWNTIME] Erro ao excluir:', error);
            alert('Erro ao excluir: ' + error.message);
            btn.disabled = false;
        }
    }

    // Função para carregar análise comparativa
    async function loadComparativeAnalysis() {
        console.log('[TRACE][loadComparativeAnalysis] View comparativa não implementada no HTML');
        // A view comparativa ainda não foi implementada no HTML
        // TODO: Adicionar canvas comparison-chart e interface no index.html para habilitar esta funcionalidade
    }

    // Função para carregar análise preditiva
    async function loadPredictiveAnalysis() {
        console.log('[PREDICTIVE] Carregando view de analytics preditivos');
        
        try {
            // Inicializar sistema de analytics preditivos se não estiver ativo
            if (!window.predictiveAnalytics || !window.predictiveAnalytics.predictions) {
                console.log('[PREDICTIVE] Inicializando sistema preditivo...');
                await window.predictiveAnalytics.initialize();
            } else {
                // Se já estiver inicializado, apenas atualizar as previsões
                console.log('[PREDICTIVE] Atualizando previsões existentes...');
                await window.predictiveAnalytics.generatePredictions();
            }

            // Inicializar KPIs avançados se não estiver ativo
            if (!window.advancedKPIs || !window.advancedKPIs.cache.lastUpdate) {
                console.log('[ADVANCED-KPIs] Inicializando KPIs avançados...');
                await window.advancedKPIs.initialize();
            } else {
                // Se já estiver inicializado, apenas atualizar se necessário
                const lastUpdate = window.advancedKPIs.cache.lastUpdate;
                const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                
                if (hoursSinceUpdate > 1) { // Atualizar se foi há mais de 1 hora
                    console.log('[ADVANCED-KPIs] Atualizando KPIs avançados...');
                    await window.advancedKPIs.calculateAllKPIs();
                }
            }

            // Inicializar análise Pareto automática
            if (!window.autoParetoAnalysis || !window.autoParetoAnalysis.analytics.lastUpdate) {
                console.log('[AUTO-PARETO] Inicializando análise Pareto automática...');
                await window.autoParetoAnalysis.initialize();
            } else {
                // Se já estiver inicializado, verificar se precisa atualizar
                const lastUpdate = window.autoParetoAnalysis.analytics.lastUpdate;
                const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                
                if (hoursSinceUpdate > 2) { // Atualizar se foi há mais de 2 horas
                    console.log('[AUTO-PARETO] Atualizando análise Pareto...');
                    await window.autoParetoAnalysis.performCompleteAnalysis();
                }
            }

            // Inicializar sistema SPC automaticamente
            if (window.spcController) {
                if (!window.spcController.spcData.lastUpdate) {
                    console.log('[SPC] Inicializando sistema SPC...');
                    await window.spcController.initialize();
                } else {
                    // Verificar se precisa atualizar
                    const lastUpdate = window.spcController.spcData.lastUpdate;
                    const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                    
                    if (hoursSinceUpdate > 1) { // Atualizar se foi há mais de 1 hora
                        console.log('[SPC] Atualizando sistema SPC...');
                        await window.spcController.initialize();
                    }
                }
            } else {
                console.warn('[SPC] SPCController não disponível');
            }

            // Inicializar sistema de rastreabilidade total
            if (!window.traceabilitySystem || !window.traceabilitySystem.traceabilityData.lastUpdate) {
                console.log('[TRACEABILITY] Inicializando sistema de rastreabilidade total...');
                await window.traceabilitySystem.initialize();
            } else {
                // Se já estiver inicializado, verificar se precisa atualizar
                const lastUpdate = window.traceabilitySystem.traceabilityData.lastUpdate;
                const hoursSinceUpdate = (new Date() - lastUpdate) / (1000 * 60 * 60);
                
                if (hoursSinceUpdate > 6) { // Atualizar se foi há mais de 6 horas
                    console.log('[TRACEABILITY] Atualizando dados de rastreabilidade...');
                    await window.traceabilitySystem.loadTraceabilityData();
                    window.traceabilitySystem.buildGenealogyTree();
                    window.traceabilitySystem.updateTraceabilityInterface();
                }
            }
            
            console.log('[PREDICTIVE] Todos os sistemas avançados carregados com sucesso');
            
        } catch (error) {
            console.error('[PREDICTIVE] Erro ao carregar analytics preditivos:', error);
            
            // Mostrar interface de erro
            const alertsContainer = document.getElementById('proactive-alerts');
            if (alertsContainer) {
                alertsContainer.innerHTML = `
                    <div class="text-center text-red-500 py-8">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto text-red-400 mb-2"></i>
                        <p class="font-semibold">Erro ao carregar sistema preditivo</p>
                        <p class="text-sm text-gray-600 mt-1">${error.message}</p>
                    </div>
                `;
            }
        }
    }

    // Função para gerar comparação
    async function generateComparison() {
        const comparisonType = document.getElementById('comparison-type').value;
        const metric = document.getElementById('comparison-metric').value;
        const { startDate, endDate } = currentAnalysisFilters;
        
        let comparisonData = [];
        
        switch (comparisonType) {
            case 'machines':
                comparisonData = await compareByMachines(metric, startDate, endDate);
                break;
            case 'shifts':
                comparisonData = await compareByShifts(metric, startDate, endDate);
                break;
            case 'periods':
                comparisonData = await compareByPeriods(metric);
                break;
            case 'products':
                comparisonData = await compareByProducts(metric, startDate, endDate);
                break;
        }

        // Gerar gráfico de comparação
        await generateComparisonChart(comparisonData, metric);
        generateComparisonRanking(comparisonData);
        generateComparisonStats(comparisonData);
    }

    // Funções auxiliares para análise
    
    // Função de diagnóstico para verificar dados no Firestore
    async function diagnosticFirestoreData() {
        console.log('📍 [DIAGNOSTIC] Iniciando diagnóstico de dados do Firestore...');
        
        try {
            // Verificar production_entries
            const prodSnapshot = await db.collection('production_entries').limit(5).get();
            console.log('📍 [DIAGNOSTIC] production_entries:', {
                size: prodSnapshot.size,
                samples: prodSnapshot.docs.map(d => ({
                    id: d.id,
                    data: d.data().data,
                    machine: d.data().machine,
                    produzido: d.data().produzido,
                    turno: d.data().turno
                }))
            });
            
            // Verificar downtime_entries
            const downtimeSnapshot = await db.collection('downtime_entries').limit(5).get();
            console.log('📍 [DIAGNOSTIC] downtime_entries:', {
                size: downtimeSnapshot.size,
                samples: downtimeSnapshot.docs.map(d => ({
                    id: d.id,
                    date: d.data().date,
                    machine: d.data().machine,
                    duration: d.data().duration,
                    reason: d.data().reason
                }))
            });
            
            // Verificar planning
            const planningSnapshot = await db.collection('planning').limit(5).get();
            console.log('📍 [DIAGNOSTIC] planning:', {
                size: planningSnapshot.size,
                samples: planningSnapshot.docs.map(d => ({
                    id: d.id,
                    date: d.data().date,
                    machine: d.data().machine,
                    mp: d.data().mp
                }))
            });
            
        } catch (error) {
            console.error('📍 [DIAGNOSTIC] Erro ao buscar dados:', error);
        }
    }

    // Função para testar todos os gráficos
    async function testAllCharts() {
        console.log('🧪 [TEST] Iniciando teste de todos os gráficos...');
        
        const chartTests = [
            { name: 'OEE Distribution', canvasId: 'oee-distribution-chart', view: 'overview' },
            { name: 'Hourly Production', canvasId: 'hourly-production-chart', view: 'production' },
            { name: 'Analysis Hourly Production', canvasId: 'analysis-hourly-production-chart', view: 'analysis-production' },
            { name: 'Shift Production', canvasId: 'shift-production-chart', view: 'production' },
            { name: 'Machine Production Timeline', canvasId: 'analysis-machine-production-timeline', view: 'analysis-production' },
            { name: 'OEE Components Timeline', canvasId: 'oee-components-timeline', view: 'efficiency' },
            { name: 'Losses Pareto', canvasId: 'losses-pareto-chart', view: 'losses' },
            { name: 'Losses by Machine', canvasId: 'losses-by-machine-chart', view: 'losses' },
            { name: 'Losses by Material', canvasId: 'losses-by-material-chart', view: 'losses' },
            { name: 'Losses Trend', canvasId: 'losses-trend-chart', view: 'losses' },
            { name: 'Downtime Reasons', canvasId: 'downtime-reasons-chart', view: 'downtime' },
            { name: 'Downtime by Machine', canvasId: 'downtime-by-machine-chart', view: 'downtime' },
            { name: 'Downtime Timeline', canvasId: 'downtime-timeline-chart', view: 'downtime' }
            // Nota: comparison-chart removido pois a view comparative não foi implementada no HTML
        ];
        
        for (const test of chartTests) {
            const canvas = document.getElementById(test.canvasId);
            const chart = canvas ? Chart.getChart(canvas) : null;
            
            const status = {
                canvasExists: !!canvas,
                chartCreated: !!chart,
                hasData: chart?.data?.datasets?.length > 0 || false,
                view: test.view
            };
            
            console.log(`🧪 [TEST] ${test.name}:`, status);
            
            if (!canvas) {
                console.error(`❌ [TEST] Canvas "${test.canvasId}" não encontrado no DOM`);
            } else if (!chart) {
                console.warn(`⚠️ [TEST] Gráfico "${test.name}" não inicializado (canvas existe mas sem Chart.js)`);
            } else if (!status.hasData) {
                console.warn(`⚠️ [TEST] Gráfico "${test.name}" sem dados`);
            } else {
                console.log(`✅ [TEST] Gráfico "${test.name}" OK`);
            }
        }
        
        console.log('🧪 [TEST] Teste completo');
    }
    
    // Helper para destruir gráficos Chart.js existentes
    function destroyChart(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (canvas) {
            const existingChart = Chart.getChart(canvas);
            if (existingChart) {
                existingChart.destroy();
            }
        }
    }
    
    // Helper para mostrar mensagem quando não há dados no gráfico
    function showNoDataMessage(canvasId, message = 'Nenhum dado disponível para o período selecionado') {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        // Limpar canvas
        const context = canvas.getContext('2d');
        if (context) {
            context.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // Adicionar mensagem
        const container = canvas.parentElement;
        if (container) {
            let messageDiv = container.querySelector('.no-data-message');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.className = 'no-data-message absolute inset-0 flex items-center justify-center';
                container.style.position = 'relative';
                container.appendChild(messageDiv);
            }
            messageDiv.innerHTML = `<p class="text-gray-500 text-sm">${message}</p>`;
        }
    }
    
    // Helper para remover mensagem de "sem dados"
    function clearNoDataMessage(canvasId) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const container = canvas.parentElement;
        if (container) {
            const messageDiv = container.querySelector('.no-data-message');
            if (messageDiv) messageDiv.remove();
        }
    }

    // Configurações responsivas globais para gráficos
    function getResponsiveChartOptions() {
        const isMobile = window.innerWidth < 768;
        const isTablet = window.innerWidth < 1024;
        
        return {
            responsive: true,
            maintainAspectRatio: false,
            devicePixelRatio: window.devicePixelRatio || 1,
            scales: {
                x: {
                    grid: {
                        display: !isMobile,
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: isMobile ? 8 : isTablet ? 10 : 12
                        },
                        maxRotation: isMobile ? 45 : 0,
                        minRotation: 0,
                        autoSkip: true,
                        maxTicksLimit: isMobile ? 8 : isTablet ? 12 : 16
                    }
                },
                y: {
                    grid: {
                        color: 'rgba(0, 0, 0, 0.05)'
                    },
                    ticks: {
                        font: {
                            size: isMobile ? 9 : isTablet ? 11 : 12
                        },
                        maxTicksLimit: isMobile ? 6 : 8
                    }
                }
            },
            plugins: {
                legend: {
                    display: true,
                    position: isMobile ? 'bottom' : 'top',
                    labels: {
                        font: {
                            size: isMobile ? 10 : isTablet ? 11 : 12
                        },
                        usePointStyle: true,
                        padding: isMobile ? 10 : 20,
                        boxWidth: isMobile ? 8 : 12
                    }
                },
                tooltip: {
                    backgroundColor: 'rgba(0, 0, 0, 0.8)',
                    titleColor: 'white',
                    bodyColor: 'white',
                    borderColor: 'rgba(255, 255, 255, 0.1)',
                    borderWidth: 1,
                    titleFont: {
                        size: isMobile ? 11 : 12
                    },
                    bodyFont: {
                        size: isMobile ? 10 : 11
                    },
                    padding: isMobile ? 6 : 10
                }
            },
            layout: {
                padding: {
                    top: isMobile ? 5 : 10,
                    right: isMobile ? 5 : 10,
                    bottom: isMobile ? 5 : 10,
                    left: isMobile ? 5 : 10
                }
            }
        };
    }

    // Função para mesclar configurações específicas com as responsivas
    function mergeChartOptions(specificOptions = {}) {
        const baseOptions = getResponsiveChartOptions();
        
        // Função helper para merge profundo
        function deepMerge(target, source) {
            for (const key in source) {
                if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                    target[key] = target[key] || {};
                    deepMerge(target[key], source[key]);
                } else {
                    target[key] = source[key];
                }
            }
            return target;
        }
        
        return deepMerge(JSON.parse(JSON.stringify(baseOptions)), specificOptions);
    }

    async function getFilteredData(collection, startDate, endDate, machine = 'all', shift = 'all') {
        try {
            console.log('[TRACE][getFilteredData] called', { collection, startDate, endDate, machine, shift });
            
            const normalizeShift = (value) => {
                if (value === undefined || value === null) return null;
                if (typeof value === 'number' && Number.isFinite(value)) return value;
                const match = String(value).match(/(\d+)/);
                return match ? Number(match[1]) : null;
            };
            // FIX: map cada tipo analítico para a coleção real no Firestore e normalizar os campos esperados pela aba de análise
            const collectionConfig = {
                production: {
                    collection: 'production_entries',
                    dateField: 'data',
                    mapper: (id, raw) => {
                        const mappedDate = raw.data || raw.date || '';
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                        const resolvedDateTime = resolveProductionDateTime(raw);
                        const timestamp = resolvedDateTime || normalizeToDate(primaryTimestamp);
                        const timeHint = raw.horaInformada || raw.hora || raw.hour || raw.time || null;
                        const workDay = getWorkDayFromTimestamp(resolvedDateTime || primaryTimestamp) || getWorkDay(mappedDate, timeHint);
                        const isoDateTime = timestamp ? new Date(timestamp.getTime() - timestamp.getTimezoneOffset() * 60000).toISOString() : null;
                        
                        // Resolver produto através de múltiplas fontes
                        const product = raw.product || raw.produto || raw.product_cod || raw.cod_produto || raw.productName || raw.mp || '';
                        
                        return {
                            id,
                            date: mappedDate,
                            machine: normalizeMachineId(raw.machine || raw.machineRef || raw.machine_id || null),
                            quantity: Number(raw.produzido ?? raw.quantity ?? 0) || 0,
                            shift: normalizeShift(raw.turno ?? raw.shift),
                            datetime: isoDateTime,
                            mp: raw.mp || '',
                            product: product,
                            workDay: workDay || mappedDate,
                            raw
                        };
                    }
                },
                losses: {
                    collection: 'production_entries',
                    dateField: 'data',
                    mapper: (id, raw) => {
                        const dateValue = raw.data || raw.date || '';
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                        const resolvedDateTime = resolveProductionDateTime(raw);
                        const timeHint = raw.horaInformada || raw.hora || raw.hour || raw.time || null;
                        const workDay = getWorkDayFromTimestamp(resolvedDateTime || primaryTimestamp) || getWorkDay(dateValue, timeHint);
                        const rawRefugoKg = Number(raw.refugo_kg ?? raw.refugoKg ?? raw.scrap_kg ?? raw.scrapKg ?? 0) || 0;
                        const rawRefugoPcs = Number(raw.refugo_qty ?? raw.refugo_qtd ?? raw.scrap_qty ?? raw.scrap_qtd ?? 0) || 0;
                        const pieceWeight = Number(raw.piece_weight ?? raw.peso_unitario ?? raw.pesoUnitario ?? raw.peso ?? 0) || 0;
                        const resolvedPcs = rawRefugoPcs > 0
                            ? rawRefugoPcs
                            : (rawRefugoKg > 0 && pieceWeight > 0 ? Math.round((rawRefugoKg * 1000) / pieceWeight) : 0);
                        const resolvedKg = rawRefugoKg > 0
                            ? rawRefugoKg
                            : (pieceWeight > 0 && resolvedPcs > 0 ? (resolvedPcs * pieceWeight) / 1000 : 0);
                        
                        // Resolver produto através de múltiplas fontes
                        const product = raw.product || raw.produto || raw.product_cod || raw.cod_produto || raw.productName || '';
                        
                        return {
                            id,
                            date: dateValue,
                            machine: normalizeMachineId(raw.machine || raw.machineRef || raw.machine_id || null),
                            quantity: resolvedPcs,
                            shift: normalizeShift(raw.turno ?? raw.shift),
                            reason: raw.perdas || raw.reason || '',
                            mp: raw.mp || '',
                            mp_type: raw.mp_type || raw.mp || '',
                            product: product,
                            workDay: workDay || dateValue,
                            scrapPcs: resolvedPcs,
                            scrapKg: resolvedKg,
                            pieceWeight,
                            raw
                        };
                    }
                },
                downtime: {
                    collection: 'downtime_entries',
                    dateField: 'date',
                    mapper: (id, raw) => {
                        const startMinutes = raw.startTime ? parseTimeToMinutes(raw.date, raw.startTime) : null;
                        const endMinutes = raw.endTime ? parseTimeToMinutes(raw.date, raw.endTime) : null;
                        let duration = Number(raw.duration ?? raw.duration_min ?? raw.duracao_min ?? 0) || 0;
                        if (!duration && startMinutes !== null && endMinutes !== null) {
                            duration = Math.max(0, endMinutes - startMinutes);
                        }
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                                const timeHint = raw.startTime || raw.endTime || null;
                                // Preferir calcular o workDay a partir da data/horário do próprio registro
                                // (evita classificar pelo createdAt quando o lançamento é retroativo)
                                const workDay = getWorkDay(raw.date || '', timeHint) || getWorkDayFromTimestamp(primaryTimestamp);
                        let mappedShift = normalizeShift(raw.shift ?? raw.turno);
                        if (!mappedShift) {
                            mappedShift = inferShiftFromSegment(raw.date || '', raw.startTime || '', raw.endTime || '');
                        }
                        return {
                            id,
                            date: raw.date || '',
                            machine: normalizeMachineId(raw.machine || null),
                            duration,
                            reason: raw.reason || '',
                            shift: mappedShift,
                            startTime: raw.startTime || '',
                            endTime: raw.endTime || '',
                            workDay: workDay || raw.date || '',
                            raw
                        };
                    }
                },
                plan: {
                    collection: 'planning',
                    dateField: 'date',
                    mapper: (id, raw) => ({
                        id,
                        date: raw.date || '',
                        machine: normalizeMachineId(raw.machine || null),
                        quantity: Number(raw.planned_quantity ?? raw.quantity ?? 0) || 0,
                        shift: normalizeShift(raw.shift ?? raw.turno),
                        product: raw.product || '',
                        mp: raw.mp || '',
                        workDay: raw.date || '',
                        raw
                    })
                },
                rework: {
                    collection: 'rework_entries',
                    dateField: 'data',
                    mapper: (id, raw) => {
                        const dateValue = raw.data || '';
                        const primaryTimestamp = raw.timestamp || raw.createdAt || raw.updatedAt;
                        const workDay = getWorkDayFromTimestamp(primaryTimestamp) || dateValue;
                        return {
                            id,
                            date: dateValue,
                            machine: normalizeMachineId(raw.machine || null),
                            quantity: Number(raw.quantidade ?? raw.quantity ?? 0) || 0,
                            shift: normalizeShift(raw.turno ?? raw.shift),
                            reason: raw.motivo || raw.reason || '',
                            mp: raw.mp || '',
                            workDay: workDay || dateValue,
                            raw
                        };
                    }
                }
            };

            const config = collectionConfig[collection];
            if (!config) {
                console.warn(`Coleção de análise desconhecida: ${collection}`);
                return [];
            }

            if (!startDate || !endDate) {
                console.warn('[TRACE][getFilteredData] datas inválidas fornecidas', { startDate, endDate });
                return [];
            }

            let query = db.collection(config.collection);
            
            // Buscar um período amplo (do dia anterior ao dia posterior)
            // para capturar dados do turno 3 (23h-7h)
            const startObj = new Date(startDate);
            startObj.setDate(startObj.getDate() - 1);
            const queryStartDate = Number.isNaN(startObj.getTime()) ? null : startObj.toISOString().split('T')[0];
            
            const endObj = new Date(endDate);
            endObj.setDate(endObj.getDate() + 1);
            const queryEndDate = Number.isNaN(endObj.getTime()) ? null : endObj.toISOString().split('T')[0];
            
            console.log('[TRACE][getFilteredData] query setup with expanded date range', { 
                collection: config.collection,
                dateField: config.dateField,
                userStartDate: startDate,
                userEndDate: endDate,
                queryStartDate,
                queryEndDate,
                machine,
                shift
            });
            
            if (queryStartDate && queryEndDate) {
                query = query.where(config.dateField, '>=', queryStartDate).where(config.dateField, '<=', queryEndDate);
            }

            let snapshot = await query.get();

            if (snapshot.empty && queryStartDate && queryEndDate) {
                console.warn('[TRACE][getFilteredData] snapshot vazio com filtro de datas, reconsultando sem faixa para aplicar filtro no cliente');
                snapshot = await db.collection(config.collection).get();
            }
            console.log('[TRACE][getFilteredData] raw snapshot', { 
                collection: config.collection,
                size: snapshot.size,
                empty: snapshot.empty
            });
            
            let data = snapshot.docs.map(doc => config.mapper(doc.id, doc.data()));

            const startWorkDay = startDate || null;
            const endWorkDay = endDate || null;

            data = data.filter(item => {
                const workDay = item.workDay || item.date;
                if (!workDay) return false;
                const meetsStart = !startWorkDay || workDay >= startWorkDay;
                const meetsEnd = !endWorkDay || workDay <= endWorkDay;
                return meetsStart && meetsEnd;
            });

            if (collection === 'losses') {
                data = data.filter(item => {
                    if (item.quantity > 0) return true;
                    const rawWeight = Number(item.raw?.refugo_kg ?? item.raw?.weight ?? 0) || 0;
                    return rawWeight > 0;
                });
            }

            if (machine !== 'all') {
                const target = normalizeMachineId(machine);
                data = data.filter(item => normalizeMachineId(item.machine) === target);
            }

            if (shift !== 'all') {
                data = data.filter(item => Number(item.shift || 0) === Number(shift));
            }

            console.log('[TRACE][getFilteredData] returning data', {
                collection,
                count: data.length,
                sample: data.slice(0, 3)
            });
            return data;
        } catch (error) {
            console.error('Erro ao buscar dados filtrados:', error);
            return [];
        }
    }

    function parseTimeToMinutes(dateStr, timeStr) {
        // FIX: utilitário para converter HH:MM em minutos absolutos para cálculos de duração
        if (!dateStr || !timeStr) return null;
        const [hours, minutes] = timeStr.split(':').map(Number);
        if (Number.isNaN(hours) || Number.isNaN(minutes)) return null;
        const date = new Date(`${dateStr}T${timeStr}:00`);
        return Math.floor(date.getTime() / 60000);
    }

    function combineDateAndTime(dateStr, timeStr) {
        if (!dateStr || !timeStr) return null;
        const [year, month, day] = dateStr.split('-').map(Number);
        const [hour, minute] = timeStr.split(':').map(Number);
        if ([year, month, day, hour, minute].some(value => Number.isNaN(value))) {
            return null;
        }
        return new Date(year, (month || 1) - 1, day || 1, hour || 0, minute || 0, 0, 0);
    }

    // Helpers para lidar com paradas multi-dia
    function pad2(n) { return String(n).padStart(2, '0'); }
    function formatDateYMD(d) {
        return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
    }
    function formatTimeHM(d) { return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`; }

    // ========================================
    // SISTEMA ROBUSTO DE PARADAS - V2.0
    // ========================================
    
    /**
     * Definição dos turnos (configurável)
     * Turno 1: 07:00 - 14:59
     * Turno 2: 15:00 - 23:19
     * Turno 3: 23:20 - 06:59 (cruza meia-noite)
     */
    const SHIFT_DEFINITIONS = [
        { shift: 1, startHour: 7, startMin: 0, endHour: 14, endMin: 59 },
        { shift: 2, startHour: 15, startMin: 0, endHour: 23, endMin: 19 },
        { shift: 3, startHour: 23, startMin: 20, endHour: 6, endMin: 59, crossesMidnight: true }
    ];

    /**
     * Determina o turno de uma data/hora específica
     */
    function getShiftForDateTime(dateTime) {
        if (!(dateTime instanceof Date) || isNaN(dateTime.getTime())) return null;
        
        const hour = dateTime.getHours();
        const min = dateTime.getMinutes();
        const totalMinutes = hour * 60 + min;
        
        // Turno 1: 07:00 - 14:59 (420 - 899 minutos)
        if (totalMinutes >= 420 && totalMinutes < 900) return 1;
        // Turno 2: 15:00 - 23:19 (900 - 1399 minutos)
        if (totalMinutes >= 900 && totalMinutes < 1400) return 2;
        // Turno 3: 23:20 - 06:59 (1400 - 1439 ou 0 - 419 minutos)
        return 3;
    }

    /**
     * Retorna o início do turno para uma data e turno específicos
     */
    function getShiftStart(date, shift) {
        const d = new Date(date);
        switch (shift) {
            case 1: d.setHours(7, 0, 0, 0); break;
            case 2: d.setHours(15, 0, 0, 0); break;
            case 3: d.setHours(23, 20, 0, 0); break;
            default: d.setHours(7, 0, 0, 0);
        }
        return d;
    }

    /**
     * Retorna o fim do turno para uma data e turno específicos
     */
    function getShiftEnd(date, shift) {
        const d = new Date(date);
        switch (shift) {
            case 1: d.setHours(14, 59, 59, 999); break;
            case 2: d.setHours(23, 19, 59, 999); break;
            case 3: 
                // Turno 3 vai até 06:59 do dia seguinte
                d.setDate(d.getDate() + 1);
                d.setHours(6, 59, 59, 999); 
                break;
            default: d.setHours(14, 59, 59, 999);
        }
        return d;
    }

    /**
     * Calcula a data de produção (workday) para uma data/hora
     * O dia de produção é definido pelo turno 1 (começa às 07:00)
     */
    function getWorkdayForDateTime(dateTime) {
        if (!(dateTime instanceof Date) || isNaN(dateTime.getTime())) {
            return formatDateYMD(new Date());
        }
        
        const hour = dateTime.getHours();
        // Se for entre 00:00 e 06:59, pertence ao dia anterior de produção
        if (hour < 7) {
            const prevDay = new Date(dateTime);
            prevDay.setDate(prevDay.getDate() - 1);
            return formatDateYMD(prevDay);
        }
        return formatDateYMD(dateTime);
    }

    /**
     * Quebra uma parada longa em segmentos por TURNO (não apenas por dia)
     * Isso garante que cada segmento tenha o turno correto associado
     */
    function splitDowntimeIntoShiftSegments(startDateStr, startTimeStr, endDateStr, endTimeStr) {
        const segments = [];
        
        // Validação e parsing das datas
        const startDateTime = parseDateTime(startDateStr, startTimeStr);
        const endDateTime = parseDateTime(endDateStr, endTimeStr);
        
        if (!startDateTime || !endDateTime) {
            console.error('[DOWNTIME] Datas inválidas:', { startDateStr, startTimeStr, endDateStr, endTimeStr });
            return segments;
        }
        
        if (endDateTime <= startDateTime) {
            console.error('[DOWNTIME] Data fim anterior ou igual à data início');
            return segments;
        }
        
        let cursor = new Date(startDateTime);
        let safetyCounter = 0;
        const MAX_ITERATIONS = 1000; // Proteção contra loop infinito
        
        while (cursor < endDateTime && safetyCounter < MAX_ITERATIONS) {
            safetyCounter++;
            
            const currentShift = getShiftForDateTime(cursor);
            const shiftEndTime = getShiftEnd(cursor, currentShift);
            
            // O segmento termina no menor entre: fim do turno ou fim da parada
            const segmentEnd = new Date(Math.min(shiftEndTime.getTime(), endDateTime.getTime()));
            
            // Calcular duração em minutos
            const durationMs = segmentEnd.getTime() - cursor.getTime();

            if (durationMs <= 0) {
                console.warn('[DOWNTIME] Segmento inválido detectado. Forçando avanço mínimo.', {
                    cursor: cursor.toISOString(),
                    shift: currentShift,
                    shiftEnd: shiftEndTime.toISOString()
                });
                cursor = new Date(cursor.getTime() + 60000);
                continue;
            }

            const durationMin = Math.max(1, Math.round(durationMs / 60000));
            
            // Determinar a data de trabalho (workday) do segmento
            const workday = getWorkdayForDateTime(cursor);
            
            segments.push({
                date: workday,
                startTime: formatTimeHM(cursor),
                endTime: formatTimeHM(segmentEnd),
                duration: durationMin,
                shift: currentShift,
                // Metadados adicionais para debug
                _segmentStart: cursor.toISOString(),
                _segmentEnd: segmentEnd.toISOString()
            });
            
            // Avançar cursor para o próximo ponto (1 minuto após o fim do segmento)
            cursor = new Date(segmentEnd.getTime() + 60000);
            
            // Se o cursor passou do fim, parar
            if (cursor >= endDateTime) break;
        }
        
        if (safetyCounter >= MAX_ITERATIONS) {
            console.error('[DOWNTIME] Loop de segmentação excedeu limite de segurança');
        }
        
        console.log('[DOWNTIME] Segmentos gerados:', segments.length, segments);
        return segments;
    }

    /**
     * Consolida segmentos de parada em eventos únicos.
     * Segmentos com o mesmo originalStartTimestamp são agrupados.
     * Segmentos sem metadados são agrupados por proximidade (mesma máquina, mesmo motivo, horários consecutivos).
     */
    function consolidateDowntimeEvents(segments = []) {
        if (!Array.isArray(segments) || segments.length === 0) {
            return [];
        }

        const MAX_DURATION_MIN = 24 * 60; // 24h máximo por evento
        const eventsMap = new Map();
        
        // Primeiro passo: ordenar segmentos por máquina, data e hora de início
        const sortedSegments = [...segments].sort((a, b) => {
            const machineA = a.machine || '';
            const machineB = b.machine || '';
            if (machineA !== machineB) return machineA.localeCompare(machineB);
            
            const dateA = a.date || a.workDay || '';
            const dateB = b.date || b.workDay || '';
            if (dateA !== dateB) return dateA.localeCompare(dateB);
            
            const timeA = a.startTime || '00:00';
            const timeB = b.startTime || '00:00';
            return timeA.localeCompare(timeB);
        });

        sortedSegments.forEach((segment, index) => {
            if (!segment) return;

            const raw = segment.raw || {};
            const baseStart = raw.originalStartTimestamp || null;
            const baseEnd = raw.originalEndTimestamp || null;
            const machineId = segment.machine || 'unknown-machine';
            const reason = (segment.reason || raw.reason || '').trim().toLowerCase();
            
            let key;
            let isGrouped = false;
            
            // Estratégia 1: Se tem originalStartTimestamp, agrupa pelo evento pai
            if (baseStart) {
                key = `parent|${machineId}|${baseStart}|${baseEnd || ''}`;
                isGrouped = true;
            }
            // Estratégia 2: Se tem totalSegments/segmentIndex, faz parte de um evento segmentado
            else if (raw.totalSegments && raw.totalSegments > 1) {
                // Usar originalStartTimestamp do parent ou criar chave baseada em metadados
                const parentStart = raw.originalStartTimestamp || raw.startTimestamp || `${segment.date}T${segment.startTime || '00:00'}`;
                key = `segmented|${machineId}|${parentStart}`;
                isGrouped = true;
            }
            // Estratégia 3: Agrupar por proximidade temporal (mesmo motivo, mesmo dia, horários próximos)
            else {
                // Verificar se este segmento pode ser agrupado com algum evento existente
                const segmentDate = segment.date || segment.workDay || '';
                const segmentStartTime = segment.startTime || '';
                const segmentEndTime = segment.endTime || '';
                
                // Procurar evento existente que possa agrupar este segmento
                let matchingKey = null;
                for (const [existingKey, existingEvent] of eventsMap.entries()) {
                    if (!existingKey.startsWith('proximity|')) continue;
                    if (existingEvent.machine !== machineId) continue;
                    if (existingEvent.reason.toLowerCase() !== reason) continue;
                    
                    // Verificar se é do mesmo dia
                    const eventDate = existingEvent.workDay || existingEvent.date || '';
                    if (eventDate !== segmentDate) continue;
                    
                    // Verificar proximidade temporal (se o fim do evento existente está próximo do início deste)
                    const lastSegment = existingEvent.segments[existingEvent.segments.length - 1];
                    const lastEndTime = lastSegment?.endTime || '';
                    
                    if (lastEndTime && segmentStartTime) {
                        // Se o início deste segmento é igual ou próximo ao fim do último
                        if (segmentStartTime <= lastEndTime || isTimeClose(lastEndTime, segmentStartTime, 5)) {
                            matchingKey = existingKey;
                            break;
                        }
                    }
                }
                
                if (matchingKey) {
                    key = matchingKey;
                    isGrouped = true;
                } else {
                    // Criar novo grupo de proximidade
                    key = `proximity|${machineId}|${segmentDate}|${segmentStartTime}|${reason.substring(0, 20)}`;
                    isGrouped = false;
                }
            }

            let event = eventsMap.get(key);
            if (!event) {
                const startDateTime = baseStart ? new Date(baseStart) : combineDateAndTime(segment.date, segment.startTime);
                const endDateTime = baseEnd ? new Date(baseEnd) : combineDateAndTime(segment.date, segment.endTime);

                event = {
                    id: key,
                    machine: machineId,
                    reason: segment.reason || raw.reason || 'Não informado',
                    duration: 0,
                    startDateTime: startDateTime,
                    endDateTime: endDateTime,
                    workDay: segment.workDay || segment.date || '',
                    segments: [],
                    metadata: raw,
                    isGrouped: isGrouped,
                    date: segment.date || ''
                };
                eventsMap.set(key, event);
            }

            // Calcular duração do segmento
            const segmentDuration = Math.min(Number(segment.duration) || 0, MAX_DURATION_MIN);
            
            // Verificar se este segmento é duplicata (mesmo horário já adicionado)
            const isDuplicate = event.segments.some(s => 
                s.date === segment.date && 
                s.startTime === segment.startTime && 
                s.endTime === segment.endTime
            );
            
            if (!isDuplicate) {
                event.duration += segmentDuration;
                event.segments.push(segment);

                const segStart = combineDateAndTime(segment.date, segment.startTime);
                const segEnd = combineDateAndTime(segment.date, segment.endTime);

                if (segStart && (!event.startDateTime || segStart < event.startDateTime)) {
                    event.startDateTime = segStart;
                }
                if (segEnd && (!event.endDateTime || segEnd > event.endDateTime)) {
                    event.endDateTime = segEnd;
                }

                if (segment.workDay && (!event.workDay || segment.workDay < event.workDay)) {
                    event.workDay = segment.workDay;
                }
            }
        });

        return Array.from(eventsMap.values()).map(event => {
            // Aplicar cap final de duração para segurança
            const cappedDuration = Math.min(event.duration, MAX_DURATION_MIN);
            
            const startDate = event.startDateTime ? formatDateYMD(event.startDateTime) : (event.segments[0]?.date || '');
            const endDate = event.endDateTime ? formatDateYMD(event.endDateTime) : (event.segments[event.segments.length - 1]?.date || '');
            const startTime = event.startDateTime ? formatTimeHM(event.startDateTime) : (event.segments[0]?.startTime || '');
            const endTime = event.endDateTime ? formatTimeHM(event.endDateTime) : (event.segments[event.segments.length - 1]?.endTime || '');

            return {
                id: event.id,
                machine: event.machine,
                reason: event.reason,
                duration: cappedDuration,
                date: startDate,
                workDay: event.workDay || startDate,
                startTime,
                endTime,
                startDateTime: event.startDateTime,
                endDateTime: event.endDateTime,
                shift: event.segments[0]?.shift || inferShiftFromSegment(event.workDay || startDate, startTime, endTime),
                segments: event.segments,
                segmentCount: event.segments.length,
                raw: event.metadata
            };
        });
    }
    
    /**
     * Verifica se dois horários estão próximos (dentro de N minutos)
     */
    function isTimeClose(time1, time2, toleranceMinutes = 5) {
        if (!time1 || !time2) return false;
        
        const toMinutes = (t) => {
            const parts = t.split(':');
            if (parts.length < 2) return null;
            const h = parseInt(parts[0], 10);
            const m = parseInt(parts[1], 10);
            if (isNaN(h) || isNaN(m)) return null;
            return h * 60 + m;
        };
        
        const min1 = toMinutes(time1);
        const min2 = toMinutes(time2);
        
        if (min1 === null || min2 === null) return false;
        
        return Math.abs(min2 - min1) <= toleranceMinutes;
    }

    /**
     * Função auxiliar para fazer parse de data + hora
     */
    function parseDateTime(dateStr, timeStr) {
        if (!dateStr || !timeStr) return null;
        
        try {
            // Normalizar formato de hora
            const normalizedTime = timeStr.length === 5 ? `${timeStr}:00` : timeStr;
            const dateTimeStr = `${dateStr}T${normalizedTime}`;
            const dt = new Date(dateTimeStr);
            
            if (isNaN(dt.getTime())) {
                console.warn('[DOWNTIME] Parse falhou para:', dateTimeStr);
                return null;
            }
            
            return dt;
        } catch (e) {
            console.error('[DOWNTIME] Erro ao fazer parse de data:', e);
            return null;
        }
    }

    /**
     * Versão legada mantida para compatibilidade - agora usa a nova função internamente
     */
    function splitDowntimeIntoDailySegments(startDateStr, startTimeStr, endDateStr, endTimeStr) {
        // Redireciona para a nova função que segmenta por turno
        return splitDowntimeIntoShiftSegments(startDateStr, startTimeStr, endDateStr, endTimeStr);
    }

    // Inferir turno a partir de um segmento (usa o ponto médio do intervalo)
    function inferShiftFromSegment(dateStr, startTimeStr, endTimeStr) {
        const toMinutes = (t) => {
            if (!t || !t.includes(':')) return null;
            const [h, m] = t.split(':').map(Number);
            if (Number.isNaN(h) || Number.isNaN(m)) return null;
            return h * 60 + m;
        };
        const startMin = toMinutes(startTimeStr);
        const endMin = toMinutes(endTimeStr);
        // Se não houver ambos, tenta classificar pelo horário disponível
        const refMin = (startMin !== null && endMin !== null)
            ? Math.floor((startMin + endMin) / 2)
            : (startMin !== null ? startMin : endMin);
        if (refMin === null) return null;

        // Turno 1: 07:00–14:59 | Turno 2: 15:00–23:19 | Turno 3: 23:20–06:59
        if (refMin >= (7 * 60) && refMin < (15 * 60)) return 1;
        if (refMin >= (15 * 60) && refMin < (23 * 60 + 20)) return 2;
        return 3; // 23:20–23:59 ou 00:00–06:59
    }

    function calculateHoursInPeriod(startDate, endDate) {
        if (!startDate || !endDate) return 0;

        const start = new Date(`${startDate}T07:00:00`);
        let end = new Date(`${endDate}T07:00:00`);

        if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
            return 0;
        }

        if (end <= start) {
            end = new Date(start);
            end.setDate(end.getDate() + 1);
        }

        const diffHours = (end - start) / (1000 * 60 * 60);
        return Math.max(24, diffHours);
    }

    function showAnalysisLoading(show) {
        const loading = document.getElementById('analysis-loading');
        const noData = document.getElementById('analysis-no-data');
        
        if (show) {
            loading.classList.remove('hidden');
            noData.classList.add('hidden');
        } else {
            loading.classList.add('hidden');
        }
    }

    function showAnalysisError() {
        const loading = document.getElementById('analysis-loading');
        const noData = document.getElementById('analysis-no-data');
        
        loading.classList.add('hidden');
        noData.classList.remove('hidden');
    }

    function showAnalysisNoData(message = 'Nenhum dado disponível para os filtros selecionados.') {
        const loading = document.getElementById('analysis-loading');
        const noData = document.getElementById('analysis-no-data');

        if (loading) {
            loading.classList.add('hidden');
        }

        if (noData) {
            noData.classList.remove('hidden');
            const messageElement = noData.querySelector('[data-analysis-empty-message]') || noData.querySelector('p');
            if (messageElement && message) {
                messageElement.textContent = message;
            }
        }
    }

    function loadAnalysisMachines() {
        // Inicializar lista de máquinas com os dados do banco de dados (normalizados)
        machines = machineDatabase.map(machine => ({ 
            id: normalizeMachineId(machine.id), 
            name: normalizeMachineId(machine.id), 
            model: machine.model 
        }));
        
        // Carregar lista de máquinas para o filtro
        const machineSelector = document.getElementById('analysis-machine');
        if (machineSelector) {
            machineSelector.innerHTML = '<option value="all">Todas as máquinas</option>';
            machines.forEach(machine => {
                const option = document.createElement('option');
                option.value = machine.id;
                option.textContent = `${machine.id} - ${machine.model}`;
                machineSelector.appendChild(option);
            });
        }

        // Carregar lista de máquinas para o formulário de ordens
        populateOrderMachineSelect();
    }

    function populateOrderMachineSelect() {
        const orderMachineSelect = document.getElementById('order-machine');
        if (orderMachineSelect) {
            // Manter a opção vazia no início
            const currentValue = orderMachineSelect.value;
            orderMachineSelect.innerHTML = '<option value="">Selecione uma máquina</option>';
            
            machineDatabase.forEach(machine => {
                const option = document.createElement('option');
                const mid = normalizeMachineId(machine.id);
                option.value = mid;
                option.textContent = `${mid} - ${machine.model}`;
                orderMachineSelect.appendChild(option);
            });

            // Restaurar valor anterior se existisse
            if (currentValue) {
                orderMachineSelect.value = currentValue;
            }
        }
    }

    // Função para atualizar o painel de informações da máquina na análise
    function updateAnalysisInfoPanel() {
        const machineSelector = document.getElementById('analysis-machine');
        const infoPanel = document.getElementById('analysis-info-panel');
        
        if (!machineSelector || !infoPanel) return;
        
        const selectedMachineId = machineSelector.value;
        
        // Se nenhuma máquina específica foi selecionada, ocultar o painel
        if (selectedMachineId === 'all') {
            infoPanel.classList.add('hidden');
            return;
        }
        
        // Encontrar a máquina
        const machineInfo = machineDatabase.find(m => normalizeMachineId(m.id) === selectedMachineId);
        
        if (machineInfo) {
            infoPanel.classList.remove('hidden');
            
            // Atualizar apenas nome e modelo da máquina
            document.getElementById('analysis-info-machine').textContent = selectedMachineId;
            document.getElementById('analysis-info-machine-model').textContent = machineInfo.model || '-';
        }
    }
    
    // Função para limpar informações do produto
    function clearAnalysisProductInfo() {
        // Função simplificada - não usada mais
    }
    
    // Função para atualizar o painel com informações do produto
    function updateAnalysisProductInfo(productCode, cycle, cavities, weight, productName) {
        const infoPanel = document.getElementById('analysis-info-panel');
        
        if (!infoPanel) return;
        
        if (productCode) {
            document.getElementById('analysis-info-product').textContent = productName || `Produto ${productCode}`;
            document.getElementById('analysis-info-product-code').textContent = `Código: ${productCode}`;
        }
        
        if (cycle) document.getElementById('analysis-info-cycle').textContent = cycle.toFixed(2);
        if (cavities) document.getElementById('analysis-info-cavities').textContent = cavities;
        if (weight) document.getElementById('analysis-info-weight').textContent = weight.toFixed(3);
    }

    function setAnalysisDefaultDates() {
    const today = getProductionDateString();
        const startDateInput = document.getElementById('analysis-start-date');
        const endDateInput = document.getElementById('analysis-end-date');
        
        if (startDateInput) startDateInput.value = today;
        if (endDateInput) endDateInput.value = today;
        
        // Configurar filtros padrão
        currentAnalysisFilters = {
            startDate: today,
            endDate: today,
            machine: 'all',
            shift: 'all'
        };
    }

    // Helper: atualiza a aba de análise se ela estiver ativa
    async function refreshAnalysisIfActive() {
        try {
            const currentPage = document.querySelector('.nav-btn.active')?.dataset.page;
            if (currentPage !== 'analise') return;

            const activeView = document.querySelector('.analysis-tab-btn.active')?.getAttribute('data-view') || 'overview';
            console.log('[TRACE][refreshAnalysisIfActive] refreshing analysis view', { activeView, filters: currentAnalysisFilters });
            await loadAnalysisData(activeView);
        } catch (err) {
            console.error('[TRACE][refreshAnalysisIfActive] erro ao refrescar análise', err);
        }
    }

    // Funções para geração de gráficos específicos da análise

    // Gráfico de distribuição OEE por máquina
    async function generateOEEDistributionChart(productionData, lossesData, downtimeData) {
        const ctx = document.getElementById('oee-distribution-chart');
        if (!ctx) return;

        destroyChart('oee-distribution-chart');

        const machines = [...new Set(productionData.map(item => item.machine))].filter(m => m);
        
        if (machines.length === 0) {
            showNoDataMessage('oee-distribution-chart');
            return;
        }
        
        clearNoDataMessage('oee-distribution-chart');
        
    const oeeByMachine = {};
    // Janela analisada em minutos (07:00 → 07:00)
    const periodMinutes = Math.max(1, calculateHoursInPeriod(currentAnalysisFilters.startDate, currentAnalysisFilters.endDate) * 60);

        machines.forEach(machine => {
            const machineProduction = productionData.filter(item => item.machine === machine);
            const machineLosses = lossesData.filter(item => item.machine === machine);
            const machineDowntime = downtimeData.filter(item => item.machine === machine);

            const totalProduced = machineProduction.reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);
            const totalLosses = machineLosses.reduce((sum, item) => sum + (Number(item.quantity) || 0), 0);
            const totalDowntime = machineDowntime.reduce((sum, item) => sum + (Number(item.duration) || 0), 0);

            // Componentes em fração [0..1]
            const availability = Math.max(0, 1 - (totalDowntime / periodMinutes));
            const quality = totalProduced > 0 ? Math.max(0, (totalProduced - totalLosses) / totalProduced) : 1;
            const performance = 0.85; // aproximação conservadora até termos cálculo por máquina

            const oeeFraction = Math.max(0, Math.min(1, availability * performance * quality));
            oeeByMachine[machine] = oeeFraction * 100; // guardar já em %
        });

        const labels = Object.keys(oeeByMachine);
        const values = Object.values(oeeByMachine).map(value => Number((value || 0).toFixed(1)));

        renderModernDonutChart({
            canvasId: 'oee-distribution-chart',
            labels,
            data: values,
            colors: ['#10B981', '#3B82F6', '#F97316', '#8B5CF6', '#F59E0B', '#EC4899'],
            datasetLabel: 'OEE %',
            tooltipFormatter: (context) => `${context.label}: ${Number(context.parsed || 0).toFixed(1)}%`
        });
    }

    // Geração do ranking de máquinas
    async function generateMachineRanking(productionData, planData) {
        const rankingContainer = document.getElementById('machine-ranking');
        if (!rankingContainer) return;

        const producedByMachine = new Map();
        const plannedByMachine = new Map();

        (productionData || []).forEach(item => {
            const m = (item?.machine || '').toString();
            if (!m) return;
            producedByMachine.set(m, (producedByMachine.get(m) || 0) + (Number(item.quantity) || 0));
        });

        (planData || []).forEach(plan => {
            const m = (plan?.machine || '').toString();
            if (!m) return;
            plannedByMachine.set(m, (plannedByMachine.get(m) || 0) + (Number(plan.quantity) || 0));
        });

        const entries = Array.from(new Set([...producedByMachine.keys(), ...plannedByMachine.keys()]))
            .map(m => {
                const produced = producedByMachine.get(m) || 0;
                const planned = plannedByMachine.get(m) || 0;
                const perf = planned > 0 ? Math.max(0, (produced / planned) * 100) : null;
                return { machine: m, produced, planned, perf };
            })
            .filter(e => e.perf !== null)
            .sort((a, b) => (b.perf - a.perf));

        if (entries.length === 0) {
            rankingContainer.innerHTML = '<div class="p-4 text-sm text-gray-500">Sem dados de plano para calcular performance.</div>';
            return;
        }

        const getColor = (p) => {
            if (p >= 90) return 'bg-green-500';
            if (p >= 75) return 'bg-blue-500';
            if (p >= 60) return 'bg-yellow-500';
            return 'bg-red-500';
        };

        const html = entries.slice(0, 6).map((row, index) => `
            <div class="flex items-center justify-between p-4 bg-gray-50 rounded-lg">
                <div class="flex items-center gap-4">
                    <div class="flex items-center justify-center w-8 h-8 ${getColor(row.perf)} text-white rounded-full font-bold">
                        ${index + 1}
                    </div>
                    <span class="font-semibold">${row.machine}</span>
                </div>
                <div class="text-right">
                    <span class="text-2xl font-bold text-gray-800">${row.perf.toFixed(1)}%</span>
                    <div class="w-24 h-2 bg-gray-200 rounded-full mt-1">
                        <div class="h-2 ${getColor(row.perf)} rounded-full" style="width: ${Math.min(100, row.perf).toFixed(1)}%"></div>
                    </div>
                    <div class="text-xs text-gray-500 mt-1">${row.produced.toLocaleString('pt-BR')} / ${row.planned.toLocaleString('pt-BR')} pcs</div>
                </div>
            </div>
        `).join('');

        rankingContainer.innerHTML = html;
    }

    // Gráfico de produção por hora
    async function generateHourlyProductionChart(productionData, options = {}) {
        const {
            canvas: providedCanvas = null,
            targetCanvasId = 'hourly-production-chart',
            chartContext = 'main',
            dailyTargetOverride = null,
            updateTimeline = chartContext === 'main'
        } = options;

        const canvas = providedCanvas || document.getElementById(targetCanvasId);
        if (!canvas) return;
        const canvasId = canvas.id || targetCanvasId;

        if (chartContext === 'analysis') {
            if (analysisHourlyChartInstance) {
                analysisHourlyChartInstance.destroy();
                analysisHourlyChartInstance = null;
            }
        } else if (hourlyChartInstance) {
            hourlyChartInstance.destroy();
            hourlyChartInstance = null;
        }

        if (!Array.isArray(productionData) || productionData.length === 0) {
            showNoDataMessage(canvasId);
            if (updateTimeline) {
                updateTimelineProgress(0, 0, 0);
            }
            return;
        }

        clearNoDataMessage(canvasId);

        const orderedHours = getProductionHoursOrder();
        const executedByHour = Object.fromEntries(orderedHours.map(label => [label, 0]));

        productionData.forEach(item => {
            if (!item?.datetime) return;
            const eventDate = new Date(item.datetime);
            if (Number.isNaN(eventDate.getTime())) return;
            const label = formatHourLabel(eventDate.getHours());
            executedByHour[label] = (executedByHour[label] || 0) + (Number(item.quantity) || 0);
        });

        const overrideTarget = Number(dailyTargetOverride);
        let dailyTarget = Number.isFinite(overrideTarget) && overrideTarget > 0 ? overrideTarget : Number(selectedMachineData?.daily_target) || 1000;
        if (!Number.isFinite(dailyTarget) || dailyTarget < 0) {
            dailyTarget = 0;
        }

        const hourlyTarget = HOURS_IN_PRODUCTION_DAY > 0 ? (dailyTarget / HOURS_IN_PRODUCTION_DAY) : 0;

        const executedSeries = orderedHours.map(label => executedByHour[label] || 0);
        const plannedSeries = orderedHours.map(() => hourlyTarget);

        const totalExecuted = executedSeries.reduce((sum, value) => sum + value, 0);
        const totalPlanned = Math.max(0, dailyTarget);
        const hoursElapsed = getHoursElapsedInProductionDay(new Date());
        const expectedByNow = totalPlanned > 0 ? Math.min(hoursElapsed * hourlyTarget, totalPlanned) : 0;

        const instance = createHourlyProductionChart({
            canvas,
            labels: orderedHours,
            executedPerHour: executedSeries,
            plannedPerHour: plannedSeries,
            highlightCurrentHour: chartContext === 'main'
        });

        if (chartContext === 'analysis') {
            analysisHourlyChartInstance = instance;
        } else {
            hourlyChartInstance = instance;
        }

        if (updateTimeline) {
            updateTimelineProgress(totalExecuted, totalPlanned, expectedByNow);
        }

    }

    // Função para atualizar a barra de timeline
    function updateTimelineProgress(executed, planned, expectedByNow) {
        const progressBar = document.getElementById('timeline-progress');
        const targetIndicator = document.getElementById('timeline-target-indicator');
        const percentageText = document.getElementById('timeline-percentage');
        const executedText = document.getElementById('timeline-executed');
        const plannedText = document.getElementById('timeline-planned');
        const statusIndicator = document.getElementById('timeline-status-indicator');
        const statusText = document.getElementById('timeline-status-text');
        const lastUpdateText = document.getElementById('timeline-last-update');

        if (!progressBar || !targetIndicator) return;

        // Calcular percentuais
        const executedPercentage = planned > 0 ? Math.min((executed / planned) * 100, 100) : 0;
        const expectedPercentage = planned > 0 ? Math.min((expectedByNow / planned) * 100, 100) : 0;
        const palette = resolveProgressPalette(executedPercentage);
        const orderStatus = (currentActiveOrder && typeof currentActiveOrder.status === 'string')
            ? currentActiveOrder.status.toLowerCase()
            : '';
        const blockedStatuses = ['concluida', 'cancelada', 'finalizada', 'encerrada'];
    const orderEligibleForFinalize = !!currentActiveOrder?.id && !blockedStatuses.includes(orderStatus);
    const orderEligibleForActivate = !!currentActiveOrder?.id && !blockedStatuses.includes(orderStatus) && orderStatus !== 'ativa';

        currentOrderProgress = {
            executed: Number.isFinite(executed) ? executed : 0,
            planned: Number.isFinite(planned) ? planned : 0,
            expected: Number.isFinite(expectedByNow) ? expectedByNow : 0
        };

        // Animar barra de progresso
        setTimeout(() => {
            progressBar.style.width = `${executedPercentage}%`;
            targetIndicator.style.left = `${expectedPercentage}%`;
        }, 100);

        progressBar.classList.add('timeline-progress');
        progressBar.style.background = `linear-gradient(90deg, ${palette.start}, ${palette.end})`;
        progressBar.style.boxShadow = `0 6px 18px ${hexWithAlpha(palette.end, 0.35)}`;
        targetIndicator.style.backgroundColor = palette.end;
    const lotCompleted = planned > 0 && executed >= planned;
    progressBar.classList.toggle('timeline-complete', lotCompleted);

        // Atualizar textos
        if (percentageText) {
            percentageText.textContent = `${executedPercentage.toFixed(1)}%`;
            percentageText.classList.remove('text-red-600', 'text-amber-500', 'text-emerald-600', 'text-green-600');
            if (palette.textClass) {
                percentageText.classList.add(palette.textClass);
            }
        }
        
        if (executedText) {
            executedText.textContent = `${executed.toLocaleString('pt-BR')} peças`;
        }
        
        if (plannedText) {
            plannedText.textContent = `${planned.toLocaleString('pt-BR')} un (Planejado)`;
        }

        // Determinar status
        let status = 'on-track';
        let statusMessage = 'No prazo';
        let indicatorClass = 'bg-green-500 animate-pulse';

        if (executed < expectedByNow * 0.8) {
            status = 'behind';
            statusMessage = 'Atrasado';
            indicatorClass = 'bg-red-500 animate-pulse';
        } else if (executed > expectedByNow * 1.2) {
            status = 'ahead';
            statusMessage = 'Adiantado';
            indicatorClass = 'bg-blue-500 animate-pulse';
        }

        if (lotCompleted) {
            status = 'completed';
            statusMessage = 'Lote concluído';
            indicatorClass = 'bg-emerald-500 animate-pulse';
        }

        // Atualizar indicador de status
        if (statusIndicator) {
            statusIndicator.className = `w-2 h-2 rounded-full ${indicatorClass}`;
        }
        
        if (statusText) {
            statusText.textContent = statusMessage;
            statusText.className = `text-gray-600 font-medium`;
            
            if (status === 'behind') {
                statusText.className = 'text-red-600 font-medium';
            } else if (status === 'ahead') {
                statusText.className = 'text-blue-600 font-medium';
            } else {
                statusText.className = 'text-green-600 font-medium';
            }
        }

        // Atualizar timestamp
        if (lastUpdateText) {
            const now = new Date();
            lastUpdateText.textContent = `Última atualização: ${now.toLocaleTimeString('pt-BR', { 
                hour: '2-digit', 
                minute: '2-digit' 
            })}`;
        }

        if (finalizeOrderBtn) {
            finalizeOrderBtn.classList.toggle('hidden', !orderEligibleForFinalize);
            finalizeOrderBtn.disabled = !orderEligibleForFinalize;
        }
        if (activateOrderBtn) {
            activateOrderBtn.classList.toggle('hidden', !orderEligibleForActivate);
            activateOrderBtn.disabled = !orderEligibleForActivate;
        }
    }

    // Ativa OP a partir do painel da máquina (botão azul)
    async function handleActivateOrderFromPanel(event) {
        event?.preventDefault?.();

        if (!selectedMachineData) {
            alert('Selecione uma máquina antes de ativar a OP.');
            return;
        }

        // Se já houver ordem ativa, não fazer nada
        if (currentActiveOrder && String(currentActiveOrder.status || '').toLowerCase() === 'ativa') {
            showNotification('Esta OP já está ativa nesta máquina.', 'info');
            return;
        }

        const machineId = selectedMachineData.machine;
        let targetOrder = currentActiveOrder;

        // Caso não exista uma ordem resolvida no contexto, localizar pela part_code atual
        if (!targetOrder || !targetOrder.id) {
            try {
                const partCode = selectedMachineData.product_cod || selectedMachineData.product_code;
                if (partCode) {
                    const lotsSnapshot = await db.collection('production_orders')
                        .where('part_code', '==', String(partCode))
                        .get();

                    if (!lotsSnapshot.empty) {
                        const orders = lotsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                        const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
                        const isOpen = (o) => !['concluida','cancelada','finalizada','encerrada'].includes(String(o.status||'').toLowerCase());
                        const sameMachine = orders.filter(o => (o.machine_id || o.machine) === machineId);
                        targetOrder = sameMachine.find(o => ['ativa','em_andamento'].includes(String(o.status||'').toLowerCase()))
                            || sameMachine.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orders.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orders.sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0];
                    }
                }
            } catch (error) {
                console.warn('Falha ao localizar OP para ativação:', error);
            }
        }

        if (!targetOrder || !targetOrder.id) {
            alert('Nenhuma OP elegível encontrada para ativação.');
            return;
        }

        try {
            const ok = await setOrderAsActive(targetOrder.id, machineId);
            if (!ok) {
                showNotification('Ativação cancelada ou não concluída.', 'warning');
                return;
            }

            // Atualizar status do planejamento para em_execucao
            const planId = selectedMachineData?.id;
            if (planId) {
                try {
                    await db.collection('planning').doc(planId).update({
                        status: 'em_execucao',
                        startedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        startedBy: getActiveUser()?.name || 'Sistema'
                    });
                } catch (planErr) {
                    console.warn('Não foi possível atualizar o status do planejamento ao ativar a OP:', planErr);
                }
            }

            // Atualizar listas e painel
            await Promise.allSettled([
                typeof loadProductionOrders === 'function' ? loadProductionOrders() : Promise.resolve(),
                populateMachineSelector()
            ]);
            if (selectedMachineData?.machine) {
                await onMachineSelected(selectedMachineData.machine);
            }

            showNotification('OP ativada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao ativar OP pelo painel:', error);
            alert('Erro ao ativar a OP. Tente novamente.');
        }
    }

    // Finalizar OP diretamente pelo botão do card
    async function handleCardFinalizeClick(buttonEl) {
        try {
            const orderId = buttonEl?.dataset?.orderId;
            const planId = buttonEl?.dataset?.planId;
            const card = buttonEl.closest('.machine-card');
            const machine = card?.dataset?.machine;
            if (!orderId) {
                alert('Ordem não encontrada para finalizar.');
                return;
            }

            if (typeof window.authSystem?.checkPermissionForAction === 'function') {
                const hasPermission = window.authSystem.checkPermissionForAction('close_production_order');
                if (hasPermission === false) return;
            }

            const confirmMsg = `Confirma a finalização desta OP?`;
            if (!window.confirm(confirmMsg)) return;

            const originalHtml = buttonEl.innerHTML;
            buttonEl.disabled = true;
            buttonEl.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Finalizando...</span>`;
            if (typeof lucide !== 'undefined') lucide.createIcons();

            const user = getActiveUser();
            const updatePayload = {
                status: 'concluida',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                completedBy: user?.username || null,
                completedByName: user?.name || null
            };
            await db.collection('production_orders').doc(orderId).update(updatePayload);

            if (planId) {
                try {
                    await db.collection('planning').doc(planId).update({
                        status: 'concluida',
                        finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        finishedBy: user?.name || user?.username || null
                    });
                } catch (e) {
                    console.warn('Falha ao atualizar planejamento ao finalizar pelo card:', e);
                }
            }

            // Se a OP finalizada for a ativa no painel, limpar contexto
            if (currentActiveOrder?.id === orderId) {
                currentActiveOrder = null;
                resetProductionTimer?.();
                if (productionControlPanel) productionControlPanel.classList.add('hidden');
            }

            showNotification('OP finalizada com sucesso!', 'success');

            // Recarregar cartões e, se a mesma máquina estiver selecionada, recarregar painel
            await populateMachineSelector();
            if (machine) {
                const stillSelected = selectedMachineData?.machine === machine;
                if (stillSelected) await onMachineSelected(machine);
            }
        } catch (err) {
            console.error('Erro ao finalizar OP pelo card:', err);
            alert('Erro ao finalizar OP. Tente novamente.');
        } finally {
            if (buttonEl) {
                buttonEl.disabled = false;
                buttonEl.classList.add('hidden');
            }
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    // Ativar próxima OP diretamente pelo botão do card
    async function handleCardActivateNextClick(buttonEl) {
        const card = buttonEl.closest('.machine-card');
        const machine = buttonEl?.dataset?.machine || card?.dataset?.machine;
        if (!machine) {
            alert('Máquina não identificada para ativar próxima OP.');
            return;
        }

        const originalHtml = buttonEl.innerHTML;
        buttonEl.disabled = true;
        buttonEl.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Ativando...</span>`;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        try {
            // Seleciona a máquina para garantir contexto e reaproveitar a lógica de ativação do painel
            await onMachineSelected(machine);
            await handleActivateOrderFromPanel();

            // Recarregar cards e painel
            await populateMachineSelector();
            await onMachineSelected(machine);
        } catch (err) {
            console.error('Erro ao ativar próxima OP pelo card:', err);
            alert('Erro ao ativar próxima OP. Tente novamente.');
        } finally {
            buttonEl.disabled = false;
            buttonEl.innerHTML = originalHtml;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    // Função de debounce para otimizar redimensionamento
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Função para lidar com redimensionamento da janela
    function handleWindowResize() {
        const chartInstances = [];

        if (typeof Chart !== 'undefined' && Chart.instances) {
            if (Array.isArray(Chart.instances)) {
                chartInstances.push(...Chart.instances);
            } else if (Chart.instances instanceof Map) {
                chartInstances.push(...Chart.instances.values());
            } else {
                chartInstances.push(...Object.values(Chart.instances));
            }
        }

        chartInstances.forEach(chart => {
            if (chart && typeof chart.resize === 'function') {
                chart.resize();
            }
        });

        // Recarregar dados da aba ativa se necessário
        const activeTab = document.querySelector('.nav-btn.active');
        if (activeTab) {
            const activePage = activeTab.getAttribute('data-page');
            
            // Só recarregar se for uma aba com gráficos e se houve mudança significativa no tamanho
            if (['analise', 'lancamento'].includes(activePage)) {
                // Verificar se mudou entre breakpoints importantes (mobile/desktop)
                const wasMobile = typeof window.previousWidth === 'number' ? window.previousWidth < 768 : window.innerWidth < 768;
                const isMobile = window.innerWidth < 768;
                
                if (wasMobile !== isMobile) {
                    // Recarregar gráficos com novas configurações responsivas
                    setTimeout(() => {
                        if (activePage === 'analise') {
                            loadAnalysisData();
                        } else if (activePage === 'lancamento') {
                            loadLaunchPanel();
                        }
                    }, 100);
                }
            }
        }
        
        // Salvar largura atual para comparação futura
        window.previousWidth = window.innerWidth;
    }

    // Função para atualizar timeline apenas se estiver visível
    async function updateTimelineIfVisible() {
        // Otimização: Não atualizar se a aba do navegador não estiver visível
        if (!isPageVisible()) {
            return;
        }
        
        const timelineElement = document.getElementById('timeline-progress');
        if (!timelineElement || timelineElement.offsetParent === null) {
            return; // Timeline não está visível
        }

        // Recarregar dados de produção atuais
        try {
            if (!selectedMachineData) {
                updateTimelineProgress(0, 0, 0);
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            const productionData = await getFilteredData('production', today, today, selectedMachineData.machine || 'all');

            const totalExecuted = productionData.reduce((sum, item) => sum + (item.quantity || 0), 0);
            const totalPlanned = Number(selectedMachineData.planned_quantity) || 0;
            const hourlyTarget = totalPlanned / HOURS_IN_PRODUCTION_DAY;
            const hoursElapsed = getHoursElapsedInProductionDay(new Date());
            const expectedByNow = Math.min(totalPlanned, hoursElapsed * hourlyTarget);

            updateTimelineProgress(totalExecuted, totalPlanned, expectedByNow);
        } catch (error) {
            console.warn('Erro ao atualizar timeline:', error);
        }
    }
    // Gráfico de produção por turno
    async function generateShiftProductionChart(productionData) {
        const ctx = document.getElementById('shift-production-chart');
        if (!ctx) return;

        destroyChart('shift-production-chart');

        if (productionData.length === 0) {
            showNoDataMessage('shift-production-chart');
            return;
        }
        
        clearNoDataMessage('shift-production-chart');

        const shiftData = [0, 0, 0]; // 1º, 2º, 3º Turno
        const shiftLabels = ['1º Turno', '2º Turno', '3º Turno'];

        productionData.forEach(item => {
            if (item.shift) {
                shiftData[item.shift - 1] += item.quantity;
            }
        });

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: shiftLabels,
                datasets: [{
                    label: 'Peças',
                    data: shiftData,
                    backgroundColor: ['#10B981', '#3B82F6', '#F59E0B'],
                    borderColor: ['#047857', '#1E40AF', '#D97706'],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: window.innerWidth < 768 ? 9 : 11
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: window.innerWidth < 768 ? 9 : 11
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y} pcs`;
                            }
                        }
                    }
                }
            }
        });
    }

    async function generateMachineProductionTimeline(productionData, options = {}) {
        const {
            canvas: providedCanvas = null,
            targetCanvasId = 'analysis-machine-production-timeline',
            maxMachines = 6
        } = options;

        const canvas = providedCanvas || document.getElementById(targetCanvasId);
        if (!canvas) return;
        const canvasId = canvas.id || targetCanvasId;

        if (machineProductionTimelineInstance) {
            machineProductionTimelineInstance.destroy();
            machineProductionTimelineInstance = null;
        }

        if (!Array.isArray(productionData) || productionData.length === 0) {
            showNoDataMessage(canvasId);
            return;
        }

        const dateSet = new Set();
        const totalsByMachine = new Map();
        const totalsByMachineDate = new Map();

        productionData.forEach(item => {
            const machine = (item?.machine || 'Sem máquina').toString();
            const rawDate = item?.workDay || item?.date || '';
            const dateKey = rawDate ? String(rawDate).slice(0, 10) : '';
            if (!dateKey) return;
            const quantity = Number(item?.quantity) || 0;

            dateSet.add(dateKey);
            totalsByMachine.set(machine, (totalsByMachine.get(machine) || 0) + quantity);
            const compositeKey = `${machine}__${dateKey}`;
            totalsByMachineDate.set(compositeKey, (totalsByMachineDate.get(compositeKey) || 0) + quantity);
        });

        if (dateSet.size === 0 || totalsByMachine.size === 0) {
            showNoDataMessage(canvasId);
            return;
        }

        const sortedDates = Array.from(dateSet).sort();
        const displayLabels = sortedDates.map(formatShortDateLabel);
        const machinesSorted = Array.from(totalsByMachine.entries())
            .sort((a, b) => b[1] - a[1])
            .map(entry => entry[0]);

        const machinesToPlot = machinesSorted.slice(0, Math.max(1, maxMachines));

        clearNoDataMessage(canvasId);

        const datasets = machinesToPlot.map((machine, index) => {
            const colors = ANALYSIS_LINE_COLORS[index % ANALYSIS_LINE_COLORS.length];
            const points = sortedDates.map(dateKey => totalsByMachineDate.get(`${machine}__${dateKey}`) || 0);
            return {
                label: machine,
                data: points,
                borderColor: colors.border,
                backgroundColor: colors.fill,
                tension: 0.3,
                pointRadius: 3,
                pointHoverRadius: 5,
                fill: false
            };
        });

        const context = canvas.getContext('2d');
        machineProductionTimelineInstance = new Chart(context, {
            type: 'line',
            data: {
                labels: displayLabels,
                datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            callback: (value) => `${Number(value).toLocaleString('pt-BR')} pcs`
                        },
                        title: {
                            display: true,
                            text: 'Peças'
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: 0
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            boxWidth: 12
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const label = context.dataset?.label || '';
                                const value = Number(context.parsed.y) || 0;
                                return `${label}: ${value.toLocaleString('pt-BR')} pcs`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Função para atualizar gráficos de eficiência em formato doughnut
    function updateGauge(canvasId, percentage) {
        console.log(`[GAUGE] Atualizando ${canvasId} com ${percentage}%`);
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error(`[GAUGE] Canvas "${canvasId}" não encontrado`);
            return;
        }

        const normalizedValue = Math.max(0, Math.min(Number(percentage) || 0, 100));
        const remainingValue = Math.max(0, 100 - normalizedValue);
        const style = gaugeChartStyles[canvasId] || { color: '#0F172A' };
        let activeColor = style.color;

        if (normalizedValue < 60 && style.dangerColor) {
            activeColor = style.dangerColor;
        } else if (normalizedValue < 80 && style.warningColor) {
            activeColor = style.warningColor;
        }

        const valueElementId = canvasId.replace('-gauge', '-value');
        const valueElement = document.getElementById(valueElementId);
        if (valueElement) {
            valueElement.style.color = activeColor;
        }

        if (gaugeChartInstances[canvasId]) {
            const chart = gaugeChartInstances[canvasId];
            chart.data.datasets[0].data = [normalizedValue, remainingValue];
            chart.data.datasets[0].backgroundColor = [
                activeColor,
                'rgba(229, 231, 235, 0.45)'
            ];
            chart.update();
            return;
        }

        gaugeChartInstances[canvasId] = new Chart(canvas, {
            type: 'doughnut',
            data: {
                labels: ['Atual', 'Restante'],
                datasets: [{
                    data: [normalizedValue, remainingValue],
                    backgroundColor: [
                        activeColor,
                        'rgba(229, 231, 235, 0.45)'
                    ],
                    borderWidth: 0,
                    hoverOffset: 4,
                    borderRadius: 10
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '72%',
                rotation: -90,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: false
                    }
                },
                animation: {
                    animateRotate: true,
                    duration: 800
                }
            }
        });
    }

    function renderModernDonutChart({
        canvasId,
        labels = [],
        data = [],
        colors = DEFAULT_DONUT_COLORS,
        datasetLabel = '',
        tooltipFormatter,
        legendPosition,
        cutout = '65%'
    }) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            console.error(`[DONUT] Canvas "${canvasId}" não encontrado`);
            return null;
        }

        const existing = Chart.getChart(canvas);
        if (existing) existing.destroy();

        const palette = labels.map((_, index) => colors[index % colors.length]);
        const total = data.reduce((sum, value) => sum + (Number(value) || 0), 0);
        const isMobile = window.innerWidth < 768;
        const resolvedLegendPosition = legendPosition || (isMobile ? 'bottom' : 'right');

        const chart = new Chart(canvas, {
            type: 'doughnut',
            data: {
                labels,
                datasets: [{
                    label: datasetLabel,
                    data,
                    backgroundColor: palette,
                    borderWidth: 0,
                    hoverOffset: 6,
                    borderRadius: 12
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout,
                rotation: -90,
                plugins: {
                    legend: {
                        position: resolvedLegendPosition,
                        labels: {
                            usePointStyle: true,
                            padding: isMobile ? 10 : 14,
                            boxWidth: isMobile ? 10 : 12,
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    tooltip: {
                        mode: 'nearest',
                        callbacks: {
                            label: tooltipFormatter || ((context) => {
                                const label = context.label || '';
                                const value = Number(context.parsed || 0);
                                if (!total) {
                                    return `${label}: ${value.toLocaleString()}`;
                                }
                                const percentage = ((value / total) * 100).toFixed(1);
                                return `${label}: ${value.toLocaleString()} (${percentage}%)`;
                            })
                        },
                        backgroundColor: '#0F172A',
                        borderColor: 'rgba(15, 23, 42, 0.2)',
                        borderWidth: 1,
                        titleFont: {
                            size: isMobile ? 11 : 12
                        },
                        bodyFont: {
                            size: isMobile ? 10 : 11
                        },
                        padding: isMobile ? 8 : 10
                    }
                },
                animation: {
                    animateRotate: true,
                    animateScale: true,
                    duration: 900,
                    easing: 'easeOutQuart'
                }
            }
        });

        return chart;
    }

    function createHourlyProductionChart({
        canvas,
        labels,
        executedPerHour,
        plannedPerHour,
        highlightCurrentHour = false
    }) {
        if (!canvas) {
            console.error('[HOUR-CHART] Canvas não encontrado para renderização.');
            return null;
        }

        const ctx = canvas.getContext('2d');
        const canvasRect = canvas.getBoundingClientRect();
        const gradientHeight = canvasRect.height || canvas.height || 320;

        const fillGradient = ctx.createLinearGradient(0, 0, 0, gradientHeight);
        fillGradient.addColorStop(0, 'rgba(16, 185, 129, 0.65)');
        fillGradient.addColorStop(1, 'rgba(16, 185, 129, 0.1)');

        const executed = executedPerHour.map(value => Number(value) || 0);
        const planned = plannedPerHour.map(value => Number(value) || 0);

        const executedCumulative = [];
        const plannedCumulative = [];
        executed.reduce((sum, value, index) => {
            const total = sum + value;
            executedCumulative[index] = total;
            return total;
        }, 0);
        planned.reduce((sum, value, index) => {
            const total = sum + value;
            plannedCumulative[index] = total;
            return total;
        }, 0);

        let highlightIndex = -1;
        if (highlightCurrentHour) {
            const highlightLabel = getProductionHourLabel();
            highlightIndex = labels.indexOf(highlightLabel);
        }

        const barBackground = (context) => {
            if (!context) return fillGradient;
            const { dataIndex } = context;
            if (dataIndex === highlightIndex) {
                return 'rgba(14, 165, 233, 0.85)';
            }
            return fillGradient;
        };

        return new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: [
                    {
                        type: 'line',
                        label: 'Produção Acumulada',
                        data: executedCumulative,
                        borderColor: '#10B981',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.35,
                        pointRadius: 0,
                        yAxisID: 'y1',
                        order: 1
                    },
                    {
                        type: 'line',
                        label: 'Meta Acumulada',
                        data: plannedCumulative,
                        borderColor: '#EF4444',
                        borderWidth: 2,
                        borderDash: [8, 6],
                        fill: false,
                        tension: 0.25,
                        pointRadius: 0,
                        yAxisID: 'y1',
                        order: 0
                    }
                ]
            },
            options: mergeChartOptions({
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                layout: {
                    padding: {
                        top: 8,
                        bottom: 0,
                        left: 6,
                        right: 12
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: {
                            color: 'rgba(148, 163, 184, 0.18)',
                            drawBorder: false
                        },
                        ticks: {
                            callback: (value) => `${Number(value).toLocaleString()} pcs`
                        }
                    },
                    y1: {
                        beginAtZero: true,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            callback: (value) => `${Number(value).toLocaleString()} pcs`
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        align: 'center',
                        labels: {
                            usePointStyle: true,
                            padding: 14
                        }
                    },
                    tooltip: {
                        callbacks: {
                            title: (tooltipItems) => `Hora ${tooltipItems[0].label}`,
                            label: (context) => {
                                const label = context.dataset.label || '';
                                const rawValue = context.parsed?.y ?? context.parsed ?? 0;
                                const suffix = label.includes('Acumulada') ? ' peças acumuladas' : ' peças';
                                return `${label}: ${Number(rawValue).toLocaleString()}${suffix}`;
                            }
                        }
                    }
                }
            })
        });
    }

    // Gráfico Pareto de perdas
    async function generateLossesParetoChart(lossesData) {
        const canvas = document.getElementById('losses-pareto-chart');
        if (!canvas) return;

        destroyChart('losses-pareto-chart');

        if (!Array.isArray(lossesData) || lossesData.length === 0) {
            showNoDataMessage('losses-pareto-chart');
            return;
        }

        clearNoDataMessage('losses-pareto-chart');

        const aggregated = {};
        lossesData.forEach(item => {
            const reason = item?.reason || item?.category || item?.type || 'Sem classificação';
            // Usar refugo_kg para perdas, não quantity
            const quantity = Number(item?.raw?.refugo_kg || item?.quantity || 0);
            aggregated[reason] = (aggregated[reason] || 0) + quantity;
        });

        const sortedEntries = Object.entries(aggregated).sort((a, b) => b[1] - a[1]);
        const labels = sortedEntries.map(([label]) => label);
        const values = sortedEntries.map(([, value]) => value);
        const total = values.reduce((sum, value) => sum + value, 0);

        const cumulativePercentages = [];
        values.reduce((sum, value, index) => {
            const accumulated = sum + value;
            cumulativePercentages[index] = total ? (accumulated / total) * 100 : 0;
            return accumulated;
        }, 0);

        new Chart(canvas, {
            type: 'bar',
            data: {
                labels,
                datasets: [
                    {
                        type: 'bar',
                        label: 'Perdas (kg)',
                        data: values,
                        backgroundColor: 'rgba(239, 68, 68, 0.85)',
                        borderColor: '#B91C1C',
                        borderWidth: 1,
                        yAxisID: 'y'
                    },
                    {
                        type: 'line',
                        label: '% Acumulado',
                        data: cumulativePercentages,
                        borderColor: '#0EA5E9',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: mergeChartOptions({
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Perdas (kg)'
                        }
                    },
                    y1: {
                        beginAtZero: true,
                        suggestedMax: 100,
                        position: 'right',
                        grid: {
                            drawOnChartArea: false
                        },
                        ticks: {
                            callback: (value) => `${value}%`
                        },
                        title: {
                            display: true,
                            text: '% Acumulado'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                if (context.dataset.type === 'line') {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                }
                                return `${context.dataset.label}: ${Number(context.parsed.y).toLocaleString()} kg`;
                            }
                        }
                    }
                }
            })
        });
    }

    // Gerar gráfico de perdas por máquina
    async function generateLossesByMachineChart(lossesData) {
        const ctx = document.getElementById('losses-by-machine-chart');
        if (!ctx) return;

        destroyChart('losses-by-machine-chart');

        if (lossesData.length === 0) {
            showNoDataMessage('losses-by-machine-chart');
            return;
        }
        
        clearNoDataMessage('losses-by-machine-chart');

        const machineLosses = {};
        lossesData.forEach(item => {
            const machine = item.machine || 'Sem máquina';
            // Usar refugo_kg para perdas, não quantity
            machineLosses[machine] = (machineLosses[machine] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
        });

        const labels = Object.keys(machineLosses);
        const data = Object.values(machineLosses);

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Perdas (kg)',
                    data: data,
                    backgroundColor: 'rgba(239, 68, 68, 0.8)',
                    borderColor: '#EF4444',
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,

                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    y: {
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Gerar gráfico de perdas por tipo de matéria-prima
    async function generateLossesByMaterialChart(lossesData) {
        const ctx = document.getElementById('losses-by-material-chart');
        if (!ctx) return;

        destroyChart('losses-by-material-chart');

        if (lossesData.length === 0) {
            showNoDataMessage('losses-by-material-chart', 'Nenhuma perda com tipo de MP registrada');
            return;
        }
        
        clearNoDataMessage('losses-by-material-chart');

        // Agrupar perdas por tipo de MP
        const materialLosses = {};
        lossesData.forEach(item => {
            const mpType = item.mp_type || 'Não especificado';
            // Usar refugo_kg para perdas em kg, não quantity (que é em peças)
            materialLosses[mpType] = (materialLosses[mpType] || 0) + (item.raw?.refugo_kg || item.quantity || 0);
        });

        const labels = Object.keys(materialLosses);
        const data = Object.values(materialLosses);

        // Se não houver dados com mp_type, mostrar mensagem
        if (labels.length === 0 || (labels.length === 1 && labels[0] === 'Não especificado')) {
            showNoDataMessage('losses-by-material-chart', 'Configure o tipo de MP no planejamento para visualizar esta análise');
            return;
        }

        const isMobile = window.innerWidth < 768;

        // Cores para diferentes tipos de MP
        const colors = [
            '#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'
        ];
        const totalLosses = data.reduce((sum, value) => sum + value, 0);

        renderModernDonutChart({
            canvasId: 'losses-by-material-chart',
            labels,
            data,
            colors,
            datasetLabel: 'Perdas (kg)',
            legendPosition: isMobile ? 'bottom' : 'right',
            tooltipFormatter: (context) => {
                const value = Number(context.parsed || 0);
                const percentage = totalLosses > 0 ? ((value / totalLosses) * 100).toFixed(1) : '0.0';
                return `${context.label}: ${value.toFixed(3)} kg (${percentage}%)`;
            }
        });
    }

    // Gerar gráfico de tendência de perdas
    async function generateLossesTrendChart(lossesData, startDate, endDate) {
        const ctx = document.getElementById('losses-trend-chart');
        if (!ctx) return;

        destroyChart('losses-trend-chart');

        if (lossesData.length === 0) {
            showNoDataMessage('losses-trend-chart');
            return;
        }
        
        clearNoDataMessage('losses-trend-chart');

        // Agrupar perdas por data
        const lossesByDate = {};
        lossesData.forEach(item => {
            const date = item.date || '';
            lossesByDate[date] = (lossesByDate[date] || 0) + (item.quantity || 0);
        });

        // Ordenar datas
        const sortedDates = Object.keys(lossesByDate).sort();
        const labels = sortedDates.map(date => {
            const [year, month, day] = date.split('-');
            return `${day}/${month}`;
        });
        const data = sortedDates.map(date => lossesByDate[date]);

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Perdas (kg)',
                    data: data,
                    borderColor: '#EF4444',
                    backgroundColor: 'rgba(239, 68, 68, 0.2)',
                    borderWidth: 2,
                    fill: true,
                    tension: 0.4,
                    pointRadius: isMobile ? 2 : 4,
                    pointHoverRadius: isMobile ? 4 : 6
                }]
            },
            options: {
                responsive: true,

                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: isMobile ? 45 : 0,
                            minRotation: isMobile ? 45 : 0,
                            font: {
                                size: isMobile ? 9 : 11
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Gerar gráfico de paradas por motivo
    async function generateDowntimeReasonsChart(downtimeData) {
        const ctx = document.getElementById('downtime-reasons-chart');
        if (!ctx) return;

        destroyChart('downtime-reasons-chart');

        if (downtimeData.length === 0) {
            showNoDataMessage('downtime-reasons-chart');
            return;
        }
        
        clearNoDataMessage('downtime-reasons-chart');

        const reasonDurations = {};
        downtimeData.forEach(item => {
            const reason = item.reason || 'Sem motivo';
            reasonDurations[reason] = (reasonDurations[reason] || 0) + (item.duration || 0);
        });

        const labels = Object.keys(reasonDurations);
        const data = Object.values(reasonDurations).map(d => Number(((d || 0) / 60).toFixed(2))); // Converter para horas

        const isMobile = window.innerWidth < 768;
        const totalHours = data.reduce((sum, value) => sum + value, 0);

        renderModernDonutChart({
            canvasId: 'downtime-reasons-chart',
            labels,
            data,
            colors: ['#EF4444', '#F59E0B', '#10B981', '#3B82F6', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'],
            datasetLabel: 'Paradas (h)',
            legendPosition: isMobile ? 'bottom' : 'right',
            tooltipFormatter: (context) => {
                const value = Number(context.parsed || 0);
                const percentage = totalHours > 0 ? ((value / totalHours) * 100).toFixed(1) : '0.0';
                return `${context.label}: ${value.toFixed(1)} h (${percentage}%)`;
            }
        });
    }

    // Gerar gráfico de paradas por máquina
    async function generateDowntimeByMachineChart(downtimeData) {
        const ctx = document.getElementById('downtime-by-machine-chart');
        if (!ctx) return;

        destroyChart('downtime-by-machine-chart');

        if (downtimeData.length === 0) {
            showNoDataMessage('downtime-by-machine-chart');
            return;
        }
        
        clearNoDataMessage('downtime-by-machine-chart');

        const machineDowntime = {};
        downtimeData.forEach(item => {
            const machine = item.machine || 'Sem máquina';
            machineDowntime[machine] = (machineDowntime[machine] || 0) + (item.duration || 0);
        });

        const labels = Object.keys(machineDowntime);
        const data = Object.values(machineDowntime).map(d => (d / 60).toFixed(1)); // Converter para horas

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Tempo de Parada (h)',
                    data: data,
                    backgroundColor: 'rgba(239, 68, 68, 0.8)',
                    borderColor: '#EF4444',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,

                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            },
                            callback: function(value) {
                                return value + 'h';
                            }
                        }
                    },
                    x: {
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Gerar timeline de paradas
    async function generateDowntimeTimelineChart(downtimeData) {
        const ctx = document.getElementById('downtime-timeline-chart');
        if (!ctx) {
            console.error('[TIMELINE] Canvas não encontrado: downtime-timeline-chart');
            return;
        }

        destroyChart('downtime-timeline-chart');

        console.log('[TIMELINE] Dados recebidos:', downtimeData.length, 'registros');
        
        if (downtimeData.length === 0) {
            console.warn('[TIMELINE] Nenhum dado de parada para mostrar');
            showNoDataMessage('downtime-timeline-chart');
            return;
        }
        
        // Log amostra de dados para debug
        if (downtimeData.length > 0) {
            console.log('[TIMELINE] Amostra de dados:', JSON.stringify(downtimeData.slice(0, 3), null, 2));
        }
        
        clearNoDataMessage('downtime-timeline-chart');

        // Limitar aos últimos 20 eventos para visualização
        const recentDowntimes = downtimeData.slice(-20).reverse();
        
        console.log('[TIMELINE] Paradas recentes:', recentDowntimes.length);
        
        const labels = recentDowntimes.map((item, index) => {
            const dateStr = item.date || item.workDay || '';
            let dateLabel;
            try {
                const date = dateStr ? new Date(dateStr) : new Date();
                dateLabel = date.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
            } catch (e) {
                dateLabel = dateStr;
            }
            return `${dateLabel} - ${item.machine || 'Máq'}`;
        });
        
        const data = recentDowntimes.map(item => item.duration || 0);
        
        console.log('[TIMELINE] Labels:', labels);
        console.log('[TIMELINE] Durações:', data);

        const isMobile = window.innerWidth < 768;

        try {
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Duração (min)',
                        data: data,
                        backgroundColor: recentDowntimes.map(item => {
                            const duration = item.duration || 0;
                            if (duration > 120) return '#EF4444'; // Vermelho para >2h
                            if (duration > 60) return '#F59E0B'; // Amarelo para >1h
                            return '#10B981'; // Verde para <1h
                        }),
                        borderWidth: 1,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                font: {
                                    size: isMobile ? 10 : 12
                                }
                            }
                        },
                        y: {
                            ticks: {
                                font: {
                                    size: isMobile ? 8 : 10
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = recentDowntimes[context.dataIndex];
                                    return [
                                        `Duração: ${context.parsed.x} min`,
                                        `Motivo: ${item.reason || 'Não informado'}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
            console.log('[TIMELINE] Gráfico criado com sucesso');
        } catch (error) {
            console.error('[TIMELINE] Erro ao criar gráfico:', error);
        }
    }

    // Gerar gráfico de borra por MP
    async function generateBorraByMPChart(borraData) {
        const ctx = document.getElementById('borra-by-mp-chart');
        if (!ctx) return;

        destroyChart('borra-by-mp-chart');

        if (borraData.length === 0) {
            showNoDataMessage('borra-by-mp-chart');
            return;
        }
        
        clearNoDataMessage('borra-by-mp-chart');

        const mpCounts = {};
        borraData.forEach(item => {
            const mpType = item.mp_type || item.raw?.mp_type || 'Não especificado';
            const weight = item.raw?.refugo_kg || item.quantity || 0;
            mpCounts[mpType] = (mpCounts[mpType] || 0) + weight;
        });

        const labels = Object.keys(mpCounts);
        const data = Object.values(mpCounts);
        const colors = ['#FCD34D', '#F59E0B', '#D97706', '#B45309', '#92400E'];

        new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: labels,
                datasets: [{
                    data: data,
                    backgroundColor: colors.slice(0, labels.length),
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            font: { size: window.innerWidth < 768 ? 10 : 12 },
                            padding: 15
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.label}: ${context.parsed.toFixed(1)} kg`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Gerar gráfico de borra por motivo
    async function generateBorraByReasonChart(borraData) {
        const ctx = document.getElementById('borra-by-reason-chart');
        if (!ctx) return;

        destroyChart('borra-by-reason-chart');

        if (borraData.length === 0) {
            showNoDataMessage('borra-by-reason-chart');
            return;
        }
        
        clearNoDataMessage('borra-by-reason-chart');

        const reasonCounts = {};
        borraData.forEach(item => {
            let reason = item.reason || item.raw?.perdas || 'Não especificado';
            // Remover prefixo "BORRA - " se existir
            reason = reason.replace(/^BORRA\s*-\s*/i, '');
            const weight = item.raw?.refugo_kg || item.quantity || 0;
            reasonCounts[reason] = (reasonCounts[reason] || 0) + weight;
        });

        const sortedReasons = Object.entries(reasonCounts)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 8); // Top 8 motivos

        const labels = sortedReasons.map(([reason]) => reason);
        const data = sortedReasons.map(([,weight]) => weight);

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Borra (kg)',
                    data: data,
                    backgroundColor: 'rgba(251, 191, 36, 0.8)',
                    borderColor: '#F59E0B',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                scales: {
                    x: {
                        beginAtZero: true,
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 10 : 12 }
                        }
                    },
                    y: {
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 9 : 11 }
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.x.toFixed(1)} kg`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Gerar gráfico de borra por máquina
    async function generateBorraByMachineChart(borraData) {
        const ctx = document.getElementById('borra-by-machine-chart');
        if (!ctx) return;

        destroyChart('borra-by-machine-chart');

        if (borraData.length === 0) {
            showNoDataMessage('borra-by-machine-chart');
            return;
        }
        
        clearNoDataMessage('borra-by-machine-chart');

        const machineCounts = {};
        borraData.forEach(item => {
            const machine = item.machine || 'Não especificado';
            const weight = item.raw?.refugo_kg || item.quantity || 0;
            machineCounts[machine] = (machineCounts[machine] || 0) + weight;
        });

        const labels = Object.keys(machineCounts);
        const data = Object.values(machineCounts);

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Borra (kg)',
                    data: data,
                    backgroundColor: 'rgba(251, 191, 36, 0.8)',
                    borderColor: '#F59E0B',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 10 : 12 }
                        }
                    },
                    x: {
                        ticks: {
                            font: { size: window.innerWidth < 768 ? 10 : 12 }
                        }
                    }
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `${context.parsed.y.toFixed(1)} kg`;
                            }
                        }
                    }
                }
            }
        });
    }

    // Função para calcular OEE detalhado
    async function calculateDetailedOEE(startDate, endDate, machine, shift) {
        try {
            console.log('[TRACE][calculateDetailedOEE] Buscando dados para:', { startDate, endDate, machine, shift });
            
            const [productionData, lossesData, downtimeData, planData] = await Promise.all([
                getFilteredData('production', startDate, endDate, machine, 'all'),
                getFilteredData('losses', startDate, endDate, machine, 'all'),
                getFilteredData('downtime', startDate, endDate, machine, 'all'),
                getFilteredData('plan', startDate, endDate, machine, 'all')
            ]);

            console.log('[TRACE][calculateDetailedOEE] Dados recebidos:', {
                production: productionData.length,
                losses: lossesData.length,
                downtime: downtimeData.length,
                plan: planData.length
            });

            if (productionData.length === 0 && lossesData.length === 0 && downtimeData.length === 0) {
                console.warn('[TRACE][calculateDetailedOEE] PROBLEMA: Nenhum dado encontrado para o período!');
                return { availability: 0, performance: 0, quality: 0, oee: 0 };
            }

            const { filtered, groups } = aggregateOeeMetrics(
                productionData,
                lossesData,
                downtimeData,
                planData,
                shift
            );

            console.log('[TRACE][calculateDetailedOEE] Resultado da agregação:', {
                gruposProcessados: groups.length,
                disponibilidade: (filtered.disponibilidade * 100).toFixed(1),
                performance: (filtered.performance * 100).toFixed(1),
                qualidade: (filtered.qualidade * 100).toFixed(1),
                oee: (filtered.oee * 100).toFixed(1)
            });

            // CORREÇÃO: Se todos os valores estão zero mas há dados, algo está errado
            if (filtered.disponibilidade === 0 && filtered.performance === 0 && filtered.qualidade === 0 && productionData.length > 0) {
                console.error('[TRACE][calculateDetailedOEE] PROBLEMA CRÍTICO: Valores zerados com dados disponíveis!');
                console.log('[TRACE][calculateDetailedOEE] Amostra production:', productionData.slice(0, 3));
                console.log('[TRACE][calculateDetailedOEE] Amostra plan:', planData.slice(0, 3));
            }

            return {
                availability: (filtered.disponibilidade * 100),
                performance: (filtered.performance * 100),
                quality: (filtered.qualidade * 100),
                oee: (filtered.oee * 100)
            };
        } catch (error) {
            console.error('Erro ao calcular OEE detalhado:', error);
            return { availability: 0, performance: 0, quality: 0, oee: 0 };
        }
    }

    // Função de comparação por máquinas
    async function compareByMachines(metric, startDate, endDate) {
        const machineIds = machines.map(m => m.id);
        const results = [];

        for (const machineId of machineIds) {
            const data = await getFilteredData('production', startDate, endDate, machineId, 'all');
            const value = data.reduce((sum, item) => sum + item.quantity, 0);
            
            results.push({
                name: machines.find(m => m.id === machineId)?.name || machineId,
                value: value
            });
        }

        return results.sort((a, b) => b.value - a.value);
    }

    // Gerar gráfico de comparação
    async function generateComparisonChart(data, metric) {
        const ctx = document.getElementById('comparison-chart');
        if (!ctx) return;

        destroyChart('comparison-chart');

        if (!data || data.length === 0) {
            showNoDataMessage('comparison-chart');
            return;
        }
        
        clearNoDataMessage('comparison-chart');

        const labels = data.map(item => item.name);
        const values = data.map(item => item.value);

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: metric.toUpperCase(),
                    data: values,
                    backgroundColor: 'rgba(59, 130, 246, 0.8)',
                    borderColor: '#3B82F6',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,

                scales: {
                    y: {
                        beginAtZero: true,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: isMobile ? 45 : 0,
                            minRotation: isMobile ? 45 : 0,
                            font: {
                                size: isMobile ? 10 : 12
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    // Gerar ranking de comparação
    function generateComparisonRanking(data) {
        const container = document.getElementById('comparison-ranking');
        if (!container) return;

        const html = data.slice(0, 5).map((item, index) => `
            <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                <div class="flex items-center gap-3">
                    <span class="w-6 h-6 bg-primary-blue text-white rounded-full text-sm flex items-center justify-center font-bold">
                        ${index + 1}
                    </span>
                    <span class="font-medium">${item.name}</span>
                </div>
                <span class="text-lg font-bold text-gray-800">${item.value.toLocaleString()}</span>
            </div>
        `).join('');

        container.innerHTML = html;
    }

    // Gerar estatísticas de comparação
    function generateComparisonStats(data) {
        const container = document.getElementById('comparison-stats');
        if (!container) return;

        const values = data.map(item => item.value);
        const max = Math.max(...values);
        const min = Math.min(...values);
        const avg = values.reduce((sum, val) => sum + val, 0) / values.length;
        const range = max - min;

        const html = `
            <div class="space-y-3">
                <div class="flex justify-between">
                    <span class="text-gray-600">Maior valor:</span>
                    <span class="font-bold">${max.toLocaleString()}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600">Menor valor:</span>
                    <span class="font-bold">${min.toLocaleString()}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600">Média:</span>
                    <span class="font-bold">${avg.toFixed(0).toLocaleString()}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-600">Amplitude:</span>
                    <span class="font-bold">${range.toLocaleString()}</span>
                </div>
            </div>
        `;

        container.innerHTML = html;
    }

    // Implementações faltantes para análise completa

    // Gerar timeline de componentes OEE
    async function generateOEEComponentsTimeline(startDate, endDate, machine) {
        const ctx = document.getElementById('oee-components-timeline');
        if (!ctx) return;

        destroyChart('oee-components-timeline');

        // Buscar dados para calcular componentes OEE ao longo do tempo
        const productionData = await getFilteredData('production', startDate, endDate, machine);
        const downtimeData = await getFilteredData('downtime', startDate, endDate, machine);

        if (productionData.length === 0) {
            showNoDataMessage('oee-components-timeline');
            return;
        }
        
        clearNoDataMessage('oee-components-timeline');

        // Agrupar por data
        const dataByDate = {};
        
        productionData.forEach(item => {
            const date = item.date || '';
            if (!dataByDate[date]) {
                dataByDate[date] = {
                    produced: 0,
                    scrap: 0,
                    planned: 0,
                    downtime: 0
                };
            }
            dataByDate[date].produced += item.quantity || 0;
            dataByDate[date].scrap += item.scrap || 0;
            dataByDate[date].planned += item.planned || item.quantity || 0;
        });

        downtimeData.forEach(item => {
            const date = item.date || '';
            if (dataByDate[date]) {
                dataByDate[date].downtime += item.duration || 0;
            }
        });

        // Ordenar datas
        const sortedDates = Object.keys(dataByDate).sort();
        const dates = sortedDates.map(date => {
            const [year, month, day] = date.split('-');
            return `${day}/${month}`;
        });
        
        const availabilityData = [];
        const performanceData = [];
        const qualityData = [];

        sortedDates.forEach(date => {
            const data = dataByDate[date];
            
            // Disponibilidade: tempo disponível / tempo planejado
            const plannedMinutes = 480; // 8 horas
            const availability = Math.max(0, Math.min(100, ((plannedMinutes - data.downtime) / plannedMinutes) * 100));
            
            // Performance: produzido / planejado
            const performance = data.planned > 0 ? Math.min(100, (data.produced / data.planned) * 100) : 100;
            
            // Qualidade: (produzido - refugo) / produzido
            const quality = data.produced > 0 ? ((data.produced - data.scrap) / data.produced) * 100 : 100;
            
            availabilityData.push(availability.toFixed(1));
            performanceData.push(performance.toFixed(1));
            qualityData.push(quality.toFixed(1));
        });

        const isMobile = window.innerWidth < 768;

        new Chart(ctx, {
            type: 'line',
            data: {
                labels: dates,
                datasets: [{
                    label: 'Disponibilidade %',
                    data: availabilityData,
                    borderColor: '#10B981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: isMobile ? 2 : 4,
                    pointHoverRadius: isMobile ? 4 : 6,
                    tension: 0.3
                }, {
                    label: 'Performance %',
                    data: performanceData,
                    borderColor: '#3B82F6',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: isMobile ? 2 : 4,
                    pointHoverRadius: isMobile ? 4 : 6,
                    tension: 0.3
                }, {
                    label: 'Qualidade %',
                    data: qualityData,
                    borderColor: '#F59E0B',
                    backgroundColor: 'rgba(245, 158, 11, 0.1)',
                    borderWidth: 2,
                    fill: false,
                    pointRadius: isMobile ? 2 : 4,
                    pointHoverRadius: isMobile ? 4 : 6,
                    tension: 0.3
                }]
            },
            options: {
                responsive: true,

                scales: {
                    y: {
                        beginAtZero: false,
                        min: 0,
                        max: 100,
                        ticks: {
                            font: {
                                size: isMobile ? 10 : 12
                            },
                            callback: function(value) {
                                return value + '%';
                            }
                        }
                    },
                    x: {
                        ticks: {
                            maxRotation: isMobile ? 45 : 0,
                            minRotation: isMobile ? 45 : 0,
                            font: {
                                size: isMobile ? 9 : 11
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: isMobile ? 'bottom' : 'top',
                        labels: {
                            font: {
                                size: isMobile ? 10 : 12
                            },
                            padding: isMobile ? 8 : 10
                        }
                    }
                }
            }
        });
    }

    // Gerar mapa de calor OEE
    async function generateOEEHeatmap(startDate, endDate, machineFilter = 'all') {
        const container = document.getElementById('oee-heatmap');
        if (!container) return;

        const normalizedMachine = (machineFilter && machineFilter !== 'all') ? machineFilter : 'all';

        try {
            const [productionData, lossesData, downtimeData, planData] = await Promise.all([
                getFilteredData('production', startDate, endDate, normalizedMachine, 'all'),
                getFilteredData('losses', startDate, endDate, normalizedMachine, 'all'),
                getFilteredData('downtime', startDate, endDate, normalizedMachine, 'all'),
                getFilteredData('plan', startDate, endDate, normalizedMachine, 'all')
            ]);

            const { groups } = aggregateOeeMetrics(
                productionData,
                lossesData,
                downtimeData,
                planData,
                'all'
            );

            if (!Array.isArray(groups) || groups.length === 0) {
                container.innerHTML = `
                    <div class="p-6 text-center text-sm text-slate-500 bg-slate-100 rounded-lg">
                        Nenhum dado de OEE encontrado para o período selecionado.
                    </div>
                `;
                return;
            }

            const shiftLabels = [
                { key: 1, label: '1º Turno' },
                { key: 2, label: '2º Turno' },
                { key: 3, label: '3º Turno' }
            ];

            const machineMap = new Map();
            const groupsMap = new Map();

            groups.forEach(item => {
                const machineId = item.machine || 'Sem máquina';
                machineMap.set(machineId, machineId);
                const groupKey = `${machineId}__${item.shift}`;
                groupsMap.set(groupKey, {
                    oee: Number(item.oee) * 100,
                    disponibilidade: Number(item.disponibilidade) * 100,
                    performance: Number(item.performance) * 100,
                    qualidade: Number(item.qualidade) * 100
                });
            });

            let machinesSorted = Array.from(machineMap.values());
            const hasMachineFilter = normalizedMachine !== 'all';
            if (!hasMachineFilter) {
                machinesSorted.sort((a, b) => a.localeCompare(b));
            }

            const resolveColorClass = (value) => {
                if (!Number.isFinite(value)) return 'bg-slate-200 text-slate-500';
                if (value >= 80) return 'bg-emerald-500 text-white';
                if (value >= 70) return 'bg-yellow-400 text-slate-900';
                if (value >= 60) return 'bg-orange-500 text-white';
                return 'bg-red-500 text-white';
            };

            let html = `
                <div class="overflow-x-auto">
                    <table class="min-w-full">
                        <thead>
                            <tr>
                                <th class="px-4 py-2 text-left">Máquina / Turno</th>
                                ${shiftLabels.map(shift => `<th class="px-4 py-2 text-center">${shift.label}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
            `;

            machinesSorted.forEach(machineId => {
                html += `<tr><td class="px-4 py-2 font-semibold text-slate-800">${machineId}</td>`;

                shiftLabels.forEach(({ key }) => {
                    const metric = groupsMap.get(`${machineId}__${key}`);
                    if (metric) {
                        const value = Number.isFinite(metric.oee) ? metric.oee : 0;
                        const colorClass = resolveColorClass(value);
                        const title = `Disponibilidade: ${metric.disponibilidade.toFixed(1)}%\nPerformance: ${metric.performance.toFixed(1)}%\nQualidade: ${metric.qualidade.toFixed(1)}%`;
                        html += `
                            <td class="px-4 py-2 text-center">
                                <div class="heatmap-cell ${colorClass} rounded-lg p-2 m-1 cursor-pointer transition-all hover:scale-105" title="${title}">
                                    ${value.toFixed(1)}%
                                </div>
                            </td>
                        `;
                    } else {
                        html += `
                            <td class="px-4 py-2 text-center">
                                <div class="heatmap-cell bg-slate-100 text-slate-400 rounded-lg p-2 m-1">
                                    --
                                </div>
                            </td>
                        `;
                    }
                });

                html += '</tr>';
            });

            html += `
                        </tbody>
                    </table>
                </div>
                <div class="mt-4 flex items-center justify-center gap-4 text-sm">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-emerald-500 rounded"></div>
                        <span>≥ 80%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-yellow-400 rounded"></div>
                        <span>70-79%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-orange-500 rounded"></div>
                        <span>60-69%</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-red-500 rounded"></div>
                        <span>&lt; 60%</span>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        } catch (error) {
            console.error('[OEE][HEATMAP] Erro ao gerar mapa de calor', error);
            container.innerHTML = `
                <div class="p-6 text-center text-sm text-red-600 bg-red-50 rounded-lg">
                    Erro ao carregar mapa de calor. Tente novamente.
                </div>
            `;
        }
    }

    // Funções de comparação faltantes
    async function compareByShifts(metric, startDate, endDate) {
        const shifts = ['1º Turno', '2º Turno', '3º Turno'];
        const results = [];

        for (let i = 1; i <= 3; i++) {
            const data = await getFilteredData('production', startDate, endDate, 'all', i.toString());
            const value = data.reduce((sum, item) => sum + item.quantity, 0);
            
            results.push({
                name: shifts[i - 1],
                value: value
            });
        }

        return results.sort((a, b) => b.value - a.value);
    }

    async function compareByPeriods(metric) {
        const today = new Date();
        const lastWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
        const lastMonth = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);

        const periods = [
            { name: 'Últimos 7 dias', start: lastWeek, end: today },
            { name: 'Últimos 30 dias', start: lastMonth, end: today },
            { name: 'Este mês', start: new Date(today.getFullYear(), today.getMonth(), 1), end: today }
        ];

        const results = [];

        for (const period of periods) {
            const startDate = period.start.toISOString().split('T')[0];
            const endDate = period.end.toISOString().split('T')[0];
            const data = await getFilteredData('production', startDate, endDate, 'all', 'all');
            const value = data.reduce((sum, item) => sum + item.quantity, 0);
            
            results.push({
                name: period.name,
                value: value
            });
        }

        return results;
    }

    async function compareByProducts(metric, startDate, endDate) {
        const productionData = await getFilteredData('production', startDate, endDate, 'all', 'all');
        const planData = await getFilteredData('plan', startDate, endDate, 'all', 'all');
        
        const productData = {};
        
        // Agrupar por produto da produção
        productionData.forEach(item => {
            const product = item.product || 'Produto Não Informado';
            productData[product] = (productData[product] || 0) + item.quantity;
        });

        const results = Object.entries(productData).map(([name, value]) => ({
            name: name,
            value: value
        }));

        return results.sort((a, b) => b.value - a.value);
    }

    // Expor o serviço de dados analíticos para módulos externos (ex.: predictive-analytics)
    if (!window.analyticsDataService) {
        window.analyticsDataService = {};
    }
    window.analyticsDataService.getFilteredData = getFilteredData;

    // Compatibilidade: garantir que outros módulos (Advanced KPIs, SPC, etc.) encontrem a versão completa
    window.getFilteredData = getFilteredData;
        
    // Final da inicialização  
    init();

    function getProductionDateString(date = new Date()) {
        const localDate = new Date(date);
        if (localDate.getHours() < 7) {
            localDate.setDate(localDate.getDate() - 1);
        }
        return new Date(localDate.getTime() - (localDate.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
    }

    function setTodayDate() {
        const todayString = getProductionDateString();
        if (planningDateSelector) planningDateSelector.value = todayString;
        if (resumoDateSelector) resumoDateSelector.value = todayString;
        if (pilotReportDateInput && !pilotReportDateInput.value) pilotReportDateInput.value = todayString;
        if (pilotFilterDateInput && !pilotFilterDateInput.value) pilotFilterDateInput.value = todayString;
        
        if (startDateSelector) startDateSelector.value = todayString;
        if (endDateSelector) endDateSelector.value = todayString;
    }

    function setupEventListeners() {
        // Usar event delegation para nav buttons (funciona com novos elementos)
        const navContainer = document.querySelector('nav');
        if (navContainer) {
            navContainer.addEventListener('click', (e) => {
                const navBtn = e.target.closest('.nav-btn');
                if (navBtn) {
                    // Se for link externo (sem data-page), deixar comportamento padrão
                    if (!navBtn.dataset.page) {
                        return; // Não interceptar
                    }
                    e.preventDefault();
                    handleNavClick({ currentTarget: navBtn, preventDefault: () => {} });
                }
            });
        } else {
            // Fallback: listener direto nos botões
            navButtons.forEach(button => button.addEventListener('click', handleNavClick));
        }
        
        analysisTabButtons.forEach(button => button.addEventListener('click', handleAnalysisTabClick));
        
        if (sidebarOpenBtn) sidebarOpenBtn.addEventListener('click', openSidebar);
        if (sidebarCloseBtn) sidebarCloseBtn.addEventListener('click', closeSidebar);
        if (sidebarToggleBtn) sidebarToggleBtn.addEventListener('click', toggleSidebarCollapse);
        if (sidebarOverlay) sidebarOverlay.addEventListener('click', closeSidebar);

    if (planningForm) planningForm.addEventListener('submit', handlePlanningFormSubmit);
    if (planningOrderSelect) planningOrderSelect.addEventListener('change', onPlanningOrderChange);
    
    // Event listeners para busca de OP
    const orderSearchInput = document.getElementById('planning-order-search');
    if (orderSearchInput) {
        console.log('[Planejamento] Adicionando event listeners ao campo de busca de OP');
        orderSearchInput.addEventListener('input', onPlanningOrderSearchInput);
        orderSearchInput.addEventListener('blur', onPlanningOrderSearchBlur);
        orderSearchInput.addEventListener('focus', (e) => {
            if (e.target.value.trim()) {
                searchPlanningOrder(e.target.value);
            }
        });
    } else {
        console.warn('[Planejamento] Campo de busca de OP não encontrado!');
    }
    
        if (planningDateSelector) planningDateSelector.addEventListener('change', (e) => listenToPlanningChanges(e.target.value));
        if (productionOrderForm) productionOrderForm.addEventListener('submit', handleProductionOrderFormSubmit);
        
        // Adicionar listener para código do produto
        const productCodInput = document.getElementById('planning-product-cod');
        if (productCodInput) {
            ['change', 'blur'].forEach(evt => {
                productCodInput.addEventListener(evt, onPlanningProductCodChange);
            });
            productCodInput.addEventListener('input', onPlanningProductCodChange);
        }
        
        if (planningTableBody) planningTableBody.addEventListener('click', handlePlanningTableClick);
        
        if (leaderLaunchPanel) leaderLaunchPanel.addEventListener('click', handleLeaderPanelClick);
        if (leaderModal) {
            const leaderModalCloseBtn = leaderModal.querySelector('#leader-modal-close-btn');
            if (leaderModalCloseBtn) leaderModalCloseBtn.addEventListener('click', hideLeaderModal);
        }
        if (leaderModalForm) leaderModalForm.addEventListener('submit', handleLeaderEntrySubmit);
        
        if (launchPanelContainer) launchPanelContainer.addEventListener('click', handleLaunchPanelClick);
        if (productionModal) {
            const prodCloseBtn = productionModal.querySelector('#production-modal-close-btn');
            const prodCancelBtn = productionModal.querySelector('#production-modal-cancel-btn');
            if (prodCloseBtn) prodCloseBtn.addEventListener('click', hideProductionModal);
            if (prodCancelBtn) prodCancelBtn.addEventListener('click', hideProductionModal);
        }
        if (productionModalForm) productionModalForm.addEventListener('submit', handleProductionEntrySubmit);
        if (refreshRecentEntriesBtn) refreshRecentEntriesBtn.addEventListener('click', () => loadRecentEntries());
        if (pilotReportForm) pilotReportForm.addEventListener('submit', handlePilotReportSubmit);
        if (pilotFilterDateInput) pilotFilterDateInput.addEventListener('change', () => refreshPilotReports());
        if (pilotRefreshBtn) pilotRefreshBtn.addEventListener('click', (event) => {
            event.preventDefault();
            refreshPilotReports(true);
        });
        if (recentEntriesList) recentEntriesList.addEventListener('click', handleRecentEntryAction);
        if (finalizeOrderBtn) finalizeOrderBtn.addEventListener('click', handleFinalizeOrderClick);
    if (activateOrderBtn) activateOrderBtn.addEventListener('click', handleActivateOrderFromPanel);
        
        // Event listeners para filtro de data e máquina de lançamentos históricos
        const entriesDateFilter = document.getElementById('entries-date-filter');
        const entriesMachineFilter = document.getElementById('entries-machine-filter');
        const entriesDateToday = document.getElementById('entries-date-today');
        const entriesClearAllFilters = document.getElementById('entries-clear-all-filters');
        
        // Popular seletor de máquinas
        if (entriesMachineFilter && typeof machineProductData !== 'undefined') {
            const machines = Object.keys(machineProductData).sort();
            machines.forEach(machine => {
                const option = document.createElement('option');
                option.value = machine;
                option.textContent = machine;
                entriesMachineFilter.appendChild(option);
            });
        }
        
        if (entriesDateFilter) {
            // Definir data atual como valor padrão
            entriesDateFilter.value = getProductionDateString();
            
            entriesDateFilter.addEventListener('change', () => {
                const selectedDate = entriesDateFilter.value;
                if (selectedDate) {
                    window.lancamentoFilterDate = selectedDate;
                    updateEntriesFilterIndicator();
                    loadRecentEntriesWithFilters();
                }
            });
        }
        
        if (entriesMachineFilter) {
            entriesMachineFilter.addEventListener('change', () => {
                const selectedMachine = entriesMachineFilter.value;
                window.lancamentoFilterMachine = selectedMachine || null;
                updateEntriesFilterIndicator();
                loadRecentEntriesWithFilters();
            });
        }
        
        if (entriesDateToday) {
            entriesDateToday.addEventListener('click', () => {
                const today = getProductionDateString();
                if (entriesDateFilter) entriesDateFilter.value = today;
                if (entriesMachineFilter) entriesMachineFilter.value = '';
                window.lancamentoFilterDate = null;
                window.lancamentoFilterMachine = null;
                hideEntriesFilterIndicator();
                loadRecentEntries(true);
            });
        }
        
        if (entriesClearAllFilters) {
            entriesClearAllFilters.addEventListener('click', () => {
                const today = getProductionDateString();
                if (entriesDateFilter) entriesDateFilter.value = today;
                if (entriesMachineFilter) entriesMachineFilter.value = '';
                window.lancamentoFilterDate = null;
                window.lancamentoFilterMachine = null;
                hideEntriesFilterIndicator();
                loadRecentEntries(true);
            });
        }
        
        // Event listeners para filtros de lançamentos recentes
        const filterButtons = document.querySelectorAll('.filter-entry-btn');
        filterButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const filter = btn.dataset.filter;
                applyEntryFilter(filter);
            });
        });
        
    if (resumoDateSelector) resumoDateSelector.addEventListener('change', loadResumoData);
        if (printReportBtn) printReportBtn.addEventListener('click', handlePrintReport);
    if (reportQuantBtn) reportQuantBtn.addEventListener('click', () => switchReportView('quant'));

    // Carregar OPs para o formulário de planejamento
    loadPlanningOrders().catch(err => console.warn('Erro ao carregar OPs para planejamento:', err));
        if (reportEfficBtn) reportEfficBtn.addEventListener('click', () => switchReportView('effic'));
        if (resumoContentContainer) resumoContentContainer.addEventListener('click', handleResumoTableClick);
        
        if (refreshDashboardBtn) refreshDashboardBtn.addEventListener('click', loadDashboardData);
        if (machineFilter) machineFilter.addEventListener('change', () => processAndRenderDashboard(fullDashboardData));
        if (graphMachineFilter) graphMachineFilter.addEventListener('change', () => processAndRenderDashboard(fullDashboardData));
        
        dateRangeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                dateRangeButtons.forEach(btn => btn.classList.remove('active'));
                e.currentTarget.classList.add('active');
                setDateRange(e.currentTarget.dataset.range);
            });
        });

        if (ajustesSearchForm) ajustesSearchForm.addEventListener('submit', handleAjustesSearch);
        if (ajustesRefreshBtn) ajustesRefreshBtn.addEventListener('click', handleAjustesRefresh);
        if (ajustesEditForm) ajustesEditForm.addEventListener('submit', handleAjustesEditSubmit);
        if (ajustesCancelBtn) ajustesCancelBtn.addEventListener('click', () => {
            resetAjustesEditor();
            updateAjustesEditStatus('Edição cancelada. Nenhuma alteração aplicada.', 'info');
        });

        // Confirm modal handlers are assigned dynamically inside showConfirmModal

        // NOVOS EVENT LISTENERS PARA O SISTEMA DE LANÇAMENTOS POR HORA
        document.addEventListener('input', function(e) {
            if (e.target.classList.contains('peso-bruto-input') || 
                e.target.classList.contains('embalagem-fechada-input')) {
                updateTotalCalculation();
            }
        });

        document.addEventListener('change', function(e) {
            if (e.target.classList.contains('usar-tara-checkbox') || e.target.id === 'use-tara-box') {
                updateTotalCalculation();
            }
        });

        // Event listener para deletar lançamentos por hora
        document.addEventListener('click', async function(e) {
            if (e.target.closest('.delete-hourly-entry')) {
                const button = e.target.closest('.delete-hourly-entry');
                const entryId = button.dataset.id;
                
                try {
                    await db.collection('hourly_production_entries').doc(entryId).delete();
                    button.closest('.hourly-entry').remove();
                    updateTotalCalculation();
                } catch (error) {
                    console.error("Erro ao deletar lançamento:", error);
                    alert("Erro ao deletar lançamento.");
                }
            }
        });
    }

    // --- GESTÃO DE LISTENERS ---
    function detachActiveListener() {
        // O gerenciador de listeners cuida automaticamente de desinscrições
        // Esta função é mantida para compatibilidade
        console.log('✅ Listeners ativos desinscritos pelo listenerManager');
    }

    // --- GESTÃO DE ORDENS DE PRODUÇÃO ---
    let ordersCache = [];
    
    async function loadProductionOrders() {
        console.log('[Ordens] Carregando ordens de produção...');
        
        const grid = document.getElementById('orders-grid');
        const tableBody = document.getElementById('orders-table-body');
        const tableContainer = document.getElementById('orders-table-container');
        const emptyState = document.getElementById('orders-empty-state');
        const countEl = document.getElementById('orders-count');
        
        try {
            const snapshot = await db.collection('production_orders').get();
            ordersCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log('[Ordens] ' + ordersCache.length + ' ordens carregadas');
            
            // Atualizar KPIs
            updateOrdersKPIs(ordersCache);
            
            // Renderizar ordens
            renderOrders(ordersCache);
            
            // Popular filtro de máquinas
            populateOrdersMachineFilter();
            
            // Configurar filtros e eventos (apenas uma vez)
            if (!window.ordersFiltersConfigured) {
                setupOrdersFilters();
                setupOrdersViewToggle();
                window.ordersFiltersConfigured = true;
            }
            
        } catch (error) {
            console.error('[Ordens] Erro ao carregar:', error);
            if (countEl) countEl.textContent = 'Erro ao carregar ordens';
        }
    }
    
    function updateOrdersKPIs(orders) {
        const total = orders.length;
        const active = orders.filter(o => ['ativa', 'em_andamento'].includes((o.status || '').toLowerCase())).length;
        const completed = orders.filter(o => ['concluida', 'finalizada'].includes((o.status || '').toLowerCase())).length;
        
        // Calcular progresso médio
        let totalProgress = 0;
        orders.forEach(o => {
            const lotSize = Number(o.lot_size) || 0;
            const produced = Number(o.total_produzido ?? o.totalProduced ?? o.total_produced) || 0;
            if (lotSize > 0) {
                totalProgress += Math.min((produced / lotSize) * 100, 100);
            }
        });
        const avgProgress = total > 0 ? Math.round(totalProgress / total) : 0;
        
        // Atualizar elementos
        const kpiTotal = document.getElementById('orders-kpi-total');
        const kpiActive = document.getElementById('orders-kpi-active');
        const kpiCompleted = document.getElementById('orders-kpi-completed');
        const kpiAvgProgress = document.getElementById('orders-kpi-avg-progress');
        
        if (kpiTotal) kpiTotal.textContent = total;
        if (kpiActive) kpiActive.textContent = active;
        if (kpiCompleted) kpiCompleted.textContent = completed;
        if (kpiAvgProgress) kpiAvgProgress.textContent = avgProgress + '%';
    }
    
    function renderOrders(orders) {
        const grid = document.getElementById('orders-grid');
        const tableBody = document.getElementById('orders-table-body');
        const tableContainer = document.getElementById('orders-table-container');
        const emptyState = document.getElementById('orders-empty-state');
        const countEl = document.getElementById('orders-count');
        
        // Atualizar contador
        if (countEl) countEl.textContent = orders.length + ' ordem' + (orders.length !== 1 ? 's' : '') + ' encontrada' + (orders.length !== 1 ? 's' : '');
        
        if (orders.length === 0) {
            if (grid) grid.innerHTML = '';
            if (tableBody) tableBody.innerHTML = '';
            if (emptyState) emptyState.classList.remove('hidden');
            return;
        }
        
        if (emptyState) emptyState.classList.add('hidden');
        
        // Renderizar Grid de Cards
        if (grid) {
            grid.innerHTML = orders.map(order => renderOrderCard(order)).join('');
        }
        
        // Renderizar Tabela
        if (tableBody) {
            tableBody.innerHTML = orders.map(order => renderOrderTableRow(order)).join('');
        }
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function renderOrderCard(order) {
        const status = (order.status || 'planejada').toLowerCase();
        const lotSize = Number(order.lot_size) || 0;
        // CORREÇÃO: Usar total_produzido OU totalProduced (nomes corretos do campo no Firebase)
        const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
        const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
        
        const statusConfig = {
            'planejada': { bg: 'bg-slate-100', text: 'text-slate-700', label: 'Planejada', icon: 'calendar' },
            'ativa': { bg: 'bg-blue-100', text: 'text-blue-700', label: 'Ativa', icon: 'zap' },
            'em_andamento': { bg: 'bg-amber-100', text: 'text-amber-700', label: 'Em Andamento', icon: 'play-circle' },
            'concluida': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Concluída', icon: 'check-circle-2' },
            'finalizada': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Finalizada', icon: 'check-circle-2' },
            'cancelada': { bg: 'bg-red-100', text: 'text-red-700', label: 'Cancelada', icon: 'x-circle' }
        };
        
        const sc = statusConfig[status] || statusConfig['planejada'];
        const progressColor = progress >= 100 ? 'bg-emerald-500' : progress >= 50 ? 'bg-blue-500' : 'bg-amber-500';
        const isActive = ['ativa', 'em_andamento'].includes(status);
        const canActivate = status === 'planejada';
        const canReactivate = ['concluida', 'finalizada'].includes(status);
        
        return '<div class="bg-white rounded-xl border ' + (isActive ? 'border-blue-300 ring-2 ring-blue-100' : 'border-gray-200') + ' shadow-sm hover:shadow-md transition-all overflow-hidden">' +
            '<div class="p-4 border-b border-gray-100 ' + (isActive ? 'bg-blue-50' : 'bg-gray-50') + '">' +
                '<div class="flex items-start justify-between gap-2">' +
                    '<div class="flex-1 min-w-0">' +
                        '<h4 class="font-bold text-gray-800 truncate">OP ' + escapeHtml(order.order_number || '') + '</h4>' +
                        '<p class="text-sm text-gray-600 truncate">' + escapeHtml(order.product || order.part_code || 'Produto não definido') + '</p>' +
                    '</div>' +
                    '<span class="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ' + sc.bg + ' ' + sc.text + '">' +
                        '<i data-lucide="' + sc.icon + '" class="w-3 h-3"></i>' +
                        sc.label +
                    '</span>' +
                '</div>' +
            '</div>' +
            '<div class="p-4 space-y-3">' +
                '<div class="grid grid-cols-2 gap-2 text-sm">' +
                    '<div class="flex items-center gap-2 text-gray-600">' +
                        '<i data-lucide="user" class="w-4 h-4 text-gray-400"></i>' +
                        '<span class="truncate">' + escapeHtml(order.customer || 'N/A') + '</span>' +
                    '</div>' +
                    '<div class="flex items-center gap-2 text-gray-600">' +
                        '<i data-lucide="settings" class="w-4 h-4 text-gray-400"></i>' +
                        '<span class="truncate">' + escapeHtml(order.machine_id || 'N/A') + '</span>' +
                    '</div>' +
                '</div>' +
                '<div class="bg-gray-50 rounded-lg p-3">' +
                    '<div class="flex items-center justify-between text-xs text-gray-500 mb-1">' +
                        '<span>Progresso</span>' +
                        '<span class="font-semibold">' + Math.round(progress) + '%</span>' +
                    '</div>' +
                    '<div class="w-full bg-gray-200 rounded-full h-2">' +
                        '<div class="' + progressColor + ' h-2 rounded-full transition-all" style="width: ' + progress + '%"></div>' +
                    '</div>' +
                    '<div class="flex justify-between text-xs text-gray-500 mt-1">' +
                        '<span>' + produced.toLocaleString('pt-BR') + ' prod.</span>' +
                        '<span>' + lotSize.toLocaleString('pt-BR') + ' plan.</span>' +
                    '</div>' +
                '</div>' +
            '</div>' +
            '<div class="px-4 pb-4 flex gap-2">' +
                (canActivate ? '<button onclick="activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="play" class="w-4 h-4"></i>Ativar</button>' : '') +
                (canReactivate ? '<button onclick="reactivateOrder(\'' + order.id + '\')" class="flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="rotate-ccw" class="w-4 h-4"></i>Reativar</button>' : '') +
                '<button onclick="editOrder(\'' + order.id + '\')" class="' + ((canActivate || canReactivate) ? 'flex-1' : 'w-full') + ' flex items-center justify-center gap-1.5 px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg text-sm font-medium transition"><i data-lucide="edit-3" class="w-4 h-4"></i>Editar</button>' +
            '</div>' +
        '</div>';
    }
    
    function renderOrderTableRow(order) {
        const status = (order.status || 'planejada').toLowerCase();
        const lotSize = Number(order.lot_size) || 0;
        // CORREÇÃO: Usar total_produzido OU totalProduced (nomes corretos do campo no Firebase)
        const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
        const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
        
        const statusBadge = {
            'planejada': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-slate-100 text-slate-700">Planejada</span>',
            'ativa': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-blue-100 text-blue-700">Ativa</span>',
            'em_andamento': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-700">Em Andamento</span>',
            'concluida': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-emerald-100 text-emerald-700">Concluída</span>',
            'finalizada': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-emerald-100 text-emerald-700">Finalizada</span>',
            'cancelada': '<span class="px-2 py-1 rounded-full text-xs font-medium bg-red-100 text-red-700">Cancelada</span>'
        };
        
        const canActivate = status === 'planejada';
        const canReactivate = ['concluida', 'finalizada'].includes(status);
        
        let actions = '';
        if (canActivate) {
            actions += '<button onclick="activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="px-2 py-1 bg-emerald-600 hover:bg-emerald-700 text-white rounded text-xs font-medium mr-1">Ativar</button>';
        }
        if (canReactivate) {
            actions += '<button onclick="reactivateOrder(\'' + order.id + '\')" class="px-2 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-xs font-medium mr-1">Reativar</button>';
        }
        actions += '<button onclick="editOrder(\'' + order.id + '\')" class="px-2 py-1 bg-gray-500 hover:bg-gray-600 text-white rounded text-xs font-medium">Editar</button>';
        
        const progressBar = '<div class="w-full bg-gray-200 rounded-full h-2"><div class="bg-blue-500 h-2 rounded-full" style="width: ' + progress + '%"></div></div><span class="text-xs text-gray-500">' + Math.round(progress) + '%</span>';
        
        return '<tr class="hover:bg-gray-50">' +
            '<td class="px-4 py-3 font-medium">' + escapeHtml(order.order_number || '') + '</td>' +
            '<td class="px-4 py-3">' + escapeHtml(order.product || order.part_code || '-') + '</td>' +
            '<td class="px-4 py-3">' + escapeHtml(order.machine_id || '-') + '</td>' +
            '<td class="px-4 py-3 text-center">' + lotSize.toLocaleString('pt-BR') + '</td>' +
            '<td class="px-4 py-3 text-center"><div class="flex flex-col items-center gap-1">' + progressBar + '</div></td>' +
            '<td class="px-4 py-3 text-center">' + (statusBadge[status] || statusBadge['planejada']) + '</td>' +
            '<td class="px-4 py-3 text-center">' + actions + '</td>' +
        '</tr>';
    }
    
    function populateOrdersMachineFilter() {
        const machineFilter = document.getElementById('orders-machine-filter');
        if (!machineFilter) return;
        
        machineFilter.innerHTML = '<option value="">Todas Máquinas</option>';
        
        if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
            machineDatabase.forEach(function(machine) {
                const mid = normalizeMachineId(machine.id);
                machineFilter.innerHTML += '<option value="' + mid + '">' + mid + ' - ' + machine.model + '</option>';
            });
        }
    }
    
    function setupOrdersFilters() {
        const searchInput = document.getElementById('orders-search');
        const statusFilter = document.getElementById('orders-status-filter');
        const machineFilter = document.getElementById('orders-machine-filter');
        const sortFilter = document.getElementById('orders-sort-filter');
        const clearBtn = document.getElementById('orders-clear-filters');
        
        function applyFilters() {
            let filtered = [...ordersCache];
            
            // Busca
            const query = (searchInput?.value || '').toLowerCase().trim();
            if (query) {
                filtered = filtered.filter(o => 
                    (o.order_number || '').toLowerCase().includes(query) ||
                    (o.product || '').toLowerCase().includes(query) ||
                    (o.part_code || '').toLowerCase().includes(query) ||
                    (o.customer || '').toLowerCase().includes(query)
                );
            }
            
            // Status
            const status = statusFilter?.value || '';
            if (status) {
                filtered = filtered.filter(o => {
                    const s = (o.status || '').toLowerCase();
                    if (status === 'concluida') return ['concluida', 'finalizada'].includes(s);
                    return s === status;
                });
            }
            
            // Máquina
            const machine = machineFilter?.value || '';
            if (machine) {
                filtered = filtered.filter(o => o.machine_id === machine);
            }
            
            // Ordenação
            const sort = sortFilter?.value || 'recent';
            filtered.sort((a, b) => {
                const lotA = Number(a.lot_size) || 0;
                const lotB = Number(b.lot_size) || 0;
                const prodA = Number(a.total_produzido ?? a.totalProduced ?? a.total_produced) || 0;
                const prodB = Number(b.total_produzido ?? b.totalProduced ?? b.total_produced) || 0;
                const progressA = lotA > 0 ? (prodA / lotA) : 0;
                const progressB = lotB > 0 ? (prodB / lotB) : 0;
                
                switch (sort) {
                    case 'recent':
                        return (b.createdAt?.toDate?.() || new Date(0)) - (a.createdAt?.toDate?.() || new Date(0));
                    case 'progress-desc':
                        return progressB - progressA;
                    case 'progress-asc':
                        return progressA - progressB;
                    case 'lot-desc':
                        return lotB - lotA;
                    case 'alpha':
                        return (a.order_number || '').localeCompare(b.order_number || '');
                    default:
                        return 0;
                }
            });
            
            updateOrdersKPIs(filtered);
            renderOrders(filtered);
        }
        
        if (searchInput) searchInput.addEventListener('input', debounce(applyFilters, 300));
        if (statusFilter) statusFilter.addEventListener('change', applyFilters);
        if (machineFilter) machineFilter.addEventListener('change', applyFilters);
        if (sortFilter) sortFilter.addEventListener('change', applyFilters);
        
        if (clearBtn) {
            clearBtn.addEventListener('click', function() {
                if (searchInput) searchInput.value = '';
                if (statusFilter) statusFilter.value = '';
                if (machineFilter) machineFilter.value = '';
                if (sortFilter) sortFilter.value = 'recent';
                applyFilters();
            });
        }
    }
    
    function setupOrdersViewToggle() {
        const gridBtn = document.getElementById('orders-view-grid-btn');
        const tableBtn = document.getElementById('orders-view-table-btn');
        const grid = document.getElementById('orders-grid');
        const tableContainer = document.getElementById('orders-table-container');
        
        if (gridBtn && tableBtn && grid && tableContainer) {
            gridBtn.addEventListener('click', function() {
                grid.classList.remove('hidden');
                tableContainer.classList.add('hidden');
                gridBtn.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                gridBtn.classList.remove('text-gray-500');
                tableBtn.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                tableBtn.classList.add('text-gray-500');
            });
            
            tableBtn.addEventListener('click', function() {
                grid.classList.add('hidden');
                tableContainer.classList.remove('hidden');
                tableBtn.classList.add('bg-white', 'shadow-sm', 'text-primary-blue');
                tableBtn.classList.remove('text-gray-500');
                gridBtn.classList.remove('bg-white', 'shadow-sm', 'text-primary-blue');
                gridBtn.classList.add('text-gray-500');
            });
        }
    }
    
    // Funções globais para ações nas ordens
    window.activateOrder = async function(orderId, machineId) {
        if (!machineId) {
            showNotification('Esta ordem não tem máquina definida. Edite primeiro.', 'warning');
            return;
        }
        if (!confirm('Ativar ordem na máquina ' + machineId + '?')) return;
        try {
            await db.collection('production_orders').doc(orderId).update({
                status: 'ativa',
                activatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            showNotification('Ordem ativada!', 'success');
            loadProductionOrders();
        } catch (e) {
            showNotification('Erro ao ativar ordem', 'error');
        }
    };
    
    window.reactivateOrder = async function(orderId) {
        if (!confirm('Reativar esta ordem?')) return;
        try {
            await db.collection('production_orders').doc(orderId).update({ status: 'ativa' });
            showNotification('Ordem reativada!', 'success');
            loadProductionOrders();
        } catch (e) {
            showNotification('Erro ao reativar ordem', 'error');
        }
    };
    
    window.editOrder = function(orderId) {
        const order = ordersCache.find(o => o.id === orderId);
        if (!order) {
            showNotification('Ordem não encontrada', 'error');
            return;
        }
        openNewOrderModal(order);
    };
    
    // Buscar MP por texto
    window.searchMP = function() {
        const searchTerm = prompt('Digite o código ou descrição da MP:');
        if (!searchTerm) return;
        
        const mpSelect = document.getElementById('order-form-mp');
        if (!mpSelect || typeof materiaPrimaDatabase === 'undefined') {
            showNotification('Database de MP não disponível', 'error');
            return;
        }
        
        const term = searchTerm.toLowerCase();
        const found = materiaPrimaDatabase.find(mp => 
            mp.codigo.toLowerCase().includes(term) || 
            mp.descricao.toLowerCase().includes(term)
        );
        
        if (found) {
            mpSelect.value = found.codigo;
            mpSelect.dispatchEvent(new Event('change'));
            showNotification(`✅ MP encontrada: ${found.codigo} - ${found.descricao}`, 'success');
        } else {
            showNotification(`❌ MP não encontrada para: ${searchTerm}`, 'warning');
        }
    };
    
    // Função para salvar ordem de produção
    window.saveOrderForm = async function() {
        console.log('📝 [saveOrderForm] Iniciando salvamento...');
        
        try {
            const id = document.getElementById('order-form-id')?.value;
            const orderData = {
                order_number: document.getElementById('order-form-number')?.value.trim() || '',
                part_code: document.getElementById('order-form-part-code')?.value.trim() || '',
                product: document.getElementById('order-form-product')?.value.trim() || '',
                lot_size: Number(document.getElementById('order-form-lot-size')?.value) || 0,
                batch_number: document.getElementById('order-form-batch')?.value.trim() || '',
                packaging_qty: Number(document.getElementById('order-form-packaging')?.value) || 0,
                customer: document.getElementById('order-form-customer')?.value.trim() || '',
                machine_id: document.getElementById('order-form-machine')?.value || '',
                raw_material: document.getElementById('order-form-mp')?.value || ''
            };
            
            console.log('📝 [saveOrderForm] Dados:', orderData);
            
            if (!orderData.order_number) {
                showNotification('Informe o número da OP', 'warning');
                return;
            }
            
            if (!orderData.lot_size || orderData.lot_size <= 0) {
                showNotification('Informe o tamanho do lote', 'warning');
                return;
            }
            
            if (id) {
                console.log('📝 [saveOrderForm] Atualizando ordem:', id);
                await db.collection('production_orders').doc(id).update(orderData);
                showNotification('Ordem atualizada com sucesso!', 'success');
                
                // Registrar log de edição
                registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            } else {
                console.log('📝 [saveOrderForm] Criando nova ordem...');
                orderData.status = 'planejada';
                orderData.total_produced = 0;
                orderData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                const docRef = await db.collection('production_orders').add(orderData);
                console.log('✅ [saveOrderForm] Ordem criada com ID:', docRef.id);
                showNotification('Ordem cadastrada com sucesso!', 'success');
                
                // Registrar log de criação
                registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: docRef.id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            }
            
            closeOrderFormModal();
            
            // Atualizar lista de ordens
            if (typeof loadProductionOrders === 'function') {
                loadProductionOrders();
            }
            // Atualizar módulo de ordens após um pequeno delay
            setTimeout(function() {
                if (window.OrdersPageModule && window.OrdersPageModule.refreshOrders) {
                    window.OrdersPageModule.refreshOrders();
                }
            }, 100);
            
        } catch (error) {
            console.error('❌ [saveOrderForm] Erro:', error);
            showNotification('Erro ao salvar: ' + error.message, 'error');
        }
    };
    
    window.openNewOrderModal = function(order) {
        const modal = document.getElementById('order-form-modal');
        if (!modal) return;
        
        const title = document.getElementById('order-form-title');
        if (title) title.textContent = order ? 'Editar Ordem de Produção' : 'Nova Ordem de Produção';
        
        // Popular select de máquinas
        const machineSelect = document.getElementById('order-form-machine');
        if (machineSelect) {
            machineSelect.innerHTML = '<option value="">Selecione uma máquina</option>';
            if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
                machineDatabase.forEach(function(machine) {
                    const mid = normalizeMachineId(machine.id);
                    machineSelect.innerHTML += '<option value="' + mid + '">' + mid + ' - ' + machine.model + '</option>';
                });
            }
        }
        
        // Popular select de Matéria-Prima
        const mpSelect = document.getElementById('order-form-mp');
        if (mpSelect) {
            mpSelect.innerHTML = '<option value="">Selecione a MP...</option>';
            if (typeof materiaPrimaDatabase !== 'undefined' && materiaPrimaDatabase.length > 0) {
                materiaPrimaDatabase.forEach(function(mp) {
                    mpSelect.innerHTML += '<option value="' + mp.codigo + '">' + mp.codigo + ' - ' + mp.descricao + '</option>';
                });
            }
        }
        
        // Preencher campos básicos
        document.getElementById('order-form-id').value = order?.id || '';
        document.getElementById('order-form-number').value = order?.order_number || '';
        document.getElementById('order-form-part-code').value = order?.part_code || '';
        document.getElementById('order-form-product').value = order?.product || '';
        document.getElementById('order-form-lot-size').value = order?.lot_size || '';
        document.getElementById('order-form-batch').value = order?.batch_number || '';
        document.getElementById('order-form-packaging').value = order?.packaging_qty || '';
        document.getElementById('order-form-customer').value = order?.customer || '';
        if (machineSelect) machineSelect.value = order?.machine_id || '';
        if (mpSelect) mpSelect.value = order?.mp || order?.raw_material || '';
        
        // Preencher campos do produto
        const cavitiesField = document.getElementById('order-form-cavities');
        const cycleField = document.getElementById('order-form-cycle');
        const weightField = document.getElementById('order-form-weight');
        const goalField = document.getElementById('order-form-goal');
        
        if (cavitiesField) cavitiesField.value = order?.cavities || '';
        if (cycleField) cycleField.value = order?.cycle || '';
        if (weightField) weightField.value = order?.weight || '';
        if (goalField) goalField.value = order?.pieces_per_hour_goal || '';
        
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    };
    
    window.closeOrderFormModal = function() {
        const modal = document.getElementById('order-form-modal');
        if (modal) modal.classList.add('hidden');
    };
    
    window.refreshOrdersList = function() {
        loadProductionOrders();
    };
    
    // Auto-completar dados do produto ao inserir código da peça
    window.onPartCodeChange = function(code) {
        if (!code || code.trim() === '') return;
        
        const partCode = code.trim();
        console.log('📍 Buscando produto pelo código:', partCode);
        
        // Buscar no productDatabase pelo código
        if (typeof productDatabase !== 'undefined' && productDatabase.length > 0) {
            // Tentar encontrar pelo cod (número)
            let product = productDatabase.find(p => String(p.cod) === partCode);
            
            // Se não encontrou, tentar pelo nome parcial
            if (!product) {
                product = productDatabase.find(p => 
                    p.name && p.name.toLowerCase().includes(partCode.toLowerCase())
                );
            }
            
            if (product) {
                console.log('✅ Produto encontrado:', product);
                
                // Preencher TODOS os campos automaticamente
                const productField = document.getElementById('order-form-product');
                const customerField = document.getElementById('order-form-customer');
                const cavitiesField = document.getElementById('order-form-cavities');
                const cycleField = document.getElementById('order-form-cycle');
                const weightField = document.getElementById('order-form-weight');
                const goalField = document.getElementById('order-form-goal');
                
                // Preencher nome do produto
                if (productField) {
                    productField.value = product.name || '';
                    productField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher cliente
                if (customerField) {
                    customerField.value = product.client || '';
                    customerField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher cavidades
                if (cavitiesField) {
                    cavitiesField.value = product.cavities || '';
                    cavitiesField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher ciclo
                if (cycleField) {
                    cycleField.value = product.cycle || '';
                    cycleField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher peso
                if (weightField) {
                    weightField.value = product.weight || '';
                    weightField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher meta peças/hora
                if (goalField) {
                    goalField.value = product.pieces_per_hour_goal || '';
                    goalField.classList.add('bg-green-50', 'border-green-300');
                }
                
                // Preencher MP automaticamente se existir no produto
                const mpSelect = document.getElementById('order-form-mp');
                const mpInfoDiv = document.getElementById('order-form-mp-info');
                const mpDisplay = document.getElementById('order-form-mp-display');
                
                if (mpSelect && product.mp) {
                    mpSelect.value = product.mp;
                    mpSelect.classList.add('bg-green-50', 'border-green-300');
                    
                    // Mostrar info da MP
                    if (mpInfoDiv && mpDisplay && typeof materiaPrimaDatabase !== 'undefined') {
                        const mpInfo = materiaPrimaDatabase.find(m => m.codigo === product.mp);
                        if (mpInfo) {
                            mpDisplay.textContent = `${mpInfo.codigo} - ${mpInfo.descricao}`;
                            mpInfoDiv.classList.remove('hidden');
                        }
                    }
                }
                
                showNotification(`✅ Produto encontrado: ${product.name} (${product.client})`, 'success');
            } else {
                console.log('❌ Produto não encontrado para o código:', partCode);
                showNotification(`❌ Produto não encontrado para o código: ${partCode}`, 'warning');
                
                // Limpar campos
                const fields = ['order-form-product', 'order-form-customer', 'order-form-cavities', 'order-form-cycle', 'order-form-weight', 'order-form-goal', 'order-form-mp'];
                fields.forEach(fieldId => {
                    const field = document.getElementById(fieldId);
                    if (field) {
                        field.value = '';
                        field.classList.remove('bg-green-50', 'border-green-300');
                    }
                });
                
                // Esconder info da MP
                const mpInfoDiv = document.getElementById('order-form-mp-info');
                if (mpInfoDiv) {
                    mpInfoDiv.classList.add('hidden');
                }
            }
        } else {
            console.log('❌ productDatabase não disponível');
            showNotification('❌ Database de produtos não carregado', 'error');
        }
    };
    
    // Listener para o campo de código da peça
    document.addEventListener('DOMContentLoaded', function() {
        const partCodeInput = document.getElementById('order-form-part-code');
        if (partCodeInput) {
            // Ao perder o foco ou pressionar Enter
            partCodeInput.addEventListener('blur', function() {
                onPartCodeChange(this.value);
            });
            partCodeInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    onPartCodeChange(this.value);
                }
            });
        }
        
        // Listener para o select de MP
        const mpSelect = document.getElementById('order-form-mp');
        if (mpSelect) {
            mpSelect.addEventListener('change', function() {
                const mpInfoDiv = document.getElementById('order-form-mp-info');
                const mpDisplay = document.getElementById('order-form-mp-display');
                
                if (this.value && typeof materiaPrimaDatabase !== 'undefined') {
                    const mpInfo = materiaPrimaDatabase.find(m => m.codigo === this.value);
                    if (mpInfo && mpInfoDiv && mpDisplay) {
                        mpDisplay.textContent = `${mpInfo.codigo} - ${mpInfo.descricao}`;
                        mpInfoDiv.classList.remove('hidden');
                    }
                } else if (mpInfoDiv) {
                    mpInfoDiv.classList.add('hidden');
                }
            });
        }
    });
    
    // Form submit para nova ordem
    document.addEventListener('DOMContentLoaded', function() {
        const form = document.getElementById('order-form-modal-form');
        if (form) {
            form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const id = document.getElementById('order-form-id')?.value;
                const orderData = {
                    order_number: document.getElementById('order-form-number')?.value.trim() || '',
                    part_code: document.getElementById('order-form-part-code')?.value.trim() || '',
                    product: document.getElementById('order-form-product')?.value.trim() || '',
                    lot_size: Number(document.getElementById('order-form-lot-size')?.value) || 0,
                    batch_number: document.getElementById('order-form-batch')?.value.trim() || '',
                    packaging_qty: Number(document.getElementById('order-form-packaging')?.value) || 0,
                    customer: document.getElementById('order-form-customer')?.value.trim() || '',
                    machine_id: document.getElementById('order-form-machine')?.value || '',
                    raw_material: document.getElementById('order-form-mp')?.value || ''
                };
                
                if (!orderData.order_number || !orderData.lot_size) {
                    showNotification('Preencha os campos obrigatórios', 'warning');
                    return;
                }
                
                try {
                    if (id) {
                        await db.collection('production_orders').doc(id).update(orderData);
                        showNotification('Ordem atualizada!', 'success');
                        
                        // Registrar log de edição
                        registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                            orderId: id,
                            orderNumber: orderData.order_number,
                            product: orderData.product,
                            lotSize: orderData.lot_size
                        });
                    } else {
                        orderData.status = 'planejada';
                        orderData.total_produced = 0;
                        orderData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                        const docRef = await db.collection('production_orders').add(orderData);
                        showNotification('Ordem cadastrada!', 'success');
                        
                        // Registrar log de criação
                        registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                            orderId: docRef.id,
                            orderNumber: orderData.order_number,
                            product: orderData.product,
                            lotSize: orderData.lot_size
                        });
                    }
                    closeOrderFormModal();
                    loadProductionOrders();
                } catch (error) {
                    showNotification('Erro ao salvar', 'error');
                }
            });
        }
    });

    // --- NAVEGAÇÃO ---
    function handleNavClick(e) {
        const page = e.currentTarget.dataset.page;
        
        // Se for um link externo (sem data-page), não interceptar
        if (!page) {
            // Permitir comportamento padrão do link
            return;
        }
        
        e.preventDefault();
        
        // Verificar se o usuário tem permissão para acessar esta aba
        if (!window.authSystem.canAccessTab(page)) {
            window.authSystem.showPermissionError();
            return;
        }
        
        navButtons.forEach(btn => btn.classList.remove('active'));
        e.currentTarget.classList.add('active');
        
        pageContents.forEach(content => {
            content.classList.toggle('hidden', content.id !== `${page}-page`);
        });
        
        if (pageTitle) {
            pageTitle.textContent = e.currentTarget.querySelector('span').textContent;
        }
        
        detachActiveListener();

        if (page === 'lancamento') loadLaunchPanel();
        if (page === 'planejamento') listenToPlanningChanges(getProductionDateString());
        if (page === 'ordens') {
            // Carregar ordens de produção
            console.log('[Nav] Abrindo aba Ordens...');
            loadProductionOrders();
        }
        if (page === 'analise') {
            console.log('📊 Abrindo aba de análise');
            
            // Garantir que o listener de ordens de produção está ativo
            setupProductionOrdersTab();
            listenToProductionOrders();
            
            // Executar diagnóstico (apenas em desenvolvimento)
            diagnosticFirestoreData();
            
            // Garantir que os filtros estão configurados
            if (!currentAnalysisFilters.startDate || !currentAnalysisFilters.endDate) {
                setAnalysisDefaultDates();
            }
            // Carregar dados da view ativa
            const activeView = document.querySelector('.analysis-tab-btn.active')?.getAttribute('data-view') || 'overview';
            console.log('📊 View ativa:', activeView);
            loadAnalysisData(activeView);
        }

        if (page === 'qualidade') {
            if (!qualityTabInitialized) {
                setupQualityTab();
            }

            if (qualityResponsavelInput && !qualityResponsavelInput.value) {
                qualityResponsavelInput.value = getCurrentUserName();
            }

            if (qualityPlanSelect && qualityPlanSelect.value && !currentQualityContext) {
                loadQualityContext();
            } else if (!qualityPlanSelect?.value) {
                setQualityStatus('Selecione a data e o plano desejado para carregar o contexto.', 'info');
            }
        }

        if (page === 'teste') {
            setupTestPage();
        }

        if (page === 'teste-piloto') {
            setupPilotTab();
        }

        if (page === 'paradas-longas') {
            setupExtendedDowntimeTab();
            loadExtendedDowntimeList();
        }

        if (page === 'acompanhamento') {
            setupAcompanhamentoTurno();
        }

        if (page === 'historico-sistema') {
            setupHistoricoSistema();
        }

        if (page === 'admin-dados') {
            setupAdminDadosPage();
        }

        if (page === 'qualidade') {
            // Página em construção - apenas renderizar ícones
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (page === 'processo') {
            // Página em construção - apenas renderizar ícones
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (page === 'ajustes') {
            setupAjustesPage();
        }

        if (page === 'relatorios') {
            // O módulo de relatórios já está inicializado pelo DOMContentLoaded
            // Apenas garantir que os ícones lucide estão renderizados
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        if (window.innerWidth < 768) {
            closeSidebar();
        }
    }

    // --- ABA DE TESTES ---
    function setupTestPage() {
        updateTestPageInfo();
        setupTestConsole();
        setupTestTools();
    }

    function updateTestPageInfo() {
        const now = new Date();
        const timeStr = now.toLocaleString('pt-BR');
        const userName = getCurrentUserName();
        const shift = getCurrentShift();
        
        const versionEl = document.getElementById('test-system-version');
        const datetimeEl = document.getElementById('test-current-datetime');
        const userEl = document.getElementById('test-current-user');
        const shiftEl = document.getElementById('test-current-shift');
        
        if (versionEl) versionEl.textContent = 'v8.0 - Modo Teste';
        if (datetimeEl) datetimeEl.textContent = timeStr;
        if (userEl) userEl.textContent = userName;
        if (shiftEl) shiftEl.textContent = `${shift}º Turno`;
    }

    function setupTestConsole() {
        const runBtn = document.getElementById('test-console-run');
        const input = document.getElementById('test-console-input');
        const output = document.getElementById('test-console-output');
        
        if (!runBtn) return;
        
        runBtn.addEventListener('click', () => {
            const code = input?.value || '';
            if (!code.trim()) {
                addTestLog('❌ Código vazio!', 'error');
                return;
            }
            
            try {
                addTestLog(`▶ Executando: ${code.substring(0, 50)}...`, 'info');
                const result = eval(code);
                addTestLog(`✔ Resultado: ${JSON.stringify(result)}`, 'success');
            } catch (error) {
                addTestLog(`✖ Erro: ${error.message}`, 'error');
            }
        });
    }

    function setupTestTools() {
        const clearCacheBtn = document.getElementById('test-clear-cache');
        const reloadBtn = document.getElementById('test-reload-page');
        const devToolsBtn = document.getElementById('test-open-devtools');
        
        if (clearCacheBtn) {
            clearCacheBtn.addEventListener('click', () => {
                localStorage.clear();
                sessionStorage.clear();
                addTestLog('✔ Cache limpo!', 'success');
            });
        }
        
        if (reloadBtn) {
            reloadBtn.addEventListener('click', () => {
                addTestLog('↻ Recarregando página...', 'info');
                setTimeout(() => location.reload(), 500);
            });
        }
        
        if (devToolsBtn) {
            devToolsBtn.addEventListener('click', () => {
                addTestLog('📋 DevTools devem abrir automaticamente (F12)', 'info');
                console.log('🔧 [DEVTOOLS] Aberto manualmente pelo usuário');
            });
        }
    }

    function addTestLog(message, type = 'info') {
        const container = document.getElementById('test-logs-container');
        if (!container) return;
        
        const icons = { success: '✔', error: '✖', info: 'ℹ', warning: '⚠ ' };
        const colors = { success: 'text-green-400', error: 'text-red-400', info: 'text-blue-400', warning: 'text-yellow-400' };
        
        const line = document.createElement('p');
        line.className = colors[type] || colors.info;
        line.textContent = `${icons[type] || '–'} ${message}`;
        
        container.appendChild(line);
        container.scrollTop = container.scrollHeight;
        
        // Manter apenas as últimas 100 linhas
        while (container.children.length > 100) {
            container.removeChild(container.firstChild);
        }
    }

    // --- ABA TESTE PILOTO ---
    function setupPilotTab() {
        updatePilotUserDisplay();
        setPilotReportStatus('', 'info');

        if (!pilotTabInitialized) {
            const today = getProductionDateString();
            if (pilotReportDateInput && !pilotReportDateInput.value) {
                pilotReportDateInput.value = today;
            }
            if (pilotFilterDateInput && !pilotFilterDateInput.value) {
                pilotFilterDateInput.value = today;
            }
            pilotTabInitialized = true;
        }

        refreshPilotReports();
    }

    function updatePilotUserDisplay() {
        if (!pilotReportUserDisplay) return;
        const userName = getCurrentUserName();
        pilotReportUserDisplay.textContent = userName || 'Desconhecido';
    }

    async function handlePilotReportSubmit(event) {
        event.preventDefault();

        if (isSubmittingPilotReport) {
            return;
        }

        const title = pilotReportTitleInput?.value?.trim() || '';
        const description = pilotReportDescriptionInput?.value?.trim() || '';
        let workDay = pilotReportDateInput?.value;

        if (!title || !description) {
            setPilotReportStatus('Informe o problema identificado e a descrição antes de registrar.', 'error');
            return;
        }

        if (!workDay) {
            workDay = getProductionDateString();
            if (pilotReportDateInput) {
                pilotReportDateInput.value = workDay;
            }
        }

        const reporterName = getCurrentUserName() || 'Desconhecido';
        const activeUser = getActiveUser();
        const reporterIdentifier = activeUser?.username || activeUser?.email || activeUser?.id || null;
        const payload = {
            title,
            description,
            workDay,
            reporterName,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            createdAtLocal: new Date().toISOString(),
            status: 'aberto'
        };

        const currentShift = typeof getCurrentShift === 'function' ? getCurrentShift() : null;
        if (currentShift) {
            payload.shift = currentShift;
        }
        if (reporterIdentifier) {
            payload.reporterIdentifier = reporterIdentifier;
        }

        try {
            isSubmittingPilotReport = true;
            if (pilotReportSubmitBtn) {
                pilotReportSubmitBtn.disabled = true;
                pilotReportSubmitBtn.classList.add('opacity-60', 'cursor-not-allowed');
            }
            setPilotReportStatus('Registrando problema...', 'info');

            await db.collection('pilot_test_reports').add(payload);

            setPilotReportStatus('Problema registrado com sucesso!', 'success');
            if (pilotReportTitleInput) pilotReportTitleInput.value = '';
            if (pilotReportDescriptionInput) pilotReportDescriptionInput.value = '';
            updatePilotUserDisplay();

            if (pilotFilterDateInput && pilotFilterDateInput.value !== workDay) {
                pilotFilterDateInput.value = workDay;
                refreshPilotReports();
            }

            setTimeout(() => setPilotReportStatus('', 'info'), 4000);
        } catch (error) {
            console.error('❌ Erro ao registrar problema do Teste Piloto:', error);
            setPilotReportStatus('Erro ao registrar problema. Tente novamente.', 'error');
        } finally {
            isSubmittingPilotReport = false;
            if (pilotReportSubmitBtn) {
                pilotReportSubmitBtn.disabled = false;
                pilotReportSubmitBtn.classList.remove('opacity-60', 'cursor-not-allowed');
            }
        }
    }

    function refreshPilotReports(fromManualTrigger = false) {
        if (!db) return;

        const selectedDate = pilotFilterDateInput?.value || getProductionDateString();
        if (pilotFilterDateInput && !pilotFilterDateInput.value) {
            pilotFilterDateInput.value = selectedDate;
        }

        // Limpar listener anterior se existir
        listenerManager.unsubscribe('pilotReports');

        setPilotReportStatus(fromManualTrigger ? 'Atualizando registros...' : '', 'info');
        setPilotLoadingState(true);
        if (pilotReportEmpty) {
            pilotReportEmpty.textContent = 'Nenhum registro encontrado para a data selecionada.';
            pilotReportEmpty.classList.add('hidden');
        }
        if (pilotReportList) {
            pilotReportList.innerHTML = '';
        }

        try {
            const query = db.collection('pilot_test_reports').where('workDay', '==', selectedDate);
            listenerManager.subscribe('pilotReports', query,
                (snapshot) => {
                    setPilotLoadingState(false);

                    if (fromManualTrigger && !snapshot.metadata.hasPendingWrites) {
                        setPilotReportStatus('Registros atualizados.', 'success');
                        setTimeout(() => setPilotReportStatus('', 'info'), 2500);
                    } else if (!fromManualTrigger) {
                        setPilotReportStatus('', 'info');
                    }

                    const orderedDocs = [...snapshot.docs].sort((a, b) => {
                        const aData = a.data();
                        const bData = b.data();
                        const aMs = getPilotReportTimestamp(aData, a);
                        const bMs = getPilotReportTimestamp(bData, b);
                        return bMs - aMs;
                    });

                    renderPilotReports(orderedDocs);
                },
                (error) => {
                    console.error('❌ Erro ao escutar registros do Teste Piloto:', error);
                    setPilotLoadingState(false);
                    setPilotReportStatus('Erro ao carregar registros. Tente novamente mais tarde.', 'error');
                    if (pilotReportEmpty) {
                        pilotReportEmpty.textContent = 'Erro ao carregar registros para esta data.';
                        pilotReportEmpty.classList.remove('hidden');
                    }
                    if (pilotReportList) {
                        pilotReportList.innerHTML = '';
                    }
                }
            );
        } catch (error) {
            console.error('❌ Erro ao configurar listener do Teste Piloto:', error);
            setPilotLoadingState(false);
            setPilotReportStatus('Erro ao carregar registros. Tente novamente mais tarde.', 'error');
        }
    }

    function renderPilotReports(docSnapshots) {
        if (!pilotReportList) return;

        pilotReportList.innerHTML = '';
        if (pilotReportEmpty) {
            pilotReportEmpty.textContent = 'Nenhum registro encontrado para a data selecionada.';
        }

        if (!docSnapshots || docSnapshots.length === 0) {
            if (pilotReportEmpty) {
                pilotReportEmpty.classList.remove('hidden');
            }
            return;
        }

        if (pilotReportEmpty) {
            pilotReportEmpty.classList.add('hidden');
        }

        docSnapshots.forEach((docSnap) => {
            const data = docSnap.data() || {};
            const card = document.createElement('div');
            card.className = 'p-5 rounded-lg border border-gray-200 shadow-sm hover:border-teal-300 transition';

            const header = document.createElement('div');
            header.className = 'flex flex-col md:flex-row md:items-start md:justify-between gap-3';

            const titleEl = document.createElement('h4');
            titleEl.className = 'text-lg font-semibold text-gray-900 flex items-center gap-2';
            const titleIcon = document.createElement('i');
            titleIcon.setAttribute('data-lucide', 'alert-circle');
            titleIcon.className = 'text-teal-500';
            const titleText = document.createElement('span');
            titleText.textContent = data.title || 'Problema sem título';
            titleEl.appendChild(titleIcon);
            titleEl.appendChild(titleText);

            const meta = document.createElement('div');
            meta.className = 'text-sm text-gray-500 flex flex-col items-start';
            const reporterLine = document.createElement('span');
            reporterLine.textContent = `Registrado por ${data.reporterName || 'Desconhecido'}`;
            meta.appendChild(reporterLine);
            if (data.reporterIdentifier) {
                const identifierLine = document.createElement('span');
                identifierLine.className = 'text-xs text-gray-400';
                identifierLine.textContent = data.reporterIdentifier;
                meta.appendChild(identifierLine);
            }
            const createdAtLine = document.createElement('span');
            createdAtLine.textContent = formatPilotReportDate(data.createdAt, data.createdAtLocal, docSnap);
            meta.appendChild(createdAtLine);

            header.appendChild(titleEl);
            header.appendChild(meta);

            const descriptionEl = document.createElement('p');
            descriptionEl.className = 'mt-4 text-sm text-gray-700 whitespace-pre-line';
            descriptionEl.textContent = data.description || '-';

            const footer = document.createElement('div');
            footer.className = 'mt-4 flex flex-wrap items-center gap-3 text-xs text-gray-500';
            const badge = document.createElement('span');
            badge.className = 'inline-flex items-center gap-1 px-3 py-1 bg-teal-50 text-teal-700 rounded-full font-semibold';
            const badgeIcon = document.createElement('i');
            badgeIcon.setAttribute('data-lucide', 'calendar');
            const badgeText = document.createElement('span');
            badgeText.textContent = data.workDay ? `Dia ${data.workDay}` : 'Dia não informado';
            badge.appendChild(badgeIcon);
            badge.appendChild(badgeText);
            footer.appendChild(badge);

            if (data.shift) {
                const shiftBadge = document.createElement('span');
                shiftBadge.className = 'inline-flex items-center gap-1 px-3 py-1 bg-gray-100 text-gray-600 rounded-full font-semibold';
                const shiftIcon = document.createElement('i');
                shiftIcon.setAttribute('data-lucide', 'clock');
                const shiftText = document.createElement('span');
                shiftText.textContent = `Turno ${data.shift}`;
                shiftBadge.appendChild(shiftIcon);
                shiftBadge.appendChild(shiftText);
                footer.appendChild(shiftBadge);
            }

            card.appendChild(header);
            card.appendChild(descriptionEl);
            card.appendChild(footer);

            pilotReportList.appendChild(card);
        });

        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    function setPilotLoadingState(isLoading) {
        if (pilotReportLoading) {
            pilotReportLoading.classList.toggle('hidden', !isLoading);
        }
        if (pilotReportList) {
            pilotReportList.classList.toggle('opacity-50', isLoading);
        }
    }

    function setPilotReportStatus(message, variant = 'info') {
        if (!pilotReportStatus) return;
        pilotReportStatus.textContent = message || '';
        pilotReportStatus.className = 'text-sm font-semibold h-5';
        if (!message) {
            return;
        }
        const variantClass = variant === 'success' ? 'text-teal-600'
            : variant === 'error' ? 'text-red-600'
            : 'text-gray-600';
        pilotReportStatus.classList.add(variantClass);
    }

    function getPilotReportTimestamp(data, docSnap) {
        if (data?.createdAt && typeof data.createdAt.toMillis === 'function') {
            return data.createdAt.toMillis();
        }
        if (typeof data?.createdAt === 'number') {
            return data.createdAt;
        }
        if (data?.createdAtLocal) {
            const parsed = Date.parse(data.createdAtLocal);
            if (!Number.isNaN(parsed)) {
                return parsed;
            }
        }
        if (docSnap?.updateTime?.toMillis) {
            return docSnap.updateTime.toMillis();
        }
        if (docSnap?.readTime?.toMillis) {
            return docSnap.readTime.toMillis();
        }
        if (docSnap?.metadata?.hasPendingWrites) {
            return Date.now();
        }
        return 0;
    }

    function formatPilotReportDate(createdAt, createdAtLocal, docSnap) {
        let date = null;
        if (createdAt && typeof createdAt.toDate === 'function') {
            date = createdAt.toDate();
        } else if (createdAt && typeof createdAt.toMillis === 'function') {
            date = new Date(createdAt.toMillis());
        } else if (createdAtLocal) {
            const parsed = new Date(createdAtLocal);
            if (!Number.isNaN(parsed.getTime())) {
                date = parsed;
            }
        } else if (docSnap?.updateTime?.toMillis) {
            date = new Date(docSnap.updateTime.toMillis());
        }

        if (!date || Number.isNaN(date.getTime())) {
            return 'Data não disponível';
        }

        return date.toLocaleString('pt-BR', { dateStyle: 'short', timeStyle: 'short' });
    }

    // --- ABA DE AJUSTES (MESTRE) ---
    function setupAjustesPage() {
        if (!ajustesPage) return;

        if (!ajustesPageInitialized) {
            attachAjustesTableListener();
            resetAjustesResults();
            resetAjustesEditor();
            updateAjustesEditStatus('Selecione um registro para habilitar o formulário.', 'info');
            ajustesPageInitialized = true;
            
            // Carregar lista de máquinas para o datalist
            loadAjustesMachinesList().catch((error) => {
                console.warn('[AJUSTES] Falha ao carregar lista de máquinas:', error);
            });
        }

        if (lastAjustesFilters) {
            performAjustesSearch(lastAjustesFilters, { silent: true }).catch((error) => {
                console.warn('[AJUSTES] Falha ao recarregar resultados anteriores:', error);
            });
        }

        lucide.createIcons();
    }

    function handleAjustesSearch(event) {
        event?.preventDefault();

        if (ajustesSearchInFlight) {
            updateAjustesSearchStatus('Já existe uma busca em andamento. Aguarde finalizar.', 'warning');
            return;
        }

        const filters = buildAjustesFiltersFromForm();
        lastAjustesFilters = filters;

        performAjustesSearch(filters).catch((error) => {
            console.error('[AJUSTES] Erro ao executar busca:', error);
            updateAjustesSearchStatus('Erro ao buscar registros. Verifique os filtros e tente novamente.', 'error');
            renderAjustesPlaceholderRow('Não foi possível carregar os registros. Consulte o console para detalhes.', 'error');
        });
    }

    function handleAjustesRefresh(event) {
        event?.preventDefault();

        if (ajustesSearchInFlight) {
            updateAjustesSearchStatus('Uma busca está em execução. Aguarde antes de recarregar.', 'warning');
            return;
        }

        if (lastAjustesFilters) {
            performAjustesSearch(lastAjustesFilters, { fromRefresh: true }).catch((error) => {
                console.error('[AJUSTES] Erro ao atualizar resultados:', error);
                updateAjustesSearchStatus('Erro ao atualizar a lista. Tente novamente.', 'error');
            });
        } else {
            resetAjustesResults();
            resetAjustesEditor();
            updateAjustesSearchStatus('Lista reiniciada. Informe os filtros desejados e clique em Buscar.', 'info');
            updateAjustesEditStatus('Selecione um registro para habilitar o formulário.', 'info');
        }
    }

    async function handleAjustesEditSubmit(event) {
        event?.preventDefault();

        if (ajustesEditForm?.dataset.busy === 'true') {
            updateAjustesEditStatus('Um ajuste já está em andamento. Aguarde.', 'warning');
            return;
        }

        const docId = ajustesEditId?.value?.trim();
        const collectionKey = ajustesEditCollection?.value?.trim();
        if (!docId || !collectionKey) {
            updateAjustesEditStatus('Selecione um registro válido antes de salvar.', 'warning');
            return;
        }

        const config = AJUSTES_COLLECTIONS[collectionKey];
        if (!config) {
            updateAjustesEditStatus('Coleção não suportada para ajustes.', 'error');
            return;
        }

        if (!config.supportsEditing) {
            updateAjustesEditStatus('Este registro é somente leitura nesta ferramenta.', 'warning');
            return;
        }

        const observation = (ajustesEditNotes?.value || '').trim();
        if (!observation) {
            updateAjustesEditStatus('Informe o motivo do ajuste nas observações.', 'warning');
            ajustesEditNotes?.focus();
            return;
        }

        let originalSnapshot = {};
        try {
            originalSnapshot = JSON.parse(ajustesEditOriginal?.value || '{}');
        } catch (error) {
            console.warn('[AJUSTES] Snapshot original inválido:', error);
        }

        const payload = extractAjustesPayloadFromForm(config);
    const diff = computeAjustesDiff(originalSnapshot, payload);
        if (!diff || diff.changedFields.length === 0) {
            updateAjustesEditStatus('Nenhum campo alterado. Ajuste não aplicado.', 'warning');
            return;
        }

        try {
            ajustesEditForm.dataset.busy = 'true';
            setAjustesFormDisabled(true);
            updateAjustesEditStatus('Aplicando ajuste...', 'info');

            const result = await applyAjusteTransaction(config, docId, payload, diff, observation);
            let auditError = null;
            try {
                await registerAjusteLog(config, docId, diff, observation, result.beforeState, result.afterState);
            } catch (logError) {
                auditError = logError;
                console.error('[AJUSTES] Erro ao registrar log de auditoria:', logError);
            }

            if (auditError) {
                updateAjustesEditStatus('Ajuste aplicado, porém falhou ao registrar a auditoria. Verifique os logs.', 'warning');
            } else {
                updateAjustesEditStatus('Ajuste aplicado com sucesso!', 'success');
            }

            if (lastAjustesFilters) {
                await performAjustesSearch(lastAjustesFilters, { silent: true, preserveDocId: docId });
            }

            const updatedRecord = currentAjustesResults.find(
                (item) => item.id === docId && item.collectionKey === collectionKey
            );
            if (updatedRecord) {
                loadAjustesRecordForEditing(updatedRecord);
            }
        } catch (error) {
            console.error('[AJUSTES] Erro ao aplicar ajuste:', error);
            updateAjustesEditStatus(getFriendlyErrorMessage(error), 'error');
        } finally {
            ajustesEditForm.dataset.busy = 'false';
            setAjustesFormDisabled(false);
        }
    }

    function resetAjustesResults() {
        currentAjustesResults = [];
        renderAjustesPlaceholderRow('Nenhum registro carregado. Use os filtros acima para iniciar uma busca.', 'info');
        updateAjustesSearchStatus('Informe os filtros desejados e clique em Buscar.', 'info');
    }

    function resetAjustesEditor() {
        if (ajustesEditForm) ajustesEditForm.reset();
        if (ajustesEditForm) ajustesEditForm.dataset.busy = 'false';
        if (ajustesEditId) ajustesEditId.value = '';
        if (ajustesEditCollection) ajustesEditCollection.value = '';
        if (ajustesEditOriginal) ajustesEditOriginal.value = '';
        if (ajustesEditMachine) ajustesEditMachine.value = '--';
        if (ajustesEditDate) ajustesEditDate.value = '--';
        if (ajustesEditExecuted) ajustesEditExecuted.value = '';
        if (ajustesEditPlanned) ajustesEditPlanned.value = '';
        if (ajustesEditLossesKg) ajustesEditLossesKg.value = '';
        if (ajustesEditLossesPcs) ajustesEditLossesPcs.value = '';
        if (ajustesEditNotes) ajustesEditNotes.value = '';
        renderAjustesLogPlaceholder('Nenhum ajuste registrado ainda.');
        toggleAjustesInputsByConfig(null);
        highlightSelectedAjustesRow(-1);
    }

    function renderAjustesPlaceholderRow(message, tone = 'info') {
        if (!ajustesResultsBody) return;

        ajustesResultsBody.innerHTML = '';
    const row = document.createElement('tr');
    row.className = 'bg-white';
        const cell = document.createElement('td');
        cell.colSpan = 9;
        cell.className = `px-4 py-6 text-center text-sm ${resolveToneClass(tone)}`;
        cell.textContent = message;
        row.appendChild(cell);
        ajustesResultsBody.appendChild(row);
    }

    function updateAjustesSearchStatus(message, tone = 'info') {
        if (!ajustesSearchStatus) return;
        ajustesSearchStatus.className = `text-sm font-medium ${resolveToneClass(tone, 'text-gray-600')}`;
        ajustesSearchStatus.textContent = message;
    }

    function updateAjustesEditStatus(message, tone = 'info') {
        if (!ajustesEditStatus) return;
        ajustesEditStatus.className = `text-sm font-medium ${resolveToneClass(tone, 'text-gray-600')}`;
        ajustesEditStatus.textContent = message;
    }

    function resolveToneClass(tone, fallback = 'text-gray-500') {
        const toneMap = {
            info: 'text-gray-500',
            warning: 'text-amber-600',
            success: 'text-emerald-600',
            error: 'text-red-600'
        };
        return toneMap[tone] || fallback;
    }

    function buildAjustesFiltersFromForm() {
        const collectionKey = ajustesCollectionSelect?.value || 'production_entries';
        const docId = ajustesDocIdInput?.value?.trim() || '';
        const machineRaw = ajustesMachineInput?.value?.trim() || '';
        const machine = machineRaw ? normalizeMachineId(machineRaw) : '';
        const workday = ajustesWorkdayInput?.value || '';

        return {
            collectionKey,
            docId,
            machine,
            workday
        };
    }

    async function performAjustesSearch(filters, options = {}) {
        const { silent = false, fromRefresh = false, preserveDocId = null } = options;
        const config = AJUSTES_COLLECTIONS[filters.collectionKey] || AJUSTES_COLLECTIONS.production_entries;

        if (!silent) {
            updateAjustesSearchStatus('Buscando registros...', 'info');
            renderAjustesPlaceholderRow('Consultando dados. Aguarde...', 'info');
        }

        ajustesSearchInFlight = true;

        try {
            const records = await fetchAjustesRecords(filters, config);
            currentAjustesResults = records;

            if (!records.length) {
                renderAjustesPlaceholderRow('Nenhum registro encontrado com os filtros informados.', 'warning');
                updateAjustesSearchStatus('Nenhum registro encontrado.', 'warning');
                resetAjustesEditor();
                return;
            }

            renderAjustesResults(records, preserveDocId);
            updateAjustesSearchStatus(`${records.length} registro(s) carregado(s) da coleção ${config.label || config.collection}.`, 'success');

            if (fromRefresh) {
                updateAjustesEditStatus('Registros atualizados. Se necessário, selecione novamente para revisar os campos.', 'info');
            }
        } finally {
            ajustesSearchInFlight = false;
        }
    }

    async function fetchAjustesRecords(filters, config) {
        const { docId, machine, workday } = filters;

        if (docId) {
            const docRef = db.collection(config.collection).doc(docId);
            const snapshot = await docRef.get();
            if (!snapshot.exists) {
                throw new Error('Documento não encontrado.');
            }
            const record = buildAjustesResult(snapshot, config, filters.collectionKey);
            if (config.filter && !config.filter(record.data)) {
                return [];
            }
            if (machine && record.machine !== machine) {
                return [];
            }
            if (workday && record.workday !== workday) {
                return [];
            }
            return [record];
        }

        // Estratégia: se houver máquina ou workday, tenta filtrar. Caso contrário, carrega tudo.
        let query = db.collection(config.collection);
        let appliedFilter = false;

        // Tenta filtrar por máquina (com fallback para campos alternativos)
        if (machine && config.machineField) {
            try {
                const altQuery = db.collection(config.collection).where(config.machineField, '==', machine).limit(AJUSTES_DEFAULT_LIMIT);
                const altSnapshot = await altQuery.get();
                if (!altSnapshot.empty) {
                    let altRecords = altSnapshot.docs.map((doc) => buildAjustesResult(doc, config, filters.collectionKey));
                    if (config.filter) {
                        altRecords = altRecords.filter((item) => config.filter(item.data));
                    }
                    if (workday) {
                        altRecords = altRecords.filter((item) => item.workday === workday);
                    }
                    console.log(`[AJUSTES] Encontrados ${altRecords.length} registros para máquina ${machine} via campo ${config.machineField}`);
                    return altRecords;
                }
            } catch (error) {
                console.warn(`[AJUSTES] Falha ao consultar ${config.machineField}:`, error);
            }

            // Tenta campos alternativos de máquina
            if (Array.isArray(config.altMachineFields) && config.altMachineFields.length) {
                for (const altField of config.altMachineFields) {
                    try {
                        const altQuery = db.collection(config.collection).where(altField, '==', machine).limit(AJUSTES_DEFAULT_LIMIT);
                        const altSnapshot = await altQuery.get();
                        if (!altSnapshot.empty) {
                            let altRecords = altSnapshot.docs.map((doc) => buildAjustesResult(doc, config, filters.collectionKey));
                            if (config.filter) {
                                altRecords = altRecords.filter((item) => config.filter(item.data));
                            }
                            if (workday) {
                                altRecords = altRecords.filter((item) => item.workday === workday);
                            }
                            console.log(`[AJUSTES] Encontrados ${altRecords.length} registros para máquina ${machine} via campo alternativo ${altField}`);
                            return altRecords;
                        }
                    } catch (error) {
                        console.warn(`[AJUSTES] Falha ao consultar campo alternativo ${altField}:`, error);
                    }
                }
            }
        }

        // Se houver workday, tenta filtrar por data
        if (workday && Array.isArray(config.dateFields) && config.dateFields.length) {
            try {
                query = query.where(config.dateFields[0], '==', workday);
                appliedFilter = true;
            } catch (error) {
                console.warn('[AJUSTES] Falha ao aplicar filtro de data:', error);
            }
        }

        // Aplica ordenação se disponível
        if (Array.isArray(config.orderCandidates) && config.orderCandidates.length) {
            try {
                query = query.orderBy(config.orderCandidates[0], 'desc');
            } catch (error) {
                console.warn('[AJUSTES] Não foi possível aplicar ordenação:', error);
            }
        }

        query = query.limit(AJUSTES_DEFAULT_LIMIT);

        const snapshot = await query.get();
        let records = snapshot.docs.map((doc) => buildAjustesResult(doc, config, filters.collectionKey));

        if (config.filter) {
            records = records.filter((item) => config.filter(item.data));
        }

        // Filtros adicionais em memória
        if (machine) {
            records = records.filter((item) => item.machine === machine);
        }

        if (workday) {
            records = records.filter((item) => item.workday === workday);
        }

        console.log(`[AJUSTES] Carregados ${records.length} registros após filtros adicionais`);
        return records;
    }

    function buildAjustesResult(docSnapshot, config, collectionKey) {
        const data = docSnapshot.data() || {};
        const machine = resolveMachineFromData(data, config);
        const workday = resolveWorkdayFromData(data, config);
        const turno = resolveShiftLabel(data, config);
        const executed = resolveNumericField(data, config.executedField);
        const planned = resolveNumericField(data, config.plannedField);
        const lossesKg = resolveNumericField(data, config.lossesKgField);
        const lossesPcs = resolveNumericField(data, config.lossesPcsField);
        const description = typeof config.descriptionBuilder === 'function' ? config.descriptionBuilder(data) : '';
        const timestamp = resolveTimestampFromData(data, config);

        return {
            id: docSnapshot.id,
            collection: config.collection,
            collectionKey,
            label: config.label || config.collection,
            data,
            machine,
            workday,
            turno,
            executed,
            planned,
            lossesKg,
            lossesPcs,
            description,
            timestamp
        };
    }

    function renderAjustesResults(records, preserveDocId = null) {
        if (!ajustesResultsBody) return;
        ajustesResultsBody.innerHTML = '';

        records.forEach((record, index) => {
            const qtySegments = [];
            if (record.executed !== null && !Number.isNaN(record.executed)) {
                qtySegments.push(`${formatPieces(record.executed)} pcs`);
            }
            if (record.lossesKg !== null && !Number.isNaN(record.lossesKg)) {
                qtySegments.push(`${formatKg(record.lossesKg)} kg refugo`);
            }
            if (record.lossesPcs !== null && !Number.isNaN(record.lossesPcs)) {
                qtySegments.push(`${formatPieces(record.lossesPcs)} peças refugo`);
            }
            const qtyDisplay = qtySegments.length ? qtySegments.join(' – ') : '-';
            const plannedDisplay = record.planned !== null && !Number.isNaN(record.planned)
                ? `${formatPieces(record.planned)} un`
                : '-';
            const timestampDisplay = record.timestamp ? formatTimestamp(record.timestamp) : '-';

            const row = document.createElement('tr');
            row.className = 'ajustes-result-row hover:bg-amber-50 transition';
            row.dataset.index = index;

            row.innerHTML = `
                <td class="px-3 py-2 text-left font-medium text-gray-700">${escapeHtml(record.label)}</td>
                <td class="px-3 py-2 text-left text-xs break-all text-gray-600">${escapeHtml(record.id)}</td>
                <td class="px-3 py-2 text-left text-gray-700">${escapeHtml(record.machine || '-')}</td>
                <td class="px-3 py-2 text-left text-gray-700">${escapeHtml(record.workday || '-')}<div class="text-xs text-gray-400">${escapeHtml(timestampDisplay)}</div></td>
                <td class="px-3 py-2 text-left text-gray-700">${escapeHtml(record.turno || '-')}</td>
                <td class="px-3 py-2 text-left text-sm text-gray-700">${escapeHtml(record.description || '-')}</td>
                <td class="px-3 py-2 text-right text-gray-700">${qtyDisplay}</td>
                <td class="px-3 py-2 text-right text-gray-700">${plannedDisplay}</td>
                <td class="px-3 py-2 text-left">
                    <button type="button" class="ajustes-select-record inline-flex items-center gap-1 px-3 py-1.5 bg-amber-600 text-white rounded-md text-xs font-semibold hover:bg-amber-700 transition" data-index="${index}">
                        <i data-lucide="edit-3" class="w-3.5 h-3.5"></i>
                        Ajustar
                    </button>
                </td>
            `;

            ajustesResultsBody.appendChild(row);
        });

        lucide.createIcons();

        if (preserveDocId) {
            const selectedIndex = records.findIndex((item) => item.id === preserveDocId);
            if (selectedIndex >= 0) {
                loadAjustesRecordForEditing(records[selectedIndex]);
            }
        }
    }

    function handleAjustesResultClick(event) {
        const trigger = event.target.closest('.ajustes-select-record');
        if (!trigger) return;

        const index = Number(trigger.dataset.index);
        if (!Number.isFinite(index) || index < 0 || index >= currentAjustesResults.length) {
            console.warn('[AJUSTES] Índice inválido selecionado:', index);
            return;
        }

        loadAjustesRecordForEditing(currentAjustesResults[index]);
    }

    function loadAjustesRecordForEditing(record) {
        if (!record) return;
        const config = AJUSTES_COLLECTIONS[record.collectionKey];
        toggleAjustesInputsByConfig(config);

        ajustesEditId.value = record.id;
        ajustesEditCollection.value = record.collectionKey;
        ajustesEditOriginal.value = JSON.stringify(record.data || {});
        ajustesEditMachine.value = record.machine || '--';
        ajustesEditDate.value = record.workday || '-';

        if (config?.editorConfig?.executed && ajustesEditExecuted) {
            ajustesEditExecuted.value = record.executed !== null && !Number.isNaN(record.executed) ? record.executed : '';
        } else if (ajustesEditExecuted) {
            ajustesEditExecuted.value = '';
        }

        if (config?.editorConfig?.planned && ajustesEditPlanned) {
            ajustesEditPlanned.value = record.planned !== null && !Number.isNaN(record.planned) ? record.planned : '';
        } else if (ajustesEditPlanned) {
            ajustesEditPlanned.value = '';
        }

        if (config?.editorConfig?.lossesKg && ajustesEditLossesKg) {
            ajustesEditLossesKg.value = record.lossesKg !== null && !Number.isNaN(record.lossesKg) ? record.lossesKg : '';
        } else if (ajustesEditLossesKg) {
            ajustesEditLossesKg.value = '';
        }

        if (config?.editorConfig?.lossesPcs && ajustesEditLossesPcs) {
            ajustesEditLossesPcs.value = record.lossesPcs !== null && !Number.isNaN(record.lossesPcs) ? record.lossesPcs : '';
        } else if (ajustesEditLossesPcs) {
            ajustesEditLossesPcs.value = '';
        }

        if (ajustesEditNotes) ajustesEditNotes.value = '';

        updateAjustesEditStatus(
            config?.supportsEditing
                ? 'Revise os campos, descreva o motivo e clique em Salvar ajuste.'
                : 'Este registro é apenas para consulta. Ajustes indisponíveis.',
            config?.supportsEditing ? 'info' : 'warning'
        );

        highlightSelectedAjustesRow(record);
        loadAjustesLogsForRecord(record).catch((error) => {
            console.warn('[AJUSTES] Falha ao carregar logs de auditoria:', error);
            renderAjustesLogPlaceholder('Erro ao carregar logs de auditoria. Verifique o console.', 'error');
        });
    }

    function attachAjustesTableListener() {
        if (ajustesResultsBody && !ajustesResultsBody.dataset.listenerAttached) {
            ajustesResultsBody.addEventListener('click', handleAjustesResultClick);
            ajustesResultsBody.dataset.listenerAttached = 'true';
        }
    }

    function toggleAjustesInputsByConfig(config) {
        const controls = [
            { el: ajustesEditExecuted, enabled: Boolean(config?.editorConfig?.executed) },
            { el: ajustesEditPlanned, enabled: Boolean(config?.editorConfig?.planned) },
            { el: ajustesEditLossesKg, enabled: Boolean(config?.editorConfig?.lossesKg) },
            { el: ajustesEditLossesPcs, enabled: Boolean(config?.editorConfig?.lossesPcs) }
        ];

        controls.forEach(({ el, enabled }) => {
            if (!el) return;
            el.dataset.disabledByConfig = enabled ? 'false' : 'true';
            el.disabled = !enabled;
            el.classList.toggle('bg-gray-100', !enabled);
        });

        if (ajustesEditNotes) {
            ajustesEditNotes.disabled = false;
            ajustesEditNotes.classList.remove('bg-gray-100');
        }
    }

    function setAjustesFormDisabled(state) {
        const controls = [
            ajustesEditExecuted,
            ajustesEditPlanned,
            ajustesEditLossesKg,
            ajustesEditLossesPcs,
            ajustesEditNotes
        ];

        controls.forEach((el) => {
            if (!el) return;
            const lockedByConfig = el.dataset.disabledByConfig === 'true';
            el.disabled = state || lockedByConfig;
        });
    }

    function resolveMachineFromData(data, config) {
        if (!data || !config) return null;
        if (config.machineField && data[config.machineField]) {
            return normalizeMachineId(data[config.machineField]);
        }
        if (Array.isArray(config.altMachineFields)) {
            for (const field of config.altMachineFields) {
                if (data[field]) return normalizeMachineId(data[field]);
            }
        }
        if (data.machine) return normalizeMachineId(data.machine);
        if (data.machine_id) return normalizeMachineId(data.machine_id);
        return null;
    }

    function resolveWorkdayFromData(data, config) {
        if (!data) return null;
        const candidates = [...(config?.dateFields || []), 'workDay', 'data', 'date'];
        for (const field of candidates) {
            const value = data[field];
            if (typeof value === 'string' && value.length >= 8) return value;
            if (value instanceof Date && !Number.isNaN(value.getTime())) {
                return formatDateYMD(value);
            }
            if (value && typeof value.toDate === 'function') {
                try {
                    return formatDateYMD(value.toDate());
                } catch (error) {
                    console.warn('[AJUSTES] Falha ao converter campo de data:', field, error);
                }
            }
        }
        return null;
    }

    function resolveShiftLabel(data, config) {
        if (!data) return null;
        const field = config?.turnoField || 'turno';
        const value = data[field];
        if (value === undefined || value === null) return null;
        const numeric = Number(value);
        if (Number.isFinite(numeric) && numeric >= 1 && numeric <= 3) {
            return `${numeric}º Turno`;
        }
        if (typeof value === 'string' && value.trim()) return value.trim();
        return null;
    }

    function resolveNumericField(data, field) {
        if (!data || !field) return null;
        const value = data[field];
        const numeric = Number(value);
        if (!Number.isFinite(numeric)) return null;
        return numeric;
    }

    function resolveTimestampFromData(data, config) {
        const candidates = [...(config?.orderCandidates || []), 'timestamp', 'createdAt', 'updatedAt'];
        for (const field of candidates) {
            const value = data[field];
            if (value && typeof value.toDate === 'function') {
                try {
                    return value.toDate();
                } catch (error) {
                    console.warn('[AJUSTES] Não foi possível converter timestamp:', field, error);
                }
            }
        }
        return null;
    }

    function formatPieces(value) {
        return Number(value).toLocaleString('pt-BR');
    }

    function formatKg(value) {
        return Number(value).toLocaleString('pt-BR', { minimumFractionDigits: 3, maximumFractionDigits: 3 });
    }

    function formatTimestamp(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '-';
        return date.toLocaleString('pt-BR');
    }

    function highlightSelectedAjustesRow(recordOrIndex) {
        const rows = ajustesResultsBody?.querySelectorAll('tr.ajustes-result-row') || [];
        rows.forEach((row) => row.classList.remove('ring', 'ring-amber-400', 'bg-amber-50/60'));

        let targetIndex = -1;
        if (typeof recordOrIndex === 'number') {
            targetIndex = recordOrIndex;
        } else if (recordOrIndex && typeof recordOrIndex === 'object') {
            targetIndex = currentAjustesResults.findIndex(
                (item) => item.id === recordOrIndex.id && item.collectionKey === recordOrIndex.collectionKey
            );
        }

        if (targetIndex >= 0 && targetIndex < rows.length) {
            const row = rows[targetIndex];
            row.classList.add('ring', 'ring-amber-400', 'bg-amber-50/60');
        }
    }

    function extractAjustesPayloadFromForm(config) {
        const payload = {};

        if (config?.editorConfig?.executed && ajustesEditExecuted) {
            payload[config.executedField || 'produzido'] = parseOptionalNumber(ajustesEditExecuted.value);
        }

        if (config?.editorConfig?.planned && ajustesEditPlanned) {
            payload[config.plannedField || 'planned_quantity'] = parseOptionalNumber(ajustesEditPlanned.value);
        }

        if (config?.editorConfig?.lossesKg && ajustesEditLossesKg) {
            payload[config.lossesKgField || 'refugo_kg'] = parseOptionalFloat(ajustesEditLossesKg.value, 3);
        }

        if (config?.editorConfig?.lossesPcs && ajustesEditLossesPcs) {
            payload[config.lossesPcsField || 'refugo_qty'] = parseOptionalNumber(ajustesEditLossesPcs.value);
        }

        return payload;
    }

    function parseOptionalFloat(value, decimals = 2) {
        if (value === null || value === undefined || value === '') return null;
        const numeric = parseFloat(value);
        if (!Number.isFinite(numeric)) return null;
        return Number(numeric.toFixed(decimals));
    }

    function computeAjustesDiff(originalData, newPayload) {
        const changedFields = [];
        const updates = {};

        Object.entries(newPayload).forEach(([field, value]) => {
            const originalValue = originalData ? originalData[field] : undefined;
            const normalizedOriginal = normalizeValueForComparison(originalValue);
            const normalizedNew = normalizeValueForComparison(value);

            if (normalizedOriginal === normalizedNew) {
                return;
            }

            changedFields.push(field);
            updates[field] = value === null ? firebase.firestore.FieldValue.delete() : value;
        });

        return { changedFields, updates };
    }

    function normalizeValueForComparison(value) {
        if (value === undefined || value === null) return null;
        if (typeof value === 'number') return Number(value.toFixed(6));
        if (typeof value === 'string') return value.trim();
        if (value instanceof Date) return value.getTime();
        if (value && typeof value.toDate === 'function') {
            try {
                return value.toDate().getTime();
            } catch (error) {
                console.warn('[AJUSTES] Falha ao normalizar valor para comparação:', error);
            }
        }
        return value;
    }

    async function applyAjusteTransaction(config, docId, payload, diff, observation) {
        const docRef = db.collection(config.collection).doc(docId);
        const currentUser = getActiveUser();
        const userName = getCurrentUserName();

        return db.runTransaction(async (transaction) => {
            const snapshot = await transaction.get(docRef);
            if (!snapshot.exists) {
                throw new Error('Documento não encontrado durante o ajuste.');
            }

            const beforeState = snapshot.data() || {};
            const afterState = { ...beforeState };

            diff.changedFields.forEach((field) => {
                const newValue = payload[field];
                if (newValue === null || newValue === undefined) {
                    delete afterState[field];
                } else {
                    afterState[field] = newValue;
                }
            });

            const updates = {
                ...diff.updates,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                lastManualAdjustment: {
                    executedBy: currentUser?.username || currentUser?.email || 'desconhecido',
                    executedByName: userName || 'Desconhecido',
                    executedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    notes: observation,
                    fields: diff.changedFields
                }
            };

            transaction.update(docRef, updates);

            return { beforeState, afterState };
        });
    }

    async function registerAjusteLog(config, docId, diff, observation, beforeState, afterState) {
        if (!diff || diff.changedFields.length === 0) return;

        const currentUser = getActiveUser();
        const userName = getCurrentUserName();

        const logEntry = {
            docPath: `${config.collection}/${docId}`,
            docId,
            collection: config.collection,
            collectionKey: config.key,
            changedFields: diff.changedFields,
            notes: observation,
            executedBy: currentUser?.username || currentUser?.email || 'desconhecido',
            executedByName: userName || 'Desconhecido',
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            beforeSnapshot: beforeState || null,
            afterSnapshot: afterState || null
        };

        const beforeFields = {};
        const afterFields = {};
        diff.changedFields.forEach((field) => {
            beforeFields[field] = sanitizeLogValue(beforeState ? beforeState[field] : null);
            afterFields[field] = sanitizeLogValue(afterState ? afterState[field] : null);
        });
        logEntry.beforeFields = beforeFields;
        logEntry.afterFields = afterFields;

        await db.collection(AJUSTES_LOG_COLLECTION).add(logEntry);
    }

    async function loadAjustesLogsForRecord(record) {
        renderAjustesLogPlaceholder('Carregando auditoria...');
        const docPath = `${record.collection}/${record.id}`;

        try {
            let query = db.collection(AJUSTES_LOG_COLLECTION)
                .where('docPath', '==', docPath)
                .orderBy('timestamp', 'desc')
                .limit(20);

            let snapshot;
            try {
                snapshot = await query.get();
            } catch (error) {
                console.warn('[AJUSTES] Falha ao ordenar logs (possível índice ausente). Tentando fallback.', error);
                query = db.collection(AJUSTES_LOG_COLLECTION)
                    .where('docPath', '==', docPath)
                    .limit(20);
                snapshot = await query.get();
            }

            const logs = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
            if (!logs.length) {
                renderAjustesLogPlaceholder('Nenhum ajuste registrado ainda para este documento.');
                return;
            }

            renderAjustesLogEntries(logs);
        } catch (error) {
            console.error('[AJUSTES] Erro ao carregar logs de auditoria:', error);
            renderAjustesLogPlaceholder('Erro ao carregar logs de auditoria. Verifique o console.', 'error');
        }
    }

    function renderAjustesLogEntries(logs) {
        if (!ajustesLogBody) return;
        ajustesLogBody.innerHTML = '';

        logs.forEach((log) => {
            const timestamp = log.timestamp && typeof log.timestamp.toDate === 'function'
                ? formatTimestamp(log.timestamp.toDate())
                : '-';
            const fields = Array.isArray(log.changedFields) ? log.changedFields.join(', ') : '-';
            const beforeFields = formatLogFields(log.beforeFields);
            const afterFields = formatLogFields(log.afterFields);
            const notes = log.notes ? escapeHtml(log.notes) : '-';

            const row = document.createElement('tr');
            row.className = 'bg-white hover:bg-gray-50';
            row.innerHTML = `
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(timestamp)}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(log.executedByName || log.executedBy || '-')}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(log.collectionKey || '-')}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(log.docId || '-')}</td>
                <td class="px-3 py-2 text-sm text-gray-700">${escapeHtml(fields)}</td>
                <td class="px-3 py-2 text-xs text-gray-600">${beforeFields}</td>
                <td class="px-3 py-2 text-xs text-gray-600">${afterFields}</td>
                <td class="px-3 py-2 text-xs text-gray-600">${notes}</td>
            `;
            ajustesLogBody.appendChild(row);
        });
    }

    function formatLogFields(fields) {
        if (!fields || typeof fields !== 'object') return '-';
        return Object.entries(fields)
            .map(([field, value]) => `${field}: ${value === null || value === undefined ? 'ˆ…' : escapeHtml(String(value))}`)
            .join(' – ');
    }

    function renderAjustesLogPlaceholder(message, tone = 'info') {
        if (!ajustesLogBody) return;
        ajustesLogBody.innerHTML = '';
        const row = document.createElement('tr');
        const cell = document.createElement('td');
        cell.colSpan = 8;
        cell.className = `px-4 py-6 text-center text-sm ${resolveToneClass(tone)}`;
        cell.textContent = message;
        row.appendChild(cell);
        ajustesLogBody.appendChild(row);
    }

    function getFriendlyErrorMessage(error) {
        if (!error) return 'Erro desconhecido. Verifique o console.';
        if (typeof error === 'string') return error;
        if (error.code === 'permission-denied') {
            return 'Permissão negada para ajustar este registro.';
        }
        if (error.message) return error.message;
        return 'Erro inesperado. Consulte o console para detalhes.';
    }

    function sanitizeLogValue(value) {
        if (value === undefined || value === null) return null;
        if (typeof value === 'number') return Number(value.toFixed(6));
        if (typeof value === 'string') return value.trim();
        if (value instanceof Date) return value.toISOString();
        if (value && typeof value.toDate === 'function') {
            try {
                return value.toDate().toISOString();
            } catch (error) {
                console.warn('[AJUSTES] Falha ao converter timestamp para log:', error);
                return null;
            }
        }
        if (typeof value === 'object') {
            try {
                return JSON.stringify(value);
            } catch (error) {
                console.warn('[AJUSTES] Falha ao serializar valor para log:', error);
            }
        }
        return value;
    }

    async function loadAjustesMachinesList() {
        const datalist = document.getElementById('ajustes-machines-list');
        if (!datalist) return;

        try {
            const machinesSet = new Set();

            // Buscar máquinas de production_entries
            try {
                const prodSnapshot = await db.collection('production_entries').limit(50).get();
                prodSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    const machine = resolveMachineFromData(data, AJUSTES_COLLECTIONS.production_entries);
                    if (machine) machinesSet.add(machine);
                });
            } catch (error) {
                console.warn('[AJUSTES] Erro ao carregar máquinas de production_entries:', error);
            }

            // Buscar máquinas de planning
            try {
                const planSnapshot = await db.collection('planning').limit(50).get();
                planSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    if (data.machine) machinesSet.add(normalizeMachineId(data.machine));
                });
            } catch (error) {
                console.warn('[AJUSTES] Erro ao carregar máquinas de planning:', error);
            }

            // Buscar máquinas de production_orders
            try {
                const ordersSnapshot = await db.collection('production_orders').limit(50).get();
                ordersSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    const machine = resolveMachineFromData(data, AJUSTES_COLLECTIONS.production_orders);
                    if (machine) machinesSet.add(machine);
                });
            } catch (error) {
                console.warn('[AJUSTES] Erro ao carregar máquinas de production_orders:', error);
            }

            // Popular datalist
            datalist.innerHTML = '';
            Array.from(machinesSet).sort().forEach((machine) => {
                const option = document.createElement('option');
                option.value = machine;
                datalist.appendChild(option);
            });

            console.log(`[AJUSTES] Carregadas ${machinesSet.size} máquinas únicas disponíveis`);
        } catch (error) {
            console.error('[AJUSTES] Erro ao carregar lista de máquinas:', error);
        }
    }

    async function diagnosticAjustesMachines() {
        console.log('[AJUSTES-DIAG] Iniciando diagnóstico de máquinas disponíveis...');

        try {
            console.log('[AJUSTES-DIAG] === PRODUCTION ENTRIES ===');
            const prodSnapshot = await db.collection('production_entries').limit(10).get();
            console.log(`Encontrados ${prodSnapshot.size} documentos. Máquinas (raw):`);
            prodSnapshot.docs.forEach((doc) => {
                const data = doc.data();
                console.log(`  ID: ${doc.id}, machine: ${data.machine}, machine_id: ${data.machine_id}, maquina: ${data.maquina}`);
            });

            console.log('[AJUSTES-DIAG] === PLANNING ===');
            const planSnapshot = await db.collection('planning').limit(10).get();
            console.log(`Encontrados ${planSnapshot.size} documentos. Máquinas (raw):`);
            planSnapshot.docs.forEach((doc) => {
                const data = doc.data();
                console.log(`  ID: ${doc.id}, machine: ${data.machine}`);
            });

            console.log('[AJUSTES-DIAG] === PRODUCTION ORDERS ===');
            const ordersSnapshot = await db.collection('production_orders').limit(10).get();
            console.log(`Encontrados ${ordersSnapshot.size} documentos. Máquinas (raw):`);
            ordersSnapshot.docs.forEach((doc) => {
                const data = doc.data();
                console.log(`  ID: ${doc.id}, machine_id: ${data.machine_id}, machine: ${data.machine}, machineId: ${data.machineId}`);
            });
        } catch (error) {
            console.error('[AJUSTES-DIAG] Erro no diagnóstico:', error);
        }
    }

    // --- ABA DE QUALIDADE ---
    function setupQualityTab() {
        if (qualityTabInitialized) return;
        qualityTabInitialized = true;

        const today = getProductionDateString();
        if (qualityDateInput && !qualityDateInput.value) {
            qualityDateInput.value = today;
        }

        const defaultShift = getCurrentShift();

        if (qualityResponsavelInput) {
            qualityResponsavelInput.value = getCurrentUserName();
        }

        if (qualityLoadBtn) {
            qualityLoadBtn.addEventListener('click', (event) => {
                event.preventDefault();
                loadQualityContext();
            });
        }

        if (qualityDateInput) {
            qualityDateInput.addEventListener('change', () => {
                qualityPlansCache = { lastDate: null, plans: [] };
                clearQualityContext(false);
                populateQualityPlanOptions(qualityDateInput.value);
            });
        }

        if (qualityPlanSelect) {
            qualityPlanSelect.addEventListener('change', () => {
                clearQualityContext(false);
                if (qualityPlanSelect.value) {
                    setQualityStatus('Plano selecionado. Clique em "Atualizar contexto" para carregar os dados.', 'info');
                }
            });
        }

        populateQualityPlanOptions(qualityDateInput?.value || today);
        setQualityStatus('Selecione a data e o plano desejado para carregar o contexto.', 'info');

        // Manipuladores de eventos para observações de produção
        if (qualityProdObsSave) {
            qualityProdObsSave.addEventListener('click', () => {
                saveQualityObservation('production');
            });
        }

        // Manipuladores de eventos para observações de qualidade
        if (qualityQualObsSave) {
            qualityQualObsSave.addEventListener('click', () => {
                saveQualityObservation('quality');
            });
        }

        // Manipuladores de eventos para controle de preenchimento
        if (qualityAutoFillBtn) {
            if (!QUALITY_AUTOFILL_ENABLED) {
                qualityAutoFillBtn.disabled = true;
                qualityAutoFillBtn.classList.add('opacity-60', 'cursor-not-allowed');
                qualityAutoFillBtn.title = 'Integração automática temporariamente desativada';
            }

            qualityAutoFillBtn.addEventListener('click', () => {
                if (!QUALITY_AUTOFILL_ENABLED) {
                    showNotification('Integração automática está desativada. Utilize o preenchimento manual.', 'info');
                    return;
                }
                loadQualityContext();
                showNotification('Preenchimento automático reativado!', 'success');
            });
        }

        if (qualityManualClearBtn) {
            qualityManualClearBtn.addEventListener('click', () => {
                clearQualityInputsForManualEntry();
                showNotification('Modo manual ativado. Campos limpos para preenchimento manual.', 'info');
            });
        }

        if (qualityClearAllBtn) {
            qualityClearAllBtn.addEventListener('click', () => {
                if (confirm('Tem certeza que deseja limpar TODOS os dados das tabelas? Esta ação não pode ser desfeita.')) {
                    clearAllQualityInputs();
                    showNotification('Todos os dados foram limpos!', 'success');
                }
            });
        }

        if (qualityPrintBtn && !qualityPrintBtn.dataset.listenerAttached) {
            qualityPrintBtn.addEventListener('click', handleQualityChecklistPrint);
            qualityPrintBtn.dataset.listenerAttached = 'true';
        }

        // Botões de adicionar linhas nas tabelas de molde (verificar se existem)
        var moldCloseAddRowBtn = document.getElementById('mold-close-add-row-btn');
        var moldOpenAddRowBtn = document.getElementById('mold-open-add-row-btn');
        var moldHistoryAddRowBtn = document.getElementById('mold-history-add-row-btn');

        if (moldCloseAddRowBtn && !moldCloseAddRowBtn.dataset.listenerAttached) {
            moldCloseAddRowBtn.addEventListener('click', (event) => {
                event.preventDefault();
                addMoldClosureRow();
            });
            moldCloseAddRowBtn.dataset.listenerAttached = 'true';
        }

        if (moldOpenAddRowBtn && !moldOpenAddRowBtn.dataset.listenerAttached) {
            moldOpenAddRowBtn.addEventListener('click', (event) => {
                event.preventDefault();
                addMoldOpeningRow();
            });
            moldOpenAddRowBtn.dataset.listenerAttached = 'true';
        }

        if (moldHistoryAddRowBtn && !moldHistoryAddRowBtn.dataset.listenerAttached) {
            moldHistoryAddRowBtn.addEventListener('click', (event) => {
                event.preventDefault();
                addMoldHistoryRow();
            });
            moldHistoryAddRowBtn.dataset.listenerAttached = 'true';
        }

        // Obter tbodys para adicionar listeners de remoção
        var moldCloseTbodyEl = document.getElementById('mold-closure-tbody');
        var moldOpenTbodyEl = document.getElementById('mold-opening-tbody');
        var moldHistoryTbodyEl = document.getElementById('mold-history-tbody');

        [moldCloseTbodyEl, moldOpenTbodyEl, moldHistoryTbodyEl].forEach(tbody => {
            if (tbody && !tbody.dataset.moldListenerAttached) {
                tbody.addEventListener('click', handleMoldRowRemoval);
                tbody.dataset.moldListenerAttached = 'true';
            }
        });

        // Tentar carregar dados de hoje automaticamente
        autoLoadQualityDataForToday(today);
    }

    function saveQualityObservation(type) {
        const timeInput = type === 'production' ? qualityProdObsTime : qualityQualObsTime;
        const textInput = type === 'production' ? qualityProdObsText : qualityQualObsText;
        const listContainer = type === 'production' ? qualityProdObsList : qualityQualObsList;

        const time = timeInput?.value || '';
        const text = textInput?.value || '';

        if (!time || !text) {
            showNotification('Por favor, preencha a hora e a observação.', 'warning');
            return;
        }

        // Criar card de observação
        const obsCard = document.createElement('div');
        obsCard.className = 'bg-gray-50 p-2 rounded border-l-2 ' + (type === 'production' ? 'border-blue-500' : 'border-emerald-500');
        obsCard.innerHTML = `
            <div class="flex justify-between items-start gap-2">
                <div>
                    <p class="text-xs font-semibold text-gray-700">${time}</p>
                    <p class="text-xs text-gray-600 mt-1">${escapeHtml(text)}</p>
                </div>
                <button class="text-xs text-red-500 hover:text-red-700 font-semibold">✕</button>
            </div>
        `;

        listContainer?.appendChild(obsCard);

        // Limpar inputs
        if (timeInput) timeInput.value = '';
        if (textInput) textInput.value = '';

        showNotification('Anotação adicionada com sucesso!', 'success');
    }

    async function autoLoadQualityDataForToday(dateValue) {
        try {
            // Buscar planos ativos para hoje
            const plansSnapshot = await db.collection('planning')
                .where('date', '==', dateValue)
                .where('status', '==', 'active')
                .limit(1)
                .get();

            if (plansSnapshot.empty) {
                console.log('ℹ️ Nenhum plano ativo para hoje');
                return;
            }

            // Pegar o primeiro plano ativo
            const planDoc = plansSnapshot.docs[0];
            const planId = planDoc.id;

            // Definir o plano no select
            if (qualityPlanSelect) {
                qualityPlanSelect.value = planId;
                // Disparar evento de mudança para atualizar a lista
                qualityPlanSelect.dispatchEvent(new Event('change'));
                
                // Aguardar um pouco para os dados carregarem
                setTimeout(() => {
                    setQualityStatus('Carregando dados de hoje automaticamente...', 'info');
                    loadQualityContext();
                }, 500);
            }
        } catch (error) {
            console.error('Erro ao carregar dados automaticamente:', error);
            // Não mostrar erro - deixar o usuário escolher manualmente se falhar
        }
    }


    function setQualityStatus(message, type = 'info') {
        if (!qualityStatusMessage) return;
        const classMap = {
            info: 'text-sm text-gray-600',
            success: 'text-sm font-semibold text-emerald-600',
            warning: 'text-sm font-semibold text-amber-600',
            error: 'text-sm font-semibold text-red-600'
        };
        qualityStatusMessage.textContent = message || '';
        qualityStatusMessage.className = classMap[type] || classMap.info;
    }

    function clearQualityContext(resetStatus = true) {
        currentQualityContext = null;

        if (qualityInfoGrid) qualityInfoGrid.innerHTML = '';
        if (qualitySummaryCards) qualitySummaryCards.innerHTML = '';
        if (qualityOperatorsChip) qualityOperatorsChip.textContent = '';
        if (qualityShiftTbody) qualityShiftTbody.innerHTML = '';
        if (qualityShiftEmpty) qualityShiftEmpty.classList.add('hidden');
        if (qualityHourlyTableBody) qualityHourlyTableBody.innerHTML = '';
        if (qualityHourlyEmpty) qualityHourlyEmpty.classList.add('hidden');
        if (qualityHourlyTotal) qualityHourlyTotal.textContent = '';
        if (qualityDowntimeList) qualityDowntimeList.innerHTML = '';
        if (qualityDowntimeEmpty) qualityDowntimeEmpty.classList.add('hidden');
        if (qualityDowntimeTotal) qualityDowntimeTotal.textContent = '';
        if (qualityChecklistStatus) qualityChecklistStatus.textContent = '';
        if (qualityNotesInput) qualityNotesInput.value = '';
        if (qualityActionsInput) qualityActionsInput.value = '';
        if (qualityHistoryList) qualityHistoryList.innerHTML = '';
        if (qualityHistoryEmpty) qualityHistoryEmpty.classList.add('hidden');
        if (qualityHistoryChip) qualityHistoryChip.textContent = '';

        if (qualityContextContainer) {
            qualityContextContainer.classList.remove('opacity-60');
        }

        if (resetStatus) {
            setQualityStatus('Selecione a data e o plano desejado para carregar o contexto.', 'info');
        }
    }

    function clearQualityInputsForManualEntry() {
        // Limpar apenas os inputs de cavidades e inspeção, mantendo o layout visível
        // Isso permite que o usuário preencha manualmente os valores
        
        const cavitiesInputs = document.querySelectorAll('.quality-cavities-input');
        const inspectionInputs = document.querySelectorAll('.quality-inspection-input');
        
        cavitiesInputs.forEach(input => {
            input.value = '';
            input.classList.remove('bg-gray-100', 'text-gray-600');
            input.classList.add('bg-white', 'text-gray-800');
            input.readOnly = false;
        });
        
        inspectionInputs.forEach(input => {
            input.value = '';
            input.classList.remove('bg-gray-100', 'text-gray-600');
            input.classList.add('bg-white', 'text-gray-800');
            input.readOnly = false;
        });

        enableManualPackagingInputs();

        // Limpar observações também
        if (qualityProdObsTime) qualityProdObsTime.value = '';
        if (qualityProdObsText) qualityProdObsText.value = '';
        if (qualityQualObsTime) qualityQualObsTime.value = '';
        if (qualityQualObsText) qualityQualObsText.value = '';
        if (qualityProdObsList) qualityProdObsList.innerHTML = '';
        if (qualityQualObsList) qualityQualObsList.innerHTML = '';
    }

    function clearAllQualityInputs() {
        // Limpar TUDO: cavidades, inspeções, observações
        clearQualityInputsForManualEntry();
        
        // Limpar a barra de controle também (esconder)
        if (qualityControlBar) {
            qualityControlBar.classList.add('hidden');
        }
        
        // Limpar header
        if (qualityProcessHeader) {
            qualityProcessHeader.classList.add('hidden');
        }
        
        // Limpar tabelas - manter a estrutura HTML mas esvaziar conteúdo
        const packagingSpans = document.querySelectorAll('[class*="quality-packaging"]');
        packagingSpans.forEach(span => {
            span.textContent = '-';
            span.title = '';
        });

        document.querySelectorAll('.quality-packaging-input').forEach(input => {
            input.value = '';
        });
        
        setQualityStatus('Todos os dados foram limpos. Selecione um plano para começar.', 'info');
    }

    function enableManualPackagingInputs() {
        const packagingSpans = document.querySelectorAll('[class*="quality-packaging-shift"]');
        packagingSpans.forEach(span => {
            const cell = span.parentElement;
            if (!cell) return;

            span.classList.add('hidden');

            let input = cell.querySelector('input.quality-packaging-input');
            if (!input) {
                input = document.createElement('input');
                input.type = 'text';
                input.className = 'quality-packaging-input w-full h-5 rounded border border-gray-300 bg-white text-center text-xs text-gray-800';
                input.placeholder = 'Saco';
                input.dataset.linkedSpanClass = span.className;
                cell.appendChild(input);
            }

            input.classList.remove('bg-gray-100', 'text-gray-600');
            input.classList.add('bg-white', 'text-gray-800');
            input.readOnly = false;
            input.value = '';
        });
    }

    function handleQualityChecklistPrint() {
        if (!currentQualityContext) {
            showNotification('Carregue um plano antes de imprimir o checklist.', 'warning');
            return;
        }

        const snapshot = buildQualityChecklistSnapshot();
        const html = renderQualityChecklistPrint(snapshot);
        const printWindow = window.open('', '_blank', 'width=1024,height=768');

        if (!printWindow) {
            showNotification('Não foi possível abrir a janela de impressão. Verifique o bloqueador de pop-ups.', 'error');
            return;
        }

        printWindow.document.write(html);
        printWindow.document.close();
        printWindow.focus();

        setTimeout(() => {
            try {
                printWindow.print();
            } catch (err) {
                console.error('Erro ao acionar impressão:', err);
            }
        }, 300);
    }

    function buildQualityChecklistSnapshot() {
        const plan = currentQualityContext?.plan || {};
        const dateValue = currentQualityContext?.date || qualityDateInput?.value || getProductionDateString();
        const responsavel = (qualityResponsavelInput?.value || getCurrentUserName() || '').trim();
        const notes = (qualityNotesInput?.value || '').trim();
        const actions = (qualityActionsInput?.value || '').trim();
        const status = (qualityChecklistStatus?.textContent || '').trim();
        const printedAt = new Date();

        const shiftHours = {
            1: [7, 8, 9, 10, 11, 12, 13, 14],
            2: [15, 16, 17, 18, 19, 20, 21, 22],
            3: [23, 0, 1, 2, 3, 4, 5, 6]
        };

        const shifts = [
            {
                id: 1,
                title: '1º Turno · 07h às 14h',
                theme: 'blue',
                data: collectQualityShiftData(1, shiftHours[1])
            },
            {
                id: 2,
                title: '2º Turno · 15h às 22h',
                theme: 'green',
                data: collectQualityShiftData(2, shiftHours[2])
            },
            {
                id: 3,
                title: '3º Turno · 23h às 06h',
                theme: 'amber',
                data: collectQualityShiftData(3, shiftHours[3])
            }
        ];

        const prodObservations = collectQualityObservations(qualityProdObsList, qualityProdObsTime, qualityProdObsText);
        const qualObservations = collectQualityObservations(qualityQualObsList, qualityQualObsTime, qualityQualObsText);

        return {
            plan,
            dateValue,
            responsavel,
            notes,
            actions,
            status,
            shifts,
            prodObservations,
            qualObservations,
            printedAt
        };
    }

    function collectQualityObservations(listContainer, pendingTimeInput, pendingTextInput) {
        const entries = [];

        if (listContainer) {
            Array.from(listContainer.children || []).forEach(card => {
                if (!(card instanceof HTMLElement)) return;
                const paragraphs = card.querySelectorAll('p');
                const time = paragraphs[0]?.textContent?.trim() || '';
                const text = paragraphs[1]?.textContent?.trim() || '';

                if (text) {
                    entries.push({ time, text });
                }
            });
        }

        const pendingTime = pendingTimeInput?.value?.trim();
        const pendingText = pendingTextInput?.value?.trim();

        if (pendingTime && pendingText) {
            entries.push({ time: pendingTime, text: `${pendingText} (não salvo)` });
        } else if (!pendingTime && pendingText) {
            entries.push({ time: '', text: `${pendingText} (não salvo)` });
        }

        return entries;
    }

    function collectQualityShiftData(shift, hours = []) {
        const rows = hours.map(hour => {
            const cavitiesInput = document.querySelector(`.quality-cavities-input.shift-${shift}.hour-${hour}`);
            const inspectionInput = document.querySelector(`.quality-inspection-input.shift-${shift}.hour-${hour}`);
            const packagingSpan = document.querySelector(`.quality-packaging-shift-${shift}-${hour}`);
            const packagingCell = packagingSpan?.parentElement || null;
            const packagingInput = packagingCell?.querySelector('.quality-packaging-input') || null;

            const cavities = cavitiesInput?.value?.trim() || '';
            const inspection = inspectionInput?.value?.trim() || '';
            const packagingFallback = packagingSpan?.textContent?.trim();
            const packagingValue = packagingInput?.value?.trim() || (packagingFallback === '-' ? '' : (packagingFallback || ''));

            return {
                hour,
                label: formatPrintHour(hour),
                cavities,
                packaging: packagingValue,
                inspection
            };
        });

        return {
            hours: rows.map(row => row.label),
            cavities: rows.map(row => row.cavities || ''),
            packaging: rows.map(row => row.packaging || ''),
            inspection: rows.map(row => row.inspection || '')
        };
    }

    function renderQualityChecklistPrint(snapshot) {
        const { plan, dateValue, responsavel, notes, actions, status, shifts, prodObservations, qualObservations, printedAt } = snapshot;
        const dateLabel = dateValue ? dateValue.split('-').reverse().join('/') : '-';
        const printedLabel = printedAt.toLocaleString('pt-BR');

        const formatMultiline = (value, emptyLabel) => {
            const safe = (value || '').trim();
            if (!safe) return escapeHtml(emptyLabel || '');
            return escapeHtml(safe).replace(/\n/g, '<br />');
        };

        const renderShiftTable = shift => {
            const data = shift.data;
            if (!data || data.hours.length === 0) {
                return '';
            }

            const renderCells = values => values.map(value => {
                const safe = (value || '').trim();
                return `<td>${safe ? escapeHtml(safe) : '&nbsp;'}</td>`;
            }).join('');
            const hoursHeader = data.hours.map(hourLabel => `<th>${escapeHtml(hourLabel)}</th>`).join('');
            const shiftClass = `shift-${shift.theme || 'neutral'}`;

            return `
                <section class="print-section ${shiftClass}">
                    <h3 class="section-title">${escapeHtml(shift.title)}</h3>
                    <table class="print-table print-table-grid">
                        <thead>
                            <tr>
                                <th class="desc-col">Desc</th>
                                ${hoursHeader}
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="row-label">Cavidades</td>
                                ${renderCells(data.cavities)}
                            </tr>
                            <tr>
                                <td class="row-label">Embalagem</td>
                                ${renderCells(data.packaging)}
                            </tr>
                            <tr>
                                <td class="row-label">Inspeção</td>
                                ${renderCells(data.inspection)}
                            </tr>
                        </tbody>
                    </table>
                </section>
            `;
        };

        const renderObs = (title, items) => {
            if (!items || items.length === 0) {
                return `
                    <div class="obs-block">
                        <h4 class="section-subtitle">${escapeHtml(title)}</h4>
                        <p class="muted">Nenhuma observação registrada.</p>
                    </div>
                `;
            }

            const obsItems = items.map(item => `
                <div class="obs-item">
                    <div class="obs-time">${escapeHtml(item.time || '--:--')}</div>
                    <div class="obs-text">${formatMultiline(item.text, '')}</div>
                </div>
            `).join('');

            return `
                <div class="obs-block">
                    <h4 class="section-subtitle">${escapeHtml(title)}</h4>
                    <div class="obs-list">${obsItems}</div>
                </div>
            `;
        };

        return `<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <title>Checklist de Qualidade - ${escapeHtml(plan.product || plan.product_name || plan.product_cod || 'Plano')}</title>
    <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; margin: 20px; color: #1f2937; }
    h1 { font-size: 18px; margin: 0; font-weight: 700; }
    h2 { font-size: 12px; margin: 4px 0 0 0; color: #475569; letter-spacing: 0.08em; text-transform: uppercase; }
    header { border-bottom: 1px solid #e2e8f0; padding-bottom: 12px; margin-bottom: 16px; }
    .meta-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 10px; margin-bottom: 16px; }
    .meta-card { border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px; background: #fafafa; }
    .meta-label { font-size: 9px; text-transform: uppercase; color: #64748b; font-weight: 600; letter-spacing: 0.06em; }
    .meta-value { margin-top: 4px; font-size: 12px; font-weight: 600; color: #0f172a; }
    .print-section { margin-top: 18px; }
    .section-title { font-size: 12px; font-weight: 700; color: #0f172a; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.06em; }
    .print-table { width: 100%; border-collapse: collapse; font-size: 11px; }
    .print-table th, .print-table td { border: 1px solid #e2e8f0; padding: 5px 6px; text-align: center; }
    .print-table th { background: #f1f5f9; color: #0f172a; font-weight: 700; }
    .print-table td { background: #ffffff; font-weight: 500; }
    .print-table .desc-col { width: 70px; text-align: left; padding-left: 8px; }
    .print-table .row-label { background: #f8fafc; text-align: left; font-weight: 700; padding-left: 8px; }
    .print-table-grid td + td { border-left: 1px solid #e2e8f0; }
    .shift-blue .section-title { color: #1d4ed8; }
    .shift-blue .print-table th { background: #e0f2fe; }
    .shift-blue .row-label { background: #eff6ff; }
    .shift-green .section-title { color: #047857; }
    .shift-green .print-table th { background: #dcfce7; }
    .shift-green .row-label { background: #ecfdf5; }
    .shift-amber .section-title { color: #b45309; }
    .shift-amber .print-table th { background: #fef3c7; }
    .shift-amber .row-label { background: #fefce8; }
    .observations-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 14px; }
    .obs-block { display: flex; flex-direction: column; gap: 6px; }
    .section-subtitle { font-size: 11px; font-weight: 700; color: #0f172a; margin: 0; text-transform: uppercase; letter-spacing: 0.05em; }
    .obs-list { border: 1px solid #e2e8f0; border-radius: 6px; padding: 10px; background: #ffffff; display: flex; flex-direction: column; gap: 6px; }
    .obs-item { display: grid; grid-template-columns: 56px 1fr; gap: 6px; font-size: 11px; }
    .obs-time { font-weight: 700; color: #2563eb; }
    .obs-text { color: #1f2937; }
    .muted { font-size: 11px; color: #94a3b8; }
    .notes { border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px; background: #ffffff; font-size: 11px; line-height: 1.5; }
    .footer { margin-top: 28px; display: flex; justify-content: space-between; font-size: 10px; color: #94a3b8; }
    .signature { margin-top: 32px; border-top: 1px solid #e2e8f0; width: 220px; padding-top: 6px; font-size: 10px; text-align: center; color: #475569; }
        @media print {
            body { margin: 16px; }
            .no-print { display: none !important; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Checklist digital de qualidade</h1>
        <h2>Inspeção hora-a-hora</h2>
    </header>

    <section class="meta-grid">
        <div class="meta-card">
            <div class="meta-label">Produto</div>
            <div class="meta-value">${escapeHtml(plan.product || plan.product_name || 'Não informado')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Máquina</div>
            <div class="meta-value">${escapeHtml(plan.machine || '-')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">OP / Plano</div>
            <div class="meta-value">${escapeHtml(plan.order_number || plan.order_id || plan.id || '-')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Data</div>
            <div class="meta-value">${escapeHtml(dateLabel)}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Responsável</div>
            <div class="meta-value">${escapeHtml(responsavel || '-')}</div>
        </div>
        <div class="meta-card">
            <div class="meta-label">Status</div>
            <div class="meta-value">${escapeHtml(status || 'Em preenchimento')}</div>
        </div>
    </section>

    ${shifts.map(renderShiftTable).join('')}

    <section class="print-section">
        <h3 class="section-title">Observações</h3>
        <div class="observations-grid">
            ${renderObs('Produção', prodObservations)}
            ${renderObs('Qualidade', qualObservations)}
        </div>
    </section>

    <section class="print-section">
        <h3 class="section-title">Anotações do checklist</h3>
        <div class="notes">
            <strong>Notas:</strong><br />${formatMultiline(notes, 'Sem anotações.')}
            <br /><br />
            <strong>Ações:</strong><br />${formatMultiline(actions, 'Sem ações registradas.')}
        </div>
    </section>

    <div class="footer">
        <div>Emitido em: ${escapeHtml(printedLabel)}</div>
        <div class="signature">Assinatura do responsável</div>
    </div>
</body>
</html>`;
    }

    function formatPrintHour(hour) {
        const normalized = Number(hour);
        if (!Number.isFinite(normalized)) return String(hour);
        const padded = String((normalized + 24) % 24).padStart(2, '0');
        return `${padded}h`;
    }

    async function populateQualityPlanOptions(dateValue) {
        if (!qualityPlanSelect) return;

        const effectiveDate = dateValue || getProductionDateString();
        if (qualityDateInput && !qualityDateInput.value) {
            qualityDateInput.value = effectiveDate;
        }

        qualityPlanSelect.disabled = true;
        const previousSelection = qualityPlanSelect.value;
        qualityPlanSelect.innerHTML = '<option value="">Carregando planos...</option>';

        try {
            if (!effectiveDate) {
                qualityPlanSelect.innerHTML = '<option value="">Informe a data para listar os planos</option>';
                return;
            }

            if (qualityPlansCache.lastDate === effectiveDate && Array.isArray(qualityPlansCache.plans)) {
                buildQualityPlanOptions(qualityPlansCache.plans, previousSelection);
                return;
            }

            // NOVO: Buscar todos os planejamentos e filtrar os ATIVOS no cliente
            const snapshot = await db.collection('planning').get();
            const allPlans = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const plans = allPlans.filter(isPlanActive);
            plans.sort((a, b) => (a.machine || '').localeCompare(b.machine || ''));
            qualityPlansCache = { lastDate: effectiveDate, plans };

            buildQualityPlanOptions(plans, previousSelection);
        } catch (error) {
            console.error('Erro ao carregar planos para a aba de qualidade:', error);
            qualityPlanSelect.innerHTML = '<option value="">Erro ao carregar planos</option>';
            setQualityStatus('Não foi possível carregar os planos do dia. Tente novamente.', 'error');
        } finally {
            qualityPlanSelect.disabled = false;
        }
    }

    function buildQualityPlanOptions(plans, previousSelection) {
        if (!qualityPlanSelect) return;

        if (!Array.isArray(plans) || plans.length === 0) {
            qualityPlanSelect.innerHTML = '<option value="">Nenhum plano ativo encontrado</option>';
            setQualityStatus('Nenhum plano ativo encontrado. Crie um planejamento para continuar.', 'warning');
            return;
        }

        const options = ['<option value="">Selecione a máquina ou OP planejada</option>'];
        plans.forEach(plan => {
            const machineLabel = escapeHtml(plan.machine || 'Máquina não definida');
            const productLabel = escapeHtml(plan.product || plan.product_cod || 'Produto não informado');
            const statusLabel = (plan.status || 'planejado').toString().replace(/_/g, ' ');
            const optionLabel = `${machineLabel} – ${productLabel} – ${escapeHtml(statusLabel.toUpperCase())}`;
            options.push(`<option value="${plan.id}">${optionLabel}</option>`);
        });

        qualityPlanSelect.innerHTML = options.join('');

        if (previousSelection && plans.some(plan => plan.id === previousSelection)) {
            qualityPlanSelect.value = previousSelection;
        } else if (plans.length === 1) {
            qualityPlanSelect.value = plans[0].id;
            setQualityStatus('Plano selecionado automaticamente. Clique em "Atualizar contexto" para visualizar os dados.', 'info');
        } else {
            qualityPlanSelect.value = '';
            setQualityStatus('Selecione o plano desejado e clique em "Atualizar contexto".', 'info');
        }
    }

    async function loadQualityContext() {
        if (!qualityPlanSelect) return;

        if (!window.authSystem.checkPermissionForAction('view_quality')) {
            return;
        }

        const planId = qualityPlanSelect.value;
        if (!planId) {
            setQualityStatus('Selecione um plano para carregar o contexto.', 'warning');
            return;
        }

        const dateValue = (qualityDateInput?.value || '').trim();
        if (!dateValue) {
            setQualityStatus('Informe a data de produção para continuar.', 'warning');
            return;
        }

        setQualityStatus('Carregando dados integrados do plano selecionado...', 'info');
        if (qualityContextContainer) {
            qualityContextContainer.classList.add('opacity-60');
        }

        try {
            const planDoc = await db.collection('planning').doc(planId).get();
            if (!planDoc.exists) {
                setQualityStatus('Plano não encontrado. Atualize a lista e tente novamente.', 'error');
                return;
            }

            const planData = { id: planDoc.id, ...planDoc.data() };
            const machineId = planData.machine || null;

            const productionSnapshot = await db.collection('production_entries').where('planId', '==', planId).get();
            const productionEntries = productionSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                .filter(entry => (entry.data || entry.workDay || '').slice(0, 10) === dateValue);

            const hourlySnapshot = await db.collection('hourly_production_entries').where('planId', '==', planId).get();
            console.log(`📊 Query 'hourly_production_entries' retornou ${hourlySnapshot.docs.length} documentos para planId=${planId}`);
            
            // Enriquecer hourlyEntries com dados de quantidade de production_entries
            const hourlyEntriesMap = {};
            hourlySnapshot.docs.forEach(doc => {
                const payload = { id: doc.id, ...doc.data() };
                const timestamp = doc.data().timestamp || doc.data().createdAt;
                if (timestamp && typeof timestamp.toDate === 'function') {
                    payload.timestampDate = timestamp.toDate();
                }
                const hora = payload.hora || '00:00';
                if (!hourlyEntriesMap[hora]) {
                    hourlyEntriesMap[hora] = [];
                }
                hourlyEntriesMap[hora].push(payload);
            });

            // Somar quantidades dos production_entries para cada hora
            productionEntries.forEach(entry => {
                const hora = entry.horaInformada || entry.hora || '00:00';
                if (!hourlyEntriesMap[hora]) {
                    hourlyEntriesMap[hora] = [];
                }
                
                // Encontrar ou criar entrada horária para essa quantidade
                let hourEntry = hourlyEntriesMap[hora].find(e => e.produzido === undefined);
                if (!hourEntry) {
                    hourEntry = { hora: hora };
                    hourlyEntriesMap[hora].push(hourEntry);
                }
                
                hourEntry.quantidade = (hourEntry.quantidade || 0) + (Number(entry.produzido || 0));
                hourEntry.produzido = hourEntry.quantidade;
                hourEntry.ciclo_real = (hourEntry.ciclo_real || 0) + (Number(entry.ciclo_real || 0));
                hourEntry.cavidades = entry.cavidades || Number(planData.mold_cavities || 1);
            });

            // Converter map de volta para array
            const hourlyEntries = Object.values(hourlyEntriesMap).flat();
            console.log(`📊 Após enriquecer com production_entries: ${hourlyEntries.length} registros`);
            hourlyEntries.forEach(e => {
                console.log(`  Hora ${e.hora}: ${e.produzido || e.quantidade || 0} peças, ${e.ciclo_real || 0} ciclos`);
            });

            let downtimeEntries = [];
            if (machineId) {
                const downtimeSnapshot = await db.collection('downtime_entries').where('machine', '==', machineId).get();
                downtimeEntries = downtimeSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(entry => (entry.date || entry.workDay || '').slice(0, 10) === dateValue);
            }

            const qualityMetrics = buildQualityMetrics(planData, productionEntries, hourlyEntries, downtimeEntries);

            currentQualityContext = {
                plan: planData,
                date: dateValue,
                machine: machineId,
                productionEntries,
                hourlyEntries,
                downtimeEntries,
                metrics: qualityMetrics,
                operators: qualityMetrics.operators,
                shiftSuggestion: qualityMetrics.shiftSuggestion
            };

            renderQualityContext(currentQualityContext);
            await loadQualityHistory(planId, dateValue);
            setQualityStatus('Dados carregados com sucesso.', 'success');
        } catch (error) {
            console.error('Erro ao carregar dados para a aba de qualidade:', error);
            setQualityStatus('Erro ao carregar os dados. Verifique sua conexão e tente novamente.', 'error');
        } finally {
            if (qualityContextContainer) {
                qualityContextContainer.classList.remove('opacity-60');
            }
            lucide.createIcons();
        }
    }

    function buildQualityMetrics(planData, productionEntries, hourlyEntries, downtimeEntries) {
        const metrics = {
            totals: {
                produced: 0,
                pesoBruto: 0,
                refugoQty: 0,
                refugoKg: 0
            },
            shifts: {
                1: { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 },
                2: { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 },
                3: { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 }
            },
            operators: [],
            downtime: {
                totalMinutes: 0,
                reasons: {}
            },
            hourly: {
                totalKg: 0,
                entries: hourlyEntries.length
            },
            shiftSuggestion: getCurrentShift()
        };

        const operatorSet = new Set();

        productionEntries.forEach(entry => {
            const turnValue = parseInt(entry.turno, 10);
            const produced = Number(entry.produzido || entry.quantity || 0);
            const pesoBruto = Number(entry.peso_bruto || 0);
            const refugoKg = Number(entry.refugo_kg || 0);
            const refugoQty = Number(entry.refugo_qty || entry.perdas_qty || 0);

            if (metrics.shifts[turnValue]) {
                metrics.shifts[turnValue].produced += produced;
                metrics.shifts[turnValue].pesoBruto += pesoBruto;
                metrics.shifts[turnValue].refugoKg += refugoKg;
                metrics.shifts[turnValue].refugoQty += refugoQty;
            }

            metrics.totals.produced += produced;
            metrics.totals.pesoBruto += pesoBruto;
            metrics.totals.refugoKg += refugoKg;
            metrics.totals.refugoQty += refugoQty;

            const operatorName = (entry.registradoPorNome || entry.registradoPor || entry.createdByName || '').toString().trim();
            if (operatorName) {
                operatorSet.add(operatorName);
            }
        });

        hourlyEntries.forEach(entry => {
            metrics.hourly.totalKg += Number(entry.peso_bruto || 0);
        });

        const downtimeReasons = {};
        downtimeEntries.forEach(entry => {
            const duration = Number(entry.duration || 0);
            metrics.downtime.totalMinutes += duration;
            const reasonKey = (entry.reason || 'Sem motivo').toString();
            downtimeReasons[reasonKey] = (downtimeReasons[reasonKey] || 0) + duration;
        });
        metrics.downtime.reasons = downtimeReasons;

        metrics.operators = Array.from(operatorSet);
        metrics.shiftSuggestion = determineSuggestedShift(metrics.shifts) || getCurrentShift();
        metrics.planTarget = Number(planData?.planned_quantity || planData?.order_lot_size || 0);

        return metrics;
    }

    function determineSuggestedShift(shiftMetrics) {
        if (!shiftMetrics) return getCurrentShift();
        let bestShift = 1;
        let bestValue = shiftMetrics[1]?.produced || 0;
        [2, 3].forEach(shift => {
            const produced = shiftMetrics[shift]?.produced || 0;
            if (produced > bestValue) {
                bestValue = produced;
                bestShift = shift;
            }
        });
        return bestShift;
    }

    function formatLocaleNumber(value, fractionDigits = 0) {
        if (!Number.isFinite(value)) return (0).toLocaleString('pt-BR');
        return Number(value).toLocaleString('pt-BR', {
            minimumFractionDigits: fractionDigits,
            maximumFractionDigits: fractionDigits
        });
    }

    function formatMinutesToHuman(minutes) {
        if (!Number.isFinite(minutes) || minutes <= 0) {
            return '0 min';
        }
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        const parts = [];
        if (hours > 0) parts.push(`${hours}h`);
        if (mins > 0) parts.push(`${mins}min`);
        return parts.join(' ') || '0 min';
    }

    function renderQualityContext(context) {
        if (!context) return;

        const { plan, date, metrics, productionEntries, hourlyEntries, downtimeEntries } = context;

        if (qualityInfoGrid) {
            const plannedQty = Number(plan?.planned_quantity || plan?.order_lot_size || 0);
            const producedTotal = metrics.totals.produced || 0;
            const progressPercent = plannedQty > 0 ? Math.min(100, Math.round((producedTotal / plannedQty) * 100)) : 0;
            const progressLabel = plannedQty > 0 ? `${progressPercent}%` : 'N/D';

            qualityInfoGrid.innerHTML = `
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-blue-50 p-2 text-blue-600"><i data-lucide="factory" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Máquina</p>
                        <p class="text-sm font-semibold text-gray-800">${escapeHtml(plan.machine || 'N/D')}</p>
                        <p class="text-xs text-gray-500">${escapeHtml(plan.machine_model || plan.model || '')}</p>
                    </div>
                </div>
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-indigo-50 p-2 text-indigo-600"><i data-lucide="package" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Produto / MP</p>
                        <p class="text-sm font-semibold text-gray-800">${escapeHtml(plan.product || 'Produto não informado')}</p>
                        <p class="text-xs text-gray-500">MP: ${escapeHtml(plan.mp || 'N/D')}</p>
                    </div>
                </div>
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-emerald-50 p-2 text-emerald-600"><i data-lucide="calendar" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Data · Turno sugerido</p>
                        <p class="text-sm font-semibold text-gray-800">${date.split('-').reverse().join('/')}</p>
                        <p class="text-xs text-gray-500">Turno destaque: ${metrics.shiftSuggestion}ú</p>
                    </div>
                </div>
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm flex items-start gap-3">
                    <div class="rounded-full bg-orange-50 p-2 text-orange-500"><i data-lucide="target" class="w-5 h-5"></i></div>
                    <div class="space-y-1">
                        <p class="text-xs uppercase font-semibold text-gray-500">Meta x Produção</p>
                        <p class="text-sm font-semibold text-gray-800">${formatLocaleNumber(producedTotal)} / ${formatLocaleNumber(plannedQty)} pcs</p>
                        <p class="text-xs text-gray-500">Progresso estimado: ${progressLabel}</p>
                    </div>
                </div>
            `;
        }

        if (qualitySummaryCards) {
            const producedTotal = metrics.totals.produced || 0;
            const pesoTotal = metrics.totals.pesoBruto || 0;
            const refugoKg = metrics.totals.refugoKg || 0;
            const refugoQty = metrics.totals.refugoQty || 0;
            const downtimeMinutes = metrics.downtime.totalMinutes || 0;

            // Calcular peso médio por peça
            const pesoMedio = producedTotal > 0 ? pesoTotal / producedTotal : 0;
            // Converter refugo kg para quantidade usando peso médio
            const refugoQtyCalculated = pesoMedio > 0 ? Math.round(refugoKg / pesoMedio) : refugoQty;

            qualitySummaryCards.innerHTML = `
                <div class="rounded-xl border border-blue-200 bg-blue-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-blue-600">Produção total (pcs)</p>
                    <p class="mt-2 text-2xl font-bold text-blue-900">${formatLocaleNumber(producedTotal)}</p>
                </div>
                <div class="rounded-xl border border-amber-200 bg-amber-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-amber-600">Refugo total (pcs)</p>
                    <p class="mt-2 text-2xl font-bold text-amber-900">${formatLocaleNumber(refugoQtyCalculated)}</p>
                    <p class="text-xs text-amber-600 mt-1">${formatLocaleNumber(refugoKg, 2)} kg</p>
                </div>
                <div class="rounded-xl border border-rose-200 bg-rose-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-rose-600">Refugo acumulado (kg)</p>
                    <p class="mt-2 text-2xl font-bold text-rose-900">${formatLocaleNumber(refugoKg, 2)}</p>
                </div>
                <div class="rounded-xl border border-gray-300 bg-gray-50 p-4 shadow-sm">
                    <p class="text-xs uppercase font-semibold text-gray-600">Paradas registradas</p>
                    <p class="mt-2 text-2xl font-bold text-gray-900">${formatMinutesToHuman(downtimeMinutes)}</p>
                </div>
            `;
        }

        if (qualityOperatorsChip) {
            if (metrics.operators.length > 0) {
                qualityOperatorsChip.textContent = `Operadores: ${metrics.operators.join(', ')}`;
            } else {
                qualityOperatorsChip.textContent = 'Nenhum operador identificado nos apontamentos.';
            }
        }

        if (qualityShiftTbody) {
            const rows = [1, 2, 3].map(shift => {
                const data = metrics.shifts[shift] || { produced: 0, pesoBruto: 0, refugoQty: 0, refugoKg: 0 };
                return `
                    <tr>
                        <td class="px-4 py-3 text-sm font-semibold text-gray-700">${shift}º Turno</td>
                        <td class="px-4 py-3 text-right text-sm text-gray-700">${formatLocaleNumber(data.produced)}</td>
                        <td class="px-4 py-3 text-right text-sm text-gray-700">${formatLocaleNumber(data.refugoQty)}</td>
                        <td class="px-4 py-3 text-right text-sm text-gray-700">${formatLocaleNumber(data.refugoKg, 2)}</td>
                    </tr>
                `;
            }).join('');
            qualityShiftTbody.innerHTML = rows;
            if (qualityShiftEmpty) {
                qualityShiftEmpty.classList.toggle('hidden', productionEntries.length > 0);
            }
        }

        if (qualityHourlyTableBody) {
            if (hourlyEntries.length === 0) {
                qualityHourlyTableBody.innerHTML = '';
                if (qualityHourlyEmpty) qualityHourlyEmpty.classList.remove('hidden');
            } else {
                const sortedHourly = [...hourlyEntries].sort((a, b) => (a.hora || '').localeCompare(b.hora || ''));
                qualityHourlyTableBody.innerHTML = sortedHourly.map(entry => {
                    const hour = entry.hora || '--:--';
                    const peso = formatLocaleNumber(Number(entry.peso_bruto || 0), 3);
                    const embalagens = formatLocaleNumber(Number(entry.embalagem_fechada || 0));
                    const tara = entry.usar_tara ? 'Sim' : 'Não';
                    return `
                        <tr>
                            <td class="px-4 py-3 text-sm text-gray-700">${escapeHtml(hour)}</td>
                            <td class="px-4 py-3 text-right text-sm text-gray-700">${peso}</td>
                            <td class="px-4 py-3 text-right text-sm text-gray-700">${embalagens}</td>
                            <td class="px-4 py-3 text-center text-sm text-gray-700">${tara}</td>
                        </tr>
                    `;
                }).join('');
                if (qualityHourlyEmpty) qualityHourlyEmpty.classList.add('hidden');
            }
        }

        if (qualityHourlyTotal) {
            qualityHourlyTotal.textContent = metrics.hourly.entries > 0
                ? `${metrics.hourly.entries} registro(s) · ${formatLocaleNumber(metrics.hourly.totalKg, 2)} kg`
                : '';
        }

        if (qualityDowntimeList) {
            if (downtimeEntries.length === 0) {
                qualityDowntimeList.innerHTML = '';
                if (qualityDowntimeEmpty) qualityDowntimeEmpty.classList.remove('hidden');
            } else {
                const reasonChips = Object.entries(metrics.downtime.reasons || {}).map(([reason, minutes]) => {
                    return `<span class="inline-flex items-center gap-1 rounded-full bg-rose-100 px-2 py-1 text-xs font-semibold text-rose-700">${escapeHtml(reason)} · ${formatMinutesToHuman(minutes)}</span>`;
                }).join('');

                const cards = downtimeEntries
                    .sort((a, b) => (a.startTime || '').localeCompare(b.startTime || ''))
                    .map(entry => {
                        const duration = formatMinutesToHuman(Number(entry.duration || 0));
                        const obs = entry.observations ? `<p class="text-xs text-gray-500 mt-1">${escapeHtml(entry.observations)}</p>` : '';
                        return `
                            <div class="rounded-lg border border-rose-100 bg-rose-50 p-4 shadow-sm">
                                <div class="flex items-start justify-between gap-3">
                                    <div>
                                        <p class="text-sm font-semibold text-rose-800">${escapeHtml(entry.reason || 'Sem motivo')}</p>
                                        <p class="text-xs text-gray-500">${escapeHtml(entry.startTime || '--:--')} ➜ ${escapeHtml(entry.endTime || '--:--')} · ${duration}</p>
                                        ${obs}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');

                qualityDowntimeList.innerHTML = `
                    <div class="flex flex-wrap items-center gap-2 mb-3">${reasonChips}</div>
                    <div class="space-y-3">${cards}</div>
                `;
                if (qualityDowntimeEmpty) qualityDowntimeEmpty.classList.add('hidden');
            }
        }

        if (qualityDowntimeTotal) {
            qualityDowntimeTotal.textContent = metrics.downtime.totalMinutes > 0
                ? formatMinutesToHuman(metrics.downtime.totalMinutes)
                : '';
        }

        if (qualityProcessForm) {
            const suggestedShift = metrics.shiftSuggestion || getCurrentShift();
            const shiftRadio = qualityProcessForm.querySelector(`input[name="quality-shift"][value="${suggestedShift}"]`);
            if (shiftRadio) {
                shiftRadio.checked = true;
            }
        }

        if (qualityChecklistStatus) {
            qualityChecklistStatus.textContent = `Plano vinculado: ${escapeHtml(plan.machine || '---')} · ${escapeHtml(plan.product || '---')}`;
        }

        // Renderizar tabelas de controle de processos
        renderQualityProcessTables(plan, hourlyEntries);

        lucide.createIcons();
    }

    function renderQualityProcessTables(plan, hourlyEntries) {
        if (!plan) {
            if (qualityProcessEmpty) qualityProcessEmpty.classList.remove('hidden');
            if (qualityProcessHeader) qualityProcessHeader.classList.add('hidden');
            if (qualityProcessTables) qualityProcessTables.classList.add('hidden');
            if (qualityControlBar) qualityControlBar.classList.add('hidden');
            if (qualityObservationsSection) qualityObservationsSection.classList.add('hidden');
            return;
        }

        // Mostrar cabeçalho com informações do plano
        if (qualityProcessEmpty) qualityProcessEmpty.classList.add('hidden');
        if (qualityProcessHeader) {
            qualityProcessHeader.classList.remove('hidden');
            if (qualityHeaderProduct) qualityHeaderProduct.textContent = plan.product || '-';
            if (qualityHeaderMachine) qualityHeaderMachine.textContent = plan.machine || '-';
            if (qualityHeaderOrder) qualityHeaderOrder.textContent = plan.order_number || plan.order_id || '-';
        }

        // Mostrar tabelas, barra de controle e observações
        if (qualityProcessTables) qualityProcessTables.classList.remove('hidden');
        if (qualityControlBar) qualityControlBar.classList.remove('hidden');
        if (qualityObservationsSection) qualityObservationsSection.classList.remove('hidden');

        if (!QUALITY_AUTOFILL_ENABLED) {
            clearQualityInputsForManualEntry();
            setQualityStatus('Modo manual ativo: preencha o checklist diretamente na tabela.', 'info');
            return;
        }

        // Popular cavidades e embalagens nas tabelas (modo automático)
        populateQualityProcessTables(hourlyEntries, plan);
    }

    function populateQualityProcessTables(hourlyEntries, plan) {
        if (!plan || !hourlyEntries || hourlyEntries.length === 0) {
            console.log('⚠️ Sem dados para popular tabelas');
            return;
        }

        // Obter cavidades padrão do plano
        const cavitiesStandard = Number(plan.mold_cavities || 1);
        
        // Se não houver capacidade de saco definida, usar quantidade planejada ou padrão
        let bagCapacity = Number(plan.bag_capacity || 0);
        if (bagCapacity <= 0) {
            // Calcular capacidade por saco: quantidade_planejada / 2 (estimativa de 2 sacos)
            const plannedQty = Number(plan.planned_quantity || plan.order_lot_size || 1000);
            bagCapacity = Math.ceil(plannedQty / 2);
        }

        console.log(`📊 Cavidades padrão: ${cavitiesStandard}, Capacidade do saco: ${bagCapacity}`);

        const parsePositiveInt = (value) => {
            const parsed = Number(value);
            return Number.isFinite(parsed) && parsed > 0 ? Math.round(parsed) : null;
        };

        const getShiftActiveCavities = (shift) => {
            const candidatesByShift = {
                1: [
                    plan.active_cavities_t1,
                    plan.active_cavities_T1,
                    plan.activeCavitiesT1,
                    plan.activeCavities?.t1
                ],
                2: [
                    plan.active_cavities_t2,
                    plan.active_cavities_T2,
                    plan.activeCavitiesT2,
                    plan.activeCavities?.t2
                ],
                3: [
                    plan.active_cavities_t3,
                    plan.active_cavities_T3,
                    plan.activeCavitiesT3,
                    plan.activeCavities?.t3
                ]
            };
            const candidates = candidatesByShift[shift] || [];
            for (const candidate of candidates) {
                const parsed = parsePositiveInt(candidate);
                if (parsed !== null) {
                    return parsed;
                }
            }
            return null;
        };

        const activeCavitiesByShift = {
            1: getShiftActiveCavities(1),
            2: getShiftActiveCavities(2),
            3: getShiftActiveCavities(3)
        };

        // Agrupar por hora
        const hourlyMap = {};
        hourlyEntries.forEach(entry => {
            const hora = entry.hora || entry.hour || '00:00';
            const hh = parseInt(hora.split(':')[0], 10);
            if (!hourlyMap[hh]) {
                hourlyMap[hh] = [];
            }
            hourlyMap[hh].push(entry);
        });

        console.log(`📊 Populando tabelas com ${Object.keys(hourlyMap).length} horas de dados`);

        // Manter rastreamento acumulado de produção por turno
        let accumulatedByShift = { 1: 0, 2: 0, 3: 0 };

        // Ordenar horas para processar sequencialmente
        const sortedHours = Object.keys(hourlyMap).map(h => parseInt(h, 10)).sort((a, b) => a - b);

        // Para cada hora, atualizar os campos de cavidades e número de embalagem
        sortedHours.forEach(hh => {
            const entries = hourlyMap[hh];
            
            // Calcular totais para essa hora
            const totalCycles = entries.reduce((sum, e) => sum + (Number(e.ciclo_real || 0)), 0);
            // A quantidade pode estar em: quantidade, produzido, ou precisar ser calculada de peso/cavidades
            let totalQuantity = entries.reduce((sum, e) => sum + (Number(e.quantidade || e.produzido || 0)), 0);
            
            // Se não houver quantidade direta, calcular a partir de ciclo_real * cavidades
            if (totalQuantity === 0) {
                totalQuantity = entries.reduce((sum, e) => {
                    const ciclos = Number(e.ciclo_real || 0);
                    const cavs = Number(e.cavidades || cavitiesStandard);
                    return sum + (ciclos * cavs);
                }, 0);
            }

            console.log(`  Hora ${hh}h: ${totalCycles} ciclos reais, ${totalQuantity} peças produzidas`);

            // Determinar turno baseado nos horários corretos:
            // 1º Turno: 7h - 14h
            // 2º Turno: 15h - 22h
            // 3º Turno: 23h - 6h
            let shift = 3; // Default para 3º Turno
            if (hh >= 7 && hh <= 14) {
                shift = 1;
            } else if (hh >= 15 && hh <= 22) {
                shift = 2;
            }

            // Determinar cavidades reais priorizando o painel de ciclo/cavidades
            let hourlyReportedCavities = null;
            for (const row of entries) {
                const candidates = [
                    row.cavidades,
                    row.cavidade,
                    row.cavidades_ativas,
                    row.cavidade_real,
                    row.active_cavities,
                    row.activeCavities
                ];
                for (const candidate of candidates) {
                    const parsed = parsePositiveInt(candidate);
                    if (parsed !== null) {
                        hourlyReportedCavities = parsed;
                        break;
                    }
                }
                if (hourlyReportedCavities !== null) {
                    break;
                }
            }

            const shiftActiveCavities = activeCavitiesByShift[shift];
            const resolvedCavities = hourlyReportedCavities ?? shiftActiveCavities ?? cavitiesStandard;
            const cavitiesSource = hourlyReportedCavities !== null
                ? 'apontamentos horários'
                : shiftActiveCavities !== null
                    ? 'painel de ciclo/cavidades'
                    : 'planejamento da OP';

            // Atualizar campo de cavidades reais
            const cavitiesInput = document.querySelector(`.quality-cavities-input.shift-${shift}.hour-${hh}`);
            if (cavitiesInput) {
                cavitiesInput.value = resolvedCavities ? String(resolvedCavities) : '';
                cavitiesInput.readOnly = true;
                cavitiesInput.classList.add('bg-gray-100');
                cavitiesInput.title = `Cavidades ativas: ${resolvedCavities} (${cavitiesSource})`;
            }

            // Calcular número de saco e atualizar (acumulado por turno)
            accumulatedByShift[shift] += totalQuantity;
            const bagsCompleted = Math.floor(accumulatedByShift[shift] / bagCapacity);
            const piecesInCurrentBag = accumulatedByShift[shift] % bagCapacity;
            const currentBag = bagsCompleted + 1;

            console.log(`    Turno ${shift} acumulado: ${accumulatedByShift[shift]} peças = ${bagsCompleted} sacos completos + ${piecesInCurrentBag} peças no saco ${currentBag}`);

            // Atualizar campo de embalagem (número do saco atual)
            const packagingSpan = document.querySelector(`.quality-packaging-shift-${shift}-${hh}`);
            if (packagingSpan) {
                packagingSpan.textContent = currentBag > 0 ? `Saco ${currentBag}` : '-';
                packagingSpan.title = `${accumulatedByShift[shift]} peças | ${piecesInCurrentBag}/${bagCapacity} no saco`;
                packagingSpan.classList.add('cursor-help');
            }
        });

        // Preparar observações salvas se existirem
        loadQualityObservations();
    }

    function loadQualityObservations() {
        // Esta função carregará observações salvas do Firestore quando implementado
        console.log('📝 Sistema de observações pronto');
    }


    async function loadQualityHistory(planId, dateValue) {
        if (!planId || !qualityHistoryList) return;

        try {
            const snapshot = await db.collection('process_control_checks').where('planId', '==', planId).get();
            const records = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const filtered = records.filter(record => (record.date || '').slice(0, 10) === dateValue);
            filtered.sort((a, b) => {
                const aTime = a.createdAt?.toMillis ? a.createdAt.toMillis() : 0;
                const bTime = b.createdAt?.toMillis ? b.createdAt.toMillis() : 0;
                return bTime - aTime;
            });

            renderQualityHistory(filtered.slice(0, 5));
        } catch (error) {
            console.error('Erro ao carregar histórico de qualidade:', error);
            if (qualityHistoryList) qualityHistoryList.innerHTML = '';
            if (qualityHistoryEmpty) {
                qualityHistoryEmpty.classList.remove('hidden');
                qualityHistoryEmpty.textContent = 'Erro ao carregar histórico. Tente novamente mais tarde.';
            }
        }
    }

    function renderQualityHistory(records) {
        if (!qualityHistoryList || !qualityHistoryEmpty) return;

        if (!Array.isArray(records) || records.length === 0) {
            qualityHistoryList.innerHTML = '';
            qualityHistoryEmpty.classList.remove('hidden');
            if (qualityHistoryChip) qualityHistoryChip.textContent = '';
            if (qualityChecklistStatus) {
                qualityChecklistStatus.textContent = 'Nenhum checklist salvo para esta data.';
            }
            return;
        }

        qualityHistoryEmpty.classList.add('hidden');
        if (qualityHistoryChip) {
            qualityHistoryChip.textContent = `${records.length} registro(s)`;
        }

        qualityHistoryList.innerHTML = records.map(record => {
            const createdAt = record.createdAt && typeof record.createdAt.toDate === 'function' ? record.createdAt.toDate() : null;
            const createdDateLabel = createdAt ? createdAt.toLocaleDateString('pt-BR') : 'Data não informada';
            const createdTimeLabel = createdAt ? createdAt.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : '--:--';
            const statusLabels = {
                em_execucao: 'Produção em execução',
                setup: 'Em setup',
                ajuste: 'Em ajuste',
                parada: 'Parada'
            };
            const statusLabel = statusLabels[record.status] || 'Status não informado';

            const checkChips = [
                { label: 'Setup', ok: record.checks?.setup },
                { label: 'Parmetros', ok: record.checks?.parameters },
                { label: 'Poka-yokes', ok: record.checks?.pokaYoke },
                { label: 'Organização', ok: record.checks?.clean }
            ].map(item => {
                const icon = item.ok ? 'check' : 'x';
                const classes = item.ok ? 'bg-emerald-100 text-emerald-700 border border-emerald-200' : 'bg-red-100 text-red-700 border border-red-200';
                return `<span class="inline-flex items-center gap-1 rounded-full px-2 py-1 text-xs font-semibold ${classes}"><i data-lucide="${icon}" class="w-3 h-3"></i>${item.label}</span>`;
            }).join(' ');

            const observations = record.observations ? `<p class="text-xs text-gray-600 mt-2"><strong>Observações:</strong> ${escapeHtml(record.observations)}</p>` : '';
            const actions = record.actions ? `<p class="text-xs text-gray-600 mt-1"><strong>Ações:</strong> ${escapeHtml(record.actions)}</p>` : '';

            return `
                <div class="rounded-lg border border-gray-200 bg-white p-4 shadow-sm">
                    <div class="flex flex-col gap-2">
                        <div class="flex flex-col md:flex-row md:items-start md:justify-between gap-2">
                            <div class="flex-1">
                                <p class="text-sm font-semibold text-gray-800">${escapeHtml(statusLabel)}</p>
                                <p class="text-xs text-gray-500">${createdDateLabel} · ${createdTimeLabel} · Turno ${record.turno || '-'} · ${escapeHtml(record.createdByName || 'Responsável não identificado')}</p>
                            </div>
                            <button class="quality-delete-history-btn inline-flex items-center justify-center gap-1 rounded-lg bg-red-100 px-3 py-1 text-xs font-semibold text-red-600 hover:bg-red-200 transition" data-record-id="${record.id}" title="Excluir este lançamento">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                                Excluir
                            </button>
                        </div>
                        <div class="flex flex-wrap gap-2">${checkChips}</div>
                        ${observations}
                        ${actions}
                    </div>
                </div>
            `;
        }).join('');

        // Adicionar event listeners para botões de exclusão
        document.querySelectorAll('.quality-delete-history-btn').forEach(btn => {
            btn.addEventListener('click', deleteQualityHistoryRecord);
        });

        if (qualityChecklistStatus) {
            const latest = records[0];
            const createdAt = latest.createdAt && typeof latest.createdAt.toDate === 'function' ? latest.createdAt.toDate() : null;
            if (createdAt) {
                qualityChecklistStatus.textContent = `Último checklist salvo em ${createdAt.toLocaleDateString('pt-BR')} às ${createdAt.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}`;
            }
        }

        lucide.createIcons();
    }

    async function deleteQualityHistoryRecord(event) {
        event.preventDefault();
        const recordId = event.currentTarget.getAttribute('data-record-id');
        
        if (!recordId) {
            showNotification('ID do registro não encontrado', 'error');
            return;
        }

        // Confirmar exclusão
        if (!confirm('Tem certeza que deseja excluir este lançamento? Esta ação não pode ser desfeita.')) {
            return;
        }

        try {
            await db.collection('process_control_checks').doc(recordId).delete();
            showNotification('Lançamento excluído com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE CHECKLIST QUALIDADE', 'qualidade', {
                recordId: recordId
            });
            
            // Recarregar histórico
            if (currentQualityContext && currentQualityContext.plan) {
                await loadQualityHistory(currentQualityContext.plan.id, currentQualityContext.date);
            }
        } catch (error) {
            console.error('Erro ao excluir lançamento:', error);
            showNotification('Erro ao excluir o lançamento. Tente novamente.', 'error');
        }
    }

    async function getPlansWithProductionDataForDate(dateValue) {
        try {
            // Buscar todos os planos para a data
            const plansSnapshot = await db.collection('planning')
                .where('date', '==', dateValue)
                .get();

            if (plansSnapshot.empty) {
                console.log('ℹ️ Nenhum plano para a data', dateValue);
                return [];
            }

            // Para cada plano, verificar se tem dados de produção
            const plansWithData = [];
            for (const planDoc of plansSnapshot.docs) {
                const planId = planDoc.id;
                const planData = planDoc.data();

                // Verificar se há apontamentos de produção
                const prodSnapshot = await db.collection('production_entries')
                    .where('planId', '==', planId)
                    .limit(1)
                    .get();

                if (!prodSnapshot.empty) {
                    plansWithData.push({
                        id: planId,
                        machine: planData.machine,
                        product: planData.product,
                        status: planData.status,
                        hasData: true
                    });
                }
            }

            return plansWithData;
        } catch (error) {
            console.error('Erro ao buscar planos com dados:', error);
            return [];
        }
    }

    
    function openSidebar() {
        if (sidebar && sidebarOverlay) {
            sidebar.classList.remove('-translate-x-full');
            sidebar.classList.add('sidebar-open');
            sidebarOverlay.classList.remove('hidden');
            sidebarOverlay.classList.add('active');
            sidebar.setAttribute('aria-hidden', 'false');
            sidebarOverlay.setAttribute('aria-hidden', 'false');
            document.body.style.overflow = 'hidden'; // Previne scroll do body
            if (sidebarOpenBtn) {
                sidebarOpenBtn.classList.add('is-active');
                sidebarOpenBtn.setAttribute('aria-expanded', 'true');
            }
        }
    }

    function closeSidebar() {
        if (sidebar && sidebarOverlay) {
            sidebar.classList.add('-translate-x-full');
            sidebar.classList.remove('sidebar-open');
            sidebarOverlay.classList.add('hidden');
            sidebarOverlay.classList.remove('active');
            sidebar.setAttribute('aria-hidden', 'true');
            sidebarOverlay.setAttribute('aria-hidden', 'true');
            document.body.style.overflow = ''; // Restaura scroll do body
            if (sidebarOpenBtn) {
                sidebarOpenBtn.classList.remove('is-active');
                sidebarOpenBtn.setAttribute('aria-expanded', 'false');
            }
        }
    }

    // Toggle collapse/expand sidebar (desktop only)
    function toggleSidebarCollapse() {
        if (!sidebar) return;
        
        const isCollapsed = sidebar.classList.contains('sidebar-collapsed');
        
        if (isCollapsed) {
            // Expandir
            sidebar.classList.remove('sidebar-collapsed');
            sidebar.classList.add('sidebar-expanded');
            localStorage.setItem('sidebar-state', 'expanded');
            console.log('[TRACE][toggleSidebarCollapse] Sidebar expandido');
        } else {
            // Retrair
            sidebar.classList.remove('sidebar-expanded');
            sidebar.classList.add('sidebar-collapsed');
            localStorage.setItem('sidebar-state', 'collapsed');
            console.log('[TRACE][toggleSidebarCollapse] Sidebar retraído');
        }
        
        // Atualizar ícone do toggle
        if (sidebarToggleBtn) {
            lucide.createIcons();
        }
    }

    // Restaurar estado do sidebar ao carregar página
    function restoreSidebarState() {
        if (!sidebar) return;
        
        const savedState = localStorage.getItem('sidebar-state') || 'expanded';
        
        if (savedState === 'collapsed') {
            sidebar.classList.remove('sidebar-expanded');
            sidebar.classList.add('sidebar-collapsed');
            console.log('[TRACE][restoreSidebarState] Sidebar restaurado como retraído');
        } else {
            sidebar.classList.add('sidebar-expanded');
            sidebar.classList.remove('sidebar-collapsed');
            console.log('[TRACE][restoreSidebarState] Sidebar restaurado como expandido');
        }
    }

    function handleAnalysisTabClick(e) {
        const view = e.currentTarget.dataset.view;
        if (view) {
            switchAnalysisView(view);
        }
    }

    function setDateRange(range) {
        const end = new Date();
        const start = new Date();
        
        switch(range) {
            case '7':
                start.setDate(start.getDate() - 7);
                break;
            case '30':
                start.setDate(start.getDate() - 30);
                break;
            case 'month':
                start.setDate(1);
                break;
            default:
                start.setDate(start.getDate() - 7);
        }
        
        if (startDateSelector) startDateSelector.value = start.toISOString().split('T')[0];
        if (endDateSelector) endDateSelector.value = end.toISOString().split('T')[0];
    }
    
    // --- ABA DE PLANEJAMENTO ---
    function setupPlanningTab() {
        if (!planningMachineSelect) return;
        
        const machineOptions = machineDatabase.map(m => {
            const mid = normalizeMachineId(m.id);
            return `<option value="${mid}">${mid} - ${m.model}</option>`;
        }).join('');
        planningMachineSelect.innerHTML = `<option value="">Selecione...</option>${machineOptions}`;

        // Configurar select de código do produto
        const productCodInput = document.getElementById('planning-product-cod');
        const productCodDatalist = document.getElementById('planning-product-cod-list');
        if (productCodInput && productCodDatalist) {
            const sortedProducts = [...productDatabase].sort((a, b) => a.cod - b.cod);
            const escapeOptionLabel = (str = '') => String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
            productCodDatalist.innerHTML = sortedProducts.map(p => {
                const label = `${p.cod} - ${p.name} (${p.client})`;
                const escapedLabel = escapeOptionLabel(label);
                return `<option value="${p.cod}" label="${escapedLabel}">${escapedLabel}</option>`;
            }).join('');
        }
    }

    // --- ABA DE ORDENS DE PRODUÇÃO ---
    function setupProductionOrdersTab() {
        if (!productionOrderCodeInput) return;

        // Popular lista de códigos disponíveis
        if (productionOrderCodeDatalist) {
            const sortedProducts = [...productDatabase].sort((a, b) => a.cod - b.cod);
            const escapeOptionLabel = (str = '') => String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');

            productionOrderCodeDatalist.innerHTML = sortedProducts.map(product => {
                const label = `${product.cod} - ${product.name} (${product.client})`;
                const escaped = escapeOptionLabel(label);
                return `<option value="${product.cod}" label="${escaped}">${escaped}</option>`;
            }).join('');
        }

        // Popular select de máquinas no formulário
        populateOrderMachineSelect();

        productionOrderCodeInput.addEventListener('input', handleProductionOrderCodeInput);
        productionOrderCodeInput.addEventListener('change', handleProductionOrderCodeSelection);

        initOrdersFilters();
        listenToProductionOrders();
    }

    function populatePlanningOrderSelect() {
        // Função mantida para compatibilidade - agora a busca usa o cache productionOrdersCache
        // Não é mais necessário popular um select com options
        if (!Array.isArray(productionOrdersCache)) return;
        
        console.log(`[Planejamento] Cache atualizado com ${productionOrdersCache.length} OPs`);
    }

    function handleProductionOrderCodeInput(e) {
        const rawCode = (e.target.value || '').trim();

        if (!rawCode) {
            clearProductionOrderAutoFields();
            setProductionOrderFeedback();
            return;
        }

        // Enquanto o usuário digita, ocultar mensagens para evitar falso negativo
        setProductionOrderFeedback();
    }

    function handleProductionOrderCodeSelection(e) {
        const rawCode = (e.target.value || '').trim();

        if (!rawCode) {
            clearProductionOrderAutoFields();
            setProductionOrderFeedback();
            return;
        }

        // Usar índice Map para O(1) lookup em vez de O(n) search
        const product = window.databaseModule.productByCode.get(Number(rawCode)) || 
                       window.databaseModule.productByCode.get(rawCode);

        if (product) {
            fillProductionOrderFields(product);
            const clientLabel = product.client ? ` – ${product.client}` : '';
            setProductionOrderFeedback(`Produto carregado: ${product.name}${clientLabel}`, 'success');
            return;
        }

        clearProductionOrderAutoFields();
        setProductionOrderFeedback('Produto não encontrado na base. Preencha manualmente.', 'error');
    }

    function fillProductionOrderFields(product) {
        if (!product) return;

        if (productionOrderProductInput) {
            productionOrderProductInput.value = product.name || '';
        }

        if (productionOrderCustomerInput) {
            productionOrderCustomerInput.value = product.client || '';
        }

        if (productionOrderRawMaterialInput) {
            productionOrderRawMaterialInput.value = product.mp || '';
        }
    }

    function clearProductionOrderAutoFields() {
        if (productionOrderProductInput) productionOrderProductInput.value = '';
        if (productionOrderCustomerInput) productionOrderCustomerInput.value = '';
        if (productionOrderRawMaterialInput) productionOrderRawMaterialInput.value = '';
    }

    function setProductionOrderFeedback(message = '', type = 'info') {
        if (!productionOrderFeedback) return;

        if (!message) {
            productionOrderFeedback.textContent = '';
            productionOrderFeedback.style.display = 'none';
            productionOrderFeedback.className = 'mt-2 text-sm font-medium text-primary-blue';
            return;
        }

        const baseClasses = 'mt-2 text-sm font-medium';
        const typeClass = type === 'success'
            ? 'text-emerald-600'
            : type === 'error'
                ? 'text-red-600'
                : 'text-primary-blue';

        productionOrderFeedback.textContent = message;
        productionOrderFeedback.style.display = 'block';
        productionOrderFeedback.className = `${baseClasses} ${typeClass}`;
    }

    function escapeHtml(str = '') {
        return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function normalizeNumericString(value) {
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        if (!trimmed) return null;

        const thousandPatternPtBr = /^\d{1,3}(\.\d{3})+(,\d+)?$/;
        const thousandPatternEn = /^\d{1,3}(,\d{3})+(\.\d+)?$/;

        const hasComma = trimmed.includes(',');
        const hasDot = trimmed.includes('.');

        // Se possuir apenas vírgula (formato típico pt-BR), tratar como decimal
        if (hasComma && !hasDot) {
            return trimmed.replace(/\s+/g, '').replace(',', '.');
        }

        if (thousandPatternPtBr.test(trimmed)) {
            return trimmed.replace(/\./g, '').replace(',', '.');
        }

        if (thousandPatternEn.test(trimmed)) {
            return trimmed.replace(/,/g, '');
        }

        // Caso geral: remover espaços e trocar vírgula por ponto
        return trimmed.replace(/\s+/g, '').replace(',', '.');
    }

    function parseOptionalNumber(value) {
        if (value === null || value === undefined || value === '') return null;

        if (typeof value === 'number') {
            return Number.isFinite(value) ? value : null;
        }

        if (typeof value === 'string') {
            const normalized = normalizeNumericString(value);
            if (normalized === null) return null;
            const parsed = Number(normalized);
            return Number.isFinite(parsed) ? parsed : null;
        }

        const fallback = Number(value);
        return Number.isFinite(fallback) ? fallback : null;
    }

    function coerceToNumber(value, fallback = 0) {
        const parsed = parseOptionalNumber(value);
        return parsed === null ? fallback : parsed;
    }

    function getProductionOrderStatusBadge(status = 'planejada') {
        const statusMap = {
            'planejada': { label: 'Planejada', className: 'bg-sky-100 text-sky-700' },
            'em_andamento': { label: 'Em andamento', className: 'bg-amber-100 text-amber-700' },
            'concluida': { label: 'Concluída', className: 'bg-emerald-100 text-emerald-700' },
            'cancelada': { label: 'Cancelada', className: 'bg-red-100 text-red-700' }
        };

        const safeStatus = statusMap[status] || statusMap['planejada'];
        return `<span class="px-2 py-1 rounded-full text-xs font-semibold ${safeStatus.className}">${safeStatus.label}</span>`;
    }

    function setProductionOrderStatus(message = '', type = 'info') {
        if (!productionOrderStatusMessage) return;

        if (!message) {
            productionOrderStatusMessage.textContent = '';
            productionOrderStatusMessage.className = 'text-sm font-semibold h-5 text-center';
            return;
        }

        const baseClasses = 'text-sm font-semibold h-5 text-center';
        const typeClass = type === 'success'
            ? 'text-status-success'
            : type === 'error'
                ? 'text-status-error'
                : 'text-gray-600';

        productionOrderStatusMessage.textContent = message;
        productionOrderStatusMessage.className = `${baseClasses} ${typeClass}`;
    }

    function populateOrdersFilterMachine() {
        if (!ordersFilterMachine) return;

        const machineSet = new Set();
        if (Array.isArray(productionOrdersCache)) {
            productionOrdersCache.forEach(order => {
                const machineId = (order.machine_id || order.machine || '').trim();
                if (machineId) machineSet.add(machineId);
            });
        }

        const currentValue = ordersFilterMachine.value;
        ordersFilterMachine.innerHTML = '<option value="">Todas as máquinas</option>';

        Array.from(machineSet).sort().forEach(machineId => {
            const option = document.createElement('option');
            option.value = machineId;
            option.textContent = machineId;
            ordersFilterMachine.appendChild(option);
        });

        if (currentValue && Array.from(ordersFilterMachine.options).some(opt => opt.value === currentValue)) {
            ordersFilterMachine.value = currentValue;
        }
    }

    function applyOrdersFilters() {
        if (!Array.isArray(productionOrdersCache)) {
            renderProductionOrdersTable([]);
            return;
        }

        const machineFilter = (ordersFilterMachine?.value || '').trim();
        const statusFilter = (ordersFilterStatus?.value || '').trim();
        const searchFilter = (ordersFilterSearch?.value || '').trim().toLowerCase();

        let result = [...productionOrdersCache];

        if (machineFilter) {
            result = result.filter(order => {
                const machineId = (order.machine_id || order.machine || '').trim();
                return machineId === machineFilter;
            });
        }

        if (statusFilter) {
            result = result.filter(order => (order.status || '').trim() === statusFilter);
        }

        if (searchFilter) {
            result = result.filter(order => {
                const parts = [
                    order.order_number || order.orderNumber || '',
                    order.product || order.product_name || '',
                    order.customer || order.client || '',
                    order.part_code || order.product_cod || ''
                ];
                return parts.some(p => String(p).toLowerCase().includes(searchFilter));
            });
        }

        filteredProductionOrders = result;
        populateOrdersFilterMachine();
        renderProductionOrdersTable(filteredProductionOrders);
    }

    function initOrdersFilters() {
        if (!ordersFilterMachine && !ordersFilterStatus && !ordersFilterSearch) return;

        if (ordersFilterMachine) {
            ordersFilterMachine.addEventListener('change', () => {
                applyOrdersFilters();
            });
        }

        if (ordersFilterStatus) {
            ordersFilterStatus.addEventListener('change', () => {
                applyOrdersFilters();
            });
        }

        if (ordersFilterSearch) {
            let searchTimeout;
            ordersFilterSearch.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    applyOrdersFilters();
                }, 250);
            });
        }

        applyOrdersFilters();
    }

    function renderProductionOrdersTable(orders = []) {
        if (!productionOrderTableBody) return;

        if (!Array.isArray(orders) || orders.length === 0) {
            productionOrderTableBody.innerHTML = '';
            if (productionOrderEmptyState) {
                productionOrderEmptyState.style.display = 'block';
            }
            return;
        }

        const rows = orders.map(order => {
            const orderNumber = escapeHtml(order.order_number || order.orderNumber || '-');
            const productName = escapeHtml(order.product || order.product_name || '-');
            const customer = escapeHtml(order.customer || order.client || '-');
            const productCode = escapeHtml(order.part_code || order.product_cod || '-');
            const lotSizeNumber = parseOptionalNumber(order.lot_size || order.lotSize);
            const lotSizeDisplay = Number.isFinite(lotSizeNumber) && lotSizeNumber > 0
                ? lotSizeNumber.toLocaleString('pt-BR')
                : '-';
            const statusBadge = getProductionOrderStatusBadge(order.status);
            const createdAt = order.createdAt?.toDate ? order.createdAt.toDate() : null;
            const createdAtLabel = createdAt ? createdAt.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' }) : '-';

            return `
                <tr class="odd:bg-white even:bg-gray-50" data-order-id="${escapeHtml(order.id || '')}">
                    <td class="px-3 py-2 text-sm border align-middle font-semibold text-gray-800">${orderNumber}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-gray-700">${productName}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-gray-700">${customer}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-gray-700">${productCode}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-center text-gray-700">${lotSizeDisplay}</td>
                    <td class="px-3 py-2 text-sm border align-middle text-center">${statusBadge}</td>
                    <td class="px-3 py-2 text-sm border align-middle">
                        <div class="flex items-center justify-center gap-2 text-gray-400">
                            <i data-lucide="clock" class="w-4 h-4"></i>
                            <span class="text-xs font-medium">${createdAtLabel}</span>
                        </div>
                    </td>
                    <td class="px-3 py-2 text-sm border align-middle">
                        <div class="flex items-center justify-center gap-1 flex-wrap">
                            <button type="button" class="edit-production-order p-1.5 text-blue-600 hover:bg-blue-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Editar ordem">
                                <i data-lucide="edit-2" class="w-4 h-4"></i>
                            </button>
                            ${order.status === 'ativa' ? `
                                <button type="button" class="finish-production-order p-1.5 text-green-600 hover:bg-green-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Finalizar OP">
                                    <i data-lucide="check-circle" class="w-4 h-4"></i>
                                </button>
                            ` : order.status !== 'concluida' ? `
                                <button type="button" class="activate-production-order p-1.5 text-green-600 hover:bg-green-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" data-machine-id="${escapeHtml(order.machine_id || '')}" title="Ativar OP">
                                    <i data-lucide="play-circle" class="w-4 h-4"></i>
                                </button>
                            ` : ''}
                            <button type="button" class="adjust-quantity-order p-1.5 text-yellow-600 hover:bg-yellow-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Ajustar quantidade">
                                <i data-lucide="package-minus" class="w-4 h-4"></i>
                            </button>
                            ${order.status !== 'ativa' ? `
                                <button type="button" class="delete-production-order p-1.5 text-red-600 hover:bg-red-50 rounded transition-colors" data-order-id="${escapeHtml(order.id || '')}" title="Excluir ordem">
                                    <i data-lucide="trash-2" class="w-4 h-4"></i>
                                </button>
                            ` : ''}
                        </div>
                    </td>
                </tr>
            `;
        }).join('');

        productionOrderTableBody.innerHTML = rows;
        if (productionOrderEmptyState) {
            productionOrderEmptyState.style.display = 'none';
        }

        // Adicionar listeners para todos os botões da tabela
        document.querySelectorAll('.edit-production-order').forEach(btn => {
            btn.addEventListener('click', handleEditProductionOrder);
        });
        document.querySelectorAll('.activate-production-order').forEach(btn => {
            btn.addEventListener('click', handleActivateProductionOrder);
        });
        document.querySelectorAll('.finish-production-order').forEach(btn => {
            btn.addEventListener('click', handleFinishProductionOrder);
        });
        document.querySelectorAll('.adjust-quantity-order').forEach(btn => {
            btn.addEventListener('click', handleAdjustQuantityOrder);
        });
        document.querySelectorAll('.delete-production-order').forEach(btn => {
            btn.addEventListener('click', handleDeleteProductionOrder);
        });

        lucide.createIcons();
    }

    function handleEditProductionOrder(e) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar ordens
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('editar ordens de produção');
            return;
        }
        
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);
        if (!order) return;

        // Preencher form com dados da ordem para edição
        if (productionOrderForm) {
            document.getElementById('order-number').value = order.order_number || '';
            document.getElementById('order-product').value = order.product || '';
            document.getElementById('order-lot-size').value = order.lot_size || '';
            document.getElementById('order-batch').value = order.batch_number || '';
            document.getElementById('order-customer-order').value = order.customer_order || '';
            document.getElementById('order-customer').value = order.customer || '';
            document.getElementById('order-part-code').value = order.part_code || '';
            document.getElementById('order-packaging-qty').value = order.packaging_qty || '';
            document.getElementById('order-internal-packaging-qty').value = order.internal_packaging_qty || '';
            document.getElementById('order-raw-material').value = order.raw_material || '';

            // Salvar ID para update
            productionOrderForm.dataset.editingOrderId = orderId;

            // Mudar texto do botão
            const submitButton = productionOrderForm.querySelector('button[type="submit"]');
            if (submitButton) {
                submitButton.innerHTML = `<i data-lucide="save"></i><span>Salvar Alterações</span>`;
            }

            // Scroll para o formulário
            productionOrderForm.scrollIntoView({ behavior: 'smooth', block: 'start' });
            lucide.createIcons();
        }
    }

    async function handleActivateProductionOrder(e) {
        e.preventDefault();
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);
        let machineId = e.currentTarget.dataset.machineId || order?.machine_id || selectedMachineData?.machine || '';

        if (!order) {
            alert('Dados da ordem não encontrados.');
            return;
        }

        if (!machineId) {
            const input = prompt('Informe a máquina para ativar esta OP (ex.: H-01):');
            if (!input) return;
            machineId = input.trim();
        }

        try {
            setProductionOrderStatus('Ativando ordem...', 'info');
            const success = await setOrderAsActive(orderId, machineId);
            
            if (success) {
                setProductionOrderStatus('Ordem ativada com sucesso!', 'success');
                
                // Registrar log
                registrarLogSistema('ATIVAÇÃO DE ORDEM', 'ordem', {
                    orderId: orderId,
                    orderNumber: order.order_number || order.codigoOP,
                    machine: machineId
                });
                
                // Atualizar listas e painel
                if (typeof loadProductionOrders === 'function') {
                    await loadProductionOrders();
                }
                await populateMachineSelector();
                if (selectedMachineData?.machine) {
                    await onMachineSelected(selectedMachineData.machine);
                }
                setTimeout(() => setProductionOrderStatus('', 'info'), 2000);
            } else {
                setProductionOrderStatus('Operação cancelada ou erro.', 'error');
            }
        } catch (error) {
            console.error('Erro ao ativar ordem:', error);
            setProductionOrderStatus('Erro ao ativar ordem. Tente novamente.', 'error');
        }
    }

    async function handleFinishProductionOrder(e) {
        e.preventDefault();
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);

        if (!order) {
            alert('Ordem não encontrada.');
            return;
        }

        try {
            setProductionOrderStatus('Finalizando ordem...', 'info');
            const success = await finishActiveOrder(orderId);
            
            if (success) {
                setProductionOrderStatus('Ordem finalizada com sucesso!', 'success');
                setTimeout(() => setProductionOrderStatus('', 'info'), 2000);
                
                // Registrar log
                registrarLogSistema('FINALIZAÇÃO DE ORDEM', 'ordem', {
                    orderId: orderId,
                    codigoOP: order.codigoOP || order.opNumber,
                    produto: order.produto || order.productName
                });
            } else {
                setProductionOrderStatus('Operação cancelada.', 'info');
            }
        } catch (error) {
            console.error('Erro ao finalizar ordem:', error);
            setProductionOrderStatus('Erro ao finalizar ordem. Tente novamente.', 'error');
        }
    }

    async function handleDeleteProductionOrder(e) {
        e.preventDefault();
        
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir ordens
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir ordens de produção');
            return;
        }
        
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);

        if (!order) return;

        if (order.status === 'ativa') {
            alert('Não é possível excluir uma OP ativa. Finalize a OP primeiro.');
            return;
        }

        if (!confirm(`Tem certeza que deseja excluir a OP "${order.order_number}"?`)) {
            return;
        }

        try {
            setProductionOrderStatus('Excluindo ordem...', 'info');
            await db.collection('production_orders').doc(orderId).delete();
            setProductionOrderStatus('Ordem excluída com sucesso!', 'success');
            setTimeout(() => setProductionOrderStatus('', 'info'), 2000);
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE ORDEM', 'ordem', {
                orderId: orderId,
                orderNumber: order.order_number,
                produto: order.produto || order.productName
            });
        } catch (error) {
            console.error('Erro ao excluir ordem:', error);
            setProductionOrderStatus('Erro ao excluir ordem. Tente novamente.', 'error');
        }
    }

    // =========================================================================
    // AJUSTE DE QUANTIDADE EXECUTADA DO PLANEJAMENTO
    // =========================================================================
    
    function openAdjustExecutedModal() {
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Verificar permissão
        if (!window.authSystem?.checkPermissionForAction('adjust_executed')) {
            showPermissionDeniedNotification('ajustar quantidade executada');
            return;
        }

        const modal = document.getElementById('adjust-executed-modal');
        if (!modal) return;

        const machineSpan = document.getElementById('adjust-exec-machine');
        const productSpan = document.getElementById('adjust-exec-product');
        const plannedSpan = document.getElementById('adjust-exec-planned');
        const currentSpan = document.getElementById('adjust-exec-current');
        const newQtyInput = document.getElementById('adjust-exec-new-qty');
        const diffDiv = document.getElementById('adjust-exec-diff');
        const reasonSelect = document.getElementById('adjust-exec-reason');
        const obsInput = document.getElementById('adjust-exec-obs');
        const statusDiv = document.getElementById('adjust-executed-status');

        // Calcular quantidade atual baseado nos entries (fonte única de verdade)
        const planId = selectedMachineData.id;
        const currentExecuted = Math.round(coerceToNumber(selectedMachineData.totalProduced, 0));
        const plannedQty = Math.round(coerceToNumber(
            selectedMachineData.order_lot_size ?? selectedMachineData.lot_size ?? selectedMachineData.planned_quantity, 0
        ));

        // Preencher informações
        if (machineSpan) machineSpan.textContent = selectedMachineData.machine || '-';
        if (productSpan) productSpan.textContent = selectedMachineData.product || '-';
        if (plannedSpan) plannedSpan.textContent = plannedQty.toLocaleString('pt-BR');
        if (currentSpan) currentSpan.textContent = currentExecuted.toLocaleString('pt-BR');
        
        // Limpar campos
        if (newQtyInput) {
            newQtyInput.value = currentExecuted;
            newQtyInput.dataset.currentQty = currentExecuted.toString();
            newQtyInput.dataset.planId = planId;
        }
        if (diffDiv) diffDiv.textContent = '';
        if (reasonSelect) reasonSelect.value = '';
        if (obsInput) obsInput.value = '';
        if (statusDiv) statusDiv.textContent = '';

        // Listener para mostrar diferença em tempo real
        if (newQtyInput) {
            newQtyInput.removeEventListener('input', updateAdjustExecutedDiff);
            newQtyInput.addEventListener('input', updateAdjustExecutedDiff);
        }

        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    function updateAdjustExecutedDiff() {
        const newQtyInput = document.getElementById('adjust-exec-new-qty');
        const diffDiv = document.getElementById('adjust-exec-diff');
        
        if (!newQtyInput || !diffDiv) return;

        const currentQty = parseInt(newQtyInput.dataset.currentQty || '0');
        const newQty = parseInt(newQtyInput.value || '0');
        const diff = newQty - currentQty;

        if (diff === 0) {
            diffDiv.textContent = 'Sem alteração';
            diffDiv.className = 'mt-1 text-xs text-gray-500';
        } else if (diff > 0) {
            diffDiv.textContent = `+${diff.toLocaleString('pt-BR')} peças (aumento)`;
            diffDiv.className = 'mt-1 text-xs text-green-600 font-medium';
        } else {
            diffDiv.textContent = `${diff.toLocaleString('pt-BR')} peças (redução)`;
            diffDiv.className = 'mt-1 text-xs text-orange-600 font-medium';
        }
    }

    function closeAdjustExecutedModal() {
        const modal = document.getElementById('adjust-executed-modal');
        if (modal) modal.classList.add('hidden');
    }

    async function handleAdjustExecutedSubmit(e) {
        e.preventDefault();

        const newQtyInput = document.getElementById('adjust-exec-new-qty');
        const reasonSelect = document.getElementById('adjust-exec-reason');
        const obsInput = document.getElementById('adjust-exec-obs');
        const statusDiv = document.getElementById('adjust-executed-status');
        const submitBtn = document.getElementById('adjust-executed-save');

        const planId = newQtyInput?.dataset.planId;
        const currentQty = parseInt(newQtyInput?.dataset.currentQty || '0');
        const newQty = parseInt(newQtyInput?.value || '0');
        const reason = reasonSelect?.value;
        const observations = obsInput?.value?.trim() || '';

        if (!planId) {
            alert('Erro interno: planejamento não identificado.');
            return;
        }

        if (newQty < 0) {
            alert('A quantidade executada não pode ser negativa.');
            return;
        }

        if (!reason) {
            alert('Por favor, selecione o motivo do ajuste.');
            return;
        }

        const diff = newQty - currentQty;
        if (diff === 0) {
            alert('A quantidade informada é igual à atual. Nenhuma alteração necessária.');
            return;
        }

        // Confirmar alteração
        const confirmMsg = diff > 0
            ? `Confirma o AUMENTO de ${diff.toLocaleString('pt-BR')} peças?\n\nDe: ${currentQty.toLocaleString('pt-BR')}\nPara: ${newQty.toLocaleString('pt-BR')}`
            : `Confirma a REDUÇÃO de ${Math.abs(diff).toLocaleString('pt-BR')} peças?\n\nDe: ${currentQty.toLocaleString('pt-BR')}\nPara: ${newQty.toLocaleString('pt-BR')}`;
        
        if (!confirm(confirmMsg)) return;

        try {
            if (submitBtn) submitBtn.disabled = true;
            if (statusDiv) {
                statusDiv.textContent = 'Processando ajuste...';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-blue-600';
            }

            const currentUser = getActiveUser();
            const now = new Date();

            // Criar registro de ajuste como entry especial
            const adjustmentEntry = {
                type: 'adjustment',
                planId: planId,
                machine: selectedMachineData.machine,
                product: selectedMachineData.product || '',
                product_cod: selectedMachineData.product_cod || '',
                previousQuantity: currentQty,
                newQuantity: newQty,
                adjustmentQty: diff,
                reason: reason,
                observations: observations,
                turno: getCurrentShift(),
                data: now.toISOString().split('T')[0],
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                adjustedBy: currentUser?.username || 'desconhecido',
                adjustedByName: currentUser?.name || 'Desconhecido',
                isManualAdjustment: true
            };

            // Salvar registro do ajuste na collection de entries
            await db.collection('production_entries').add(adjustmentEntry);

            // Atualizar o planejamento com a nova quantidade
            await db.collection('planning').doc(planId).update({
                total_produzido: newQty,
                totalProduced: newQty,
                lastManualAdjustment: {
                    previousValue: currentQty,
                    newValue: newQty,
                    diff: diff,
                    reason: reason,
                    observations: observations,
                    adjustedBy: currentUser?.username || 'desconhecido',
                    adjustedByName: currentUser?.name || 'Desconhecido',
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                },
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            console.log(`[AUDIT] ${currentUser?.name || 'Desconhecido'} ajustou quantidade executada do planejamento ${planId}: ${currentQty} → ${newQty} (${diff > 0 ? '+' : ''}${diff}) - Motivo: ${reason}`);

            // Registrar log do ajuste
            registrarLogSistema('AJUSTE DE QUANTIDADE EXECUTADA', 'planejamento', {
                planId: planId,
                machine: selectedMachineData?.machine,
                previousQty: currentQty,
                newQty: newQty,
                diff: diff,
                motivo: reason,
                observacoes: observations
            });

            if (statusDiv) {
                statusDiv.textContent = 'Ajuste aplicado com sucesso!';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-green-600';
            }

            showNotification(`Quantidade ajustada: ${currentQty.toLocaleString('pt-BR')} → ${newQty.toLocaleString('pt-BR')}`, 'success');

            // Fechar modal após 1.5 segundos
            setTimeout(() => {
                closeAdjustExecutedModal();
                // Forçar atualização do dashboard
                if (typeof updateDashboard === 'function') {
                    updateDashboard();
                }
            }, 1500);

        } catch (error) {
            console.error('Erro ao ajustar quantidade executada:', error);
            if (statusDiv) {
                statusDiv.textContent = 'Erro ao aplicar ajuste. Tente novamente.';
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
            }
            showNotification('Erro ao aplicar ajuste', 'error');
        } finally {
            if (submitBtn) submitBtn.disabled = false;
        }
    }

    // Inicializar listeners do modal de ajuste de quantidade executada
    function initAdjustExecutedModal() {
        const closeBtn = document.getElementById('adjust-executed-close');
        const cancelBtn = document.getElementById('adjust-executed-cancel');
        const form = document.getElementById('adjust-executed-form');

        if (closeBtn) closeBtn.addEventListener('click', closeAdjustExecutedModal);
        if (cancelBtn) cancelBtn.addEventListener('click', closeAdjustExecutedModal);
        if (form) form.addEventListener('submit', handleAdjustExecutedSubmit);
    }

    function handleAdjustQuantityOrder(e) {
        e.preventDefault();
        const orderId = e.currentTarget.dataset.orderId;
        const order = productionOrdersCache.find(o => o.id === orderId);

        if (!order) {
            alert('Ordem de produção não encontrada.');
            return;
        }

        showAdjustQuantityModal(order);
    }

    function showAdjustQuantityModal(order) {
        const modal = document.getElementById('adjust-quantity-modal');
        const opNumberSpan = document.getElementById('adjust-op-number');
        const opProductSpan = document.getElementById('adjust-op-product');
        const opOriginalQtySpan = document.getElementById('adjust-op-original-qty');
        const reductionInput = document.getElementById('adjust-reduction-qty');
        const reasonSelect = document.getElementById('adjust-reason');
        const observationsInput = document.getElementById('adjust-observations');
        const finalQtySpan = document.getElementById('adjust-final-qty');
        const statusDiv = document.getElementById('adjust-quantity-status');

        if (!modal) return;

        // Preencher informações da OP
        if (opNumberSpan) opNumberSpan.textContent = order.order_number || '-';
        if (opProductSpan) opProductSpan.textContent = order.product || '-';
        
        const originalQty = parseOptionalNumber(order.lot_size || order.lotSize) || 0;
        if (opOriginalQtySpan) opOriginalQtySpan.textContent = originalQty.toLocaleString('pt-BR');

        // Limpar campos
        if (reductionInput) reductionInput.value = '';
        if (reasonSelect) reasonSelect.value = '';
        if (observationsInput) observationsInput.value = '';
        if (finalQtySpan) finalQtySpan.textContent = originalQty.toLocaleString('pt-BR');
        if (statusDiv) statusDiv.textContent = '';

        // Armazenar dados da ordem para uso posterior
        modal.dataset.orderId = order.id;
        modal.dataset.originalQty = originalQty.toString();

        // Listener para cálculo em tempo real da quantidade final
        if (reductionInput) {
            reductionInput.addEventListener('input', updateFinalQuantity);
        }

        modal.classList.remove('hidden');
    }

    function updateFinalQuantity() {
        const modal = document.getElementById('adjust-quantity-modal');
        const reductionInput = document.getElementById('adjust-reduction-qty');
        const finalQtySpan = document.getElementById('adjust-final-qty');

        if (!modal || !reductionInput || !finalQtySpan) return;

        const originalQty = parseInt(modal.dataset.originalQty || '0');
        const adjustmentQty = parseInt(reductionInput.value || '0');
        const newQty = originalQty + adjustmentQty;

        // Mostrar a nova quantidade após o ajuste
        if (adjustmentQty !== 0) {
            const sign = adjustmentQty > 0 ? '+' : '';
            finalQtySpan.textContent = `${newQty.toLocaleString('pt-BR')} (${sign}${adjustmentQty.toLocaleString('pt-BR')})`;
        } else {
            finalQtySpan.textContent = originalQty.toLocaleString('pt-BR');
        }
        
        // Validação visual - não permitir quantidade final negativa
        if (newQty < 0) {
            finalQtySpan.className = 'text-lg font-bold text-red-600';
            reductionInput.style.borderColor = '#DC2626';
        } else if (adjustmentQty > 0) {
            finalQtySpan.className = 'text-lg font-bold text-green-600';
            reductionInput.style.borderColor = '#10B981';
        } else if (adjustmentQty < 0) {
            finalQtySpan.className = 'text-lg font-bold text-orange-600';
            reductionInput.style.borderColor = '#F59E0B';
        } else {
            finalQtySpan.className = 'text-lg font-bold text-blue-800';
            reductionInput.style.borderColor = '#D1D5DB';
        }
    }

    function closeAdjustQuantityModal() {
        const modal = document.getElementById('adjust-quantity-modal');
        const reductionInput = document.getElementById('adjust-reduction-qty');
        
        if (modal) {
            modal.classList.add('hidden');
            modal.removeAttribute('data-order-id');
            modal.removeAttribute('data-original-qty');
        }
        
        // Remover listener temporário
        if (reductionInput) {
            reductionInput.removeEventListener('input', updateFinalQuantity);
        }
    }

    async function handleAdjustQuantitySubmit(e) {
        e.preventDefault();

        const modal = document.getElementById('adjust-quantity-modal');
        const orderId = modal?.dataset.orderId;
        const originalQty = parseInt(modal?.dataset.originalQty || '0');
        
        const reductionInput = document.getElementById('adjust-reduction-qty');
        const reasonSelect = document.getElementById('adjust-reason');
        const observationsInput = document.getElementById('adjust-observations');
        const statusDiv = document.getElementById('adjust-quantity-status');
        const submitButton = document.getElementById('adjust-quantity-save');

        if (!orderId) {
            alert('Erro interno: ID da ordem não encontrado.');
            return;
        }

        const adjustmentQty = parseInt(reductionInput?.value || '0');
        const reason = reasonSelect?.value || '';
        const observations = (observationsInput?.value || '').trim();

        // Validações
        if (!adjustmentQty || adjustmentQty === 0) {
            alert('Informe um valor válido para o ajuste (positivo para aumentar, negativo para reduzir).');
            if (reductionInput) reductionInput.focus();
            return;
        }

        const finalQty = originalQty + adjustmentQty;

        if (finalQty < 0) {
            alert('A quantidade final não pode ser negativa. Ajuste inválido.');
            if (reductionInput) reductionInput.focus();
            return;
        }

        if (!reason) {
            alert('Selecione o motivo do ajuste.');
            if (reasonSelect) reasonSelect.focus();
            return;
        }

        try {
            if (statusDiv) statusDiv.textContent = 'Aplicando ajuste...';
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.textContent = 'Aplicando...';
            }

            // Criar registro do ajuste (para o array, sem serverTimestamp)
            const adjustmentRecordForArray = {
                orderId: orderId,
                originalQuantity: originalQty,
                adjustmentQuantity: adjustmentQty,
                finalQuantity: finalQty,
                adjustmentType: adjustmentQty > 0 ? 'increase' : 'decrease',
                reason: reason,
                observations: observations,
                adjustedBy: getActiveUser()?.name || 'Sistema',
                adjustedAt: new Date().toISOString(),
                workDay: new Date().toISOString().split('T')[0]
            };

            // Criar registro do ajuste (para coleção separada, com serverTimestamp)
            const adjustmentRecordForCollection = {
                ...adjustmentRecordForArray,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            };

            // Salvar registro do ajuste na coleção
            await db.collection('quantity_adjustments').add(adjustmentRecordForCollection);

            // Atualizar a quantidade do lote (lot_size) da OP
            const currentOrder = await db.collection('production_orders').doc(orderId).get();
            const orderData = currentOrder.data();
            const currentAdjustments = orderData.quantity_adjustments || [];
            
            await db.collection('production_orders').doc(orderId).update({
                lot_size: finalQty,
                quantity_adjustments: [...currentAdjustments, adjustmentRecordForArray],
                total_adjustments: (orderData.total_adjustments || 0) + adjustmentQty,
                lastQuantityAdjustment: adjustmentRecordForArray,
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            if (statusDiv) {
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-green-600';
                statusDiv.textContent = 'Ajuste aplicado com sucesso!';
            }
            
            // Após ajuste de quantidade, garantir que os cards de máquina e o painel de lançamento
            // reflitam o novo tamanho de lote da OP
            listenToProductionOrders();
            await populateMachineSelector();

            if (selectedMachineData && selectedMachineData.machine) {
                const machine = selectedMachineData.machine;
                const updatedMachineData = machineCardData[machine] || machineSelector?.machineData?.[machine];
                if (updatedMachineData) {
                    selectedMachineData = updatedMachineData;
                    updateMachineInfo();
                }
            }
            
            setTimeout(() => {
                closeAdjustQuantityModal();
            }, 1500);

        } catch (error) {
            console.error('Erro ao aplicar ajuste de quantidade:', error);
            if (statusDiv) {
                statusDiv.className = 'text-sm font-semibold h-5 text-center mt-2 text-red-600';
                statusDiv.textContent = 'Erro ao aplicar ajuste. Tente novamente.';
            }
        } finally {
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Aplicar Ajuste';
            }
        }
    }

    // Funções para controle de OP ativa na máquina
    async function checkActiveOrderOnMachine(machineId) {
        try {
            if (!machineId) return null;

            const snapshot = await db.collection('production_orders')
                .where('machine_id', '==', machineId)
                .where('status', '==', 'ativa')
                .limit(1)
                .get();

            if (snapshot.empty) return null;

            const doc = snapshot.docs[0];
            const data = doc.data();

            return { id: doc.id, ...data };
        } catch (error) {
            console.error('Erro ao verificar OP ativa na máquina:', error);
            return null;
        }
    }

    // Sincronizar selectedMachineData com a OP ativa antes de atualizar o card
    async function syncSelectedMachineWithActiveOrder() {
        try {
            if (!selectedMachineData || !selectedMachineData.machine) return;

            const activeOrder = await checkActiveOrderOnMachine(selectedMachineData.machine);
            if (!activeOrder) {
                return;
            }
            // Carregar lançamentos desta OP para aplicar a mesma regra da análise
            const productionSnapshot = await db.collection('production_entries')
                .where('orderId', '==', activeOrder.id)
                .get();

            const productionTotalsByOrderId = new Map();
            let aggregate = 0;
            productionSnapshot.docs.forEach(doc => {
                const data = doc.data();
                const producedQty = coerceToNumber(data.produzido ?? data.quantity, 0);
                if (Number.isFinite(producedQty) && producedQty > 0) {
                    aggregate += producedQty;
                }
            });
            productionTotalsByOrderId.set(activeOrder.id, aggregate);

            const metrics = computeOrderExecutionMetrics(activeOrder, productionTotalsByOrderId);

            selectedMachineData = {
                ...selectedMachineData,
                order_id: activeOrder.id || activeOrder.order_id || selectedMachineData.order_id,
                orderId: activeOrder.id || activeOrder.orderId || selectedMachineData.orderId,
                order_lot_size: metrics.lotSize,
                lot_size: metrics.lotSize,
                total_produzido: metrics.totalProduced,
                totalProduced: metrics.totalProduced
            };

            console.log('[SYNC-ORDER] selectedMachineData sincronizado com OP ativa', {
                machine: selectedMachineData.machine,
                order_id: selectedMachineData.order_id,
                lot_size: selectedMachineData.order_lot_size,
                total_produzido: selectedMachineData.total_produzido
            });
        } catch (error) {
            console.error('Erro ao sincronizar máquina com OP ativa:', error);
        }
    }

    async function setOrderAsActive(orderId, machineId) {
        try {
            // Verificar se já existe OP ativa na máquina
            const activeOrder = await checkActiveOrderOnMachine(machineId);
            
            if (activeOrder && activeOrder.id !== orderId) {
                const confirmChange = confirm(
                    `A máquina ${machineId} já possui a OP "${activeOrder.order_number}" ativa.\n\n` +
                    `Deseja finalizar a OP atual e ativar a nova OP?\n\n` +
                    `⚠️ IMPORTANTE: Certifique-se de que todas as quantidades da OP atual estão corretas antes de continuar.`
                );
                
                if (!confirmChange) {
                    return false;
                }
                
                // Finalizar OP atual
                await db.collection('production_orders').doc(activeOrder.id).update({
                    status: 'concluida',
                    finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    finishedBy: getActiveUser()?.name || 'Sistema'
                });
            }
            
            // Ativar nova OP
            await db.collection('production_orders').doc(orderId).update({
                status: 'ativa',
                machine_id: machineId,
                startedAt: firebase.firestore.FieldValue.serverTimestamp(),
                startedBy: getActiveUser()?.name || 'Sistema'
            });
            
            return true;
        } catch (error) {
            console.error('Erro ao ativar OP na máquina:', error);
            return false;
        }
    }

    async function finishActiveOrder(orderId) {
        try {
            const confirmFinish = confirm(
                `Deseja finalizar esta Ordem de Produção?\n\n` +
                `⚠️ IMPORTANTE: Certifique-se de que todas as quantidades produzidas estão corretas.\n` +
                `Após finalizar, uma nova OP poderá ser ativada na máquina.`
            );
            
            if (!confirmFinish) {
                return false;
            }
            
            await db.collection('production_orders').doc(orderId).update({
                status: 'concluida',
                finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                finishedBy: getActiveUser()?.name || 'Sistema'
            });
            
            return true;
        } catch (error) {
            console.error('Erro ao finalizar OP:', error);
            return false;
        }
    }

    /**
     * Verifica e restaura paradas ativas do Firebase
     * Chamada ao selecionar uma máquina ou ao recarregar a página
     */
    async function checkActiveDowntimes() {
        if (!db || !selectedMachineData) {
            console.log('[DOWNTIME][CHECK] Nenhuma máquina selecionada ou DB indisponível');
            return;
        }
        
        try {
            const activeDowntimeDoc = await db.collection('active_downtimes').doc(selectedMachineData.machine).get();
            
            if (activeDowntimeDoc.exists) {
                const activeDowntime = activeDowntimeDoc.data();
                console.log('[DOWNTIME][CHECK] Parada ativa encontrada:', activeDowntime);
                
                // Validar dados mínimos
                if (!activeDowntime.machine || !activeDowntime.startDate || !activeDowntime.startTime) {
                    console.warn('[DOWNTIME][CHECK] Dados de parada ativa incompletos, removendo...');
                    await db.collection('active_downtimes').doc(selectedMachineData.machine).delete();
                    return;
                }
                
                // Reconstruir timestamp de início
                let startTimestamp;
                if (activeDowntime.startTimestamp?.toDate) {
                    startTimestamp = activeDowntime.startTimestamp.toDate();
                } else if (activeDowntime.startTimestampLocal) {
                    startTimestamp = new Date(activeDowntime.startTimestampLocal);
                } else {
                    // Fallback: reconstruir a partir de date + time
                    startTimestamp = parseDateTime(activeDowntime.startDate, activeDowntime.startTime);
                }
                
                if (!startTimestamp || isNaN(startTimestamp.getTime())) {
                    console.warn('[DOWNTIME][CHECK] Timestamp de início inválido, removendo parada...');
                    await db.collection('active_downtimes').doc(selectedMachineData.machine).delete();
                    return;
                }
                
                // Verificar se a parada é muito antiga (mais de 7 dias)
                const now = new Date();
                const elapsedMs = now.getTime() - startTimestamp.getTime();
                const elapsedDays = elapsedMs / (1000 * 60 * 60 * 24);
                
                if (elapsedDays > 7) {
                    console.warn(`[DOWNTIME][CHECK] Parada muito antiga (${elapsedDays.toFixed(1)} dias), requer atenção especial`);
                    // Mostrar alerta para o usuário
                    const confirmar = confirm(
                        `⚠️ Parada Muito Longa Detectada!\n\n` +
                        `Máquina: ${activeDowntime.machine}\n` +
                        `Iniciada em: ${activeDowntime.startDate} às ${activeDowntime.startTime}\n` +
                        `Duração: ${elapsedDays.toFixed(1)} dias\n\n` +
                        `Deseja restaurar esta parada? Se não, ela será removida.`
                    );
                    
                    if (!confirmar) {
                        await db.collection('active_downtimes').doc(selectedMachineData.machine).delete();
                        console.log('[DOWNTIME][CHECK] Parada antiga removida pelo usuário');
                        return;
                    }
                }
                
                // Restaurar estado da parada
                currentDowntimeStart = {
                    machine: activeDowntime.machine,
                    date: activeDowntime.startDate,
                    startTime: activeDowntime.startTime,
                    startTimestamp: startTimestamp,
                    startTimestampLocal: startTimestamp.toISOString(),
                    startShift: activeDowntime.startShift || getShiftForDateTime(startTimestamp),
                    // Contexto de produção
                    product: activeDowntime.product || null,
                    productCod: activeDowntime.productCod || null,
                    orderId: activeDowntime.orderId || null,
                    orderNumber: activeDowntime.orderNumber || null
                };
                
                machineStatus = 'stopped';
                updateMachineStatus();
                freezeProductionTimer();
                startDowntimeTimer();
                
                // Calcular tempo decorrido para exibição
                const elapsedHours = (elapsedMs / (1000 * 60 * 60)).toFixed(1);
                const elapsedMinutes = Math.floor((elapsedMs / 60000) % 60);
                
                let durationText;
                if (elapsedDays >= 1) {
                    durationText = `${Math.floor(elapsedDays)}d ${Math.floor((elapsedMs / 3600000) % 24)}h`;
                } else if (parseFloat(elapsedHours) >= 1) {
                    durationText = `${elapsedHours}h`;
                } else {
                    durationText = `${elapsedMinutes} min`;
                }
                
                showNotification(`⏱️ Parada ativa restaurada! Tempo decorrido: ${durationText}`, 'warning');
                
                console.log('[DOWNTIME][CHECK] Estado da parada restaurado:', {
                    machine: activeDowntime.machine,
                    duration: durationText,
                    startedAt: activeDowntime.startDate + ' ' + activeDowntime.startTime
                });
            } else {
                console.log('[DOWNTIME][CHECK] Nenhuma parada ativa para:', selectedMachineData.machine);
            }
        } catch (error) {
            console.error('[DOWNTIME][CHECK] Erro ao verificar paradas ativas:', error);
        }
    }

    function listenToProductionOrders() {
        if (!db || !productionOrderTableBody) return;

        try {
            const query = db.collection('production_orders').orderBy('createdAt', 'desc');
            listenerManager.subscribe('productionOrders', query,
                (snapshot) => {
                    productionOrdersCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    applyOrdersFilters();
                    populatePlanningOrderSelect();
                    if (productionOrderStatusMessage && productionOrderStatusMessage.className.includes('text-status-error')) {
                        setProductionOrderStatus('', 'info');
                    }
                },
                (error) => {
                    console.error('Erro ao carregar ordens de produção:', error);
                    renderProductionOrdersTable([]);
                    setProductionOrderStatus('Não foi possível carregar as ordens de produção.', 'error');
                }
            );
        } catch (error) {
            console.error('Erro ao inicializar listener de ordens de produção:', error);
            setProductionOrderStatus('Erro ao iniciar monitoramento das ordens.', 'error');
        }
    }

    async function handleProductionOrderFormSubmit(event) {
        event.preventDefault();

        if (!productionOrderForm) return;

        if (!window.authSystem.checkPermissionForAction('create_production_order')) {
            return;
        }

        const formData = new FormData(productionOrderForm);
        const rawData = Object.fromEntries(formData.entries());

        const orderNumber = (rawData.order_number || '').trim();
        if (!orderNumber) {
            setProductionOrderStatus('Informe o número da OP antes de salvar.', 'error');
            return;
        }

        const normalizedOrderNumber = orderNumber.toUpperCase();

        const partCode = (rawData.part_code || '').trim();
        // Usar índice Map para O(1) lookup
        const matchedProduct = partCode ? (window.databaseModule.productByCode.get(Number(partCode)) || window.databaseModule.productByCode.get(partCode)) : null;

        const submitButton = productionOrderForm.querySelector('button[type="submit"]');
        const originalButtonContent = submitButton ? submitButton.innerHTML : '';

        try {
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.innerHTML = `<i data-lucide="loader-2" class="animate-spin"></i><span>Salvando...</span>`;
                lucide.createIcons();
            }

            setProductionOrderStatus('Salvando ordem de produção...', 'info');

            const existingSnapshot = await db.collection('production_orders')
                .where('order_number', '==', normalizedOrderNumber)
                .limit(1)
                .get();

            if (!existingSnapshot.empty && !productionOrderForm.dataset.editingOrderId) {
                setProductionOrderStatus('Já existe uma ordem com este número.', 'error');
                return;
            }

            // Se estamos editando, deletar ordem antiga se o número mudou
            const editingOrderId = productionOrderForm.dataset.editingOrderId;
            if (editingOrderId && !existingSnapshot.empty && existingSnapshot.docs[0].id !== editingOrderId) {
                setProductionOrderStatus('Já existe uma ordem com este número.', 'error');
                return;
            }

            const docData = {
                order_number: normalizedOrderNumber,
                order_number_original: orderNumber,
                customer_order: (rawData.customer_order || '').trim(),
                customer: (rawData.customer || matchedProduct?.client || '').trim(),
                client: (rawData.customer || matchedProduct?.client || '').trim(),
                product: (rawData.product || matchedProduct?.name || '').trim(),
                part_code: partCode,
                product_cod: partCode,
                lot_size: parseOptionalNumber(rawData.lot_size),
                batch_number: (rawData.batch_number || '').trim(),
                packaging_qty: parseOptionalNumber(rawData.packaging_qty),
                internal_packaging_qty: parseOptionalNumber(rawData.internal_packaging_qty),
                raw_material: (rawData.raw_material || matchedProduct?.mp || '').trim(),
                machine_id: (rawData.machine_id || '').trim() || null,
                status: 'planejada',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            if (!editingOrderId) {
                docData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
            }

            if (matchedProduct) {
                docData.product_snapshot = {
                    cod: matchedProduct.cod,
                    client: matchedProduct.client || '',
                    name: matchedProduct.name || '',
                    cavities: parseOptionalNumber(matchedProduct.cavities),
                    cycle: parseOptionalNumber(matchedProduct.cycle),
                    weight: parseOptionalNumber(matchedProduct.weight),
                    mp: matchedProduct.mp || ''
                };
            }

            if (editingOrderId) {
                await db.collection('production_orders').doc(editingOrderId).update(docData);
                setProductionOrderStatus('Ordem atualizada com sucesso!', 'success');
                
                // Registrar log de edição
                registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: editingOrderId,
                    orderNumber: normalizedOrderNumber,
                    product: docData.product,
                    lotSize: docData.lot_size
                });
            } else {
                const docRef = await db.collection('production_orders').add(docData);
                setProductionOrderStatus('Ordem cadastrada com sucesso!', 'success');
                
                // Registrar log de criação
                registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: docRef.id,
                    orderNumber: normalizedOrderNumber,
                    product: docData.product,
                    lotSize: docData.lot_size
                });
            }

            productionOrderForm.reset();
            delete productionOrderForm.dataset.editingOrderId;
            clearProductionOrderAutoFields();
            setProductionOrderFeedback();

            if (submitButton) {
                submitButton.innerHTML = `<i data-lucide="plus-circle"></i><span>Cadastrar OP</span>`;
            }

            setTimeout(() => setProductionOrderStatus('', 'info'), 3000);
        } catch (error) {
            console.error('Erro ao cadastrar ordem de produção:', error);
            setProductionOrderStatus('Erro ao cadastrar ordem. Tente novamente.', 'error');
        } finally {
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.innerHTML = originalButtonContent;
                lucide.createIcons();
            }
        }
    }

    function onPlanningProductCodChange(e) {
        const input = e?.target;
        if (!input) return;

        const rawCode = (input.value || '').trim();
        // Usar índice Map para O(1) lookup
        const product = window.databaseModule.productByCode.get(Number(rawCode)) || window.databaseModule.productByCode.get(rawCode);

        const cycleInput = document.getElementById('budgeted-cycle');
        const cavitiesInput = document.getElementById('mold-cavities');
        const weightInput = document.getElementById('piece-weight');
        const plannedQtyInput = document.getElementById('planned-quantity');
        const productNameDisplay = document.getElementById('product-name-display');
        const mpInput = planningMpInput || document.getElementById('planning-mp');

        const resetFields = () => {
            if (cycleInput) cycleInput.value = '';
            if (cavitiesInput) cavitiesInput.value = '';
            if (weightInput) weightInput.value = '';
            if (plannedQtyInput) plannedQtyInput.value = '';
            if (mpInput) mpInput.value = '';
        };

        const hideDisplay = () => {
            if (productNameDisplay) {
                productNameDisplay.textContent = '';
                productNameDisplay.style.display = 'none';
                productNameDisplay.classList.remove('text-red-600', 'bg-red-50');
                productNameDisplay.classList.add('text-primary-blue', 'bg-gray-50');
            }
        };

        if (product) {
            if (cycleInput) cycleInput.value = product.cycle || '';
            if (cavitiesInput) cavitiesInput.value = product.cavities || '';
            if (weightInput) weightInput.value = typeof product.weight === 'number' ? product.weight : '';
            if (mpInput) mpInput.value = product.mp || '';

            const cycle = Number(product.cycle) || 0;
            const cavities = Number(product.cavities) || 0;
            const plannedQty = cycle > 0 ? Math.floor((86400 / cycle) * cavities * 0.85) : 0;
            if (plannedQtyInput) plannedQtyInput.value = plannedQty;

            if (productNameDisplay) {
                productNameDisplay.textContent = `${product.name} (${product.client})`;
                productNameDisplay.style.display = 'block';
                productNameDisplay.classList.remove('text-red-600', 'bg-red-50');
                productNameDisplay.classList.add('text-primary-blue', 'bg-gray-50');
            }
            return;
        }

        // Caso sem produto encontrado
        resetFields();

        if (!rawCode) {
            hideDisplay();
            return;
        }

        if (productNameDisplay && e.type !== 'input') {
            productNameDisplay.textContent = 'Produto não encontrado';
            productNameDisplay.style.display = 'block';
            productNameDisplay.classList.remove('text-primary-blue', 'bg-gray-50');
            productNameDisplay.classList.add('text-red-600', 'bg-red-50');
        } else if (productNameDisplay && e.type === 'input') {
            hideDisplay();
        }
    }

    async function handlePlanningFormSubmit(e) {
        e.preventDefault();
        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('create_planning')) {
            return;
        }
        
        const form = e.target;
    const formData = new FormData(form);
        const data = Object.fromEntries(formData.entries());
        const productionOrderId = (data.production_order_id || '').trim();
        
        // Validar data - usar data do input ou data atual
        if (!data.date) {
            const dateInput = document.getElementById('planning-date-selector');
            if (dateInput && dateInput.value) {
                data.date = dateInput.value;
            } else {
                // Fallback para data atual
                const hoje = new Date();
                data.date = hoje.getFullYear() + '-' + 
                           String(hoje.getMonth() + 1).padStart(2, '0') + '-' + 
                           String(hoje.getDate()).padStart(2, '0');
            }
        }
        
        // Validar máquina
        if (!data.machine) {
            alert('Por favor, selecione uma máquina!');
            return;
        }
        
        // Buscar dados completos do produto selecionado
        const productCod = data.product_cod;
        // Usar índice Map para O(1) lookup
        const product = window.databaseModule.productByCode.get(Number(productCod)) || window.databaseModule.productByCode.get(productCod);
        
        if (!product) {
            alert('Produto não encontrado!');
            return;
        }

        const statusMessage = document.getElementById('planning-status-message');
        const submitButton = document.getElementById('planning-submit-button');
        
        if (!submitButton) return;
        
        submitButton.disabled = true;
        submitButton.innerHTML = `<i data-lucide="loader-2" class="animate-spin"></i><span>A Adicionar...</span>`;
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
        try {
            let linkedOrder = null;
            if (productionOrderId) {
                linkedOrder = Array.isArray(productionOrdersCache)
                    ? productionOrdersCache.find(order => order && order.id === productionOrderId)
                    : null;

                if (!linkedOrder) {
                    try {
                        const orderDoc = await db.collection('production_orders').doc(productionOrderId).get();
                        if (orderDoc.exists) {
                            linkedOrder = { id: orderDoc.id, ...orderDoc.data() };
                        }
                    } catch (orderError) {
                        console.warn('Falha ao carregar dados da OP vinculada:', orderError);
                    }
                }
            }

            const snapshot = linkedOrder?.product_snapshot || {};
            const resolvedProductName = linkedOrder?.product || product.name;
            const resolvedClient = linkedOrder?.customer || linkedOrder?.client || product.client || '';
            const resolvedMp = (data.mp || linkedOrder?.raw_material || snapshot.mp || product.mp || '').trim();
            const resolvedCycle = parseFloat(data.budgeted_cycle) || Number(product.cycle) || Number(snapshot.cycle) || 0;
            const resolvedCavities = parseFloat(data.mold_cavities) || Number(product.cavities) || Number(snapshot.cavities) || 0;
            
            // Converter peso da peça usando parser específico para peças (não converte kg->g)
            let resolvedWeight = 0;
            if (data.piece_weight) {
                resolvedWeight = parsePieceWeightInput(data.piece_weight);
                console.log('[PLANNING] piece_weight from input:', { raw: data.piece_weight, converted: resolvedWeight });
            }
            // Se não tiver peso, usar fallback do produto/snapshot
            if (!resolvedWeight && (snapshot.weight || product.weight)) {
                resolvedWeight = parsePieceWeightInput(snapshot.weight || product.weight);
                console.log('[PLANNING] piece_weight from fallback:', { snapshot: snapshot.weight, product: product.weight, resolved: resolvedWeight });
            }
            const resolvedQuantidadeEmbalagem = parseFloat(data.quantidade_da_embalagem) || null;
            const resolvedPlannedQuantity = (() => {
                const parsed = parseInt(data.planned_quantity, 10);
                return Number.isFinite(parsed) ? parsed : 0;
            })();

            product.mp = resolvedMp;

            const docData = {
                date: data.date,
                machine: data.machine,
                production_order_id: productionOrderId || null,
                product_cod: product.cod,
                client: resolvedClient,
                product: resolvedProductName,
                budgeted_cycle: resolvedCycle || null,
                mold_cavities: resolvedCavities || null,
                piece_weight: resolvedWeight || null,
                piece_weight_grams: resolvedWeight || null,
                quantidade_da_embalagem: resolvedQuantidadeEmbalagem,
                planned_quantity: resolvedPlannedQuantity,
                mp: resolvedMp,
                mp_type: data.mp_type || linkedOrder?.mp_type || '',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            };
            console.log('[PLANNING] docData to be saved:', { piece_weight: docData.piece_weight, piece_weight_grams: docData.piece_weight_grams });

            if (linkedOrder) {
                docData.order_id = linkedOrder.id;
                docData.order_number = linkedOrder.order_number || linkedOrder.order_number_original || linkedOrder.id;
                docData.order_customer = resolvedClient;
                const linkedLotSize = parseOptionalNumber(linkedOrder.lot_size);
                if (typeof linkedLotSize === 'number' && Number.isFinite(linkedLotSize)) {
                    docData.order_lot_size = linkedLotSize;
                }
                const linkedPartCode = linkedOrder.part_code || linkedOrder.product_cod;
                if (linkedPartCode) {
                    docData.order_part_code = String(linkedPartCode);
                }
            }
            await db.collection('planning').add(docData);
            
            // Registrar log
            registrarLogSistema('CRIAÇÃO DE PLANEJAMENTO', 'planejamento', {
                machine: data.machine,
                date: data.date,
                product: resolvedProductName,
                productCod: product.cod,
                plannedQuantity: resolvedPlannedQuantity,
                orderNumber: linkedOrder?.order_number || null
            });
            
            if (statusMessage) {
                statusMessage.textContent = 'Item adicionado com sucesso!';
                statusMessage.className = 'text-status-success text-sm font-semibold h-5 text-center';
            }
            form.reset();
            
            // Limpar campos com verificação de existência
            const budgetedCycleEl = document.getElementById('budgeted-cycle');
            const moldCavitiesEl = document.getElementById('mold-cavities');
            const pieceWeightEl = document.getElementById('piece-weight');
            const quantidadeEmbalagemEl = document.getElementById('quantidade-embalagem');
            const plannedQuantityEl = document.getElementById('planned-quantity');
            
            if (budgetedCycleEl) budgetedCycleEl.value = '';
            if (moldCavitiesEl) moldCavitiesEl.value = '';
            if (pieceWeightEl) pieceWeightEl.value = '';
            if (quantidadeEmbalagemEl) quantidadeEmbalagemEl.value = '';
            if (plannedQuantityEl) plannedQuantityEl.value = '';
            if (planningMpInput) planningMpInput.value = '';
            if (planningOrderSelect) {
                planningOrderSelect.value = '';
                planningOrderSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }
            const productNameDisplay = document.getElementById('product-name-display');
            if (productNameDisplay) {
                productNameDisplay.textContent = '';
                productNameDisplay.style.display = 'none';
            }
            const orderInfo = document.getElementById('planning-order-info');
            if (orderInfo) {
                orderInfo.style.display = 'none';
                orderInfo.textContent = '';
            }
        } catch (error) {
            console.error("Erro ao adicionar planejamento: ", error);
            if (statusMessage) {
                statusMessage.textContent = 'Erro ao adicionar. Tente novamente.';
                statusMessage.className = 'text-status-error text-sm font-semibold h-5 text-center';
            }
        } finally {
            submitButton.disabled = false;
            submitButton.innerHTML = `<i data-lucide="plus-circle"></i><span>Adicionar ao Plano</span>`;
            if (typeof lucide !== 'undefined') lucide.createIcons();
            if (statusMessage) {
                setTimeout(() => statusMessage.textContent = '', 3000);
            }
        }
    }

    // Função para atualizar KPIs do Planejamento
    function updatePlanningKPIs(planningItems, combinedData) {
        const kpiItems = document.getElementById('planning-kpi-items');
        const kpiMachines = document.getElementById('planning-kpi-machines');
        const kpiProduced = document.getElementById('planning-kpi-produced');
        const kpiProducts = document.getElementById('planning-kpi-products');
        
        if (!kpiItems || !kpiMachines || !kpiProduced || !kpiProducts) return;
        
        // Total de itens planejados
        const totalItems = planningItems?.length || 0;
        kpiItems.textContent = totalItems.toLocaleString('pt-BR');
        
        // Máquinas únicas ativas
        const uniqueMachines = new Set((planningItems || []).map(p => p.machine).filter(Boolean));
        kpiMachines.textContent = uniqueMachines.size.toLocaleString('pt-BR');
        
        // Produção total acumulada
        const totalProduced = (combinedData || []).reduce((sum, item) => {
            return sum + (Number(item.total_produzido) || 0);
        }, 0);
        kpiProduced.textContent = totalProduced.toLocaleString('pt-BR');
        
        // Produtos únicos
        const uniqueProducts = new Set((planningItems || []).map(p => p.product_cod || p.product).filter(Boolean));
        kpiProducts.textContent = uniqueProducts.size.toLocaleString('pt-BR');
    }

    // Função para atualizar dados do planejamento (botão refresh)
    window.refreshPlanningData = function() {
        const dateSelector = document.getElementById('planning-date-selector');
        if (dateSelector && dateSelector.value) {
            listenToPlanningChanges(dateSelector.value);
        }
    };

    // Função para imprimir relatório de planejamento
    window.printPlanningReport = function() {
        window.print();
    };

    // Função para exportar tabela de planejamento
    window.exportPlanningTable = function() {
        const table = document.getElementById('planning-table-body');
        if (!table) return;
        
        const rows = table.querySelectorAll('tr');
        if (rows.length === 0) {
            alert('Nenhum dado para exportar.');
            return;
        }
        
        let csv = 'Máquina,Produto,MP,Ciclo Planejado,Cav. Planejadas,Peso,Ciclo T1,Cav T1,Qtd T1,Ciclo T2,Cav T2,Qtd T2,Ciclo T3,Cav T3,Qtd T3,Total\n';
        
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 15) {
                const rowData = Array.from(cells).slice(0, 16).map(cell => {
                    let text = cell.textContent.trim().replace(/,/g, ';');
                    return `"${text}"`;
                });
                csv += rowData.join(',') + '\n';
            }
        });
        
        const blob = new Blob(['\ufeff' + csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const date = document.getElementById('planning-date-selector')?.value || 'export';
        link.href = URL.createObjectURL(blob);
        link.download = `planejamento_${date}.csv`;
        link.click();
    };

    // Setup de busca na tabela de planejamento
    function setupPlanningTableSearch() {
        const searchInput = document.getElementById('planning-table-search');
        if (!searchInput) return;
        
        let debounceTimer;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                const searchTerm = e.target.value.toLowerCase().trim();
                const tableBody = document.getElementById('planning-table-body');
                if (!tableBody) return;
                
                const rows = tableBody.querySelectorAll('tr');
                rows.forEach(row => {
                    const text = row.textContent.toLowerCase();
                    row.style.display = text.includes(searchTerm) ? '' : 'none';
                });
            }, 300);
        });
    }

    // Inicializar busca na tabela
    setTimeout(setupPlanningTableSearch, 1000);

    function listenToPlanningChanges(date) {
        if (!date) return;
        
        detachActiveListener();
        showLoadingState('leader-panel', true);
        
        let planningItems = [];
        let productionEntries = [];
        let downtimeEntries = [];
        let activeDowntimeSet = new Set();

        const render = async () => {
            const combinedData = planningItems.map(plan => {
                const shifts = { T1: 0, T2: 0, T3: 0 };

                productionEntries.forEach(entry => {
                    if (!entry || entry.planId !== plan.id) return;
                    const shiftKey = normalizeShiftValue(entry.turno);
                    if (!shiftKey || !shifts.hasOwnProperty(shiftKey)) return;
                    const produced = Number(entry.produzido) || 0;
                    shifts[shiftKey] += produced;
                });

                return {
                    ...plan,
                    T1: { produzido: shifts.T1 },
                    T2: { produzido: shifts.T2 },
                    T3: { produzido: shifts.T3 },
                    total_produzido: shifts.T1 + shifts.T2 + shifts.T3
                };
            });

            // Atualizar KPIs do Planejamento
            updatePlanningKPIs(planningItems, combinedData);
            
            renderPlanningTable(combinedData);
            renderLeaderPanel(planningItems);
            const activePlans = planningItems.filter(isPlanActive);
            
            // NOVO: Carregar paradas ativas para mostrar no painel de máquinas
            const machinesDowntime = await getAllMachinesDowntimeStatus();
            renderMachineCards(activePlans, productionEntries, downtimeEntries, activeDowntimeSet, machinesDowntime);
            showLoadingState('leader-panel', false, planningItems.length === 0);
            
            // Atualizar contagem no painel
            const panelCount = document.getElementById('planning-panel-count');
            if (panelCount) {
                panelCount.textContent = `${planningItems.length} ${planningItems.length === 1 ? 'item' : 'itens'}`;
            }
        };

        // Chamar render de forma assíncrona quando necessário
        const scheduleRender = () => {
            requestAnimationFrame(() => render().catch(e => console.error('Erro em render:', e)));
        };

        // Limpar listeners anteriores se existirem
        listenerManager.unsubscribe('planning');
        listenerManager.unsubscribe('productionEntries');
        listenerManager.unsubscribe('downtime');
        listenerManager.unsubscribe('activeDowntimes');

        // Filtrar planejamentos pela data selecionada (dia de trabalho inicia às 7h)
        // Busca planejamentos onde a data do planejamento é igual à data selecionada
        const planningQuery = db.collection('planning').where('date', '==', date);
        listenerManager.subscribe('planning', planningQuery,
            (snapshot) => {
                // Filtrar apenas planejamentos ativos (não concluídos/finalizados/cancelados)
                planningItems = snapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(isPlanActive);
                planningItems.sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                if (machineSelector) {
                    machineSelector.machineData = {};
                    planningItems.forEach(item => {
                        if (isPlanActive(item)) {
                            machineSelector.machineData[item.machine] = { id: item.id, ...item };
                        }
                    });
                }
                if (selectedMachineData) {
                    const updatedSelected = planningItems.find(item => item.id === selectedMachineData.id);
                    if (updatedSelected) {
                        selectedMachineData = { ...selectedMachineData, ...updatedSelected };
                        updateQuickProductionPieceWeightUI();
                        if (productName) {
                            productName.textContent = selectedMachineData.product || 'Produto não definido';
                        }
                        if (shiftTarget) {
                            // Usar lot_size (tamanho do lote OP), não planned_quantity/3
                            const totalPlanned = coerceToNumber(selectedMachineData.order_lot_size ?? selectedMachineData.lot_size, 0);
                            const totalExecuted = coerceToNumber(selectedMachineData.total_produzido, 0);
                            if (!totalPlanned) {
                                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / N/A`;
                            } else {
                                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / ${totalPlanned.toLocaleString('pt-BR')}`;
                            }
                        }
                        if (productMp) {
                            productMp.textContent = selectedMachineData.mp ? `MP: ${selectedMachineData.mp}` : 'Matéria-prima não definida';
                        }
                    }
                }
                scheduleRender();
            },
            (error) => {
                console.error("Erro ao carregar planejamentos:", error);
                if(leaderLaunchPanel) leaderLaunchPanel.innerHTML = `<div class="col-span-full text-center text-red-600">Erro ao carregar dados.</div>`;
                showLoadingState('leader-panel', false, true);
            }
        );

        const entriesQuery = db.collection('production_entries').where('data', '==', date);
        listenerManager.subscribe('productionEntries', entriesQuery,
            (snapshot) => {
                productionEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                scheduleRender();
            },
            (error) => console.error("Erro ao carregar lançamentos de produção:", error)
        );

        // Listener de paradas do dia selecionado e próximo dia (para cobrir T3 após 00:00)
        const base = new Date(`${date}T12:00:00`);
        const next = new Date(base);
        next.setDate(next.getDate() + 1);
        const nextStr = new Date(next.getTime() - next.getTimezoneOffset()*60000).toISOString().split('T')[0];
        
        const downtimeQuery = db.collection('downtime_entries')
            .where('date', 'in', [date, nextStr]);
        listenerManager.subscribe('downtime', downtimeQuery,
            (snapshot) => {
                downtimeEntries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                scheduleRender();
            },
            (error) => console.error('Erro ao carregar paradas:', error)
        );

        // Listener para paradas ativas (cards vermelhos)
        const activeDowntimesQuery = db.collection('active_downtimes');
        listenerManager.subscribe('activeDowntimes', activeDowntimesQuery,
            (snapshot) => {
                activeDowntimeSet = new Set(snapshot.docs.map(doc => doc.id));
                scheduleRender();
            },
            (error) => console.error('Erro ao carregar paradas ativas:', error)
        );
    }

    function renderPlanningTable(items) {
        if (!planningTableBody) return;
        const orDash = (value) => value || '-';
        const orDashNum = (value) => {
            const parsed = parseOptionalNumber(value);
            return parsed !== null ? parsed.toLocaleString('pt-BR') : '-';
        };
        const cycleClass = (realCycle, budgetedCycle) => {
            if (!realCycle || !budgetedCycle) return '';
            return realCycle > budgetedCycle ? 'text-status-error font-bold' : '';
        };

        // Agrupar por Máquina + Produto (independente da OP)
        const grouped = new Map();
        (items || []).forEach(item => {
            const key = `${item.machine}||${item.product_cod || item.product || ''}`;
            if (!grouped.has(key)) {
                grouped.set(key, {
                    id: item.id, // Guardar ID do primeiro item do grupo
                    machine: item.machine,
                    product: item.product,
                    product_cod: item.product_cod,
                    mp: item.mp,
                    budgeted_cycle: item.budgeted_cycle,
                    mold_cavities: item.mold_cavities,
                    piece_weight: item.piece_weight,
                    // Ciclos/Cavidades reais por turno (pega o primeiro valor informado)
                    real_cycle_t1: item.real_cycle_t1 || null,
                    active_cavities_t1: item.active_cavities_t1 || null,
                    real_cycle_t2: item.real_cycle_t2 || null,
                    active_cavities_t2: item.active_cavities_t2 || null,
                    real_cycle_t3: item.real_cycle_t3 || null,
                    active_cavities_t3: item.active_cavities_t3 || null,
                    // Produção por turno acumulada
                    T1: { produzido: Number(item.T1?.produzido) || 0 },
                    T2: { produzido: Number(item.T2?.produzido) || 0 },
                    T3: { produzido: Number(item.T3?.produzido) || 0 },
                    total_produzido: coerceToNumber(item.total_produzido, 0)
                });
            } else {
                const agg = grouped.get(key);
                // Manter primeiro valor de ciclo/cavidades reais informado; se vazio, assumir do item atual
                if (!agg.real_cycle_t1 && item.real_cycle_t1) agg.real_cycle_t1 = item.real_cycle_t1;
                if (!agg.active_cavities_t1 && item.active_cavities_t1) agg.active_cavities_t1 = item.active_cavities_t1;
                if (!agg.real_cycle_t2 && item.real_cycle_t2) agg.real_cycle_t2 = item.real_cycle_t2;
                if (!agg.active_cavities_t2 && item.active_cavities_t2) agg.active_cavities_t2 = item.active_cavities_t2;
                if (!agg.real_cycle_t3 && item.real_cycle_t3) agg.real_cycle_t3 = item.real_cycle_t3;
                if (!agg.active_cavities_t3 && item.active_cavities_t3) agg.active_cavities_t3 = item.active_cavities_t3;
                // Atualizar campos básicos se estiverem vazios
                if (!agg.mp && item.mp) agg.mp = item.mp;
                if (!agg.budgeted_cycle && item.budgeted_cycle) agg.budgeted_cycle = item.budgeted_cycle;
                if (!agg.mold_cavities && item.mold_cavities) agg.mold_cavities = item.mold_cavities;
                if (!agg.piece_weight && item.piece_weight) agg.piece_weight = item.piece_weight;
                // Somar produção por turno e total
                agg.T1.produzido += Number(item.T1?.produzido) || 0;
                agg.T2.produzido += Number(item.T2?.produzido) || 0;
                agg.T3.produzido += Number(item.T3?.produzido) || 0;
                agg.total_produzido += coerceToNumber(item.total_produzido, 0);
            }
        });

        // Ordenar por máquina em ordem crescente (numérica se possível)
        const sortedItems = Array.from(grouped.values()).sort((a, b) => {
            const machineA = a.machine || '';
            const machineB = b.machine || '';
            // Tentar extrair número da máquina para ordenação numérica
            const numA = parseInt(machineA.replace(/\D/g, ''), 10);
            const numB = parseInt(machineB.replace(/\D/g, ''), 10);
            if (!isNaN(numA) && !isNaN(numB)) {
                return numA - numB;
            }
            return machineA.localeCompare(machineB, 'pt-BR', { numeric: true });
        });

        const rows = sortedItems.map(item => `
            <tr class="hover:bg-gray-50 text-center text-sm">
                <td class="px-2 py-2 whitespace-nowrap border text-left">${item.machine}</td>
                <td class="px-2 py-2 whitespace-nowrap border text-left">${item.product}</td>
                <td class="px-2 py-2 whitespace-nowrap border text-left">${orDash(item.mp)}</td>
                <td class="px-2 py-2 whitespace-nowrap border">${orDash(item.budgeted_cycle)}</td>
                <td class="px-2 py-2 whitespace-nowrap border">${orDash(item.mold_cavities)}</td>
                <td class="px-2 py-2 whitespace-nowrap border">${orDash(item.piece_weight)}</td>
                
                <td class="px-2 py-2 whitespace-nowrap border bg-blue-50 ${cycleClass(item.real_cycle_t1, item.budgeted_cycle)}">${orDash(item.real_cycle_t1)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-blue-50">${orDash(item.active_cavities_t1)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-blue-50">${orDashNum(item.T1?.produzido)}</td>

                <td class="px-2 py-2 whitespace-nowrap border bg-yellow-50 ${cycleClass(item.real_cycle_t2, item.budgeted_cycle)}">${orDash(item.real_cycle_t2)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-yellow-50">${orDash(item.active_cavities_t2)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-yellow-50">${orDashNum(item.T2?.produzido)}</td>

                <td class="px-2 py-2 whitespace-nowrap border bg-purple-50 ${cycleClass(item.real_cycle_t3, item.budgeted_cycle)}">${orDash(item.real_cycle_t3)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-purple-50">${orDash(item.active_cavities_t3)}</td>
                <td class="px-2 py-2 whitespace-nowrap border bg-purple-50">${orDashNum(item.T3?.produzido)}</td>

                <td class="px-3 py-2 whitespace-nowrap bg-emerald-50 font-bold text-emerald-700 text-base">${orDashNum(item.total_produzido)}</td>
                <td class="px-2 py-2 whitespace-nowrap no-print text-center">
                    <button class="delete-plan-btn bg-red-100 hover:bg-red-200 text-red-600 hover:text-red-700 p-1.5 rounded-lg transition-all" data-id="${item.id}" title="Deletar planejamento">
                        <i data-lucide="trash-2" class="w-4 h-4"></i>
                    </button>
                </td>
            </tr>
        `).join('');

        planningTableBody.innerHTML = rows;
        
        // Mostrar/ocultar estado vazio
        const emptyState = document.getElementById('planning-table-empty');
        if (emptyState) {
            emptyState.classList.toggle('hidden', sortedItems.length > 0);
        }
        
        lucide.createIcons();
    }

    function handlePlanningTableClick(e) {
        const deleteButton = e.target.closest('.delete-plan-btn');
        if (deleteButton) {
            const docId = deleteButton.dataset.id;
            showConfirmModal(docId, 'planning');
        }
    }
    
    // --- PAINEL DO LÍDER ---
    function renderLeaderPanel(planItems) {
        if (!leaderLaunchPanel) return;

        // Agrupar por Máquina + Produto (consolidar itens de OPs diferentes do mesmo produto)
        const groups = new Map();
        (planItems || []).forEach(item => {
            const key = `${item.machine}||${item.product_cod || item.product || ''}`;
            if (!groups.has(key)) {
                groups.set(key, {
                    ids: [item.id],
                    machine: item.machine,
                    product: item.product,
                    product_cod: item.product_cod,
                    mp: item.mp || '',
                    real_cycle_t1: item.real_cycle_t1 || null,
                    active_cavities_t1: item.active_cavities_t1 || null,
                    real_cycle_t2: item.real_cycle_t2 || null,
                    active_cavities_t2: item.active_cavities_t2 || null,
                    real_cycle_t3: item.real_cycle_t3 || null,
                    active_cavities_t3: item.active_cavities_t3 || null
                });
            } else {
                const g = groups.get(key);
                g.ids.push(item.id);
                // Manter o primeiro valor informado para ciclo/cavidades de cada turno
                if (!g.real_cycle_t1 && item.real_cycle_t1) g.real_cycle_t1 = item.real_cycle_t1;
                if (!g.active_cavities_t1 && item.active_cavities_t1) g.active_cavities_t1 = item.active_cavities_t1;
                if (!g.real_cycle_t2 && item.real_cycle_t2) g.real_cycle_t2 = item.real_cycle_t2;
                if (!g.active_cavities_t2 && item.active_cavities_t2) g.active_cavities_t2 = item.active_cavities_t2;
                if (!g.real_cycle_t3 && item.real_cycle_t3) g.real_cycle_t3 = item.real_cycle_t3;
                if (!g.active_cavities_t3 && item.active_cavities_t3) g.active_cavities_t3 = item.active_cavities_t3;
                if (!g.mp && item.mp) g.mp = item.mp;
            }
        });

        leaderLaunchPanel.innerHTML = Array.from(groups.values()).map(group => {
            const turnos = ['T1', 'T2', 'T3'];
            const statusHtml = turnos.map(turno => {
                const rc = group[`real_cycle_${turno.toLowerCase()}`];
                const cav = group[`active_cavities_${turno.toLowerCase()}`];
                const isComplete = rc && cav;
                const statusClass = isComplete ? 'bg-green-100 text-status-success' : 'bg-yellow-100 text-status-warning';
                const statusIcon = isComplete ? `<i data-lucide="check-circle-2" class="w-4 h-4"></i>` : `<i data-lucide="alert-circle" class="w-4 h-4"></i>`;
                return `<div class="flex items-center justify-center gap-2 p-1 rounded-md text-xs font-semibold ${statusClass}">${statusIcon} ${turno}</div>`;
            }).join('');

            const btnClasses = turnos.map(turno => {
                const rc = group[`real_cycle_${turno.toLowerCase()}`];
                const cav = group[`active_cavities_${turno.toLowerCase()}`];
                const isComplete = rc && cav;
                return isComplete ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            });
            const mpLabel = group.mp ? `<p class="text-xs text-gray-500 mt-1">MP: ${group.mp}</p>` : '';
            const idsCsv = group.ids.join(',');

            return `
                <div class="border rounded-lg p-4 shadow-md flex flex-col justify-between bg-white">
                    <div>
                        <h3 class="font-bold text-lg">${group.machine}</h3>
                        <p class="text-sm text-gray-600">${group.product}</p>
                        ${mpLabel}
                        <div class="grid grid-cols-3 gap-2 mt-2">
                           ${statusHtml}
                        </div>
                    </div>
                    <div class="grid grid-cols-3 gap-2 mt-4">
                        <button data-id="${idsCsv}" data-turno="T1" class="setup-btn ${btnClasses[0]} text-white font-bold py-2 px-3 rounded-lg text-sm">1º Turno</button>
                        <button data-id="${idsCsv}" data-turno="T2" class="setup-btn ${btnClasses[1]} text-white font-bold py-2 px-3 rounded-lg text-sm">2º Turno</button>
                        <button data-id="${idsCsv}" data-turno="T3" class="setup-btn ${btnClasses[2]} text-white font-bold py-2 px-3 rounded-lg text-sm">3º Turno</button>
                    </div>
                </div>
            `;
        }).join('');
        lucide.createIcons();
    }
    
    function handleLeaderPanelClick(e) {
        const setupButton = e.target.closest('.setup-btn');
        if (setupButton) {
            const docId = setupButton.dataset.id;
            const turno = setupButton.dataset.turno;
            showLeaderModal(docId, turno);
        }
    }

    async function showLeaderModal(docId, turno) {
        if (!leaderModalForm || !leaderModalTitle) return;
        
        console.log('[TRACE][showLeaderModal] opening', { docId, turno });

        leaderModalForm.querySelector('#leader-modal-cancel-btn')?.remove();
        
        leaderModalForm.innerHTML = `
            <input type="hidden" id="leader-entry-doc-id" name="docId">
            <input type="hidden" id="leader-entry-turno" name="turno">
            <div>
                <label for="leader-entry-real-cycle" class="block text-sm font-medium">Ciclo Real (${turno})</label>
                <input type="number" id="leader-entry-real-cycle" name="real_cycle" step="0.1" class="mt-1 w-full p-2 border-gray-300 rounded-md">
            </div>
            <div>
                <label for="leader-entry-active-cavities" class="block text-sm font-medium">Cavidades Ativas (${turno})</label>
                <input type="number" id="leader-entry-active-cavities" name="active_cavities" step="1" class="mt-1 w-full p-2 border-gray-300 rounded-md">
            </div>
            <div class="mt-6 flex justify-end gap-3 pt-4 border-t">
                <button type="button" id="leader-modal-cancel-btn" class="bg-gray-200 hover:bg-gray-300 font-bold py-2 px-6 rounded-lg">Cancelar</button>
                <button type="submit" class="bg-primary-blue hover:bg-blue-800 text-white font-bold py-2 px-6 rounded-lg">Salvar</button>
            </div>`;
        
        leaderModal.querySelector('#leader-modal-cancel-btn').addEventListener('click', hideLeaderModal);
        
        document.getElementById('leader-entry-doc-id').value = docId;
        document.getElementById('leader-entry-turno').value = turno;

        try {
            // Suporta múltiplos IDs (csv) vindos do painel consolidado
            const ids = String(docId).split(',').map(s => s.trim()).filter(Boolean);
            let headerMachine = '';
            let prefillReal = '';
            let prefillCav = '';
            for (const id of ids) {
                try {
                    const ref = db.collection('planning').doc(id);
                    const snap = await ref.get();
                    if (snap.exists) {
                        const data = snap.data();
                        if (!headerMachine) headerMachine = data.machine || '';
                        const rc = data[`real_cycle_${turno.toLowerCase()}`];
                        const cav = data[`active_cavities_${turno.toLowerCase()}`];
                        if (!prefillReal && rc) prefillReal = rc;
                        if (!prefillCav && cav) prefillCav = cav;
                        if (prefillReal && prefillCav) break; // já temos valores para preencher
                    }
                } catch (innerErr) {
                    console.warn('[TRACE][showLeaderModal] falha ao recuperar doc para prefill', id, innerErr);
                }
            }
            leaderModalTitle.textContent = `Lançamento: ${headerMachine || 'Máquina'} - ${turno}`;
            document.getElementById('leader-entry-real-cycle').value = prefillReal || '';
            document.getElementById('leader-entry-active-cavities').value = prefillCav || '';
            
        } catch (error) {
            console.error("Erro ao buscar dados do setup: ", error);
        }
        
        leaderModal.classList.remove('hidden');
        console.log('[TRACE][showLeaderModal] modal displayed');
    }
    
    function hideLeaderModal() {
        if (leaderModal) leaderModal.classList.add('hidden');
    }

    async function handleLeaderEntrySubmit(e) {
        e.preventDefault();
        const formData = new FormData(e.target);
        const docId = formData.get('docId');
        const turno = formData.get('turno');
        const realCycle = parseFloat(formData.get('real_cycle')) || null;
        const activeCavities = parseInt(formData.get('active_cavities')) || null;

        console.log('[TRACE][handleLeaderEntrySubmit] submission data', {
            docId,
            turno,
            realCycle,
            activeCavities
        });

        const planDataToUpdate = {
            [`real_cycle_${turno.toLowerCase()}`]: realCycle,
            [`active_cavities_${turno.toLowerCase()}`]: activeCavities,
        };

        console.log('[TRACE][handleLeaderEntrySubmit] updating planning document', planDataToUpdate);

        try {
            // Suporta múltiplos IDs (csv) para manter OPs sincronizadas para o mesmo produto
            const ids = String(docId).split(',').map(s => s.trim()).filter(Boolean);
            const batchSize = 20; // segurança para não estourar limites
            for (let i = 0; i < ids.length; i += batchSize) {
                const slice = ids.slice(i, i + batchSize);
                const batch = db.batch();
                slice.forEach(id => {
                    const ref = db.collection('planning').doc(id);
                    batch.update(ref, planDataToUpdate);
                });
                await batch.commit();
            }

            hideLeaderModal();
            console.log('[TRACE][handleLeaderEntrySubmit] completed successfully for ids', ids);
        } catch (error) {
            console.error("Erro ao salvar dados do líder: ", error);
            alert("Não foi possível salvar os dados. Tente novamente.");
        }
    }

    // --- PAINEL DO OPERADOR ---
    function listenToCurrentProductionPlan() {
        detachActiveListener();
        const date = getProductionDateString();
        showLoadingState('launch-panel', true);

        let planningItems = [];
        let launchedEntries = new Set();
        let productionEntries = [];

        const render = () => {
            renderLaunchPanel(planningItems, launchedEntries, productionEntries);
            showLoadingState('launch-panel', false, planningItems.length === 0);
        };

        // Limpar listeners anteriores se existirem
        listenerManager.unsubscribe('launchPlanning');
        listenerManager.unsubscribe('launchProductions');

        // NOVO: Buscar todos os planejamentos e filtrar os ATIVOS no cliente
        const planningQuery = db.collection('planning');
        listenerManager.subscribe('launchPlanning', planningQuery,
            (snapshot) => {
                // Filtrar apenas planejamentos ativos (não concluídos/finalizados/cancelados)
                planningItems = snapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(isPlanActive);
                planningItems.sort((a, b) => (a.createdAt?.toMillis() || 0) - (b.createdAt?.toMillis() || 0));
                render();
            },
            (error) => {
                console.error("Erro ao carregar plano de produção: ", error);
                if (launchPanelContainer) {
                    launchPanelContainer.innerHTML = `<div class="col-span-full text-center text-red-600 bg-red-50 p-4 rounded-lg"><p class="font-bold">Falha ao carregar dados.</p></div>`;
                }
            }
        );
        
        const entriesQuery = db.collection('production_entries').where('data', '==', date);
        listenerManager.subscribe('launchProductions', entriesQuery,
            (snapshot) => {
                launchedEntries = new Set();
                productionEntries = snapshot.docs.map(doc => doc.data());
                snapshot.forEach(doc => {
                    const entry = doc.data();
                    if(entry.produzido > 0 || entry.refugo_kg > 0) {
                        launchedEntries.add(`${entry.planId}-${entry.turno}`);
                    }
                });
                render();
            },
            (error) => {
                console.error("Erro ao carregar lançamentos de produção: ", error);
            }
        );
    }

    function renderLaunchPanel(planItems, launchedEntries, productionEntries) {
        if (!launchPanelContainer) return;
        launchPanelContainer.innerHTML = planItems.map(item => {
            const t1Launched = launchedEntries.has(`${item.id}-T1`);
            const t2Launched = launchedEntries.has(`${item.id}-T2`);
            const t3Launched = launchedEntries.has(`${item.id}-T3`);

            const t1Class = t1Launched ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            const t2Class = t2Launched ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            const t3Class = t3Launched ? 'bg-status-success hover:bg-green-700' : 'bg-gray-500 hover:bg-gray-600';
            
            const totalProduzido = productionEntries
                .filter(p => p.planId === item.id)
                .reduce((sum, p) => sum + (p.produzido || 0), 0);
            
            const meta = item.planned_quantity || 0;
            const progresso = meta > 0 ? (totalProduzido / meta) * 100 : 0;
            const progressoCor = progresso < 50 ? 'bg-status-error' : progresso < 90 ? 'bg-status-warning' : 'bg-status-success';

            const linkedOrderId = item.order_id || item.production_order_id || item.production_order || null;
            const linkedOrder = linkedOrderId && Array.isArray(productionOrdersCache)
                ? productionOrdersCache.find(order => order && order.id === linkedOrderId)
                : null;
            const orderNumberRaw = linkedOrder?.order_number
                || item.order_number
                || linkedOrder?.order_number_original
                || item.order_number_original
                || linkedOrder?.id
                || '';
            const orderNumberLabel = orderNumberRaw
                ? `OP ${escapeHtml(orderNumberRaw)}`
                : 'OP não vinculada';

            return `
            <div class="bg-gray-50 border rounded-lg p-4 shadow-sm flex flex-col justify-between">
                <div>
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="font-bold text-lg">${item.machine}</h3>
                            <p class="text-sm text-gray-600">${item.product}</p>
                            <p class="text-xs text-gray-500">${orderNumberLabel}</p>
                            <p class="text-xs text-gray-500 mt-1">${item.mp ? `MP: ${item.mp}` : 'MP não definida'}</p>
                        </div>
                        <span class="text-xs font-bold text-gray-500">${totalProduzido.toLocaleString('pt-BR')} / ${meta.toLocaleString('pt-BR')}</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                        <div class="${progressoCor} h-2.5 rounded-full" style="width: ${Math.min(progresso, 100)}%"></div>
                    </div>
                </div>
                <div class="grid grid-cols-3 gap-2 mt-4">
                    <button data-id="${item.id}" data-turno="T1" class="launch-btn ${t1Class} text-white font-bold py-2 rounded-md">Turno 1</button>
                    <button data-id="${item.id}" data-turno="T2" class="launch-btn ${t2Class} text-white font-bold py-2 rounded-md">Turno 2</button>
                    <button data-id="${item.id}" data-turno="T3" class="launch-btn ${t3Class} text-white font-bold py-2 rounded-md">Turno 3</button>
                </div>
            </div>
        `}).join('');
        lucide.createIcons();
    }
    
    async function handleLaunchPanelClick(e) {
        const launchButton = e.target.closest('.launch-btn');
        if (launchButton) {
            const planId = launchButton.dataset.id;
            const turno = launchButton.dataset.turno;
            showProductionModal(planId, turno);
        }
    }

    async function showProductionModal(planId, turno) {
        if (!productionModalForm || !productionModalTitle) return;
        
        productionModalForm.reset();
        document.getElementById('production-entry-plan-id').value = planId;
        document.getElementById('production-entry-turno').value = turno;

        try {
            const planDoc = await db.collection('planning').doc(planId).get();
            if (planDoc.exists) {
                const planData = planDoc.data();
                productionModalTitle.textContent = `Lançamento: ${planData.machine} - ${turno}`;
                // Preencher contexto do modal com dados do plano (máquina/produto)
                try {
                    fillModalContext(productionModal, {
                        machine: planData.machine,
                        product: planData.product,
                        product_cod: planData.product_cod
                    });
                } catch (e) { /* noop */ }
                
                // Configurar informações do produto
                const productWeightInfo = document.getElementById('product-weight-info');
                if (productWeightInfo) {
                    const pieceWeightGrams = resolvePieceWeightGrams(
                        planData.piece_weight_grams,
                        planData.piece_weight,
                        planData.weight
                    );
                    const infoParts = [
                        pieceWeightGrams > 0
                            ? `Peso da peça: ${pieceWeightGrams.toFixed(3)}g`
                            : 'Peso da peça: -'
                    ];
                    if (planData.mp) infoParts.push(`MP: ${planData.mp}`);
                    productWeightInfo.textContent = infoParts.join(' – ');
                }
                
                // Configurar caixa de tara
                const taraCheckbox = document.getElementById('use-tara-box');
                const taraWeightInput = document.getElementById('tara-box-weight');
                const taraInfo = document.getElementById('tara-box-info');
                
                const taraData = taraBoxesDatabase[planData.machine];
                if (taraData) {
                    taraWeightInput.value = taraData.peso;
                    taraInfo.textContent = taraData.descricao;
                }
            } else { throw new Error("Plano não encontrado."); }
            
            // Carregar lançamentos existentes
            await loadHourlyEntries(planId, turno);
            
            productionModal.classList.remove('hidden');

        } catch(error) {
            console.error("Erro ao abrir modal de produção:", error);
            alert("Não foi possível carregar os dados. Tente novamente.");
        }
    }

    function hideProductionModal() {
        if (productionModal) productionModal.classList.add('hidden');
    }

    async function handleProductionEntrySubmit(e) {
        e.preventDefault();
        const statusMessage = document.getElementById('production-modal-status');
        const saveButton = document.getElementById('production-modal-save-btn');
        
        if (!saveButton) return;
        
        saveButton.disabled = true;
        saveButton.textContent = 'Salvando...';

        const formData = new FormData(productionModalForm);
        const planId = formData.get('planId');
        const turno = formData.get('turno');
        
        console.log('[TRACE][handleProductionEntrySubmit] submission started', { planId, turno });

        const produzido = parseInt(formData.get('produzido')) || 0;
        const refugoKg = parseFloat(formData.get('refugo')) || 0;
        const borrasKg = parseFloat(formData.get('borras')) || 0;
        const motivoRefugo = formData.get('perdas');

        console.log('[TRACE][handleProductionEntrySubmit] parsed form values', {
            produzido,
            refugoKg,
            borrasKg,
            motivoRefugo
        });

        try {
            // Salvar lançamentos por hora
            await saveHourlyEntries(planId, turno);
            console.log('[TRACE][handleProductionEntrySubmit] hourly entries saved');

            // Salvar registro principal de produção
            const entriesRef = db.collection('production_entries');
            const q = entriesRef.where('planId', '==', planId).where('turno', '==', turno).limit(1);
            const querySnapshot = await q.get();
            const planDoc = await db.collection('planning').doc(planId).get();
            const planData = planDoc.exists ? planDoc.data() : {};
            const linkedOrderId = planData.order_id || planData.production_order_id || planData.production_order || null;
            const linkedOrderNumber = planData.order_number || planData.orderNumber || null;
            const planMachine = planData.machine || selectedMachineData?.machine || null;
            const planDate = planData.date || getProductionDateString();
            const planMp = planData.mp || '';
            const planMpType = planData.mp_type || '';

            console.log('[TRACE][handleProductionEntrySubmit] resolved plan info', {
                planMachine,
                planDate,
                planMp,
                planMpType,
                linkedOrderId
            });

            const entryPayload = {
                produzido,
                duracao_min: 0,
                refugo_kg: refugoKg,
                borras_kg: borrasKg,
                motivo_refugo: motivoRefugo,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                machine: planMachine, // FIX: vincula a máquina correta para análise e filtros
                mp: planMp,
                mp_type: planMpType,
                orderId: linkedOrderId || null,
                order_id: linkedOrderId || null,
                production_order_id: linkedOrderId || null,
                order_number: linkedOrderNumber || null
            };

            console.log('[TRACE][handleProductionEntrySubmit] entry payload', entryPayload);
            
            if(querySnapshot.empty){
                console.log('[TRACE][handleProductionEntrySubmit] creating production entry');
                await entriesRef.add({
                    ...entryPayload,
                    planId,
                    turno,
                    data: planDate,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                }); // FIX: inclui data/createdAt para uso futuro
            } else {
                console.log('[TRACE][handleProductionEntrySubmit] updating existing production entry');
                await querySnapshot.docs[0].ref.update({
                    ...entryPayload,
                    data: planDate
                });
            }

            if (statusMessage) {
                statusMessage.textContent = 'Lançamentos salvos com sucesso!';
                statusMessage.className = 'text-green-600 text-sm font-semibold h-5 text-center';
            }
            // Atualizar aba de análise se estiver aberta
            await refreshAnalysisIfActive();
            setTimeout(() => {
                hideProductionModal();
                if (statusMessage) statusMessage.textContent = '';
            }, 1500);
        } catch (error) {
            console.error("Erro ao salvar lançamentos: ", error);
            if (statusMessage) {
                statusMessage.textContent = 'Erro ao salvar. Tente novamente.';
                statusMessage.className = 'text-red-600 text-sm font-semibold h-5 text-center';
            }
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Salvar Lançamentos';
        }
    }
    // --- ABA DE LANÇAMENTO INTERATIVO ---
    
    function setupLaunchTab() {
        populateMachineSelector();

        if (machineCardGrid && !machineCardGrid.dataset.listenerAttached) {
            machineCardGrid.addEventListener('click', async (event) => {
                // Ações de botões dentro do card
                const finalizeBtn = event.target.closest('.card-finalize-btn');
                if (finalizeBtn) {
                    event.preventDefault();
                    event.stopPropagation();
                    await handleCardFinalizeClick(finalizeBtn);
                    return;
                }
                const activateNextBtn = event.target.closest('.card-activate-next-btn');
                if (activateNextBtn) {
                    event.preventDefault();
                    event.stopPropagation();
                    await handleCardActivateNextClick(activateNextBtn);
                    return;
                }

                // Seleção do card da máquina
                const card = event.target.closest('.machine-card');
                if (!card) return;
                const machine = card.dataset.machine;
                if (!machine) return;
                await onMachineSelected(machine);
            });
            machineCardGrid.dataset.listenerAttached = 'true';
        }

        setupActionButtons();
        updateCurrentShift();
        setInterval(updateCurrentShift, 60000);

        // Toggle modo do gráfico (Por hora / OP)
        if (launchChartModeHourlyBtn && !launchChartModeHourlyBtn.dataset.listenerAttached) {
            launchChartModeHourlyBtn.addEventListener('click', async () => {
                if (launchChartMode === 'hourly') return;
                launchChartMode = 'hourly';
                launchChartModeHourlyBtn.classList.add('bg-white','text-blue-600','shadow-sm');
                launchChartModeOpBtn?.classList.remove('bg-white','text-blue-600','shadow-sm');
                if (opProductionChart) opProductionChart.classList.add('hidden');
                if (hourlyProductionChart) hourlyProductionChart.classList.remove('hidden');
                await refreshLaunchCharts();
            });
            launchChartModeHourlyBtn.dataset.listenerAttached = 'true';
        }
        if (launchChartModeOpBtn && !launchChartModeOpBtn.dataset.listenerAttached) {
            launchChartModeOpBtn.addEventListener('click', async () => {
                if (launchChartMode === 'op') return;
                launchChartMode = 'op';
                launchChartModeOpBtn.classList.add('bg-white','text-blue-600','shadow-sm');
                launchChartModeHourlyBtn?.classList.remove('bg-white','text-blue-600','shadow-sm');
                if (hourlyProductionChart) hourlyProductionChart.classList.add('hidden');
                if (opProductionChart) opProductionChart.classList.remove('hidden');
                await refreshLaunchCharts();
            });
            launchChartModeOpBtn.dataset.listenerAttached = 'true';
        }
    }

    function updateCurrentShift() {
        const now = new Date();
        const hour = now.getHours();
        let currentShift;
        
        if (hour >= 7 && hour < 15) {
            currentShift = 'T1';
        } else if (hour >= 15 && hour < 23) {
            currentShift = 'T2';
        } else {
            currentShift = 'T3';
        }
        
        if (currentShiftDisplay) {
            currentShiftDisplay.textContent = currentShift;
        }
    }
    
    function updateMachineInfo() {
        if (!selectedMachineData) return;
        
        if (machineIcon) machineIcon.textContent = selectedMachineData.machine;
        if (machineName) machineName.textContent = `Máquina ${selectedMachineData.machine}`;
        if (productName) productName.textContent = selectedMachineData.product || 'Produto não definido';
        if (shiftTarget) {
            // Usar APENAS lot_size, não planned_quantity (meta diária)
            const totalPlanned = selectedMachineData.order_lot_size || selectedMachineData.lot_size || 0;
            const totalExecuted = coerceToNumber(selectedMachineData.total_produzido, 0);
            
            if (!totalPlanned) {
                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / N/A`;
            } else {
                shiftTarget.textContent = `${totalExecuted.toLocaleString('pt-BR')} / ${totalPlanned.toLocaleString('pt-BR')}`;
            }
        }
    }
    
    
    
    // Carregar gráfico da OP (acumulado por DIA ao longo da ordem)
    async function loadOpProductionChart() {
        if (!selectedMachineData || !opProductionChart) return;
        try {
            const orderId = selectedMachineData.order_id || selectedMachineData.orderId || null;
            const planId = selectedMachineData.id;
            let query = db.collection('production_entries');
            if (orderId) {
                query = query.where('orderId', '==', orderId);
            } else {
                query = query.where('planId', '==', planId);
            }
            const snap = await query.get();
            const entries = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            if (entries.length === 0) {
                if (opChartInstance) { opChartInstance.destroy(); opChartInstance = null; }
                const ctx = opProductionChart.getContext('2d');
                ctx.clearRect(0,0,opProductionChart.width, opProductionChart.height);
                return;
            }
            const parseDate = (e) => {
                try {
                    if (e.timestamp?.toDate) return e.timestamp.toDate();
                } catch (_) {}
                if (e.dataHoraInformada) return new Date(e.dataHoraInformada);
                if (e.data && e.horaInformada) return new Date(`${e.data}T${e.horaInformada}:00`);
                if (e.data) return new Date(`${e.data}T12:00:00`);
                return new Date();
            };
            // Agrupar por DIA de produção
            const toDateKey = (e) => {
                if (e.data) return e.data; // já deve estar em YYYY-MM-DD
                const d = parseDate(e);
                const y = d.getFullYear();
                const m = String(d.getMonth()+1).padStart(2,'0');
                const day = String(d.getDate()).padStart(2,'0');
                return `${y}-${m}-${day}`;
            };
            const dailyTotals = {};
            entries.forEach(e => {
                const key = toDateKey(e);
                const qty = Number(e.produzido || e.quantity || 0) || 0;
                dailyTotals[key] = (dailyTotals[key] || 0) + qty;
            });
            const dayKeys = Object.keys(dailyTotals).sort(); // YYYY-MM-DD ordena lexicograficamente por data
            let cumulative = 0;
            const labels = [];
            const values = [];
            const fmtDay = (k) => {
                // k: YYYY-MM-DD -> DD/MM
                const [yy, mm, dd] = k.split('-');
                return `${dd}/${mm}`;
            };
            dayKeys.forEach(k => {
                cumulative += dailyTotals[k];
                labels.push(fmtDay(k));
                values.push(cumulative);
            });
            if (opChartInstance) { opChartInstance.destroy(); opChartInstance = null; }
            opChartInstance = new Chart(opProductionChart.getContext('2d'), {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Acumulado da OP (por dia)',
                            data: values,
                            borderColor: '#10B981',
                            backgroundColor: 'rgba(16,185,129,0.15)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.2,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { grid: { display: false } },
                        y: { beginAtZero: true, grid: { color: 'rgba(0,0,0,0.05)' } }
                    },
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: (ctx) => ` ${ctx.parsed.y?.toLocaleString('pt-BR')} peças`
                            }
                        }
                    }
                }
            });
        } catch (error) {
            console.error('Erro ao carregar gráfico da OP:', error);
        }
    }

    async function refreshLaunchCharts() {
        // Guard para evitar atualizações concorrentes sobrescrevendo o gráfico
        if (isRefreshingLaunchCharts) return;
        isRefreshingLaunchCharts = true;
        try {
            if (launchChartMode === 'op') {
                await loadOpProductionChart();
            } else {
                await loadHourlyProductionChart();
            }
        } finally {
            isRefreshingLaunchCharts = false;
        }
    }
    
    async function loadTodayStats() {
        if (!selectedMachineData) return;
        
        try {
            const today = getProductionDateString();
            // Calcular janela do dia de produção atual [07:00 de hoje, 07:00 de amanhã)
            const windowStart = combineDateAndTime(today, '07:00');
            const nextDay = new Date(windowStart);
            nextDay.setDate(nextDay.getDate() + 1);
            const tomorrow = nextDay.toISOString().split('T')[0];
            const windowEnd = combineDateAndTime(tomorrow, '07:00');
            
            // Carregar produção do dia para a MÁQUINA (somando todas as OPs do dia)
            const prodSnapshot = await db.collection('production_entries')
                .where('data', '==', today)
                .where('machine', '==', selectedMachineData.machine)
                .get();
            const prodDocs = prodSnapshot.docs;
            let totalProduced = 0;
            let totalLosses = 0;
            
            // Produção por turno
            let producedT1 = 0;
            let producedT2 = 0;
            let producedT3 = 0;
            
            prodDocs.forEach(doc => {
                const data = doc.data();
                const quantidade = Number(data.produzido || data.quantity || 0) || 0;
                const turno = Number(data.turno || data.shift || 0);
                
                totalProduced += quantidade;
                totalLosses += Number(data.refugo_kg || 0) || 0;
                
                // Separar por turno
                if (turno === 1) {
                    producedT1 += quantidade;
                } else if (turno === 2) {
                    producedT2 += quantidade;
                } else if (turno === 3) {
                    producedT3 += quantidade;
                }
            });
            
            // Carregar paradas (duas consultas por data para evitar índice composto)
            const [dtSnapToday, dtSnapTomorrow] = await Promise.all([
                db.collection('downtime_entries')
                  .where('machine', '==', selectedMachineData.machine)
                  .where('date', '==', today)
                  .get(),
                db.collection('downtime_entries')
                  .where('machine', '==', selectedMachineData.machine)
                  .where('date', '==', tomorrow)
                  .get()
            ]);
            const dtDocs = [...dtSnapToday.docs, ...dtSnapTomorrow.docs];
            let totalDowntime = 0;
            dtDocs.forEach(doc => {
                const data = doc.data();
                const start = combineDateAndTime(data.date, data.startTime);
                const end = combineDateAndTime(data.date, data.endTime);
                if (!(start instanceof Date) || Number.isNaN(start.getTime())) return;
                if (!(end instanceof Date) || Number.isNaN(end.getTime())) return;
                const overlapStart = start > windowStart ? start : windowStart;
                const overlapEnd = end < windowEnd ? end : windowEnd;
                if (overlapEnd > overlapStart) {
                    totalDowntime += Math.round((overlapEnd - overlapStart) / 60000);
                }
            });
            
            // Calcular eficiência baseado na meta diária (com fallback para planned_quantity)
            const dailyTarget = Number(selectedMachineData.daily_target || selectedMachineData.planned_quantity || 0);
            const efficiency = dailyTarget > 0 ? (totalProduced / dailyTarget * 100) : 0;
            
            // Atualizar display - produção por turno
            const producedT1El = document.getElementById('produced-t1');
            const producedT2El = document.getElementById('produced-t2');
            const producedT3El = document.getElementById('produced-t3');
            if (producedT1El) producedT1El.textContent = producedT1.toLocaleString('pt-BR');
            if (producedT2El) producedT2El.textContent = producedT2.toLocaleString('pt-BR');
            if (producedT3El) producedT3El.textContent = producedT3.toLocaleString('pt-BR');
            
            // Atualizar display - totais
            if (producedToday) producedToday.textContent = totalProduced.toLocaleString('pt-BR');
            if (efficiencyToday) efficiencyToday.textContent = efficiency.toFixed(1) + '%';
            if (lossesToday) lossesToday.textContent = totalLosses.toFixed(2);
            if (downtimeToday) downtimeToday.textContent = totalDowntime;
            
        } catch (error) {
            console.error("Erro ao carregar estatísticas: ", error);
        }
    }
    
    function setupActionButtons() {
        // Botão de produção
        const btnProduction = document.getElementById('btn-production');
        if (btnProduction && !btnProduction.dataset.listenerAttached) {
            btnProduction.addEventListener('click', openProductionModal);
            btnProduction.dataset.listenerAttached = 'true';
        }

        // Botão de perdas
        const btnLosses = document.getElementById('btn-losses');
        if (btnLosses && !btnLosses.dataset.listenerAttached) {
            btnLosses.addEventListener('click', openLossesModal);
            btnLosses.dataset.listenerAttached = 'true';
        }
        
        // Botão de parada
        const btnDowntime = document.getElementById('btn-downtime');
        if (btnDowntime && !btnDowntime.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-downtime');
            btnDowntime.addEventListener('click', toggleDowntime);
            btnDowntime.dataset.listenerAttached = 'true';
        } else if (btnDowntime) {
            console.log('[TRACE][setupEventListeners] btn-downtime listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-downtime não encontrado no DOM');
        }
        
        // Botão de produção manual
        const btnManualProduction = document.getElementById('btn-manual-production');
        if (btnManualProduction && !btnManualProduction.dataset.listenerAttached) {
            btnManualProduction.addEventListener('click', openManualProductionModal);
            btnManualProduction.dataset.listenerAttached = 'true';
        }

        const btnManualLosses = document.getElementById('btn-manual-losses');
        if (btnManualLosses && !btnManualLosses.dataset.listenerAttached) {
            btnManualLosses.addEventListener('click', openManualLossesModal);
            btnManualLosses.dataset.listenerAttached = 'true';
        }

        // Botão de lançamento manual de parada
        const btnManualDowntime = document.getElementById('btn-manual-downtime');
        if (btnManualDowntime && !btnManualDowntime.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-manual-downtime');
            btnManualDowntime.addEventListener('click', openManualDowntimeModal);
            btnManualDowntime.dataset.listenerAttached = 'true';
        } else if (btnManualDowntime) {
            console.log('[TRACE][setupEventListeners] btn-manual-downtime listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-manual-downtime não encontrado no DOM');
        }
        
        // Botão de retrabalho
        const btnRework = document.getElementById('btn-rework');
        if (btnRework && !btnRework.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-rework');
            btnRework.addEventListener('click', openReworkModal);
            btnRework.dataset.listenerAttached = 'true';
        } else if (btnRework) {
            console.log('[TRACE][setupEventListeners] btn-rework listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-rework não encontrado no DOM');
        }
        
        // Botão de borra
        const btnManualBorra = document.getElementById('btn-manual-borra');
        if (btnManualBorra && !btnManualBorra.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-manual-borra');
            btnManualBorra.addEventListener('click', openManualBorraModal);
            btnManualBorra.dataset.listenerAttached = 'true';
        } else if (btnManualBorra) {
            console.log('[TRACE][setupEventListeners] btn-manual-borra listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-manual-borra não encontrado no DOM');
        }

        // Botão de ajuste de quantidade executada
        const btnAdjustExecuted = document.getElementById('btn-adjust-executed');
        if (btnAdjustExecuted && !btnAdjustExecuted.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-adjust-executed');
            btnAdjustExecuted.addEventListener('click', openAdjustExecutedModal);
            btnAdjustExecuted.dataset.listenerAttached = 'true';
        } else if (btnAdjustExecuted) {
            console.log('[TRACE][setupEventListeners] btn-adjust-executed listener já anexado');
        }

        // Botão de paradas longas
        const btnExtendedDowntime = document.getElementById('btn-extended-downtime');
        if (btnExtendedDowntime && !btnExtendedDowntime.dataset.listenerAttached) {
            console.log('[TRACE][setupEventListeners] Anexando listener ao btn-extended-downtime');
            btnExtendedDowntime.addEventListener('click', openExtendedDowntimeModal);
            btnExtendedDowntime.dataset.listenerAttached = 'true';
        } else if (btnExtendedDowntime) {
            console.log('[TRACE][setupEventListeners] btn-extended-downtime listener já anexado');
        } else {
            console.warn('[WARN][setupEventListeners] btn-extended-downtime não encontrado no DOM');
        }

        // Nota: O submit de paradas longas da ABA é tratado pelo setupExtendedDowntimeTab()
        // Não anexar listener duplicado aqui
        
        // Setup modals
        try {
            setupModals();
            console.log('[TRACE][setupEventListeners] setupModals completed successfully');
        } catch (err) {
            console.error('[ERROR][setupEventListeners] setupModals failed:', err);
        }
        
        // Setup tare controls
        try {
            setupTareControls();
            console.log('[TRACE][setupEventListeners] setupTareControls completed successfully');
        } catch (err) {
            console.error('[ERROR][setupEventListeners] setupTareControls failed:', err);
        }
    }

    async function handleFinalizeOrderClick(event) {
        event?.preventDefault?.();

        if (!currentActiveOrder || !currentActiveOrder.id) {
            showNotification('Nenhuma ordem ativa identificada para esta máquina.', 'warning');
            return;
        }

        if (!selectedMachineData) {
            alert('Selecione uma máquina antes de finalizar a ordem.');
            return;
        }

        if (typeof window.authSystem?.checkPermissionForAction === 'function') {
            const hasPermission = window.authSystem.checkPermissionForAction('close_production_order');
            if (hasPermission === false) {
                return;
            }
        }

        const orderLabel = currentActiveOrder.order_number || currentActiveOrder.order_number_original || currentActiveOrder.id;
        const confirmMessage = `Confirma a finalização da OP ${orderLabel || ''}? Esta ação marcará o lote como concluído.`;
        if (!window.confirm(confirmMessage)) {
            return;
        }

        const button = finalizeOrderBtn;
        const originalContent = button ? button.innerHTML : '';

        try {
            if (button) {
                button.disabled = true;
                button.innerHTML = `<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span>Finalizando...</span>`;
                lucide.createIcons();
            }

        const currentUser = getActiveUser();
            const progressSnapshot = {
                executed: Number(currentOrderProgress.executed) || 0,
                planned: Number(currentOrderProgress.planned) || 0,
                expected: Number(currentOrderProgress.expected) || 0
            };

            const updatePayload = {
                status: 'concluida',
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                completedAt: firebase.firestore.FieldValue.serverTimestamp(),
                completedBy: currentUser.username || null,
                completedByName: currentUser.name || null,
                last_progress: {
                    ...progressSnapshot,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                }
            };

            await db.collection('production_orders').doc(currentActiveOrder.id).update(updatePayload);

            const planId = selectedMachineData?.id;
            if (planId) {
                const planUpdate = {
                    status: 'concluida',
                    finishedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    finishedBy: currentUser.name || currentUser.username || null
                };

                try {
                    await db.collection('planning').doc(planId).update(planUpdate);
                } catch (planError) {
                    console.warn('Não foi possível atualizar status do planejamento:', planError);
                }
            }

            showNotification(`OP ${orderLabel} finalizada com sucesso!`, 'success');

            if (button) {
                button.classList.add('hidden');
            }

            currentActiveOrder = { ...currentActiveOrder, status: 'concluida' };

            await Promise.allSettled([
                loadTodayStats(),
                refreshAnalysisIfActive()
            ]);

            currentActiveOrder = null;
            selectedMachineData = null;
            setActiveMachineCard(null);
            resetProductionTimer();
            if (productionControlPanel) {
                productionControlPanel.classList.add('hidden');
            }
            if (recentEntriesList) {
                recentEntriesList.innerHTML = '';
            }
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });

            await populateMachineSelector();
        } catch (error) {
            console.error('Erro ao finalizar ordem de produção:', error);
            alert('Não foi possível finalizar a ordem. Tente novamente.');
        } finally {
            if (button) {
                button.disabled = false;
                button.innerHTML = originalContent;
                lucide.createIcons();
            }
        }
    }
    
    function setupModals() {
    // ================================
    // VALIDAÇÃO EM TEMPO REAL (POKA-YOKE)
    // ================================
    
    // Validar campos de lançamento de produção em tempo real
    function setupProductionFormValidation() {
        const qtyInput = document.getElementById('quick-production-qty');
        const weightInput = document.getElementById('quick-production-weight');
        const useTareCheckbox = document.getElementById('quick-production-use-tare');
        const submitBtn = document.getElementById('quick-production-submit');
        const measuredFeedback = document.getElementById('quick-production-piece-weight-feedback');
        const measuredVariation = document.getElementById('quick-production-piece-weight-variation');
        
        if (!qtyInput || !weightInput) return;
        
        // Função para atualizar feedback
        const updateFeedback = () => {
            const qty = qtyInput.value ? parseInt(qtyInput.value, 10) : 0;
            const weightInput_value = weightInput.value || '';
            const weightGrams = parseWeightInputToGrams(weightInput_value);
            // Usar getActivePieceWeightGrams que faz fallback para o catálogo
            const activePieceWeight = getActivePieceWeightGrams();
            
            // Atualizar display de conversão
            const convertedDisplay = document.getElementById('quick-production-weight-converted');
            if (weightGrams > 0) {
                let conversionText = '';
                
                // Mostrar conversão de unidade
                if (parseFloat(weightInput_value) > 0 && parseFloat(weightInput_value) < 100) {
                    conversionText = `= ${weightGrams}g`;
                } else {
                    conversionText = `= ${(weightGrams/1000).toFixed(3)}kg`;
                }
                
                // Calcular peso líquido se tara estiver ativa
                let netWeightGrams = weightGrams;
                if (useTareCheckbox && useTareCheckbox.checked) {
                    const tareGrams = getTareWeightForMachine(selectedMachineData?.machine);
                    if (tareGrams > 0) {
                        netWeightGrams = Math.max(0, weightGrams - tareGrams);
                        conversionText += ` → ${(netWeightGrams/1000).toFixed(3)}kg (líquido)`;
                    }
                }
                
                // ✅ NOVO: Mostrar conversão para peças
                if (activePieceWeight > 0 && netWeightGrams > 0) {
                    const estimatedPieces = Math.floor(netWeightGrams / activePieceWeight);
                    conversionText += ` ≈ ${estimatedPieces.toLocaleString('pt-BR')} peças`;
                }
                
                convertedDisplay.textContent = conversionText;
                convertedDisplay.classList.remove('hidden');
            } else {
                convertedDisplay.textContent = '';
            }
            
            if (measuredVariation) {
                measuredVariation.textContent = '';
                measuredVariation.classList.add('hidden');
            }
            
            // Validar consistência se ambos preenchidos
            const consistencyAlert = document.getElementById('quick-production-consistency-alert');
            const consistencyMsg = document.getElementById('quick-production-consistency-message');
            
            if (qty > 0 && weightGrams > 0 && selectedMachineData) {
                if (activePieceWeight > 0) {
                    const consistency = validateWeightQuantityConsistency(weightGrams, qty, activePieceWeight, PIECE_WEIGHT_TOLERANCE_PERCENT);
                    if (!consistency.valid) {
                        consistencyAlert.classList.remove('hidden');
                        consistencyMsg.textContent = consistency.message;
                        submitBtn.classList.add('opacity-75');
                    } else {
                        consistencyAlert.classList.add('hidden');
                        submitBtn.classList.remove('opacity-75');
                    }
                }
            } else {
                consistencyAlert.classList.add('hidden');
                submitBtn.classList.remove('opacity-75');
            }
            
            // Validar que pelo menos um campo está preenchido
            if ((qty === 0 || !qtyInput.value) && (weightGrams === 0 || !weightInput.value)) {
                submitBtn.disabled = true;
                submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                submitBtn.disabled = false;
                submitBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        };

        quickProductionUpdateFeedback = updateFeedback;
        
        // Event listeners
        qtyInput.addEventListener('input', updateFeedback);
        qtyInput.addEventListener('blur', updateFeedback);
        qtyInput.addEventListener('change', updateFeedback);

        weightInput.addEventListener('input', updateFeedback);
        weightInput.addEventListener('blur', updateFeedback);
        weightInput.addEventListener('change', updateFeedback);
        
        if (measuredInput) {
            measuredInput.addEventListener('input', () => {
                if (measuredInput.value && measuredFeedback) {
                    measuredFeedback.textContent = '';
                }
                updateFeedback();
            });
            measuredInput.addEventListener('blur', () => {
                const val = measuredInput.value;
                if (val && (isNaN(parseFloat(val)) || parseFloat(val) <= 0)) {
                    measuredInput.classList.add('border-red-500', 'border-2');
                    if (measuredFeedback) {
                        measuredFeedback.textContent = '❌ Informe um peso válido em gramas';
                        measuredFeedback.classList.add('text-red-600');
                    }
                } else {
                    measuredInput.classList.remove('border-red-500', 'border-2');
                    if (measuredFeedback) {
                        measuredFeedback.textContent = 'Se vazio, será usado o peso padrão do planejamento.';
                        measuredFeedback.classList.remove('text-red-600');
                    }
                }
            });
        }
        
        if (useTareCheckbox) {
            useTareCheckbox.addEventListener('change', updateFeedback);
        }
        
        // Validar que quantidade é inteiro positivo
        qtyInput.addEventListener('blur', function() {
            const val = this.value;
            if (val && (isNaN(parseInt(val, 10)) || parseInt(val, 10) < 0)) {
                this.classList.add('border-red-500', 'border-2');
                document.getElementById('quick-production-qty-feedback').textContent = '❌ Deve ser um número inteiro positivo';
                document.getElementById('quick-production-qty-feedback').classList.add('text-red-600');
            } else {
                this.classList.remove('border-red-500', 'border-2');
                document.getElementById('quick-production-qty-feedback').textContent = '';
                document.getElementById('quick-production-qty-feedback').classList.remove('text-red-600');
            }
        });
        
        // Validar que peso é número positivo
        weightInput.addEventListener('blur', function() {
            const val = this.value;
            if (val && (isNaN(parseFloat(val)) || parseFloat(val) < 0)) {
                this.classList.add('border-red-500', 'border-2');
                document.getElementById('quick-production-weight-feedback').textContent = '❌ Deve ser um número positivo';
                document.getElementById('quick-production-weight-feedback').classList.add('text-red-600');
            } else {
                this.classList.remove('border-red-500', 'border-2');
                document.getElementById('quick-production-weight-feedback').textContent = 'Digite o peso em gramas (Ex: 1500g = 1,5kg)';
                document.getElementById('quick-production-weight-feedback').classList.remove('text-red-600');
            }
        });
        
        // Primeiro update
        updateFeedback();
    }

        // Modal de produção
        const quickProductionModal = document.getElementById('quick-production-modal');
        const quickProductionClose = document.getElementById('quick-production-close');
        const quickProductionCancel = document.getElementById('quick-production-cancel');
        const quickProductionForm = document.getElementById('quick-production-form');
        
        if (quickProductionClose) quickProductionClose.addEventListener('click', () => closeModal('quick-production-modal'));
        if (quickProductionCancel) quickProductionCancel.addEventListener('click', () => closeModal('quick-production-modal'));
        // Listeners serão adicionados em openProductionModal() quando o modal abre
        
        // Modal de perdas
        const quickLossesClose = document.getElementById('quick-losses-close');
        const quickLossesCancel = document.getElementById('quick-losses-cancel');
        const quickLossesForm = document.getElementById('quick-losses-form');
        const quickLossesDeleteBtn = document.getElementById('quick-losses-delete-btn');
        
        if (quickLossesClose) quickLossesClose.addEventListener('click', () => closeModal('quick-losses-modal'));
        if (quickLossesCancel) quickLossesCancel.addEventListener('click', () => closeModal('quick-losses-modal'));
        if (quickLossesForm) quickLossesForm.addEventListener('submit', handleLossesSubmit);
        if (quickLossesDeleteBtn) {
            quickLossesDeleteBtn.addEventListener('click', () => {
                if (currentEditContext && currentEditContext.type === 'loss' && currentEditContext.id) {
                    const targetCollection = currentEditContext.collection || 'production_entries';
                    showConfirmModal(currentEditContext.id, targetCollection);
                } else {
                    alert('Abra um lançamento existente para excluir.');
                }
            });
        }
        
        // Modal de parada
        const quickDowntimeClose = document.getElementById('quick-downtime-close');
        const quickDowntimeCancel = document.getElementById('quick-downtime-cancel');
        const quickDowntimeForm = document.getElementById('quick-downtime-form');
        
        if (quickDowntimeClose) quickDowntimeClose.addEventListener('click', () => closeModal('quick-downtime-modal'));
        if (quickDowntimeCancel) quickDowntimeCancel.addEventListener('click', () => closeModal('quick-downtime-modal'));
        if (quickDowntimeForm) quickDowntimeForm.addEventListener('submit', handleDowntimeSubmit);
        
        // Modal de produção manual
        const manualProductionClose = document.getElementById('manual-production-close');
        const manualProductionCancel = document.getElementById('manual-production-cancel');
        const manualProductionForm = document.getElementById('manual-production-form');
        const manualProductionSubmitBtn = document.getElementById('manual-production-submit');

        if (manualProductionClose) manualProductionClose.addEventListener('click', () => closeModal('manual-production-modal'));
        if (manualProductionCancel) manualProductionCancel.addEventListener('click', () => closeModal('manual-production-modal'));
        
        // Modal de perdas manual
        const manualLossesClose = document.getElementById('manual-losses-close');
        const manualLossesCancel = document.getElementById('manual-losses-cancel');

        if (manualLossesClose) manualLossesClose.addEventListener('click', () => closeModal('manual-losses-modal'));
        if (manualLossesCancel) manualLossesCancel.addEventListener('click', () => closeModal('manual-losses-modal'));

        // Modal de parada manual
        const manualDowntimeClose = document.getElementById('manual-downtime-close');
        const manualDowntimeCancel = document.getElementById('manual-downtime-cancel');
        
        if (manualDowntimeClose) manualDowntimeClose.addEventListener('click', () => closeModal('manual-downtime-modal'));
        if (manualDowntimeCancel) manualDowntimeCancel.addEventListener('click', () => closeModal('manual-downtime-modal'));

        // Modal de retrabalho
        const quickReworkClose = document.getElementById('quick-rework-close');
        const quickReworkCancel = document.getElementById('quick-rework-cancel');
        const quickReworkForm = document.getElementById('quick-rework-form');

        if (quickReworkClose) quickReworkClose.addEventListener('click', () => closeModal('quick-rework-modal'));
        if (quickReworkCancel) quickReworkCancel.addEventListener('click', () => closeModal('quick-rework-modal'));
        if (quickReworkForm) quickReworkForm.addEventListener('submit', handleReworkSubmit);

        // Modal de borra
        const manualBorraClose = document.getElementById('manual-borra-close');
        const manualBorraCancel = document.getElementById('manual-borra-cancel');
        const manualBorraForm = document.getElementById('manual-borra-form');

        if (manualBorraClose) manualBorraClose.addEventListener('click', () => closeModal('manual-borra-modal'));
        if (manualBorraCancel) manualBorraCancel.addEventListener('click', () => closeModal('manual-borra-modal'));
        if (manualBorraForm) manualBorraForm.addEventListener('submit', handleManualBorraSubmit);

        // Modal de ajuste de quantidade
        const adjustQuantityClose = document.getElementById('adjust-quantity-close');
        const adjustQuantityCancel = document.getElementById('adjust-quantity-cancel');
        const adjustQuantityForm = document.getElementById('adjust-quantity-form');

        if (adjustQuantityClose) adjustQuantityClose.addEventListener('click', closeAdjustQuantityModal);
        if (adjustQuantityCancel) adjustQuantityCancel.addEventListener('click', closeAdjustQuantityModal);
        if (adjustQuantityForm) adjustQuantityForm.addEventListener('submit', handleAdjustQuantitySubmit);

        // Modal de ajuste de quantidade executada (planejamento)
        initAdjustExecutedModal();
    }
    
    // Funções para abrir/fechar modais
    function openProductionModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }
        updateQuickProductionPieceWeightUI({ forceUpdateInput: true });
        
        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('quick-production-form');
        const submitBtn = document.getElementById('quick-production-submit');
        
        if (form) {
            form.removeEventListener('submit', handleQuickProductionSubmit);
            form.addEventListener('submit', handleQuickProductionSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleQuickProductionSubmit);
            submitBtn.addEventListener('click', handleQuickProductionSubmit);
        }
        
        openModal('quick-production-modal');
    }
    
    function openLossesModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }
        // Ocultar botão de exclusão em novo lançamento
        const quickLossesDeleteBtn = document.getElementById('quick-losses-delete-btn');
        if (quickLossesDeleteBtn) quickLossesDeleteBtn.classList.add('hidden');
        
        // Configurar poka yoke para entrada de peso
        const weightInput = document.getElementById('quick-losses-weight');
        if (weightInput) {
            // Criar helper de validação se não existir
            if (!document.getElementById('weight-feedback-helper')) {
                const helper = document.createElement('div');
                helper.id = 'weight-feedback-helper';
                helper.className = 'mt-1 text-sm font-medium';
                weightInput.parentElement.appendChild(helper);
            }
            
            // Limpar valor anterior
            weightInput.value = '';
            
            // Adicionar listener para feedback real-time
            weightInput.removeEventListener('input', updateWeightFeedback);
            weightInput.addEventListener('input', updateWeightFeedback);
            
            // Adicionar listener para validação ao sair
            weightInput.removeEventListener('blur', validateWeightInput);
            weightInput.addEventListener('blur', validateWeightInput);
        }

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('quick-losses-form');
        const submitBtn = document.getElementById('quick-losses-submit');
        const closeBtn = document.getElementById('quick-losses-close');
        const cancelBtn = document.getElementById('quick-losses-cancel');
        
        if (form) {
            form.removeEventListener('submit', handleLossesSubmit);
            form.addEventListener('submit', handleLossesSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleLossesSubmit);
            submitBtn.addEventListener('click', handleLossesSubmit);
        }

        if (closeBtn) {
            closeBtn.removeEventListener('click', () => closeModal('quick-losses-modal'));
            closeBtn.addEventListener('click', () => closeModal('quick-losses-modal'));
        }

        if (cancelBtn) {
            cancelBtn.removeEventListener('click', () => closeModal('quick-losses-modal'));
            cancelBtn.addEventListener('click', () => closeModal('quick-losses-modal'));
        }
        
        openModal('quick-losses-modal');
    }
    
    // Atualizar feedback em tempo real do input de peso
    function updateWeightFeedback() {
        const weightInput = document.getElementById('quick-losses-weight');
        const helper = document.getElementById('weight-feedback-helper');
        
        if (!helper || !weightInput.value) {
            if (helper) {
                helper.innerHTML = '';
                helper.className = 'mt-1 text-sm';
            }
            return;
        }
        
        const rawValue = weightInput.value;
        const weightGrams = parseInt(rawValue, 10) || 0;
        
        let feedbackHTML = '';
        let feedbackClass = 'text-gray-600';
        
        // Obter peso da peça para conversão (usa catálogo como fallback)
        const pieceWeightGrams = getActivePieceWeightGrams();
        
        if (weightGrams > 0) {
            // Entrada em gramas - mostrar conversão para kg
            const weightKg = (weightGrams / 1000).toFixed(3);
            feedbackHTML = `✔ ${weightGrams}g = <strong>${weightKg} kg</strong>`;
            
            // Calcular e mostrar quantidade de peças
            if (pieceWeightGrams > 0) {
                const estimatedPieces = Math.floor(weightGrams / pieceWeightGrams);
                feedbackHTML += ` ≈ <strong class="text-blue-600">${estimatedPieces.toLocaleString('pt-BR')} peças</strong>`;
            }
            
            feedbackClass = 'text-green-700';
        } else if (rawValue && weightGrams === 0) {
            // Entrada não-vazia mas não foi convertida
            feedbackHTML = `❌ <strong>Erro:</strong> Não foi possível interpretar "${rawValue}" como número`;
            feedbackClass = 'text-red-700 bg-red-50 p-2 rounded border border-red-200';
        }
        
        if (helper) {
            helper.innerHTML = feedbackHTML;
            helper.className = `mt-1 text-sm font-medium ${feedbackClass}`;
        }
    }
    
    // Validar e corrigir entrada de peso ao sair do campo
    function validateWeightInput() {
        const weightInput = document.getElementById('quick-losses-weight');
        if (!weightInput || !weightInput.value) return;
        
        const rawValue = weightInput.value;
        const weightGrams = parseInt(rawValue, 10) || 0;
        
        if (weightGrams === 0 && rawValue.trim()) {
            // Campo tem texto mas não foi interpretado como número
            const confirmation = window.confirm(
                `Não consegui interpretar "${rawValue}" como peso em gramas.\n\n` +
                `Digite apenas números inteiros (ex: 1500 para 1,5kg)\n\n` +
                `Deseja limpar o campo e tentar novamente?`
            );
            if (confirmation) {
                weightInput.value = '';
                updateWeightFeedback();
                weightInput.focus();
            }
        } else if (weightGrams > 50000) {
            // Alerta se peso muito alto (mais de 50kg em gramas)
            const weightKg = (weightGrams / 1000).toFixed(3);
            const confirmation = window.confirm(
                `⚠️ Peso muito alto: ${weightGrams}g (${weightKg}kg)\n\n` +
                `Confirma este peso ou quer corrigir?`
            );
            if (!confirmation) {
                weightInput.value = '';
                updateWeightFeedback();
                weightInput.focus();
            }
        }
    }
    
    function openReworkModal() {
        console.log('[TRACE][openReworkModal] called, selectedMachineData:', selectedMachineData);
        
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][openReworkModal] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }
        
        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('quick-rework-form');
        const submitBtn = document.getElementById('quick-rework-submit');
        
        if (form) {
            form.removeEventListener('submit', handleReworkSubmit);
            form.addEventListener('submit', handleReworkSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleReworkSubmit);
            submitBtn.addEventListener('click', handleReworkSubmit);
        }
        
        const reworkModal = document.getElementById('quick-rework-modal');
        if (reworkModal) {
            console.log('[DEBUG] Portalizando quick-rework-modal antes da abertura');
            modalManager.portalize(reworkModal);
        }

        setTimeout(() => {
            console.log('[TRACE][openReworkModal] abrindo modal quick-rework-modal');
            openModal('quick-rework-modal');
        }, 0);
    }
    
    function openManualProductionModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina e produto)
        const contextMachine = document.querySelector('#manual-production-modal .context-machine');
        const contextProduct = document.querySelector('#manual-production-modal .context-product');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        if (contextProduct) contextProduct.textContent = selectedMachineData.product || '-';

        const dateInput = document.getElementById('manual-production-date');
        if (dateInput) {
            dateInput.value = getProductionDateString();
        }

        const shiftSelect = document.getElementById('manual-production-shift');
        if (shiftSelect) {
            shiftSelect.value = String(getCurrentShift());
        }

        const hourInput = document.getElementById('manual-production-hour');
        if (hourInput) {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            hourInput.value = `${hours}:${minutes}`;
        }
        
        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-production-form');
        const submitBtn = document.getElementById('manual-production-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualProductionSubmit);
            form.addEventListener('submit', handleManualProductionSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualProductionSubmit);
            submitBtn.addEventListener('click', handleManualProductionSubmit);
        }

        openModal('manual-production-modal');
    }

    function openManualLossesModal() {
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina e produto)
        const contextMachine = document.querySelector('#manual-losses-modal .context-machine');
        const contextProduct = document.querySelector('#manual-losses-modal .context-product');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        if (contextProduct) contextProduct.textContent = selectedMachineData.product || '-';

        const dateInput = document.getElementById('manual-losses-date');
        if (dateInput) {
            dateInput.value = getProductionDateString();
        }

        const shiftSelect = document.getElementById('manual-losses-shift');
        if (shiftSelect) {
            shiftSelect.value = String(getCurrentShift());
        }

        const hourInput = document.getElementById('manual-losses-hour');
        if (hourInput) {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            hourInput.value = `${hours}:${minutes}`;
        }

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-losses-form');
        const submitBtn = document.getElementById('manual-losses-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualLossesSubmit);
            form.addEventListener('submit', handleManualLossesSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualLossesSubmit);
            submitBtn.addEventListener('click', handleManualLossesSubmit);
        }

        openModal('manual-losses-modal');
    }

    function openManualBorraModal() {
        console.log('[TRACE][openManualBorraModal] called, selectedMachineData:', selectedMachineData);
        
        currentEditContext = null;
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][openManualBorraModal] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina e produto)
        const contextMachine = document.querySelector('#manual-borra-modal .context-machine');
        const contextProduct = document.querySelector('#manual-borra-modal .context-product');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        if (contextProduct) contextProduct.textContent = selectedMachineData.product || '-';

        // Popular os selects do modal com máquinas e motivos do database.js
        populateBorraModal();

        const dateInput = document.getElementById('manual-borra-date');
        if (dateInput) {
            dateInput.value = getProductionDateString();
        }

        const shiftSelect = document.getElementById('manual-borra-shift');
        if (shiftSelect) {
            shiftSelect.value = String(getCurrentShift());
        }

        const machineSelect = document.getElementById('manual-borra-machine');
        if (machineSelect && selectedMachineData) {
            machineSelect.value = normalizeMachineId(selectedMachineData.machine);
        }

        const hourInput = document.getElementById('manual-borra-hour');
        if (hourInput) {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            hourInput.value = `${hours}:${minutes}`;
        }

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-borra-form');
        const submitBtn = document.getElementById('manual-borra-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualBorraSubmit);
            form.addEventListener('submit', handleManualBorraSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualBorraSubmit);
            submitBtn.addEventListener('click', handleManualBorraSubmit);
        }

        const borraModal = document.getElementById('manual-borra-modal');
        if (borraModal) {
            console.log('[DEBUG] Portalizando manual-borra-modal antes da abertura');
            modalManager.portalize(borraModal);
        }

        setTimeout(() => {
            console.log('[TRACE][openManualBorraModal] abrindo modal manual-borra-modal');
            openModal('manual-borra-modal');
        }, 0);
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;

        modal.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
        modal.removeAttribute('data-modal-open');

        modalManager.clearStyles(modal);
        const modalContent = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
        if (modalContent) {
            modalManager.clearContentStyles(modalContent);
        }

        // Limpar formulários associados ao modal fechado
        const form = modal.querySelector('form');
        if (form) form.reset();
        if (['quick-production-modal', 'quick-losses-modal', 'quick-downtime-modal', 'quick-rework-modal', 'manual-borra-modal'].includes(modalId)) {
            currentEditContext = null;
        }
    }

    // Preenche o contexto (máquina/produto) em um modal, se existir o bloco .modal-context
    function fillModalContext(modalEl, context = null) {
        if (!modalEl) return;
        const ctx = modalEl.querySelector('.modal-context');
        if (!ctx) return;
        const machineEl = ctx.querySelector('.context-machine');
        const productEl = ctx.querySelector('.context-product');
        const src = context || selectedMachineData || {};
        const machine = src.machine || src.machine_id || '-';
        let product = src.product || src.product_name || '';
        const code = src.product_cod || src.product_code || src.part_code || '';
        if (!product && code) product = `Cod ${code}`;
        if (machineEl) machineEl.textContent = machine || '-';
        if (productEl) productEl.textContent = product || 'Produto não definido';
    }

    function openModal(modalId) {
        if (modalId === 'quick-downtime-modal') {
            // Forçar re-vinculação do submit do formulário de parada
            const quickDowntimeForm = document.getElementById('quick-downtime-form');
            if (quickDowntimeForm) {
                quickDowntimeForm.onsubmit = null;
                quickDowntimeForm.removeEventListener('submit', handleDowntimeSubmit);
                quickDowntimeForm.addEventListener('submit', handleDowntimeSubmit);
                console.log('[DEBUG] Evento de submit vinculado ao quick-downtime-form (openModal)');
            }
        }
        console.error('🔴🔴🔴 OPENMODAL START, modalId=' + modalId + ' 🔴🔴🔴');

        const modal = document.getElementById(modalId);
        console.error('🔴 modal found:', !!modal, 'typeof:', typeof modal);

        if (!modal) {
            console.error('🔴 EARLY RETURN: Modal not found');
            return;
        }

        modalManager.portalize(modal);
        console.error('🔴 calling fillModalContext');

        // Atualizar faixa de contexto do modal, quando aplicável
        try {
            fillModalContext(modal);
            console.error('🔴 fillModalContext OK');
        } catch (e) {
            console.error('🔴 fillModalContext ERROR:', e.message);
        }

        modal.setAttribute('data-modal-open', 'true');
        modal.setAttribute('aria-hidden', 'false');
        modal.classList.remove('hidden');
        modalManager.applyStyles(modal);

        const modalContent = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
        if (modalContent) {
            modalManager.applyContentStyles(modalContent);
        } else {
            console.warn('🔴 Nenhum container interno padrão (.bg-white/.modal-content) encontrado para', modalId);
        }

        const initialComputed = window.getComputedStyle(modal);
        console.error('🔴 after force -> hidden:', modal.classList.contains('hidden'),
            'display:', initialComputed.display,
            'opacity:', initialComputed.opacity,
            'visibility:', initialComputed.visibility,
            'z-index:', initialComputed.zIndex);

        const logState = (label) => {
            if (!modal || !modal.isConnected) {
                console.error(`🔴 ${label} modal desconectado do DOM`, { modalId });
                return;
            }
            const style = window.getComputedStyle(modal);
            const rect = modal.getBoundingClientRect();
            console.error(`🔴 ${label} hidden=${modal.classList.contains('hidden')} display=${style.display} opacity=${style.opacity} visibility=${style.visibility} z-index=${style.zIndex} rect=${Math.round(rect.width)}x${Math.round(rect.height)} top=${Math.round(rect.top)} left=${Math.round(rect.left)}`);
        };

        requestAnimationFrame(() => {
            modalManager.verify(modal);
            logState('RAF check');
        });

        setTimeout(() => logState('100ms later'), 100);
        setTimeout(() => logState('300ms later'), 300);
        setTimeout(() => logState('500ms later'), 500);

        console.error('🔴🔴🔴 OPENMODAL END 🔴🔴🔴');
    }

    // Função para toggle de parada (stop/start)
    function toggleDowntime() {
        console.log('[TRACE][toggleDowntime] called, selectedMachineData:', selectedMachineData, 'machineStatus:', machineStatus);
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][toggleDowntime] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }
        
        if (machineStatus === 'running') {
            console.log('[TRACE][toggleDowntime] Status running -> iniciando parada');
            // Parar máquina - registrar início da parada
            startMachineDowntime();
        } else {
            console.log('[TRACE][toggleDowntime] Status stopped -> abrindo modal de motivo');
            // Retomar máquina - solicitar motivo e finalizar parada
            openDowntimeReasonModal();
        }
    }
    
    // Função para abrir modal de lançamento manual de parada passada
    function openManualDowntimeModal() {
        console.log('[TRACE][openManualDowntimeModal] called, selectedMachineData:', selectedMachineData);
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!selectedMachineData) {
            console.warn('[WARN][openManualDowntimeModal] Nenhuma máquina selecionada');
            alert('Selecione uma máquina primeiro.');
            return;
        }

        // Preenchimento do contexto (máquina)
        const contextMachine = document.querySelector('#manual-downtime-modal .context-machine');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';
        
        // Preencher datas padrão
        const today = getProductionDateString();
        const ds = document.getElementById('manual-downtime-date-start');
        const de = document.getElementById('manual-downtime-date-end');
        
        if (ds && !ds.value) ds.value = today;
        if (de && !de.value) de.value = today;

        // ⚠️ ADICIONAR LISTENERS QUANDO O MODAL ABRE
        const form = document.getElementById('manual-downtime-form');
        const submitBtn = document.getElementById('manual-downtime-submit');
        
        if (form) {
            form.removeEventListener('submit', handleManualDowntimeSubmit);
            form.addEventListener('submit', handleManualDowntimeSubmit);
        }
        
        if (submitBtn) {
            submitBtn.removeEventListener('click', handleManualDowntimeSubmit);
            submitBtn.addEventListener('click', handleManualDowntimeSubmit);
        }

        openModal('manual-downtime-modal');
        console.log('[TRACE][openManualDowntimeModal] completed');
    }
    
    // ========================================
    // SISTEMA ROBUSTO DE PARADAS - FUNÇÕES PRINCIPAIS
    // ========================================
    
    /**
     * Inicia uma parada de máquina com persistência robusta
     */
    async function startMachineDowntime() {
        if (!selectedMachineData) {
            console.error('[DOWNTIME] Tentativa de iniciar parada sem máquina selecionada');
            showNotification('Selecione uma máquina primeiro.', 'error');
            return;
        }

        const now = new Date();
        const currentShift = getShiftForDateTime(now);
        const workday = getWorkdayForDateTime(now);
        
        // Estrutura de dados robusta para a parada
        currentDowntimeStart = {
            machine: selectedMachineData.machine,
            date: workday,
            startTime: formatTimeHM(now),
            startTimestamp: now,
            startShift: currentShift,
            // Dados adicionais para rastreabilidade
            product: selectedMachineData.product || null,
            productCod: selectedMachineData.product_cod || null,
            orderId: selectedMachineData.order_id || null,
            orderNumber: selectedMachineData.order_number || null
        };
        
        console.log('[DOWNTIME][START] Parada iniciada:', currentDowntimeStart);
        
        // Salvar parada ativa no Firebase para persistência (sobrevive a refresh/troca de máquina)
        try {
            const activeDowntimeData = {
                // Identificação
                machine: selectedMachineData.machine,
                
                // Timestamps (múltiplos formatos para robustez)
                startDate: workday,
                startTime: formatTimeHM(now),
                startTimestamp: firebase.firestore.FieldValue.serverTimestamp(),
                startTimestampLocal: now.toISOString(),
                startShift: currentShift,
                
                // Contexto de produção
                product: selectedMachineData.product || null,
                productCod: selectedMachineData.product_cod || null,
                orderId: selectedMachineData.order_id || null,
                orderNumber: selectedMachineData.order_number || null,
                
                // Metadados
                startedBy: getActiveUser()?.name || 'Sistema',
                startedByUsername: getActiveUser()?.username || null,
                isActive: true,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                
                // Versão do sistema para compatibilidade futura
                systemVersion: '2.0'
            };
            
            // Usar merge para não perder dados em caso de erro parcial
            await db.collection('active_downtimes').doc(selectedMachineData.machine).set(activeDowntimeData, { merge: true });
            
            console.log('[DOWNTIME][START] Parada ativa persistida no Firebase:', activeDowntimeData);
        } catch (error) {
            console.error('[DOWNTIME][START] Erro ao persistir parada no Firebase:', error);
            // Mesmo com erro no Firebase, continuamos com a parada local
            showNotification('Parada iniciada localmente. Pode haver erro de sincronização.', 'warning');
        }
        
        machineStatus = 'stopped';
        updateMachineStatus();
        freezeProductionTimer();
        startDowntimeTimer();
        
        // Notificação com informações contextuais
        const shiftLabel = currentShift === 1 ? '1º Turno' : currentShift === 2 ? '2º Turno' : '3º Turno';
        showNotification(`Máquina parada às ${formatTimeHM(now)} (${shiftLabel}). Clique em START quando retomar.`, 'warning');
    }
    
    // Função para abrir modal solicitando motivo da parada ao retomar
    function openDowntimeReasonModal() {
        console.log('[TRACE][openDowntimeReasonModal] called, currentDowntimeStart:', currentDowntimeStart);
        
        if (!currentDowntimeStart) {
            console.warn('[WARN][openDowntimeReasonModal] Nenhuma parada ativa para finalizar.');
            machineStatus = 'running';
            updateMachineStatus();
            resumeProductionTimer();
            return;
        }
        
        console.log('[TRACE][openDowntimeReasonModal] abrindo modal quick-downtime-modal');
        openModal('quick-downtime-modal');
    }

    // ======== PARADAS LONGAS (Fim de Semana, Manutenção, etc.) ========
    
    // Função para popular motivos de parada - ATIVA
    // extended-downtime-reason agora é um SELECT com optgroups
    function populateExtendedDowntimeReasons() {
        const reasonSelect = document.getElementById('extended-downtime-reason');
        if (!reasonSelect) return;

        const groupedReasons = getGroupedDowntimeReasons();
        let options = '<option value="">Selecione o motivo...</option>';

        Object.entries(groupedReasons).forEach(([group, reasons]) => {
            options += `<optgroup label="${group}">`;
            reasons.forEach(reason => {
                options += `<option value="${reason}">${reason}</option>`;
            });
            options += '</optgroup>';
        });

        reasonSelect.innerHTML = options;
        console.log('[PARADAS-LONGAS] Motivos carregados:', Object.keys(groupedReasons).length, 'grupos');
    }

    function populateExtendedDowntimeMachines() {
        const machineSelect = document.getElementById('extended-downtime-machine');
        if (!machineSelect) {
            console.warn('[PARADAS-LONGAS] Select de máquina não encontrado');
            return;
        }

        if (window.databaseModule && window.databaseModule.machineDatabase) {
            const machines = window.databaseModule.machineDatabase;
            let options = '<option value="">Selecione uma ou mais máquinas...</option>';
            
            machines.forEach(m => {
                const machineId = normalizeMachineId(m.id);
                options += `<option value="${machineId}">${machineId}</option>`;
            });
            
            machineSelect.innerHTML = options;
            console.log('[PARADAS-LONGAS] Máquinas carregadas:', machines.length);
        } else {
            console.warn('[PARADAS-LONGAS] machineDatabase não disponível');
        }
    }

    function setupExtendedDowntimeTab() {
        populateExtendedDowntimeReasons();
        populateExtendedDowntimeMachines();

        // Elementos do formulário
        const startDateInput = document.getElementById('extended-downtime-start-date');
        const customTimeInput = document.getElementById('extended-downtime-custom-time');
        const useNowBtn = document.getElementById('extended-downtime-use-now');
        const startTimeElement = document.getElementById('extended-downtime-start-time');
        
        // Função para preencher com data/hora atual
        function setCurrentDateTime() {
            const now = new Date();
            const dateString = now.toISOString().split('T')[0];  // YYYY-MM-DD
            const timeString = `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
            
            if (startDateInput) startDateInput.value = dateString;
            if (customTimeInput) customTimeInput.value = timeString;
            if (startTimeElement) startTimeElement.textContent = `Definido: ${dateString} às ${timeString}`;
        }
        
        // Preencher com data/hora atual ao carregar
        setCurrentDateTime();
        
        // Botão para usar data/hora atual
        if (useNowBtn) {
            useNowBtn.addEventListener('click', function(e) {
                e.preventDefault();
                setCurrentDateTime();
                showNotification('✅ Data e hora atualizados para agora', 'success');
            });
        }
        
        // Atualizar display quando campos mudarem
        function updateDisplay() {
            if (startDateInput && customTimeInput && startTimeElement) {
                const date = startDateInput.value || '--';
                const time = customTimeInput.value || '--:--';
                startTimeElement.textContent = `Selecionado: ${date} às ${time}`;
            }
        }
        
        if (startDateInput) startDateInput.addEventListener('change', updateDisplay);
        if (customTimeInput) customTimeInput.addEventListener('change', updateDisplay);

        const form = document.getElementById('extended-downtime-form');
        if (form && !form.dataset.listenerAttached) {
            form.addEventListener('submit', handleExtendedDowntimeFormSubmit);
            form.dataset.listenerAttached = 'true';
        }
    }

    // ==================== ACOMPANHAMENTO DE TURNO ====================
    let acompanhamentoInitialized = false;

    function setupAcompanhamentoTurno() {
        if (acompanhamentoInitialized) return;
        acompanhamentoInitialized = true;

        console.log('[ACOMPANHAMENTO] Inicializando aba de acompanhamento de turno...');

        // Definir data padrão = hoje
        const dataInput = document.getElementById('acompanhamento-data');
        if (dataInput && !dataInput.value) {
            dataInput.value = getProductionDateString();
        }

        // Atualizar status de conexão
        const statusEl = document.getElementById('acompanhamento-status');
        if (statusEl && db) {
            statusEl.textContent = '✅ Conectado';
            statusEl.classList.remove('text-blue-600', 'bg-blue-100');
            statusEl.classList.add('text-green-600', 'bg-green-100');
        }

        // Event listeners
        const btnCarregar = document.getElementById('acompanhamento-carregar');
        const btnLimpar = document.getElementById('acompanhamento-limpar');
        const btnImprimir = document.getElementById('acompanhamento-imprimir');

        if (btnCarregar && !btnCarregar.dataset.listenerAttached) {
            btnCarregar.addEventListener('click', carregarDadosAcompanhamento);
            btnCarregar.dataset.listenerAttached = 'true';
        }

        if (btnLimpar && !btnLimpar.dataset.listenerAttached) {
            btnLimpar.addEventListener('click', limparCedocAcompanhamento);
            btnLimpar.dataset.listenerAttached = 'true';
        }

        if (btnImprimir && !btnImprimir.dataset.listenerAttached) {
            btnImprimir.addEventListener('click', () => window.print());
            btnImprimir.dataset.listenerAttached = 'true';
        }

        const btnSalvar = document.getElementById('acompanhamento-salvar');
        if (btnSalvar && !btnSalvar.dataset.listenerAttached) {
            btnSalvar.addEventListener('click', salvarDadosAcompanhamento);
            btnSalvar.dataset.listenerAttached = 'true';
        }

        // Renderizar ícones Lucide
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    async function carregarDadosAcompanhamento() {
        const data = document.getElementById('acompanhamento-data')?.value;

        if (!data) {
            showNotification('⚠️ Selecione a data!', 'warning');
            return;
        }

        const tbody = document.getElementById('acompanhamento-tbody');
        if (!tbody) return;

        tbody.innerHTML = `
            <tr>
                <td colspan="10" class="px-4 py-10 text-center text-gray-400">
                    <i data-lucide="loader-2" class="w-10 h-10 mx-auto mb-3 animate-spin opacity-50"></i>
                    <p>Carregando dados do SYNCHRO...</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        try {
            // Buscar todos os 3 turnos
            const turnosParaBuscar = [1, 2, 3];
            
            // Estrutura: { maquina: { t1: synchro, t2: synchro, t3: synchro } }
            const producaoPorMaquina = new Map();

            for (const t of turnosParaBuscar) {
                // Buscar por 'turno'
                const snapshot = await db.collection('production_entries')
                    .where('data', '==', data)
                    .where('turno', '==', t)
                    .get();

                snapshot.docs.forEach(doc => {
                    const d = doc.data();
                    const machine = d.machine || d.machine_id || d.maquina || 'N/A';
                    const quantidade = parseFloat(d.produzido || d.quantity || d.peso_liquido || 0);

                    if (!producaoPorMaquina.has(machine)) {
                        producaoPorMaquina.set(machine, { t1: 0, t2: 0, t3: 0 });
                    }
                    producaoPorMaquina.get(machine)[`t${t}`] += quantidade;
                });

                // Buscar por 'shift' também
                const snapshotShift = await db.collection('production_entries')
                    .where('data', '==', data)
                    .where('shift', '==', t)
                    .get();

                snapshotShift.docs.forEach(doc => {
                    const d = doc.data();
                    const machine = d.machine || d.machine_id || d.maquina || 'N/A';
                    const quantidade = parseFloat(d.produzido || d.quantity || d.peso_liquido || 0);

                    if (!producaoPorMaquina.has(machine)) {
                        producaoPorMaquina.set(machine, { t1: 0, t2: 0, t3: 0 });
                    }
                    producaoPorMaquina.get(machine)[`t${t}`] += quantidade;
                });
            }

            // Renderizar tabela
            tbody.innerHTML = '';

            if (producaoPorMaquina.size === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" class="px-4 py-10 text-center text-gray-400">
                            <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                            <p>Nenhum lançamento encontrado para esta data</p>
                        </td>
                    </tr>
                `;
                document.getElementById('acompanhamento-resumo')?.classList.add('hidden');
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            // Ordenar por máquina
            const maquinasOrdenadas = Array.from(producaoPorMaquina.entries()).sort((a, b) => a[0].localeCompare(b[0]));

            // Carregar dados salvos dos 3 turnos
            let dadosSalvos = {};
            try {
                for (const t of ['1', '2', '3']) {
                    const docId = `${data}_T${t}`;
                    const docSalvo = await db.collection('acompanhamento_turno').doc(docId).get();
                    if (docSalvo.exists) {
                        const saved = docSalvo.data();
                        if (saved.registros) {
                            saved.registros.forEach(r => {
                                const key = `${r.maquina}_T${t}`;
                                dadosSalvos[key] = { cedoc: r.cedoc };
                            });
                        }
                    }
                }
                console.log('[ACOMPANHAMENTO] Dados salvos carregados:', Object.keys(dadosSalvos).length, 'registros');
            } catch (e) {
                console.warn('[ACOMPANHAMENTO] Não foi possível carregar dados salvos:', e);
            }

            maquinasOrdenadas.forEach(([maquina, synchros]) => {
                const salvoT1 = dadosSalvos[`${maquina}_T1`] || {};
                const salvoT2 = dadosSalvos[`${maquina}_T2`] || {};
                const salvoT3 = dadosSalvos[`${maquina}_T3`] || {};
                
                const linha = document.createElement('tr');
                linha.className = 'hover:bg-gray-50 transition-colors';
                linha.innerHTML = `
                    <td class="px-3 py-2 border-r border-gray-200"><strong class="text-blue-600 text-sm">${maquina}</strong></td>
                    
                    <!-- T1 -->
                    <td class="px-1 py-2 text-center bg-blue-50/30">
                        <input type="number" class="acompanhamento-cedoc w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-blue-500" 
                               data-maquina="${maquina}" data-turno="1" placeholder="0" value="${salvoT1.cedoc || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-blue-50/30">
                        <span class="text-xs font-semibold acompanhamento-synchro" data-turno="1">${Math.round(synchros.t1)}</span>
                    </td>
                    <td class="px-1 py-2 text-center border-r border-gray-200 bg-blue-50/30">
                        <span class="acompanhamento-diferenca text-xs font-bold" data-maquina="${maquina}" data-turno="1">0</span>
                    </td>
                    
                    <!-- T2 -->
                    <td class="px-1 py-2 text-center bg-purple-50/30">
                        <input type="number" class="acompanhamento-cedoc w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-purple-500" 
                               data-maquina="${maquina}" data-turno="2" placeholder="0" value="${salvoT2.cedoc || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-purple-50/30">
                        <span class="text-xs font-semibold acompanhamento-synchro" data-turno="2">${Math.round(synchros.t2)}</span>
                    </td>
                    <td class="px-1 py-2 text-center border-r border-gray-200 bg-purple-50/30">
                        <span class="acompanhamento-diferenca text-xs font-bold" data-maquina="${maquina}" data-turno="2">0</span>
                    </td>
                    
                    <!-- T3 -->
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <input type="number" class="acompanhamento-cedoc w-20 p-1.5 border border-gray-200 rounded text-center text-xs focus:ring-1 focus:ring-orange-500" 
                               data-maquina="${maquina}" data-turno="3" placeholder="0" value="${salvoT3.cedoc || ''}">
                    </td>
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <span class="text-xs font-semibold acompanhamento-synchro" data-turno="3">${Math.round(synchros.t3)}</span>
                    </td>
                    <td class="px-1 py-2 text-center bg-orange-50/30">
                        <span class="acompanhamento-diferenca text-xs font-bold" data-maquina="${maquina}" data-turno="3">0</span>
                    </td>
                `;

                // Adicionar listeners para calcular diferenças
                linha.querySelectorAll('.acompanhamento-cedoc').forEach(input => {
                    input.addEventListener('input', calcularDiferencasAcompanhamento);
                });

                tbody.appendChild(linha);
            });

            document.getElementById('acompanhamento-resumo')?.classList.remove('hidden');
            calcularDiferencasAcompanhamento();
            if (typeof lucide !== 'undefined') lucide.createIcons();

            console.log('[ACOMPANHAMENTO] Dados carregados:', producaoPorMaquina.size, 'máquinas');

        } catch (error) {
            console.error('[ACOMPANHAMENTO] Erro ao carregar dados:', error);
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="px-4 py-10 text-center text-red-400">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                        <p>Erro ao carregar: ${error.message}</p>
                    </td>
                </tr>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    function calcularDiferencasAcompanhamento() {
        let celulasComDiferenca = 0;

        document.querySelectorAll('#acompanhamento-tbody tr').forEach(row => {
            // Para cada linha, processar os 3 turnos
            row.querySelectorAll('.acompanhamento-cedoc').forEach(cedocInput => {
                const turno = cedocInput.dataset.turno;
                const maquina = cedocInput.dataset.maquina;
                
                // Encontrar o synchro e diferença correspondentes na mesma linha
                const synchroSpan = row.querySelector(`.acompanhamento-synchro[data-turno="${turno}"]`);
                const diferencaCell = row.querySelector(`.acompanhamento-diferenca[data-turno="${turno}"]`);

                if (cedocInput && synchroSpan && diferencaCell) {
                    const cedoc = parseFloat(cedocInput.value) || 0;
                    const synchro = parseFloat(synchroSpan.textContent) || 0;
                    const diferenca = cedoc - synchro;

                    diferencaCell.textContent = Math.round(diferenca);

                    // Resetar classes
                    diferencaCell.classList.remove('text-red-600', 'bg-red-100', 'text-yellow-600', 'bg-yellow-100', 'text-green-600', 'bg-green-100', 'rounded', 'px-1');

                    if (diferenca > 0) {
                        diferencaCell.classList.add('text-red-600', 'bg-red-100', 'rounded', 'px-1');
                        celulasComDiferenca++;
                    } else if (diferenca < 0) {
                        diferencaCell.classList.add('text-yellow-600', 'bg-yellow-100', 'rounded', 'px-1');
                        celulasComDiferenca++;
                    } else if (cedoc > 0) {
                        diferencaCell.classList.add('text-green-600', 'bg-green-100', 'rounded', 'px-1');
                    }
                }
            });
        });

        // Atualizar resumo
        const maquinasDiffEl = document.getElementById('acompanhamento-maquinas-diff');
        if (maquinasDiffEl) {
            maquinasDiffEl.textContent = celulasComDiferenca;
        }
    }

    function limparCedocAcompanhamento() {
        if (!confirm('⚠️ Limpar todos os valores CEDOC?')) return;

        document.querySelectorAll('.acompanhamento-cedoc').forEach(input => {
            input.value = '';
        });
        calcularDiferencasAcompanhamento();
        showNotification('✅ Campos limpos!', 'success');
    }

    async function salvarDadosAcompanhamento() {
        const data = document.getElementById('acompanhamento-data')?.value;

        if (!data) {
            showNotification('⚠️ Selecione a data primeiro!', 'warning');
            return;
        }

        // Agrupar registros por turno
        const registrosPorTurno = { 1: [], 2: [], 3: [] };
        let temDados = false;

        document.querySelectorAll('#acompanhamento-tbody tr').forEach(row => {
            // Processar cada input CEDOC da linha (3 turnos)
            row.querySelectorAll('.acompanhamento-cedoc').forEach(cedocInput => {
                const maquina = cedocInput.dataset.maquina;
                const turnoLinha = parseInt(cedocInput.dataset.turno);
                const synchroSpan = row.querySelector(`.acompanhamento-synchro[data-turno="${turnoLinha}"]`);
                const diferencaCell = row.querySelector(`.acompanhamento-diferenca[data-turno="${turnoLinha}"]`);

                const cedoc = parseFloat(cedocInput.value) || 0;
                const synchro = parseFloat(synchroSpan?.textContent) || 0;
                const diferenca = parseFloat(diferencaCell?.textContent) || 0;

                if (cedoc > 0) {
                    temDados = true;
                }

                registrosPorTurno[turnoLinha].push({
                    maquina: maquina,
                    cedoc: cedoc,
                    synchro: synchro,
                    diferenca: diferenca
                });
            });
        });

        if (!temDados) {
            showNotification('⚠️ Preencha ao menos um valor CEDOC!', 'warning');
            return;
        }

        try {
            const usuario = window.authSystem?.getCurrentUser()?.name || 'Desconhecido';

            // Salvar cada turno separadamente
            for (const t of [1, 2, 3]) {
                if (registrosPorTurno[t].length > 0) {
                    const docId = `${data}_T${t}`;
                    await db.collection('acompanhamento_turno').doc(docId).set({
                        data: data,
                        turno: t,
                        registros: registrosPorTurno[t],
                        salvoEm: firebase.firestore.FieldValue.serverTimestamp(),
                        salvoEmLocal: new Date().toLocaleString('pt-BR'),
                        usuario: usuario
                    }, { merge: true });
                }
            }
            showNotification('✅ Acompanhamento salvo com sucesso!', 'success');
            console.log('[ACOMPANHAMENTO] Dados salvos para todos os turnos');
            
            // Registrar log
            registrarLogSistema('SALVAMENTO DE ACOMPANHAMENTO', 'acompanhamento', {
                data: data,
                turnosRegistrados: Object.keys(registrosPorTurno).filter(t => registrosPorTurno[t].length > 0).length,
                totalRegistros: registrosPorTurno[1].length + registrosPorTurno[2].length + registrosPorTurno[3].length
            });

        } catch (error) {
            console.error('[ACOMPANHAMENTO] Erro ao salvar:', error);
            showNotification('❌ Erro ao salvar: ' + error.message, 'error');
        }
    }
    // ==================== FIM ACOMPANHAMENTO DE TURNO ====================

    // ==================== HISTÓRICO DO SISTEMA ====================
    
    // Função global para registrar ações no sistema
    window.logSystemAction = async function(tipo, descricao, detalhes = {}) {
        try {
            const usuario = window.authSystem?.getCurrentUser();
            const now = new Date();
            
            await db.collection('system_logs').add({
                tipo: tipo,
                descricao: descricao,
                maquina: detalhes.maquina || selectedMachineData?.machine || null,
                usuario: usuario?.name || 'Desconhecido',
                userId: usuario?.id || null,
                detalhes: detalhes,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                timestampLocal: now.toISOString(),
                data: now.toISOString().split('T')[0],
                hora: now.toTimeString().split(' ')[0]
            });
            
            console.log('[SYSTEM_LOG]', tipo, descricao);
        } catch (error) {
            console.error('[SYSTEM_LOG] Erro ao registrar ação:', error);
        }
    };
    
    // Função interna para registrar logs (usada em diversos pontos do sistema)
    async function registrarLogSistema(acao, tipo, detalhes = {}) {
        try {
            const usuario = window.authSystem?.getCurrentUser();
            const now = new Date();
            
            await db.collection('system_logs').add({
                acao: acao,
                tipo: tipo,
                descricao: acao,
                maquina: detalhes.machine || detalhes.maquina || selectedMachineData?.machine || null,
                usuario: usuario?.name || 'Desconhecido',
                userId: usuario?.id || null,
                detalhes: detalhes,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                timestampLocal: now.toISOString(),
                data: now.toISOString().split('T')[0],
                hora: now.toTimeString().split(' ')[0]
            });
            
            console.log('[SYSTEM_LOG]', acao, tipo, detalhes);
        } catch (error) {
            console.error('[SYSTEM_LOG] Erro ao registrar log:', error);
        }
    }

    // ==================== ADMINISTRAÇÃO DE DADOS ====================
    let adminDadosSetupDone = false;
    let adminCurrentOrderDoc = null;
    
    function setupAdminDadosPage() {
        // Verificar permissão - apenas gestores e admins
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('acessar a administração de dados');
            navigateTo('lancamento');
            return;
        }
        
        if (adminDadosSetupDone) {
            if (typeof lucide !== 'undefined') lucide.createIcons();
            return;
        }
        adminDadosSetupDone = true;
        
        console.log('[ADMIN-DADOS] Inicializando página de administração...');
        
        // Setup das abas internas
        document.querySelectorAll('.admin-tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tab = e.currentTarget.dataset.adminTab;
                switchAdminTab(tab);
            });
        });
        
        // Aba Paradas - botões
        const btnAnalyze = document.getElementById('admin-btn-analyze');
        const btnFix = document.getElementById('admin-btn-fix');
        const btnClearLog = document.getElementById('admin-btn-clear-log');
        
        if (btnAnalyze) btnAnalyze.addEventListener('click', adminAnalyzeDowntimeProblems);
        if (btnFix) btnFix.addEventListener('click', adminFixDowntimeRecords);
        if (btnClearLog) btnClearLog.addEventListener('click', () => {
            const logContainer = document.getElementById('admin-log-container');
            if (logContainer) logContainer.innerHTML = '';
        });
        
        // Aba Ordens - botões
        const btnBuscarOrdem = document.getElementById('admin-btn-buscar-ordem');
        const btnAjustarOrdem = document.getElementById('admin-btn-ajustar-ordem');
        
        if (btnBuscarOrdem) btnBuscarOrdem.addEventListener('click', adminBuscarOrdem);
        if (btnAjustarOrdem) btnAjustarOrdem.addEventListener('click', adminAjustarQuantidadeOrdem);
        
        // Aba Produção - setup
        const dataProducao = document.getElementById('admin-producao-data');
        if (dataProducao) dataProducao.value = getProductionDateString();
        
        // Popular select de máquinas
        const selectMaquina = document.getElementById('admin-producao-maquina');
        if (selectMaquina && window.databaseModule?.machineDatabase) {
            let options = '<option value="">Todas</option>';
            window.databaseModule.machineDatabase.forEach(m => {
                const id = normalizeMachineId(m.id);
                options += `<option value="${id}">${id}</option>`;
            });
            selectMaquina.innerHTML = options;
        }
        
        const btnBuscarProducao = document.getElementById('admin-btn-buscar-producao');
        if (btnBuscarProducao) btnBuscarProducao.addEventListener('click', adminBuscarProducao);
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function switchAdminTab(tabName) {
        // Atualizar botões
        document.querySelectorAll('.admin-tab-btn').forEach(btn => {
            if (btn.dataset.adminTab === tabName) {
                btn.className = 'admin-tab-btn active px-4 py-2 text-sm font-semibold rounded-t-lg transition bg-blue-500 text-white';
            } else {
                btn.className = 'admin-tab-btn px-4 py-2 text-sm font-semibold rounded-t-lg transition bg-gray-100 text-gray-600 hover:bg-gray-200';
            }
        });
        
        // Mostrar/ocultar conteúdo
        document.querySelectorAll('.admin-tab-content').forEach(content => {
            content.classList.add('hidden');
        });
        const activeContent = document.getElementById(`admin-tab-${tabName}`);
        if (activeContent) activeContent.classList.remove('hidden');
    }
    
    function adminLog(message, type = 'info') {
        const container = document.getElementById('admin-log-container');
        if (!container) return;
        
        const colors = {
            info: 'text-blue-400',
            warn: 'text-yellow-400',
            error: 'text-red-400',
            success: 'text-green-400'
        };
        
        const entry = document.createElement('div');
        entry.className = `${colors[type] || colors.info} py-0.5`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        container.appendChild(entry);
        container.scrollTop = container.scrollHeight;
    }
    
    async function adminAnalyzeDowntimeProblems() {
        adminLog('Iniciando análise de registros de paradas...', 'info');
        
        const stats = { total: 0, problems: 0, fixed: 0, deleted: 0 };
        
        try {
            const snapshot = await db.collection('downtime_entries').limit(1000).get();
            stats.total = snapshot.size;
            
            adminLog(`Total de registros: ${stats.total}`, 'info');
            
            let problemCount = 0;
            snapshot.forEach(doc => {
                const data = doc.data();
                const problems = [];
                
                // Verificar problemas comuns
                if (!data.end_timestamp && !data.endTimestamp && data.status !== 'active') {
                    problems.push('Sem timestamp de fim (não ativo)');
                }
                if (!data.start_timestamp && !data.startTimestamp && !data.originalStartTimestamp) {
                    problems.push('Sem timestamp de início');
                }
                if (!data.machine_id && !data.machine) {
                    problems.push('Sem ID de máquina');
                }
                if (data.duration_minutes > 1440) {
                    problems.push(`Duração muito alta: ${data.duration_minutes}min`);
                }
                
                if (problems.length > 0) {
                    problemCount++;
                    adminLog(`⚠️ ${doc.id}: ${problems.join(', ')}`, 'warn');
                }
            });
            
            stats.problems = problemCount;
            
            // Atualizar estatísticas na UI
            document.getElementById('admin-stat-total').textContent = stats.total;
            document.getElementById('admin-stat-problems').textContent = stats.problems;
            document.getElementById('admin-stat-fixed').textContent = stats.fixed;
            document.getElementById('admin-stat-deleted').textContent = stats.deleted;
            
            adminLog(`✅ Análise completa: ${stats.problems} registros com problemas de ${stats.total}`, 'success');
            
            // Habilitar botão de correção se houver problemas
            const btnFix = document.getElementById('admin-btn-fix');
            if (btnFix) btnFix.disabled = stats.problems === 0;
            
        } catch (error) {
            adminLog(`❌ Erro na análise: ${error.message}`, 'error');
        }
    }
    
    async function adminFixDowntimeRecords() {
        const isDryRun = document.getElementById('admin-chk-dry-run')?.checked ?? true;
        const deleteInvalid = document.getElementById('admin-chk-delete-invalid')?.checked ?? false;
        
        adminLog(`🔧 Iniciando correção (Simulação: ${isDryRun ? 'SIM' : 'NÃO'})...`, 'info');
        
        const stats = { fixed: 0, deleted: 0 };
        
        try {
            const snapshot = await db.collection('downtime_entries').limit(500).get();
            const batch = db.batch();
            let batchCount = 0;
            
            for (const doc of snapshot.docs) {
                const data = doc.data();
                const updates = {};
                let shouldDelete = false;
                
                // Tentar corrigir timestamp de início
                if (!data.start_timestamp && !data.startTimestamp) {
                    if (data.originalStartTimestamp) {
                        updates.start_timestamp = data.originalStartTimestamp;
                        adminLog(`Corrigindo início de ${doc.id} usando originalStartTimestamp`, 'info');
                    } else if (data.date && data.start_time) {
                        try {
                            const startDate = new Date(`${data.date}T${data.start_time}:00`);
                            if (!isNaN(startDate.getTime())) {
                                updates.start_timestamp = firebase.firestore.Timestamp.fromDate(startDate);
                                adminLog(`Corrigindo início de ${doc.id} usando date+start_time`, 'info');
                            }
                        } catch (e) {}
                    } else {
                        adminLog(`⚠️ ${doc.id}: Não foi possível recuperar timestamp de início`, 'warn');
                        if (deleteInvalid) shouldDelete = true;
                    }
                }
                
                // Tentar corrigir timestamp de fim
                if (!data.end_timestamp && !data.endTimestamp && data.status !== 'active') {
                    if (data.originalEndTimestamp) {
                        updates.end_timestamp = data.originalEndTimestamp;
                        adminLog(`Corrigindo fim de ${doc.id} usando originalEndTimestamp`, 'info');
                    } else if (data.date && data.end_time) {
                        try {
                            const endDate = new Date(`${data.date}T${data.end_time}:00`);
                            if (!isNaN(endDate.getTime())) {
                                updates.end_timestamp = firebase.firestore.Timestamp.fromDate(endDate);
                                adminLog(`Corrigindo fim de ${doc.id} usando date+end_time`, 'info');
                            }
                        } catch (e) {}
                    }
                }
                
                // Aplicar correções ou deletar
                if (!isDryRun) {
                    if (shouldDelete) {
                        batch.delete(doc.ref);
                        stats.deleted++;
                        batchCount++;
                    } else if (Object.keys(updates).length > 0) {
                        batch.update(doc.ref, updates);
                        stats.fixed++;
                        batchCount++;
                    }
                } else {
                    if (shouldDelete) {
                        adminLog(`[SIMULAÇÃO] Deletaria: ${doc.id}`, 'warn');
                        stats.deleted++;
                    } else if (Object.keys(updates).length > 0) {
                        adminLog(`[SIMULAÇÃO] Corrigiria: ${doc.id} - ${JSON.stringify(updates)}`, 'info');
                        stats.fixed++;
                    }
                }
                
                // Commit batch a cada 400 operações
                if (batchCount >= 400) {
                    if (!isDryRun) await batch.commit();
                    batchCount = 0;
                }
            }
            
            // Commit final
            if (!isDryRun && batchCount > 0) {
                await batch.commit();
            }
            
            // Atualizar UI
            document.getElementById('admin-stat-fixed').textContent = stats.fixed;
            document.getElementById('admin-stat-deleted').textContent = stats.deleted;
            
            adminLog(`✅ Correção ${isDryRun ? '(simulação)' : ''} completa: ${stats.fixed} corrigidos, ${stats.deleted} excluídos`, 'success');
            
        } catch (error) {
            adminLog(`❌ Erro na correção: ${error.message}`, 'error');
        }
    }
    
    // ===== Funções de Ajuste de Ordens =====
    async function adminBuscarOrdem() {
        const numeroOP = document.getElementById('admin-ordem-numero')?.value?.trim();
        const detalhesDiv = document.getElementById('admin-ordem-detalhes');
        const btnAjustar = document.getElementById('admin-btn-ajustar-ordem');
        const logDiv = document.getElementById('admin-ordem-log');
        
        if (!numeroOP) {
            alert('Digite o número da OP');
            return;
        }
        
        try {
            adminCurrentOrderDoc = null;
            if (detalhesDiv) detalhesDiv.classList.add('hidden');
            if (btnAjustar) btnAjustar.disabled = true;
            
            // Buscar ordem
            const snapshot = await db.collection('production_orders')
                .where('order_number', '==', numeroOP)
                .limit(1)
                .get();
            
            if (snapshot.empty) {
                // Tentar busca numérica
                const numerico = parseInt(numeroOP);
                if (!isNaN(numerico)) {
                    const snapshot2 = await db.collection('production_orders')
                        .where('order_number', '==', numerico)
                        .limit(1)
                        .get();
                    
                    if (!snapshot2.empty) {
                        adminCurrentOrderDoc = snapshot2.docs[0];
                    }
                }
            } else {
                adminCurrentOrderDoc = snapshot.docs[0];
            }
            
            if (!adminCurrentOrderDoc) {
                alert(`Ordem ${numeroOP} não encontrada`);
                return;
            }
            
            const data = adminCurrentOrderDoc.data();
            
            // Preencher detalhes
            document.getElementById('admin-ordem-info-op').textContent = data.order_number || '-';
            document.getElementById('admin-ordem-info-produto').textContent = data.product_name || data.product_code || '-';
            document.getElementById('admin-ordem-info-maquina').textContent = data.machine_id || '-';
            document.getElementById('admin-ordem-info-status').textContent = data.status || '-';
            document.getElementById('admin-ordem-info-planejada').textContent = data.planned_quantity || '-';
            document.getElementById('admin-ordem-info-executada').textContent = data.executed_quantity || 0;
            
            const progresso = data.planned_quantity > 0 
                ? ((data.executed_quantity || 0) / data.planned_quantity * 100).toFixed(1) + '%'
                : '-';
            document.getElementById('admin-ordem-info-progresso').textContent = progresso;
            
            if (detalhesDiv) detalhesDiv.classList.remove('hidden');
            if (btnAjustar) btnAjustar.disabled = false;
            
            // Log
            if (logDiv) {
                const entry = document.createElement('div');
                entry.className = 'text-blue-400 py-0.5';
                entry.textContent = `[${new Date().toLocaleTimeString()}] OP ${numeroOP} encontrada - Executada atual: ${data.executed_quantity || 0}`;
                logDiv.appendChild(entry);
            }
            
        } catch (error) {
            console.error('[ADMIN] Erro ao buscar ordem:', error);
            alert('Erro ao buscar ordem: ' + error.message);
        }
    }
    
    async function adminAjustarQuantidadeOrdem() {
        if (!adminCurrentOrderDoc) {
            alert('Nenhuma ordem selecionada');
            return;
        }
        
        const novaQuantidade = parseInt(document.getElementById('admin-ordem-quantidade')?.value);
        const logDiv = document.getElementById('admin-ordem-log');
        
        if (isNaN(novaQuantidade) || novaQuantidade < 0) {
            alert('Digite uma quantidade válida');
            return;
        }
        
        const data = adminCurrentOrderDoc.data();
        const quantidadeAnterior = data.executed_quantity || 0;
        
        if (!confirm(`Confirma alteração da quantidade executada?\n\nOP: ${data.order_number}\nAnterior: ${quantidadeAnterior}\nNova: ${novaQuantidade}`)) {
            return;
        }
        
        try {
            await db.collection('production_orders').doc(adminCurrentOrderDoc.id).update({
                executed_quantity: novaQuantidade,
                last_manual_adjustment: firebase.firestore.FieldValue.serverTimestamp(),
                adjusted_by: getActiveUser()?.name || 'Admin'
            });
            
            // Registrar log do sistema
            await registrarLogSistema(
                `AJUSTE MANUAL: OP ${data.order_number} - Quantidade: ${quantidadeAnterior} → ${novaQuantidade}`,
                'admin_adjustment',
                {
                    order_number: data.order_number,
                    machine_id: data.machine_id,
                    previous_quantity: quantidadeAnterior,
                    new_quantity: novaQuantidade
                }
            );
            
            // Atualizar UI
            document.getElementById('admin-ordem-info-executada').textContent = novaQuantidade;
            
            const progresso = data.planned_quantity > 0 
                ? (novaQuantidade / data.planned_quantity * 100).toFixed(1) + '%'
                : '-';
            document.getElementById('admin-ordem-info-progresso').textContent = progresso;
            
            // Log visual
            if (logDiv) {
                const entry = document.createElement('div');
                entry.className = 'text-green-400 py-0.5';
                entry.textContent = `[${new Date().toLocaleTimeString()}] ✅ OP ${data.order_number} atualizada: ${quantidadeAnterior} → ${novaQuantidade}`;
                logDiv.appendChild(entry);
            }
            
            alert('Quantidade atualizada com sucesso!');
            
        } catch (error) {
            console.error('[ADMIN] Erro ao ajustar ordem:', error);
            alert('Erro ao ajustar: ' + error.message);
            
            if (logDiv) {
                const entry = document.createElement('div');
                entry.className = 'text-red-400 py-0.5';
                entry.textContent = `[${new Date().toLocaleTimeString()}] ❌ Erro: ${error.message}`;
                logDiv.appendChild(entry);
            }
        }
    }
    
    // ===== Funções de Produção =====
    async function adminBuscarProducao() {
        const data = document.getElementById('admin-producao-data')?.value;
        const maquina = document.getElementById('admin-producao-maquina')?.value;
        const listaDiv = document.getElementById('admin-producao-lista');
        
        if (!data) {
            alert('Selecione uma data');
            return;
        }
        
        try {
            listaDiv.innerHTML = '<div class="text-center py-4 text-gray-500"><i class="animate-spin">⏳</i> Carregando...</div>';
            
            let query = db.collection('production_entries').where('date', '==', data);
            if (maquina) {
                query = query.where('machine_id', '==', maquina);
            }
            
            const snapshot = await query.orderBy('timestamp', 'desc').limit(100).get();
            
            if (snapshot.empty) {
                listaDiv.innerHTML = '<div class="text-center py-8 text-gray-400">Nenhum registro encontrado para esta data/máquina.</div>';
                return;
            }
            
            let html = '';
            snapshot.forEach(doc => {
                const d = doc.data();
                const hora = d.timestamp?.toDate ? d.timestamp.toDate().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }) : '-';
                
                html += `
                    <div class="flex items-center justify-between bg-gray-50 rounded-lg p-3 border border-gray-200">
                        <div class="flex items-center gap-4">
                            <span class="font-semibold text-gray-800">${d.machine_id || '-'}</span>
                            <span class="text-sm text-gray-600">${d.product_name || d.product_code || '-'}</span>
                            <span class="text-sm font-medium text-blue-600">Qtd: ${d.quantity || 0}</span>
                            <span class="text-xs text-gray-400">${hora}</span>
                            <span class="text-xs px-2 py-0.5 rounded bg-gray-200 text-gray-600">T${d.shift || '-'}</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <button class="admin-btn-edit-producao text-blue-500 hover:text-blue-700 px-2 py-1" data-id="${doc.id}">
                                <i data-lucide="edit-2" class="w-4 h-4"></i>
                            </button>
                            <button class="admin-btn-delete-producao text-red-500 hover:text-red-700 px-2 py-1" data-id="${doc.id}" data-machine="${d.machine_id}" data-qty="${d.quantity}">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                `;
            });
            
            listaDiv.innerHTML = html;
            lucide.createIcons();
            
            // Attach delete handlers
            listaDiv.querySelectorAll('.admin-btn-delete-producao').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const docId = btn.dataset.id;
                    const machine = btn.dataset.machine;
                    const qty = btn.dataset.qty;
                    
                    if (!confirm(`Excluir registro de produção?\n\nMáquina: ${machine}\nQuantidade: ${qty}`)) return;
                    
                    try {
                        await db.collection('production_entries').doc(docId).delete();
                        btn.closest('div.flex').remove();
                        alert('Registro excluído com sucesso');
                    } catch (err) {
                        alert('Erro ao excluir: ' + err.message);
                    }
                });
            });
            
        } catch (error) {
            console.error('[ADMIN] Erro ao buscar produção:', error);
            listaDiv.innerHTML = `<div class="text-center py-4 text-red-500">Erro: ${error.message}</div>`;
        }
    }

    // ==================== FIM ADMINISTRAÇÃO DE DADOS ====================

    let historicoCurrentPage = 0;
    let historicoPageSize = 50;
    let historicoLastDoc = null;
    let historicoFirstDoc = null;
    let historicoDataSelecionada = null; // 'hoje', 'ontem' ou data específica
    let historicoSetupDone = false; // Flag para evitar setup duplicado

    function setupHistoricoSistema() {
        // Evitar configuração duplicada de event listeners
        if (historicoSetupDone) {
            // Apenas recarregar os dados
            carregarHistorico();
            return;
        }
        historicoSetupDone = true;

        const btnHoje = document.getElementById('historico-hoje');
        const btnOntem = document.getElementById('historico-ontem');
        const dataEspecifica = document.getElementById('historico-data-especifica');
        const btnRefresh = document.getElementById('historico-refresh');
        const btnPrev = document.getElementById('historico-prev');
        const btnNext = document.getElementById('historico-next');

        // Função para atualizar visual dos botões
        function atualizarBotaoAtivo(ativo) {
            if (btnHoje) {
                btnHoje.className = ativo === 'hoje' 
                    ? 'flex-1 px-3 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition'
                    : 'flex-1 px-3 py-2.5 bg-white border border-gray-200 rounded-lg text-sm font-medium hover:bg-gray-50 transition';
            }
            if (btnOntem) {
                btnOntem.className = ativo === 'ontem'
                    ? 'flex-1 px-3 py-2.5 bg-blue-600 text-white rounded-lg text-sm font-medium hover:bg-blue-700 transition'
                    : 'flex-1 px-3 py-2.5 bg-white border border-gray-200 rounded-lg text-sm font-medium hover:bg-gray-50 transition';
            }
            if (dataEspecifica && ativo !== 'hoje' && ativo !== 'ontem') {
                dataEspecifica.classList.add('ring-2', 'ring-blue-500');
            } else if (dataEspecifica) {
                dataEspecifica.classList.remove('ring-2', 'ring-blue-500');
            }
        }

        // Definir data padrão como hoje
        historicoDataSelecionada = new Date().toISOString().split('T')[0];
        atualizarBotaoAtivo('hoje');

        // Evento botão Hoje
        if (btnHoje) btnHoje.addEventListener('click', () => {
            historicoDataSelecionada = new Date().toISOString().split('T')[0];
            if (dataEspecifica) dataEspecifica.value = '';
            atualizarBotaoAtivo('hoje');
            historicoCurrentPage = 0;
            historicoLastDoc = null;
            carregarHistorico();
        });

        // Evento botão Ontem
        if (btnOntem) btnOntem.addEventListener('click', () => {
            const ontem = new Date();
            ontem.setDate(ontem.getDate() - 1);
            historicoDataSelecionada = ontem.toISOString().split('T')[0];
            if (dataEspecifica) dataEspecifica.value = '';
            atualizarBotaoAtivo('ontem');
            historicoCurrentPage = 0;
            historicoLastDoc = null;
            carregarHistorico();
        });

        // Evento seleção de data específica
        if (dataEspecifica) dataEspecifica.addEventListener('change', () => {
            if (dataEspecifica.value) {
                historicoDataSelecionada = dataEspecifica.value;
                atualizarBotaoAtivo('especifica');
                historicoCurrentPage = 0;
                historicoLastDoc = null;
                carregarHistorico();
            }
        });
        
        if (btnRefresh) btnRefresh.addEventListener('click', () => {
            historicoCurrentPage = 0;
            historicoLastDoc = null;
            carregarHistorico();
        });

        if (btnPrev) btnPrev.addEventListener('click', () => {
            if (historicoCurrentPage > 0) {
                historicoCurrentPage--;
                carregarHistorico('prev');
            }
        });

        if (btnNext) btnNext.addEventListener('click', () => {
            historicoCurrentPage++;
            carregarHistorico('next');
        });

        // Event listeners para os filtros
        const tipoAcaoSelect = document.getElementById('historico-tipo-acao');
        const usuarioInput = document.getElementById('historico-usuario');
        const maquinaInput = document.getElementById('historico-maquina');

        if (tipoAcaoSelect) {
            tipoAcaoSelect.addEventListener('change', () => {
                historicoCurrentPage = 0;
                historicoLastDoc = null;
                carregarHistorico();
            });
        }

        // Debounce para inputs de texto (evita muitas requisições)
        let debounceTimer = null;
        const debounceCarregar = () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                historicoCurrentPage = 0;
                historicoLastDoc = null;
                carregarHistorico();
            }, 500);
        };

        if (usuarioInput) {
            usuarioInput.addEventListener('input', debounceCarregar);
        }

        if (maquinaInput) {
            maquinaInput.addEventListener('input', debounceCarregar);
        }

        // Botão para gerar dados de teste
        const btnTeste = document.getElementById('historico-teste');
        if (btnTeste) btnTeste.addEventListener('click', async () => {
            try {
                btnTeste.disabled = true;
                btnTeste.textContent = 'Gerando...';
                
                const usuario = window.authSystem?.getCurrentUser();
                const now = new Date();
                const dataHoje = now.toISOString().split('T')[0];
                
                // Criar alguns registros de teste
                const testeLogs = [
                    { acao: 'LANÇAMENTO DE PRODUÇÃO', tipo: 'producao', descricao: 'Produção de teste - 500 peças', maquina: 'H-01', detalhes: { quantidade: 500, turno: 1 } },
                    { acao: 'ATIVAÇÃO DE ORDEM', tipo: 'ordem', descricao: 'Ordem OP-12345 ativada', maquina: 'H-05', detalhes: { orderNumber: 'OP-12345' } },
                    { acao: 'LANÇAMENTO DE PERDA', tipo: 'perda', descricao: 'Perda registrada - 20 peças', maquina: 'H-11', detalhes: { quantidade: 20, motivo: 'Material fora de especificação' } },
                    { acao: 'REGISTRO DE PARADA', tipo: 'parada', descricao: 'Parada por manutenção - 45min', maquina: 'H-01', detalhes: { duracao: 45, motivo: 'Manutenção preventiva' } },
                ];
                
                for (const log of testeLogs) {
                    await db.collection('system_logs').add({
                        ...log,
                        usuario: usuario?.name || 'Teste',
                        userId: usuario?.id || null,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                        timestampLocal: now.toISOString(),
                        data: dataHoje,
                        hora: now.toTimeString().split(' ')[0]
                    });
                }
                
                showNotification('✅ 4 registros de teste criados!', 'success');
                carregarHistorico();
            } catch (error) {
                console.error('Erro ao gerar teste:', error);
                showNotification('Erro ao gerar dados de teste', 'error');
            } finally {
                btnTeste.disabled = false;
                btnTeste.innerHTML = '<i data-lucide="plus" class="w-4 h-4"></i> Gerar Teste';
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
        });

        // Carregar dados iniciais (hoje)
        carregarHistorico();
    }

    async function carregarHistorico(direction = 'first') {
        const tbody = document.getElementById('historico-tbody');
        if (!tbody) return;

        tbody.innerHTML = `
            <tr>
                <td colspan="6" class="px-4 py-10 text-center text-gray-400">
                    <i data-lucide="loader-2" class="w-10 h-10 mx-auto mb-3 animate-spin opacity-50"></i>
                    <p>Carregando histórico...</p>
                </td>
            </tr>
        `;
        if (typeof lucide !== 'undefined') lucide.createIcons();

        try {
            const dataSelecionada = historicoDataSelecionada || new Date().toISOString().split('T')[0];
            const tipoAcao = document.getElementById('historico-tipo-acao')?.value;
            const usuarioFiltro = document.getElementById('historico-usuario')?.value?.toLowerCase();
            const maquinaFiltro = document.getElementById('historico-maquina')?.value?.toLowerCase();

            // Construir query base - filtra apenas pela data selecionada
            // Nota: ordenação será feita localmente para evitar necessidade de índice composto
            let query = db.collection('system_logs')
                .where('data', '==', dataSelecionada)
                .limit(500); // Buscar mais registros e ordenar localmente

            const snapshot = await query.get();
            
            if (snapshot.empty) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" class="px-4 py-10 text-center text-gray-400">
                            <i data-lucide="inbox" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                            <p>Nenhum registro encontrado para a data selecionada</p>
                        </td>
                    </tr>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                atualizarEstatisticasHistorico([]);
                return;
            }

            // Converter para array e ordenar localmente por timestamp (mais recente primeiro)
            let registros = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            registros.sort((a, b) => {
                const tsA = a.timestamp?.toDate?.() || new Date(a.timestampLocal || 0);
                const tsB = b.timestamp?.toDate?.() || new Date(b.timestampLocal || 0);
                return tsB - tsA; // Ordem decrescente
            });

            // Aplicar filtros locais
            if (tipoAcao) {
                registros = registros.filter(r => r.tipo === tipoAcao);
            }
            if (usuarioFiltro) {
                registros = registros.filter(r => (r.usuario || '').toLowerCase().includes(usuarioFiltro));
            }
            if (maquinaFiltro) {
                registros = registros.filter(r => (r.maquina || '').toLowerCase().includes(maquinaFiltro));
            }

            // Atualizar estatísticas antes de paginar
            atualizarEstatisticasHistorico(registros);

            tbody.innerHTML = '';

            if (registros.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="6" class="px-4 py-10 text-center text-gray-400">
                            <i data-lucide="filter-x" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                            <p>Nenhum registro corresponde aos filtros aplicados</p>
                        </td>
                    </tr>
                `;
                if (typeof lucide !== 'undefined') lucide.createIcons();
                return;
            }

            registros.forEach(log => {
                const row = document.createElement('tr');
                row.className = 'hover:bg-gray-50 transition-colors';
                
                const tipoInfo = getTipoInfo(log.tipo);
                const dataHora = formatarDataHoraLog(log);
                const detalhesStr = formatarDetalhes(log.detalhes);
                
                row.innerHTML = `
                    <td class="px-4 py-3 text-sm text-gray-600 whitespace-nowrap">${dataHora}</td>
                    <td class="px-4 py-3">
                        <span class="inline-flex items-center gap-1.5 px-2.5 py-1 rounded-full text-xs font-medium ${tipoInfo.class}">
                            ${tipoInfo.icon} ${tipoInfo.label}
                        </span>
                    </td>
                    <td class="px-4 py-3 text-sm text-gray-800">${log.descricao || log.acao || '-'}</td>
                    <td class="px-4 py-3 text-sm font-medium text-blue-600">${log.maquina || '-'}</td>
                    <td class="px-4 py-3 text-sm text-gray-600">${log.usuario || '-'}</td>
                    <td class="px-4 py-3 text-xs text-gray-500 max-w-xs truncate" title="${detalhesStr}">${detalhesStr || '-'}</td>
                `;
                
                tbody.appendChild(row);
            });

            // Atualizar info de paginação
            const info = document.getElementById('historico-info');
            if (info) {
                info.textContent = `Mostrando ${registros.length} registros`;
            }

            // Esconder botões de paginação (não necessário com ordenação local)
            const btnPrev = document.getElementById('historico-prev');
            const btnNext = document.getElementById('historico-next');
            if (btnPrev) btnPrev.style.display = 'none';
            if (btnNext) btnNext.style.display = 'none';

            if (typeof lucide !== 'undefined') lucide.createIcons();

        } catch (error) {
            console.error('[HISTORICO] Erro ao carregar:', error);
            tbody.innerHTML = `
                <tr>
                    <td colspan="6" class="px-4 py-10 text-center text-red-400">
                        <i data-lucide="alert-circle" class="w-12 h-12 mx-auto mb-3 opacity-50"></i>
                        <p>Erro ao carregar: ${error.message}</p>
                    </td>
                </tr>
            `;
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
    }

    function getTipoInfo(tipo) {
        const tipos = {
            'producao': { label: 'Produção', icon: '📦', class: 'bg-green-100 text-green-800' },
            'perda': { label: 'Perda', icon: '⚠️', class: 'bg-orange-100 text-orange-800' },
            'parada': { label: 'Parada', icon: '⏸️', class: 'bg-red-100 text-red-800' },
            'ordem': { label: 'Ordem', icon: '📋', class: 'bg-blue-100 text-blue-800' },
            'ordem_ativada': { label: 'Ordem Ativada', icon: '✅', class: 'bg-blue-100 text-blue-800' },
            'ordem_finalizada': { label: 'Ordem Finalizada', icon: '🏁', class: 'bg-purple-100 text-purple-800' },
            'ordem_criada': { label: 'Ordem Criada', icon: '📋', class: 'bg-indigo-100 text-indigo-800' },
            'exclusao': { label: 'Exclusão', icon: '🗑️', class: 'bg-red-100 text-red-800' },
            'edicao': { label: 'Edição', icon: '✏️', class: 'bg-yellow-100 text-yellow-800' },
            'login': { label: 'Login', icon: '🔐', class: 'bg-emerald-100 text-emerald-800' },
            'logout': { label: 'Logout', icon: '🚪', class: 'bg-gray-100 text-gray-800' },
            'ciclo_cavidade': { label: 'Ciclo/Cavidade', icon: '⚙️', class: 'bg-cyan-100 text-cyan-800' },
            'acompanhamento': { label: 'Acompanhamento', icon: '📊', class: 'bg-violet-100 text-violet-800' },
            'planejamento': { label: 'Planejamento', icon: '📅', class: 'bg-teal-100 text-teal-800' },
            'qualidade': { label: 'Qualidade', icon: '✔', class: 'bg-sky-100 text-sky-800' },
            'retrabalho': { label: 'Retrabalho', icon: '🔄', class: 'bg-amber-100 text-amber-800' }
        };
        return tipos[tipo] || { label: tipo || 'Outro', icon: '📝', class: 'bg-gray-100 text-gray-800' };
    }

    function formatarDataHoraLog(log) {
        if (log.timestamp?.toDate) {
            const d = log.timestamp.toDate();
            return d.toLocaleString('pt-BR');
        }
        if (log.timestampLocal) {
            return new Date(log.timestampLocal).toLocaleString('pt-BR');
        }
        return `${log.data || ''} ${log.hora || ''}`;
    }

    function formatarDetalhes(detalhes) {
        if (!detalhes || typeof detalhes !== 'object') return '';
        
        const partes = [];
        if (detalhes.quantidade) partes.push(`Qtd: ${detalhes.quantidade}`);
        if (detalhes.op) partes.push(`OP: ${detalhes.op}`);
        if (detalhes.produto) partes.push(`Prod: ${detalhes.produto}`);
        if (detalhes.motivo) partes.push(`Motivo: ${detalhes.motivo}`);
        if (detalhes.duracao) partes.push(`Dur: ${detalhes.duracao}min`);
        if (detalhes.turno) partes.push(`T${detalhes.turno}`);
        
        return partes.join(' | ') || JSON.stringify(detalhes).substring(0, 100);
    }

    function atualizarEstatisticasHistorico(registros) {
        const total = document.getElementById('historico-total');
        const producao = document.getElementById('historico-producao-count');
        const paradas = document.getElementById('historico-paradas-count');
        const ordens = document.getElementById('historico-ordens-count');
        const exclusoes = document.getElementById('historico-exclusoes-count');

        if (total) total.textContent = registros.length;
        if (producao) producao.textContent = registros.filter(r => r.tipo === 'producao').length;
        if (paradas) paradas.textContent = registros.filter(r => r.tipo === 'parada').length;
        if (ordens) ordens.textContent = registros.filter(r => r.tipo === 'ordem' || r.tipo?.startsWith('ordem')).length;
        if (exclusoes) exclusoes.textContent = registros.filter(r => r.tipo === 'exclusao' || (r.acao && r.acao.includes('EXCLUSÃO'))).length;
    }

    // ==================== FIM HISTÓRICO DO SISTEMA ====================

    function openExtendedDowntimeModal() {
        if (!selectedMachineData) {
            alert('Selecione uma máquina primeiro.');
            return;
        }

        const contextMachine = document.querySelector('#extended-downtime-modal .context-machine');
        if (contextMachine) contextMachine.textContent = selectedMachineData.machine || '-';

        const today = getProductionDateString();
        const ds = document.getElementById('extended-downtime-date-start');
        const de = document.getElementById('extended-downtime-date-end');
        
        if (ds && !ds.value) ds.value = today;
        if (de && !de.value) de.value = today;

        // Attach event listeners
        const dateStart = document.getElementById('extended-downtime-date-start');
        const dateEnd = document.getElementById('extended-downtime-date-end');
        const durationDisplay = document.getElementById('extended-downtime-duration');

        const updateDuration = () => {
            if (dateStart.value && dateEnd.value) {
                const start = new Date(dateStart.value);
                const end = new Date(dateEnd.value);
                const diffMs = end - start;
                const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
                const diffDays = Math.floor(diffHours / 24);
                
                if (diffDays > 0) {
                    durationDisplay.textContent = `${diffDays} dia(s) e ${diffHours % 24}h`;
                } else {
                    durationDisplay.textContent = `${diffHours}h`;
                }
            }
        };

        dateStart.removeEventListener('change', updateDuration);
        dateEnd.removeEventListener('change', updateDuration);
        dateStart.addEventListener('change', updateDuration);
        dateEnd.addEventListener('change', updateDuration);
        updateDuration();

        openModal('extended-downtime-modal');
    }

    async function handleExtendedDowntimeSubmit(e) {
        e.preventDefault();

        if (!selectedMachineData) {
            alert('Máquina não selecionada.');
            return;
        }

        const type = document.getElementById('extended-downtime-type').value;
        const dateStart = document.getElementById('extended-downtime-date-start').value;
        const dateEnd = document.getElementById('extended-downtime-date-end').value;
        const timeStart = document.getElementById('extended-downtime-time-start').value || '00:00';
        const timeEnd = document.getElementById('extended-downtime-time-end').value || '23:59';
        const reason = document.getElementById('extended-downtime-reason').value || '';

        if (!type || !dateStart || !dateEnd) {
            alert('Preencha os campos obrigatórios.');
            return;
        }

        try {
            const startDateTime = new Date(`${dateStart}T${timeStart}`);
            const endDateTime = new Date(`${dateEnd}T${timeEnd}`);
            const durationMinutes = Math.floor((endDateTime - startDateTime) / (1000 * 60));

            const downtimeData = {
                machine_id: selectedMachineData.machine,
                type: type,
                reason: reason,
                start_date: dateStart,
                end_date: dateEnd,
                start_time: timeStart,
                end_time: timeEnd,
                start_datetime: firebase.firestore.Timestamp.fromDate(startDateTime),
                end_datetime: firebase.firestore.Timestamp.fromDate(endDateTime),
                duration_minutes: durationMinutes,
                status: 'registered',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                createdBy: getActiveUser()?.name || 'Sistema',
                shift: getCurrentShift(startDateTime),
                date: dateStart
            };

            await db.collection('extended_downtime_logs').add(downtimeData);

            alert('Parada longa registrada com sucesso!');
            closeModal('extended-downtime-modal');
            
            // Clear form
            document.getElementById('extended-downtime-type').value = '';
            document.getElementById('extended-downtime-reason').value = '';
            document.getElementById('extended-downtime-time-start').value = '';
            document.getElementById('extended-downtime-time-end').value = '';

        } catch (error) {
            console.error('Erro ao registrar parada longa:', error);
            alert('Erro ao registrar parada longa: ' + error.message);
        }
    }

    // ============================================================
    // ATUALIZAÇÃO AUTOMÁTICA DE PARADAS LONGAS (a cada 30 minutos)
    // ============================================================
    
    /**
     * Inicia o timer de atualização automática de paradas longas ativas
     * Atualiza o campo duration_minutes no Firebase a cada 30 minutos
     */
    function startExtendedDowntimeAutoUpdate() {
        // Limpar timer anterior se existir
        if (extendedDowntimeUpdateTimer) {
            clearInterval(extendedDowntimeUpdateTimer);
        }
        
        console.log('[PARADAS-LONGAS] Iniciando atualização automática a cada 30 minutos');
        
        // Executar imediatamente na primeira vez
        updateActiveExtendedDowntimes();
        
        // Agendar execução a cada 30 minutos
        extendedDowntimeUpdateTimer = setInterval(() => {
            updateActiveExtendedDowntimes();
        }, EXTENDED_DOWNTIME_UPDATE_INTERVAL);
    }
    
    /**
     * Atualiza o tempo de todas as paradas longas ativas no Firebase
     */
    async function updateActiveExtendedDowntimes() {
        try {
            console.log('[PARADAS-LONGAS] Atualizando tempo de paradas ativas...');
            
            // Buscar todas as paradas ativas
            const snapshot = await db.collection('extended_downtime_logs')
                .where('status', '==', 'active')
                .get();
            
            if (snapshot.empty) {
                console.log('[PARADAS-LONGAS] Nenhuma parada ativa para atualizar');
                return;
            }
            
            const now = new Date();
            const batch = db.batch();
            let updatedCount = 0;
            
            snapshot.docs.forEach(doc => {
                const data = doc.data();
                
                // Calcular duração atual
                let startDatetime;
                if (data.start_datetime?.toDate) {
                    startDatetime = data.start_datetime.toDate();
                } else if (data.start_date && data.start_time) {
                    startDatetime = new Date(`${data.start_date}T${data.start_time}:00`);
                } else {
                    console.warn('[PARADAS-LONGAS] Registro sem data de início válida:', doc.id);
                    return;
                }
                
                const durationMinutes = Math.floor((now - startDatetime) / (1000 * 60));
                
                // Atualizar no batch
                batch.update(doc.ref, {
                    duration_minutes: durationMinutes,
                    last_duration_update: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                updatedCount++;
                
                console.log(`[PARADAS-LONGAS] ${data.machine_id || 'N/A'}: ${Math.floor(durationMinutes/60)}h ${durationMinutes % 60}m`);
            });
            
            if (updatedCount > 0) {
                await batch.commit();
                console.log(`[PARADAS-LONGAS] ✅ ${updatedCount} parada(s) atualizada(s)`);
            }
            
        } catch (error) {
            console.error('[PARADAS-LONGAS] Erro ao atualizar paradas ativas:', error);
        }
    }
    
    /**
     * Para o timer de atualização automática
     */
    function stopExtendedDowntimeAutoUpdate() {
        if (extendedDowntimeUpdateTimer) {
            clearInterval(extendedDowntimeUpdateTimer);
            extendedDowntimeUpdateTimer = null;
            console.log('[PARADAS-LONGAS] Timer de atualização automática parado');
        }
    }

    async function handleExtendedDowntimeFormSubmit(e) {
        e.preventDefault();

        const machineSelect = document.getElementById('extended-downtime-machine');
        const categorySelect = document.getElementById('extended-downtime-category');
        const reasonSelect = document.getElementById('extended-downtime-reason');
        const startDateInput = document.getElementById('extended-downtime-start-date');
        const startTimeInput = document.getElementById('extended-downtime-custom-time');
        const statusDiv = document.getElementById('extended-downtime-status');
        const submitBtn = document.getElementById('extended-downtime-submit');

        // SINGLE MACHINE (not array)
        const selectedMachine = machineSelect?.value?.trim() || '';
        const category = categorySelect?.value?.trim() || '';
        const reason = reasonSelect?.value?.trim() || '';
        const selectedDate = startDateInput?.value || '';
        const selectedTime = startTimeInput?.value || '';

        console.log('[PARADAS-LONGAS] Registrando parada ATIVA:', { machine: selectedMachine, category, reason, date: selectedDate, time: selectedTime });

        // Validação
        if (!selectedMachine || !category || !reason) {
            const missing = [];
            if (!selectedMachine) missing.push('máquina');
            if (!category) missing.push('categoria');
            if (!reason) missing.push('motivo');
            
            statusDiv.textContent = `❌ Preencha: ${missing.join(', ')}`;
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            return;
        }

        // Validar data e hora
        if (!selectedDate || !selectedTime) {
            statusDiv.textContent = `❌ Preencha a data e hora de início`;
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            return;
        }

        try {
            submitBtn.disabled = true;
            statusDiv.textContent = 'Registrando parada...';
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-blue-600';

            // Criar data/hora a partir dos inputs
            const [hours, minutes] = selectedTime.split(':');
            const startDateTime = new Date(selectedDate + 'T' + selectedTime + ':00');
            
            console.log('[PARADAS-LONGAS] Data/hora selecionada:', { date: selectedDate, time: selectedTime, datetime: startDateTime });
            
            const userName = getActiveUser()?.name || 'Sistema';
            const normalizedMachineId = normalizeMachineId(selectedMachine);
            
            // Criar um ÚNICO documento para esta parada
            const downtimeData = {
                machine_id: normalizedMachineId,
                category: category,  // Nova campo de categoria
                type: reason,  // Usar reason como tipo (vem da lista de motivos)
                reason: reason,  // Manter também como reason para compatibilidade
                
                // Data/hora de início = SELECIONADA pelo usuário
                start_date: selectedDate,
                start_time: selectedTime,
                start_datetime: firebase.firestore.Timestamp.fromDate(startDateTime),
                
                // Data/hora de fim: NOT SET (vai ser preenchido ao finalizar)
                end_date: null,
                end_time: null,
                end_datetime: null,
                
                // Status: ATIVA (não finalized yet)
                status: 'active',
                
                // Auditoria
                createdBy: userName,
                shift: getCurrentShift(startDateTime),
                date: selectedDate
            };

            // Verificar se é edição ou criação
            const editingId = submitBtn.dataset.editingId;
            let docRef;
            
            if (editingId) {
                // ATUALIZAÇÃO de registro existente
                downtimeData.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                downtimeData.updatedBy = userName;
                await db.collection('extended_downtime_logs').doc(editingId).update(downtimeData);
                docRef = { id: editingId };
                
                console.log('[PARADAS-LONGAS] Parada atualizada com sucesso:', {
                    recordId: editingId,
                    machine: normalizedMachineId,
                    startTime: `${selectedDate} ${selectedTime}`
                });
                
                statusDiv.textContent = `✅ Parada atualizada para ${normalizedMachineId}`;
                
                // Limpar modo de edição
                delete submitBtn.dataset.editingId;
                submitBtn.innerHTML = '<i data-lucide="pause-circle" class="w-5 h-5"></i><span>🚨 REGISTRAR PARADA</span>';
            } else {
                // CRIAÇÃO de novo registro
                downtimeData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                docRef = await db.collection('extended_downtime_logs').add(downtimeData);
                
                console.log('[PARADAS-LONGAS] Parada registrada com sucesso:', {
                    recordId: docRef.id,
                    machine: normalizedMachineId,
                    startTime: `${selectedDate} ${selectedTime}`
                });

                statusDiv.textContent = `✅ Parada iniciada para ${normalizedMachineId} em ${selectedDate} às ${selectedTime}`;
            }
            
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-green-600';

            // Limpar formulário
            document.getElementById('extended-downtime-form').reset();
            setupExtendedDowntimeTab();  // Reinicializar (vai preencher com data/hora atual)
            
            submitBtn.disabled = false;
            lucide.createIcons();
            
            // Recarregar painel de máquinas (vai mostrar a parada ativa)
            const machinesDowntime = await getAllMachinesDowntimeStatus();
            await renderMachineCards([], [], [], new Set(), machinesDowntime);
            
            // Se lista de paradas está visível, atualizar
            if (typeof loadExtendedDowntimeList === 'function') {
                await loadExtendedDowntimeList();
            }

            setTimeout(() => {
                statusDiv.textContent = '';
                statusDiv.className = 'text-sm font-semibold h-5 text-center';
            }, 5000);

        } catch (error) {
            console.error('[PARADAS-LONGAS] Erro ao registrar parada:', error);
            statusDiv.textContent = `❌ Erro: ${error.message}`;
            statusDiv.className = 'text-sm font-semibold h-5 text-center text-red-600';
            submitBtn.disabled = false;
        }
    }

    async function loadExtendedDowntimeList() {
        const listContainer = document.getElementById('extended-downtime-list');
        const loadingDiv = document.getElementById('extended-downtime-list-loading');
        const emptyDiv = document.getElementById('extended-downtime-list-empty');

        if (!listContainer) return;

        try {
            loadingDiv?.classList.remove('hidden');
            listContainer.innerHTML = '';

            const snap = await db.collection('extended_downtime_logs').orderBy('createdAt', 'desc').limit(50).get();
            const rawRecords = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            const records = [];
            const seenIds = new Set();

            rawRecords.forEach(record => {
                if (!record.id) return;
                if (seenIds.has(record.id)) {
                    console.warn('[EXTENDED-DOWNTIME] Registro duplicado ignorado:', record.id);
                    return;
                }
                seenIds.add(record.id);
                records.push(record);
            });

            if (records.length === 0) {
                emptyDiv?.classList.remove('hidden');
                loadingDiv?.classList.add('hidden');
                return;
            }

            emptyDiv?.classList.add('hidden');
            loadingDiv?.classList.add('hidden');

            const typeLabels = {
                weekend: 'Fim de Semana',
                maintenance: 'Manutenção Preventiva',
                preventive: 'Manutenção Preventiva',
                maintenance_planned: 'Manutenção Programada',
                maintenance_emergency: 'Manutenção Emergencial',
                no_order: 'Sem Pedido',
                commercial: 'Parada Comercial',
                holiday: 'Feriado',
                setup: 'Setup/Troca',
                other: 'Outro'
            };
            const typeColors = {
                weekend: 'bg-gray-100 text-gray-700',
                maintenance: 'bg-blue-100 text-blue-700',
                preventive: 'bg-blue-100 text-blue-700',
                maintenance_planned: 'bg-blue-100 text-blue-700',
                maintenance_emergency: 'bg-red-100 text-red-700',
                no_order: 'bg-orange-100 text-orange-700',
                commercial: 'bg-amber-100 text-amber-700',
                holiday: 'bg-amber-100 text-amber-700',
                setup: 'bg-purple-100 text-purple-700',
                other: 'bg-red-100 text-red-700'
            };

            records.forEach(record => {
                const startDate = record.start_date || '-';
                const endDate = record.end_date || '-';
                const machine = record.machine_id || '-';
                const type = record.type || 'other';
                const category = record.category || '';
                const reason = record.reason || '-';
                const durationDays = Math.floor((record.duration_minutes || 0) / (24 * 60));
                const durationHours = Math.floor(((record.duration_minutes || 0) % (24 * 60)) / 60);
                const durationText = durationDays > 0 ? `${durationDays}d ${durationHours}h` : `${durationHours}h`;
                const typeLabel = typeLabels[type] || type;
                const typeColor = typeColors[type] || 'bg-gray-100 text-gray-700';
                
                // Cores das categorias
                const categoryColors = {
                    'FERRAMENTARIA': 'bg-indigo-100 text-indigo-700',
                    'PROCESSO': 'bg-cyan-100 text-cyan-700',
                    'COMPRAS': 'bg-green-100 text-green-700',
                    'PREPARAÇÃO': 'bg-yellow-100 text-yellow-700',
                    'QUALIDADE': 'bg-pink-100 text-pink-700',
                    'MANUTENÇÃO': 'bg-blue-100 text-blue-700',
                    'PRODUÇÃO': 'bg-orange-100 text-orange-700',
                    'SETUP': 'bg-purple-100 text-purple-700',
                    'ADMINISTRATIVO': 'bg-slate-100 text-slate-700',
                    'PCP': 'bg-teal-100 text-teal-700',
                    'COMERCIAL': 'bg-amber-100 text-amber-700'
                };
                const categoryColor = categoryColors[category] || 'bg-gray-100 text-gray-600';
                const categoryBadge = category ? `<span class="text-xs px-2 py-0.5 rounded font-medium ${categoryColor}">${category}</span>` : '';

                const html = `
                    <div class="bg-white border border-gray-200 rounded-lg px-3 py-2 flex flex-col md:flex-row md:items-center md:justify-between gap-3">
                        <div class="flex-1 flex flex-wrap items-center gap-3 text-sm">
                            <span class="font-semibold text-gray-800">${machine}</span>
                            ${categoryBadge}
                            <span class="text-xs px-2 py-0.5 rounded ${typeColor}">${typeLabel}</span>
                            <span class="text-xs text-gray-500">${startDate} → ${endDate}</span>
                            <span class="text-xs text-gray-500">${durationText}</span>
                            <span class="text-xs text-gray-400 truncate max-w-[220px]">${reason}</span>
                        </div>
                        <div class="flex items-center gap-2 text-xs">
                            <button class="btn-edit-extended-downtime bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded font-semibold transition flex items-center gap-1" data-id="${record.id}" data-machine="${machine}" data-type="${type}" data-category="${category}" data-start-date="${startDate}" data-end-date="${endDate}" data-reason="${reason}" data-start-time="${record.start_time || '00:00'}" data-end-time="${record.end_time || '23:59'}">
                                <i data-lucide="edit-2" class="w-4 h-4"></i>
                                <span>Editar</span>
                            </button>
                            <button class="btn-delete-extended-downtime bg-red-500 hover:bg-red-600 text-white px-3 py-1.5 rounded font-semibold transition flex items-center gap-1" data-id="${record.id}" data-machine="${machine}">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                                <span>Excluir</span>
                            </button>
                        </div>
                    </div>
                `;
                listContainer.insertAdjacentHTML('beforeend', html);
            });

            // Attach event listeners para edit e delete
            attachExtendedDowntimeEventListeners();
            lucide.createIcons();

        } catch (error) {
            console.error('Erro ao carregar paradas longas:', error);
            emptyDiv?.classList.remove('hidden');
            loadingDiv?.classList.add('hidden');
        }
    }

    function attachExtendedDowntimeEventListeners() {
        // Botões de editar
        document.querySelectorAll('.btn-edit-extended-downtime').forEach(btn => {
            btn.removeEventListener('click', handleEditExtendedDowntime);
            btn.addEventListener('click', handleEditExtendedDowntime);
        });

        // Botões de deletar
        document.querySelectorAll('.btn-delete-extended-downtime').forEach(btn => {
            btn.removeEventListener('click', handleDeleteExtendedDowntime);
            btn.addEventListener('click', handleDeleteExtendedDowntime);
        });
    }

    async function handleEditExtendedDowntime(e) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('editar paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        const machine = btn.dataset.machine;
        const type = btn.dataset.type;
        const category = btn.dataset.category || '';
        const startDate = btn.dataset.startDate;
        const endDate = btn.dataset.endDate;
        const reason = btn.dataset.reason;
        const startTime = btn.dataset.startTime;
        const endTime = btn.dataset.endTime;

        console.log('[EXTENDED-DOWNTIME] Editando registro:', recordId, { category });

        // Preencher form com dados existentes
        document.getElementById('extended-downtime-machine').value = machine;
        const categorySelect = document.getElementById('extended-downtime-category');
        if (categorySelect) categorySelect.value = category;
        document.getElementById('extended-downtime-reason').value = reason;
        document.getElementById('extended-downtime-start-date').value = startDate;
        document.getElementById('extended-downtime-custom-time').value = startTime;

        // Mudar texto do botão para "Atualizar"
        const submitBtn = document.getElementById('extended-downtime-submit');
        const originalText = submitBtn.innerHTML;
        submitBtn.dataset.editingId = recordId;
        submitBtn.innerHTML = '<i data-lucide="save" class="w-4 h-4"></i><span>Atualizar Parada</span>';
        lucide.createIcons();

        // Scroll para o formulário
        document.getElementById('extended-downtime-form').scrollIntoView({ behavior: 'smooth' });
    }

    async function handleDeleteExtendedDowntime(e) {
        // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem excluir
        if (!isUserGestorOrAdmin()) {
            showPermissionDeniedNotification('excluir paradas longas');
            return;
        }
        
        const btn = e.currentTarget;
        const recordId = btn.dataset.id;
        const machine = btn.dataset.machine;

        console.log('[EXTENDED-DOWNTIME] Deletando registro:', recordId);

        if (!confirm(`Tem certeza que deseja excluir a parada da máquina ${machine}?`)) {
            return;
        }

        try {
            btn.disabled = true;
            btn.textContent = 'Excluindo...';

            await db.collection('extended_downtime_logs').doc(recordId).delete();

            console.log('[EXTENDED-DOWNTIME] Registro excluído com sucesso');
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE PARADA ESTENDIDA', 'parada', {
                recordId: recordId,
                machine: machine
            });
            
            // Recarregar lista e análise
            await loadExtendedDowntimeList();
            
            // Se estiver na análise, recarregar também
            if (document.querySelector('#extended-downtime-analysis-list')) {
                const { startDate, endDate, machine } = currentAnalysisFilters;
                await loadExtendedDowntimeAnalysis(startDate, endDate, machine);
            }

        } catch (error) {
            console.error('[EXTENDED-DOWNTIME] Erro ao excluir:', error);
            alert('Erro ao excluir parada: ' + error.message);
            btn.disabled = false;
            btn.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4"></i><span>Excluir</span>';
            lucide.createIcons();
        }
    }

    // Handlers dos formulários
    async function handleManualProductionSubmit(e) {
        e.preventDefault();
        e.stopPropagation();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }
        
        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }
        
        if (!window.authSystem.checkPermissionForAction('add_production')) {
            showNotification('Permissão negada para registrar produção', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }
        
        const dateInput = document.getElementById('manual-production-date');
        const hourInput = document.getElementById('manual-production-hour');
        const shiftSelect = document.getElementById('manual-production-shift');
        const qtyInput = document.getElementById('manual-production-qty');
        const weightInput = document.getElementById('manual-production-weight');
        const useTareCheckbox = document.getElementById('manual-production-use-tare');
        const obsInput = document.getElementById('manual-production-obs');

        const dateValue = dateInput?.value || '';
        const hourValue = hourInput?.value || '';
        const shiftRaw = shiftSelect?.value || '';
        const quantityValue = parseInt(qtyInput?.value || '0', 10);
        const rawWeightGrams = parseWeightInputToGrams(weightInput?.value || '');
        let netWeightGrams = rawWeightGrams;
        const observations = (obsInput?.value || '').trim();
        
        if (!dateValue) {
            showNotification('Informe a data da produção', 'warning');
            dateInput?.focus();
            return;
        }
        
        const hasQty = Number.isFinite(quantityValue) && quantityValue > 0;
        if (!hasQty && rawWeightGrams <= 0) {
            showNotification('Informe quantidade OU peso', 'warning');
            return;
        }

        if (useTareCheckbox?.checked && rawWeightGrams > 0) {
            const tareWeightGrams = getTareWeightForMachine(selectedMachineData?.machine);
            if (tareWeightGrams > 0) {
                netWeightGrams = Math.max(0, rawWeightGrams - tareWeightGrams);
            }
        }

        const hasWeight = netWeightGrams > 0;
        
        if (!hasQty && !hasWeight) {
            showNotification('Peso informado é inválido após descontar a tara', 'warning');
            return;
        }
        
        try {
            const shiftNumeric = parseInt(shiftRaw, 10);
            const turno = [1, 2, 3].includes(shiftNumeric) ? shiftNumeric : getCurrentShift();
            const planId = selectedMachineData?.id || null;
            const currentUser = getActiveUser();

            let resolvedQuantity = hasQty ? quantityValue : 0;
            if (!hasQty && hasWeight) {
                const pieceWeightGrams = getActivePieceWeightGrams();
                if (pieceWeightGrams <= 0) {
                    showNotification('Peso médio da peça não encontrado. Informe a quantidade manualmente ou cadastre o peso no planejamento.', 'warning');
                    return;
                }
                const conversion = calculateQuantityFromGrams(netWeightGrams, pieceWeightGrams);
                if (conversion.error || conversion.quantity <= 0) {
                    showNotification('Não foi possível converter o peso informado em peças. Verifique o valor digitado.', 'warning');
                    return;
                }
                resolvedQuantity = conversion.quantity;
            }

            const netWeightKg = hasWeight ? Number(gramsToKg(netWeightGrams).toFixed(3)) : 0;
            
            const payloadBase = {
                planId,
                data: dateValue,
                turno,
                produzido: resolvedQuantity,
                peso_bruto: netWeightKg,
                refugo_kg: 0,
                perdas: '',
                observacoes: observations,
                machine: selectedMachineData.machine || null,
                mp: selectedMachineData.mp || '',
                orderId: selectedMachineData.order_id || null,
                manual: true,
                horaInformada: hourValue || null,
                registradoPor: currentUser?.username || null,
                registradoPorNome: getCurrentUserName()
            };
            
            await db.collection('production_entries').add({
                ...payloadBase,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // CRÍTICO: Atualizar total_produzido na OP vinculada e no planejamento
            const linkedOrderId = selectedMachineData.order_id || selectedMachineData.orderId;
            if (linkedOrderId && resolvedQuantity > 0) {
                try {
                    const orderRef = db.collection('production_orders').doc(linkedOrderId);
                    const orderSnap = await orderRef.get();
                    if (orderSnap.exists) {
                        const orderData = orderSnap.data() || {};
                        const currentTotal = coerceToNumber(orderData.total_produzido ?? orderData.totalProduced, 0);
                        const newTotal = currentTotal + resolvedQuantity;
                        await orderRef.update({
                            total_produzido: newTotal,
                            totalProduced: newTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-ORDER] OP ${linkedOrderId} atualizada: total_produzido ${currentTotal} → ${newTotal}`);
                    }
                } catch (orderErr) {
                    console.warn('[SYNC-ORDER] Falha ao atualizar total da OP:', orderErr);
                }
            }

            // Atualizar total_produzido no planejamento também
            if (planId && resolvedQuantity > 0) {
                try {
                    const planRef = db.collection('planning').doc(planId);
                    const planSnap = await planRef.get();
                    if (planSnap.exists) {
                        const planData = planSnap.data() || {};
                        const currentPlanTotal = coerceToNumber(planData.total_produzido, 0);
                        const newPlanTotal = currentPlanTotal + resolvedQuantity;
                        await planRef.update({
                            total_produzido: newPlanTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-PLAN] Plano ${planId} atualizado: total_produzido ${currentPlanTotal} → ${newPlanTotal}`);
                    }
                } catch (planErr) {
                    console.warn('[SYNC-PLAN] Falha ao atualizar total do plano:', planErr);
                }
            }

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('producao', `Produção manual: ${resolvedQuantity} peças`, {
                    quantidade: resolvedQuantity,
                    maquina: selectedMachineData.machine,
                    op: linkedOrderId || planId,
                    turno: turno,
                    data: dateValue,
                    peso: netWeightKg
                });
            }
            
            closeModal('manual-production-modal');
            await populateMachineSelector();
            await refreshLaunchCharts();
            await loadTodayStats();
            await loadRecentEntries(false);
            
            showNotification('✅ Produção manual registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar produção:', error);
            showNotification('❌ Erro ao registrar produção: ' + error.message, 'error');
        }
    }

    // ✅ POKA-YOKE: Validar se a OP está ativada
    function validateOrderActivated() {
        if (!currentActiveOrder || !currentActiveOrder.id) {
            showNotification('⚠️ ORDEM NÃO ATIVADA! Ative a OP antes de fazer qualquer lançamento.', 'error');
            console.warn('[POKA-YOKE] Tentativa de lançamento bloqueada: OP não ativada');
            return false;
        }
        const status = String(currentActiveOrder.status || '').toLowerCase();
        if (status !== 'ativa' && status !== 'em_andamento') {
            showNotification(`⚠️ OP NÃO ESTÁ ATIVA! Status atual: ${currentActiveOrder.status}. Ative antes de registrar.`, 'error');
            console.warn('[POKA-YOKE] Tentativa de lançamento bloqueada: status inválido -', status);
            return false;
        }
        return true;
    }

    // Função validateCycleCavityLaunched() DESABILITADA - ciclo/cavidade não é mais obrigatório
    function validateCycleCavityLaunched() {
        // Sempre retorna true - validação desabilitada por solicitação do usuário
        return true;
    }

    //  POKA-YOKE: Verificar se existe OP ativa para a máquina atual
    function isOrderActiveForCurrentMachine() {
        if (!currentActiveOrder || !currentActiveOrder.id) {
            return false;
        }
        const status = String(currentActiveOrder.status || '').toLowerCase();
        return status === 'ativa' || status === 'em_andamento';
    }


    async function handleQuickProductionSubmit(e) {
        e.preventDefault();
        e.stopPropagation();

        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }


        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }

        if (!window.authSystem.checkPermissionForAction('add_production')) {
            showNotification('Permissão negada para registrar produção', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }

        const qtyInput = document.getElementById('quick-production-qty');
        const weightInput = document.getElementById('quick-production-weight');
        const obsInput = document.getElementById('quick-production-obs');
        const useTareCheckbox = document.getElementById('quick-production-use-tare');

        const quantityValue = parseInt(qtyInput?.value || '0', 10);
        const rawWeightGrams = parseWeightInputToGrams(weightInput?.value || '');
        let netWeightGrams = rawWeightGrams;
        const observations = (obsInput?.value || '').trim();

        const hasQty = Number.isFinite(quantityValue) && quantityValue > 0;

        if (useTareCheckbox?.checked && rawWeightGrams > 0) {
            const tareWeight = getTareWeightForMachine(selectedMachineData?.machine);
            if (tareWeight > 0) {
                netWeightGrams = Math.max(0, rawWeightGrams - tareWeight);
            }
        }

        const hasWeight = netWeightGrams > 0;

        if (!hasQty && !hasWeight) {
            showNotification('Informe quantidade OU peso', 'warning');
            return;
        }

        try {
            const planId = selectedMachineData?.id || null;
            if (!planId) {
                showNotification('Não foi possível identificar o planejamento', 'error');
                return;
            }

            const turno = getCurrentShift();
            const currentUser = getActiveUser();

            let resolvedQuantity = hasQty ? quantityValue : 0;
            if (!hasQty && hasWeight) {
                const pieceWeightGrams = getActivePieceWeightGrams();
                if (pieceWeightGrams <= 0) {
                    showNotification('Peso médio da peça não encontrado. Informe quantidade ou cadastre o peso da peça.', 'warning');
                    return;
                }
                const conversion = calculateQuantityFromGrams(netWeightGrams, pieceWeightGrams);
                if (conversion.error || conversion.quantity <= 0) {
                    showNotification('Não foi possível converter o peso em peças. Verifique o valor informado.', 'warning');
                    return;
                }
                resolvedQuantity = conversion.quantity;
            }

            const netWeightKg = hasWeight ? Number(gramsToKg(netWeightGrams).toFixed(3)) : 0;

            const payloadBase = {
                planId,
                data: getProductionDateString(),
                turno,
                produzido: resolvedQuantity,
                peso_bruto: netWeightKg,
                refugo_kg: 0,
                perdas: '',
                observacoes: observations,
                machine: selectedMachineData.machine || null,
                mp: selectedMachineData.mp || '',
                orderId: selectedMachineData.order_id || null,
                manual: false,
                registradoPor: currentUser?.username || null,
                registradoPorNome: getCurrentUserName()
            };

            await db.collection('production_entries').add({
                ...payloadBase,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // CRÍTICO: Atualizar total_produzido na OP vinculada e no planejamento
            const linkedOrderId = selectedMachineData.order_id || selectedMachineData.orderId;
            if (linkedOrderId && resolvedQuantity > 0) {
                try {
                    const orderRef = db.collection('production_orders').doc(linkedOrderId);
                    const orderSnap = await orderRef.get();
                    if (orderSnap.exists) {
                        const orderData = orderSnap.data() || {};
                        const currentTotal = coerceToNumber(orderData.total_produzido ?? orderData.totalProduced, 0);
                        const newTotal = currentTotal + resolvedQuantity;
                        await orderRef.update({
                            total_produzido: newTotal,
                            totalProduced: newTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-ORDER] OP ${linkedOrderId} atualizada: total_produzido ${currentTotal} → ${newTotal}`);
                    }
                } catch (orderErr) {
                    console.warn('[SYNC-ORDER] Falha ao atualizar total da OP:', orderErr);
                }
            }

            // Atualizar total_produzido no planejamento também
            if (planId && resolvedQuantity > 0) {
                try {
                    const planRef = db.collection('planning').doc(planId);
                    const planSnap = await planRef.get();
                    if (planSnap.exists) {
                        const planData = planSnap.data() || {};
                        const currentPlanTotal = coerceToNumber(planData.total_produzido, 0);
                        const newPlanTotal = currentPlanTotal + resolvedQuantity;
                        await planRef.update({
                            total_produzido: newPlanTotal,
                            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                        });
                        console.log(`[SYNC-PLAN] Plano ${planId} atualizado: total_produzido ${currentPlanTotal} → ${newPlanTotal}`);
                    }
                } catch (planErr) {
                    console.warn('[SYNC-PLAN] Falha ao atualizar total do plano:', planErr);
                }
            }

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('producao', `Produção rápida: ${resolvedQuantity} peças`, {
                    quantidade: resolvedQuantity,
                    maquina: selectedMachineData.machine,
                    op: linkedOrderId || planId,
                    turno: turno,
                    data: getProductionDateString(),
                    peso: netWeightKg
                });
            }

            closeModal('quick-production-modal');
            await populateMachineSelector();
            await refreshLaunchCharts();
            await loadTodayStats();
            await loadRecentEntries(false);

            showNotification('✅ Produção rápida registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar produção rápida:', error);
            showNotification('❌ Erro ao registrar produção: ' + error.message, 'error');
        }
    }

    async function handleManualLossesSubmit(e) {
        e.preventDefault();
        e.stopPropagation();

        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!isOrderActiveForCurrentMachine()) {
            showNotification('⚠️ Ative uma OP antes de fazer lançamentos. Vá em "Ordens" e clique em "Ativar" na OP desejada.', 'warning');
            return;
        }


        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }

        if (!window.authSystem.checkPermissionForAction('add_losses')) {
            showNotification('Permissão negada para registrar perdas', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }

        const dateInput = document.getElementById('manual-losses-date');
        const shiftSelect = document.getElementById('manual-losses-shift');
        const hourInput = document.getElementById('manual-losses-hour');
        const qtyInput = document.getElementById('manual-losses-qty');
        const weightInput = document.getElementById('manual-losses-weight');
        const reasonSelect = document.getElementById('manual-losses-reason');
        const obsInput = document.getElementById('manual-losses-obs');

        const dateValue = (dateInput?.value || '').trim();
        const shiftRaw = shiftSelect?.value || '';
        const hourValue = (hourInput?.value || '').trim();
        const quantityValue = parseInt(qtyInput?.value || '0', 10);
        const weightValueKg = parseFloat(weightInput?.value || '0');
        let netWeightGrams = kgToGrams(weightValueKg);
        const reasonValue = reasonSelect?.value || '';
        const observations = (obsInput?.value || '').trim();

        if (!dateValue) {
            showNotification('Informe a data da perda', 'warning');
            dateInput?.focus();
            return;
        }

        const hasQuantity = Number.isFinite(quantityValue) && quantityValue > 0;
        const hasWeight = netWeightGrams > 0;

        if (!hasQuantity && !hasWeight) {
            showNotification('Informe quantidade OU peso', 'warning');
            return;
        }

        if (!reasonValue) {
            showNotification('Selecione o motivo da perda', 'warning');
            reasonSelect?.focus();
            return;
        }

        try {
            const planId = selectedMachineData?.id || null;
            if (!planId) {
                showNotification('Não foi possível identificar o planejamento', 'error');
                return;
            }

            const pieceWeightGrams = getActivePieceWeightGrams();
            let refugoQty = hasQuantity ? quantityValue : 0;

            if (!hasQuantity && hasWeight) {
                if (pieceWeightGrams <= 0) {
                    showNotification('Peso médio da peça não encontrado. Informe a quantidade manualmente ou cadastre o peso no planejamento.', 'warning');
                    qtyInput?.focus();
                    return;
                }
                const conversion = calculateQuantityFromGrams(netWeightGrams, pieceWeightGrams);
                refugoQty = conversion.quantity > 0 ? conversion.quantity : 1;
            }

            if (refugoQty <= 0) {
                showNotification('Não foi possível determinar a quantidade de perdas.', 'warning');
                return;
            }

            let pesoTotalKg = hasWeight ? gramsToKg(netWeightGrams) : 0;
            if (pesoTotalKg <= 0 && pieceWeightGrams > 0) {
                pesoTotalKg = (refugoQty * pieceWeightGrams) / 1000;
            }
            pesoTotalKg = Number(pesoTotalKg.toFixed(3));

            const shiftNumeric = parseInt(shiftRaw, 10);
            const turno = [1, 2, 3].includes(shiftNumeric) ? shiftNumeric : getCurrentShift();
            const currentUser = getActiveUser();

            const payloadBase = {
                planId,
                data: dateValue,
                turno,
                produzido: 0,
                peso_bruto: 0,
                refugo_kg: Number.isFinite(pesoTotalKg) && pesoTotalKg > 0 ? Number(pesoTotalKg) : 0,
                refugo_qty: refugoQty,
                perdas: reasonValue,
                observacoes: observations,
                machine: selectedMachineData.machine || null,
                mp: selectedMachineData.mp || '',
                orderId: selectedMachineData.order_id || null,
                manual: true,
                horaInformada: hourValue || null,
                registradoPor: currentUser?.username || null,
                registradoPorNome: getCurrentUserName()
            };

            await db.collection('production_entries').add({
                ...payloadBase,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('perda', `Perda manual: ${payloadBase.refugo_qty || 0} peças (${payloadBase.refugo_kg || 0}kg)`, {
                    quantidade: payloadBase.refugo_qty,
                    pesoKg: payloadBase.refugo_kg,
                    maquina: selectedMachineData?.machine,
                    motivo: payloadBase.perdas,
                    turno: payloadBase.turno,
                    data: payloadBase.data
                });
            }

            closeModal('manual-losses-modal');
            await populateMachineSelector();
            await refreshLaunchCharts();
            await loadTodayStats();
            await loadRecentEntries(false);

            showNotification('✅ Perda manual registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar perda:', error);
            showNotification('❌ Erro ao registrar perda: ' + error.message, 'error');
        }
    }
    
    // Helper: Converte string com vírgula ou ponto em número, normalizando para locale pt-BR
    function parseNumberPtBR(str) {
        if (!str) return 0;
        str = String(str).trim();
        // Remover espaços
        str = str.replace(/\s/g, '');
        // Se tem ambos vírgula e ponto, considerar o último como separador decimal
        const lastComma = str.lastIndexOf(',');
        const lastDot = str.lastIndexOf('.');
        let normalized = str;
        
        if (lastComma > lastDot) {
            // Vírgula é o separador decimal: "1.234,56" → "1234.56"
            normalized = str.replace(/\./g, '').replace(',', '.');
        } else if (lastDot > lastComma) {
            // Ponto é o separador decimal: "1,234.56" ou "1.23" → mantém "1.23"
            normalized = str.replace(/,/g, '');
        } else if (lastComma >= 0) {
            // Só tem vírgula: "1,50" → "1.50"
            normalized = str.replace(',', '.');
        }
        // Caso contrário (só números ou só ponto): mantém como está
        
        const result = parseFloat(normalized) || 0;
        console.log(`[TRACE][parseNumberPtBR] Input: "${str}" → Normalized: "${normalized}" → Result: ${result}`);
        return result;
    }

    async function handleLossesSubmit(e) {
        e.preventDefault();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }

        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('add_losses')) {
            return;
        }
        
        console.log('[TRACE][handleLossesSubmit] triggered', {
            selectedMachineData,
            currentEditContext
        });

        const quantityInput = document.getElementById('quick-losses-qty');
        const weightInput = document.getElementById('quick-losses-weight');
        const quantity = parseInt(quantityInput.value, 10) || 0;
        // Entrada agora é em GRAMAS diretamente (não mais em kg)
        let weightGrams = parseInt(weightInput.value, 10) || 0;
        const reason = document.getElementById('quick-losses-reason').value;
        const obs = (document.getElementById('quick-losses-obs').value || '').trim();
        
        // Verificar se deve aplicar tara da caixa plástica
        const useTare = document.getElementById('quick-losses-use-tare').checked;
        if (useTare && weightGrams > 0) {
            const tareWeight = getTareWeightForMachine(selectedMachineData?.machine);
            if (tareWeight > 0) {
                weightGrams = Math.max(0, weightGrams - tareWeight);
                console.log(`[TRACE][handleLossesSubmit] Tara aplicada: ${tareWeight}g descontados. Peso líquido: ${weightGrams}g`);
            }
        }

        console.log('[TRACE][handleLossesSubmit] parsed form values', { quantity, weightGrams, reason, obs, useTare });

        if (quantity <= 0 && weightGrams <= 0) {
            alert('Informe a quantidade ou o peso da perda.');
            if (quantityInput) quantityInput.focus();
            else if (weightInput) weightInput.focus();
            return;
        }

        if (!reason) {
            alert('Por favor, selecione o motivo da perda.');
            return;
        }

        // ========================================
        // CONVERSÃO DE PESO PARA PEÇAS
        // ========================================
        let refugoQty = quantity > 0 ? quantity : 0;
        const pieceWeightGrams = getActivePieceWeightGrams();

        if (refugoQty <= 0 && weightGrams > 0) {
            if (pieceWeightGrams <= 0) {
                alert('Não foi possível converter peso para peças. O peso médio da peça não está configurado. Informe a quantidade diretamente.');
                console.warn('[TRACE][handleLossesSubmit] Peso médio não encontrado: selectedMachineData =', selectedMachineData);
                return;
            }
            const conversion = calculateQuantityFromGrams(weightGrams, pieceWeightGrams);
            refugoQty = conversion.quantity > 0 ? conversion.quantity : 1;
            console.log(`[TRACE][handleLossesSubmit] Conversão: ${weightGrams}g  /  ${pieceWeightGrams}g/peça = ${refugoQty} peças`);
            showNotification(`Convertido: ${weightGrams}g = ${refugoQty} peças`, 'info');
        }
        
        console.log('[TRACE][handleLossesSubmit] Perda em peças:', { quantity, weightGrams, refugoQty, pesoMedio: weightGrams > 0 ? (weightGrams / Math.max(refugoQty, 1)) : 0 });

        const isEditing = currentEditContext && currentEditContext.type === 'loss' && currentEditContext.id;
        const originalData = isEditing ? currentEditContext.original : null;

        console.log('[TRACE][handleLossesSubmit] context info', { isEditing, originalData });

        const fallbackPlan = selectedMachineData ? selectedMachineData.id : originalData?.planId;
        const planId = isEditing ? (originalData?.planId || fallbackPlan) : fallbackPlan;

        console.log('[TRACE][handleLossesSubmit] resolved plan', { fallbackPlan, planId });

        if (!planId) {
            alert('Não foi possível identificar o planejamento associado ao lançamento.');
            return;
        }

        const currentShift = getCurrentShift();
        const turno = isEditing ? (originalData?.turno || currentShift) : currentShift;
        const dataReferencia = isEditing ? (originalData?.data || getProductionDateString()) : getProductionDateString();
        const machineRef = isEditing ? (originalData?.machine || selectedMachineData?.machine) : selectedMachineData?.machine;
        const mpValue = isEditing ? (originalData?.mp || selectedMachineData?.mp || '') : (selectedMachineData?.mp || '');

        // Calcular peso total se necessário (peças  x  peso médio)
        let pesoTotalKg = weightGrams > 0 ? gramsToKg(weightGrams) : 0;
        if (pesoTotalKg <= 0 && refugoQty > 0 && pieceWeightGrams > 0) {
            pesoTotalKg = (refugoQty * pieceWeightGrams) / 1000;
        }
        pesoTotalKg = Number(pesoTotalKg.toFixed(3));

        const payloadBase = {
            planId,
            data: dataReferencia,
            turno,
            produzido: 0,
            peso_bruto: 0,
            refugo_kg: pesoTotalKg,
            refugo_qty: refugoQty,  // SEMPRE em peças
            perdas: reason,
            observacoes: obs,
            machine: machineRef || null,
            mp: mpValue,
            orderId: selectedMachineData?.order_id || null,
            orderNumber: selectedMachineData?.order_number || null
        };

        console.log('[TRACE][handleLossesSubmit] payloadBase prepared', payloadBase);

        const collectionRef = db.collection('production_entries');
        const successMessage = isEditing ? 'Perda atualizada com sucesso!' : 'Perda registrada com sucesso!';

        try {
            if (isEditing) {
                console.log('[TRACE][handleLossesSubmit] updating existing entry', currentEditContext.id);
                await collectionRef.doc(currentEditContext.id).update({
                    ...payloadBase,
                    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            } else {
                console.log('[TRACE][handleLossesSubmit] creating new entry');
                await collectionRef.add({
                    ...payloadBase,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            }

            closeModal('quick-losses-modal');
            await populateMachineSelector();
            
            // Atualizar selectedMachineData com os dados mais recentes
            if (selectedMachineData && selectedMachineData.machine && machineCardData[selectedMachineData.machine]) {
                selectedMachineData = machineCardData[selectedMachineData.machine];
                updateMachineInfo();
                updateQuickProductionPieceWeightUI();
            }
            
            await loadTodayStats();
            await loadHourlyProductionChart();
            await loadRecentEntries(false);
            // Atualizar aba de análise se estiver aberta
            await refreshAnalysisIfActive();
            showNotification(successMessage, 'success');
            
            // Registrar log
            registrarLogSistema(isEditing ? 'EDIÇÃO DE PERDA' : 'LANÇAMENTO DE PERDA', 'perda', {
                machine: machineRef,
                refugoQty: refugoQty,
                pesoKg: pesoTotalKg,
                motivo: reason,
                observacoes: obs
            });

            console.log('[TRACE][handleLossesSubmit] success path completed');
        } catch (error) {
            console.error('Erro ao registrar perda: ', error);
            alert('Erro ao registrar perda. Tente novamente.');
        }
    }
    
    /**
     * Handler robusto para finalização de parada (quando usuário clica START)
     * Segmenta paradas longas por turno e salva cada segmento individualmente
     */
    async function handleDowntimeSubmit(e) {
        e.preventDefault();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!validateOrderActivated()) {
            return;
        }

        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('add_downtime')) {
            return;
        }
        
        console.log('[DOWNTIME][SUBMIT] Iniciando finalização de parada', {
            selectedMachineData,
            currentDowntimeStart,
            machineStatus
        });

        const reason = document.getElementById('quick-downtime-reason').value;
        const obs = (document.getElementById('quick-downtime-obs').value || '').trim();
        
        console.log('[DOWNTIME][SUBMIT] Valores do formulário:', { reason, obs });

        if (!reason) {
            alert('Por favor, selecione o motivo da parada.');
            return;
        }

        if (!currentDowntimeStart) {
            console.warn('[DOWNTIME][SUBMIT] Nenhuma parada ativa encontrada');
            alert('Nenhuma parada ativa para finalizar.');
            closeModal('quick-downtime-modal');
            // Garante que o status da máquina volte para running e a UI seja atualizada
            machineStatus = 'running';
            updateMachineStatus();
            resumeProductionTimer();
            stopDowntimeTimer();
            await loadTodayStats();
            await loadRecentEntries(false);
            await refreshAnalysisIfActive();
            return;
        }
        
        let erroFinal = null;
        let savedSegments = 0;
        
        try {
            const now = new Date();
            const endShift = getShiftForDateTime(now);
            const endWorkday = getWorkdayForDateTime(now);
            
            // Reconstruir data de início a partir dos dados salvos
            let startDateTime;
            if (currentDowntimeStart.startTimestamp instanceof Date) {
                startDateTime = currentDowntimeStart.startTimestamp;
            } else if (currentDowntimeStart.startTimestampLocal) {
                startDateTime = new Date(currentDowntimeStart.startTimestampLocal);
            } else {
                // Fallback: reconstruir a partir de date + startTime
                startDateTime = parseDateTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            }
            
            if (!startDateTime || isNaN(startDateTime.getTime())) {
                console.error('[DOWNTIME][SUBMIT] Data de início inválida:', currentDowntimeStart);
                alert('Erro: Data de início da parada inválida. Registre manualmente.');
                return;
            }
            
            const startDateStr = formatDateYMD(startDateTime);
            const startTimeStr = formatTimeHM(startDateTime);
            const endDateStr = formatDateYMD(now);
            const endTimeStr = formatTimeHM(now);
            
            // Calcular duração total para log
            const totalDurationMs = now.getTime() - startDateTime.getTime();
            const totalDurationMin = Math.round(totalDurationMs / 60000);
            const totalDurationHours = (totalDurationMs / 3600000).toFixed(2);
            
            console.log('[DOWNTIME][SUBMIT] Calculando segmentos:', {
                startDate: startDateStr,
                startTime: startTimeStr,
                endDate: endDateStr,
                endTime: endTimeStr,
                totalDurationMin,
                totalDurationHours: `${totalDurationHours}h`
            });
            
            // Segmentar a parada por turno
            const segments = splitDowntimeIntoShiftSegments(startDateStr, startTimeStr, endDateStr, endTimeStr);
            
            if (!segments.length) {
                console.error('[DOWNTIME][SUBMIT] Nenhum segmento gerado');
                alert('Intervalo de parada inválido. Verifique os horários ou registre manualmente.');
                return;
            }
            
            console.log('[DOWNTIME][SUBMIT] Segmentos a salvar:', segments.length, segments);
            
            const currentUser = getActiveUser();
            const batch = db.batch();
            
            for (const seg of segments) {
                const downtimeData = {
                    // Identificação
                    machine: currentDowntimeStart.machine,
                    
                    // Período
                    date: seg.date,
                    startTime: seg.startTime,
                    endTime: seg.endTime,
                    duration: seg.duration,
                    shift: seg.shift,
                    
                    // Motivo e observações
                    reason: reason,
                    observations: obs,
                    
                    // Contexto de produção (se disponível)
                    product: currentDowntimeStart.product || null,
                    productCod: currentDowntimeStart.productCod || null,
                    orderId: currentDowntimeStart.orderId || null,
                    orderNumber: currentDowntimeStart.orderNumber || null,
                    
                    // Metadados de registro
                    registradoPor: currentUser?.username || null,
                    registradoPorNome: getCurrentUserName(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    
                    // Metadados adicionais para auditoria
                    originalStartTimestamp: startDateTime.toISOString(),
                    originalEndTimestamp: now.toISOString(),
                    totalParentDuration: totalDurationMin,
                    segmentIndex: segments.indexOf(seg),
                    totalSegments: segments.length,
                    systemVersion: '2.0'
                };
                
                const docRef = db.collection('downtime_entries').doc();
                batch.set(docRef, downtimeData);
                savedSegments++;
                
                console.log(`[DOWNTIME][SUBMIT] Segmento ${savedSegments}/${segments.length} preparado:`, {
                    date: seg.date,
                    shift: seg.shift,
                    duration: seg.duration,
                    startTime: seg.startTime,
                    endTime: seg.endTime
                });
            }
            
            // Executar batch de salvamento
            await batch.commit();
            console.log(`[DOWNTIME][SUBMIT] ${savedSegments} segmentos salvos com sucesso`);
            
        } catch (error) {
            erroFinal = error;
            console.error('[DOWNTIME][SUBMIT] Erro ao registrar parada:', error);
            alert('Erro ao registrar parada. Tente novamente.');
        } finally {
            // Remover parada ativa dessa máquina (evita restauração automática na troca de máquina/reload)
            try {
                if (currentDowntimeStart?.machine) {
                    await db.collection('active_downtimes').doc(currentDowntimeStart.machine).delete();
                    console.log('[TRACE][handleDowntimeSubmit] active_downtime removed for machine', currentDowntimeStart.machine);
                }
            } catch (err) {
                console.warn('[WARN][handleDowntimeSubmit] failed to delete active_downtime doc', err);
            }
            // Resetar status e timers (sempre)
            currentDowntimeStart = null;
            machineStatus = 'running';
            updateMachineStatus();
            stopDowntimeTimer();
            resumeProductionTimer();
            closeModal('quick-downtime-modal');
            await loadTodayStats();
            await loadRecentEntries(false);
            await refreshAnalysisIfActive();
            if (!erroFinal) {
                showNotification('Parada finalizada e registrada com sucesso!', 'success');
                console.log('[TRACE][handleDowntimeSubmit] success path completed');
                
                // Registrar log de parada
                registrarLogSistema('REGISTRO DE PARADA', 'parada', {
                    machine: currentDowntimeStart?.machine || selectedMachineData?.machine,
                    motivo: document.getElementById('downtime-reason')?.value || '-',
                    duracao: downtimeElapsedSeconds ? Math.round(downtimeElapsedSeconds / 60) + ' min' : '-'
                });
            } else {
                showNotification('Parada finalizada localmente, mas houve erro ao registrar no banco.', 'warning');
            }
        }
    }

    async function handleManualBorraSubmit(e) {
        e.preventDefault();

        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!isOrderActiveForCurrentMachine()) {
            showNotification('⚠️ Ative uma OP antes de fazer lançamentos. Vá em "Ordens" e clique em "Ativar" na OP desejada.', 'warning');
            return;
        }


        if (!window.authSystem.checkPermissionForAction('add_losses')) {
            return;
        }

        if (!selectedMachineData) {
            alert('Nenhuma máquina selecionada. Selecione uma máquina para registrar a borra.');
            return;
        }

        const dateInput = document.getElementById('manual-borra-date');
        const shiftSelect = document.getElementById('manual-borra-shift');
        const hourInput = document.getElementById('manual-borra-hour');
        const machineSelect = document.getElementById('manual-borra-machine');
        const weightInput = document.getElementById('manual-borra-weight');
        const mpTypeSelect = document.getElementById('manual-borra-mp-type');
        const reasonInput = document.getElementById('manual-borra-reason');
        const obsInput = document.getElementById('manual-borra-obs');

        const dateValue = (dateInput?.value || '').trim();
        const shiftRaw = shiftSelect?.value || '';
        const hourValue = (hourInput?.value || '').trim();
    const machineValue = machineSelect?.value || '';
        // Entrada agora é em GRAMAS diretamente
        const weightGrams = parseInt(weightInput?.value || '0', 10);
        const weightKg = weightGrams / 1000; // Converter para kg para salvar
        const mpTypeValue = mpTypeSelect?.value || '';
        const reasonValue = (reasonInput?.value || '').trim();
        const observations = (obsInput?.value || '').trim();

        if (!dateValue) {
            alert('Informe a data de geração da borra.');
            if (dateInput) dateInput.focus();
            return;
        }

        if (!machineValue) {
            alert('Selecione a máquina que gerou a borra.');
            if (machineSelect) machineSelect.focus();
            return;
        }

        if (!Number.isFinite(weightGrams) || weightGrams <= 0) {
            alert('Informe o peso da borra em gramas (valor deve ser maior que zero).');
            if (weightInput) weightInput.focus();
            return;
        }

        if (!mpTypeValue) {
            alert('Selecione o tipo de matéria-prima da borra.');
            if (mpTypeSelect) mpTypeSelect.focus();
            return;
        }

        if (!reasonValue) {
            alert('Informe o motivo da geração da borra.');
            if (reasonInput) reasonInput.focus();
            return;
        }

        const statusDiv = document.getElementById('manual-borra-status');
        const submitButton = document.getElementById('manual-borra-save');

        try {
            if (statusDiv) statusDiv.textContent = 'Salvando borra...';
            if (submitButton) {
                submitButton.disabled = true;
                submitButton.textContent = 'Salvando...';
            }

            const currentUser = getActiveUser();
            const workDay = getWorkDayFromDate(dateValue, hourValue);
            const normalizedMachine = normalizeMachineId(machineValue || selectedMachineData.machine || '');
            const resolvedPlanId = selectedMachineData?.id || selectedMachineData?.planId || selectedMachineData?.planningRef || null;
            if (!resolvedPlanId) {
                console.warn('[WARN][handleManualBorraSubmit] planId não encontrado para BORRA, registro será salvo sem vínculo de plano.', {
                    selectedMachineData
                });
            }
            
            // Preparar dados da borra (salvar como perda especial)
            const borraData = {
                data: dateValue,
                workDay: workDay,
                machine: normalizedMachine,
                planId: resolvedPlanId || null,
                planningRef: resolvedPlanId || null,
                refugo_kg: weightKg, // Salvar em kg (convertido de gramas)
                perdas: `BORRA - ${reasonValue}`,
                mp: '',
                mp_type: mpTypeValue,
                turno: parseInt(shiftRaw, 10) || 1,
                horaInformada: hourValue || null,
                observacoes: observations || '',
                tipo_lancamento: 'borra', // Identificador especial
                planningRef: selectedMachineData.id,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                createdBy: currentUser.username || 'sistema',
                createdByName: currentUser.name || 'Sistema'
            };

            console.log('[TRACE][handleManualBorraSubmit] prepared borra data', borraData);

            // Salvar na coleção production_entries (como outras perdas)
            const docRef = await db.collection('production_entries').add(borraData);
            
            console.log('[TRACE][handleManualBorraSubmit] borra saved successfully', { docId: docRef.id });

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('perda', `Borra registrada: ${weightKg.toFixed(3)}kg`, {
                    pesoKg: weightKg,
                    pesoGramas: weightGrams,
                    maquina: normalizedMachine,
                    motivo: reasonValue,
                    tipoMp: mpTypeValue,
                    turno: borraData.turno,
                    data: dateValue
                });
            }

            if (statusDiv) statusDiv.textContent = 'Borra registrada com sucesso!';
            showNotification(`Borra de ${weightGrams}g (${weightKg.toFixed(3)}kg) registrada com sucesso!`, 'success');

            // Fechar modal e atualizar dados
            setTimeout(() => {
                closeModal('manual-borra-modal');
                if (typeof updateOverviewData === 'function') {
                    updateOverviewData();
                }
                if (typeof refreshRecentEntries === 'function') {
                    refreshRecentEntries();
                }
            }, 1500);

        } catch (error) {
            console.error('[ERROR][handleManualBorraSubmit] falha ao salvar borra', error);
            
            if (statusDiv) statusDiv.textContent = 'Erro ao registrar borra. Tente novamente.';
            showNotification('Erro ao registrar borra. Verifique os dados e tente novamente.', 'error');
        } finally {
            if (submitButton) {
                submitButton.disabled = false;
                submitButton.textContent = 'Registrar Borra';
            }
        }
    }
    
    // Função para lançamento manual de parada passada
    async function handleManualDowntimeSubmit(e) {
        e.preventDefault();
        e.stopPropagation();
        
        if (!window.authSystem || !window.authSystem.checkPermissionForAction) {
            showNotification('Erro de permissão', 'error');
            return;
        }

        if (!window.authSystem.checkPermissionForAction('add_downtime')) {
            showNotification('Permissão negada para registrar paradas', 'error');
            return;
        }

        if (!selectedMachineData) {
            showNotification('Selecione uma máquina', 'warning');
            return;
        }

        const dateStartInput = document.getElementById('manual-downtime-date-start');
        const dateEndInput = document.getElementById('manual-downtime-date-end');
        const startTimeInput = document.getElementById('manual-downtime-start');
        const endTimeInput = document.getElementById('manual-downtime-end');
        const reasonSelect = document.getElementById('manual-downtime-reason');
        const obsInput = document.getElementById('manual-downtime-obs');

        const dateStartStr = (dateStartInput?.value || '').trim();
        const dateEndStr = (dateEndInput?.value || '').trim();
        const startTime = (startTimeInput?.value || '').trim();
        const endTime = (endTimeInput?.value || '').trim();
        const reason = reasonSelect?.value || '';
        const obs = (obsInput?.value || '').trim();

        if (!dateStartStr || !startTime || !endTime || !reason) {
            showNotification('Preencha data inicial, horários e motivo', 'warning');
            return;
        }

        try {
            const todayStr = getProductionDateString();
            const finalDateEnd = dateEndStr || dateStartStr;

            // Validar coerência temporal
            const dtStart = new Date(`${dateStartStr}T${startTime}:00`);
            const dtEnd = new Date(`${finalDateEnd}T${endTime}:00`);
            
            if (Number.isNaN(dtStart.getTime()) || Number.isNaN(dtEnd.getTime()) || dtEnd <= dtStart) {
                showNotification('Intervalo de parada inválido', 'warning');
                return;
            }

            // Quebrar em segmentos por dia
            const segments = splitDowntimeIntoDailySegments(dateStartStr, startTime, finalDateEnd, endTime);
            if (!segments.length) {
                showNotification('Não foi possível processar o período informado', 'error');
                return;
            }

            // Persistir cada segmento
            const currentUser = getActiveUser();
            for (const seg of segments) {
                const downtimeData = {
                    machine: selectedMachineData.machine,
                    date: seg.date,
                    startTime: seg.startTime,
                    endTime: seg.endTime,
                    duration: seg.duration,
                    reason: reason,
                    observations: obs,
                    registradoPor: currentUser?.username || null,
                    registradoPorNome: getCurrentUserName(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                await db.collection('downtime_entries').add(downtimeData);
            }

            // Calcular duração total para o log
            const totalDuration = segments.reduce((sum, seg) => sum + (seg.duration || 0), 0);

            // Registrar no histórico do sistema
            if (typeof logSystemAction === 'function') {
                logSystemAction('parada', `Parada manual registrada: ${reason}`, {
                    maquina: selectedMachineData?.machine,
                    motivo: reason,
                    inicio: startTime,
                    fim: endTime,
                    duracao: totalDuration,
                    dataInicio: dateStartStr,
                    dataFim: finalDateEnd
                });
            }

            closeModal('manual-downtime-modal');
            await loadTodayStats();
            await loadRecentEntries(false);

            showNotification('✅ Parada manual registrada com sucesso!', 'success');
        } catch (error) {
            console.error('Erro ao registrar parada:', error);
            showNotification('❌ Erro ao registrar parada: ' + error.message, 'error');
        }
    }
    
    async function finishDowntime() {
        try {
            console.log('[TRACE][finishDowntime] invoked', { currentDowntimeStart, machineStatus });
            if (!currentDowntimeStart) {
                console.warn('Nenhuma parada ativa para finalizar.');
                return;
            }

            const now = new Date();
            const endTime = now.toTimeString().substr(0, 5);

            const startDateStr = currentDowntimeStart.date || formatDateYMD(currentDowntimeStart.startTimestamp || now);
            const endDateStr = formatDateYMD(now);

            const segments = splitDowntimeIntoDailySegments(startDateStr, currentDowntimeStart.startTime, endDateStr, endTime);
            console.log('[TRACE][finishDowntime] segments', segments);

            if (!segments.length) {
                // fallback simples
                const downtimeData = {
                    ...currentDowntimeStart,
                    endTime,
                    duration: 1,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                await db.collection('downtime_entries').add(downtimeData);
            } else {
                for (const seg of segments) {
                    const downtimeData = {
                        machine: currentDowntimeStart.machine,
                        date: seg.date,
                        startTime: seg.startTime,
                        endTime: seg.endTime,
                        duration: seg.duration,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp()
                    };
                    await db.collection('downtime_entries').add(downtimeData);
                }
            }
            
            // Remover parada ativa do Firebase
            try {
                await db.collection('active_downtimes').doc(currentDowntimeStart.machine).delete();
                console.log('[TRACE] Parada ativa removida do Firebase');
            } catch (error) {
                console.error('Erro ao remover parada ativa do Firebase:', error);
            }
            
            // Resetar status
            currentDowntimeStart = null;
            machineStatus = 'running';
            updateMachineStatus();
            stopDowntimeTimer();
            resumeProductionTimer();
            
            loadTodayStats();
            await loadRecentEntries(false);
            
            // Mostrar sucesso
            showNotification('Parada finalizada!', 'success');

            console.log('[TRACE][finishDowntime] successfully persisted and reset state');
            
        } catch (error) {
            console.error("Erro ao finalizar parada: ", error);
            alert('Erro ao finalizar parada. Tente novamente.');
        }
    }
    
    // Handler para registrar retrabalho
    async function handleReworkSubmit(e) {
        e.preventDefault();
        
        // ✅ POKA-YOKE: Bloquear lançamento se OP não estiver ativada
        if (!isOrderActiveForCurrentMachine()) {
            showNotification('⚠️ Ative uma OP antes de fazer lançamentos. Vá em "Ordens" e clique em "Ativar" na OP desejada.', 'warning');
            return;
        }

        
        // Verificar permissão
        if (!window.authSystem.checkPermissionForAction('add_rework')) {
            return;
        }
        
        console.log('[TRACE][handleReworkSubmit] triggered', { selectedMachineData });

        if (!selectedMachineData) {
            alert('Nenhuma máquina selecionada. Selecione uma máquina para registrar o retrabalho.');
            return;
        }

        const qtyInput = document.getElementById('quick-rework-qty');
        const weightInput = document.getElementById('quick-rework-weight');
        const reasonSelect = document.getElementById('quick-rework-reason');
        const obsInput = document.getElementById('quick-rework-obs');

        const quantity = parseInt(qtyInput?.value, 10) || 0;
        const weight = parseFloat(weightInput?.value) || 0;
        const reason = reasonSelect?.value || '';
        const observations = (obsInput?.value || '').trim();

        if (quantity <= 0) {
            alert('Informe uma quantidade válida de peças para retrabalho.');
            if (qtyInput) qtyInput.focus();
            return;
        }

        if (!reason) {
            alert('Selecione o motivo do retrabalho.');
            if (reasonSelect) reasonSelect.focus();
            return;
        }

        const planId = selectedMachineData?.id || null;
        if (!planId) {
            alert('Não foi possível identificar o planejamento associado a esta máquina.');
            return;
        }

        const currentShift = getCurrentShift();
        const dataReferencia = getProductionDateString();
        const currentUser = getActiveUser();

        console.log('[TRACE][handleReworkSubmit] starting rework submission');

        try {
            const machineId = selectedMachineData.machine || '';
            const shiftKey = `T${currentShift}`;
            const productionDocsMap = new Map();
            const dateFields = ['data', 'workDay'];
            const shiftVariants = [currentShift, shiftKey, String(currentShift)];

            for (const field of dateFields) {
                for (const shiftVariant of shiftVariants) {
                    try {
                        const snapshot = await db.collection('production_entries')
                            .where('machine', '==', machineId)
                            .where(field, '==', dataReferencia)
                            .where('turno', '==', shiftVariant)
                            .get();

                        if (!snapshot.empty) {
                            console.log(`[TRACE][handleReworkSubmit] found ${snapshot.size} production entries via ${field}/${shiftVariant}`);
                            snapshot.docs.forEach((doc) => productionDocsMap.set(doc.id, doc));
                        }
                    } catch (queryError) {
                        console.warn(`[TRACE][handleReworkSubmit] query failed for ${field}/${shiftVariant}`, queryError);
                    }
                }
            }

            const productionDocs = Array.from(productionDocsMap.values());
            console.log(`[TRACE][handleReworkSubmit] total candidate production docs: ${productionDocs.length}`);

            const transactionResult = await db.runTransaction(async (transaction) => {
                const reworkRef = db.collection('rework_entries').doc();
                let totalDeducted = 0;
                let adjustedDocs = 0;

                for (const doc of productionDocs) {
                    const freshSnapshot = await transaction.get(doc.ref);
                    if (!freshSnapshot.exists) {
                        console.warn(`[TRACE][handleReworkSubmit] skipping missing production doc ${doc.id}`);
                        continue;
                    }

                    const prodData = freshSnapshot.data() || {};
                    const docShiftKey = normalizeShiftValue(prodData.turno);
                    if (docShiftKey && docShiftKey !== shiftKey) {
                        console.log(`[TRACE][handleReworkSubmit] skipping production doc ${doc.id} for shift ${docShiftKey}`);
                        continue;
                    }

                    const currentQty = Number(prodData.produzido ?? prodData.quantity ?? prodData.quantidade ?? 0) || 0;
                    if (currentQty <= 0) {
                        console.log(`[TRACE][handleReworkSubmit] skipping production doc ${doc.id} (current quantity <= 0)`);
                        continue;
                    }

                    const newQty = Math.max(0, currentQty - quantity);
                    const deducted = currentQty - newQty;
                    if (deducted <= 0) {
                        console.log(`[TRACE][handleReworkSubmit] no deduction applied to doc ${doc.id} (current=${currentQty}, requested=${quantity})`);
                        continue;
                    }

                    totalDeducted += deducted;
                    adjustedDocs += 1;

                    const updatePayload = {
                        produzido: newQty,
                        updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                        lastAdjustment: {
                            type: 'rework_deduction',
                            requestedQty: quantity,
                            appliedQty: deducted,
                            previousQty: currentQty,
                            newQty,
                            shift: shiftKey,
                            reworkTurn: currentShift,
                            reworkWorkDay: dataReferencia,
                            adjustedBy: currentUser.username || currentUser.email || 'sistema',
                            adjustedByName: getCurrentUserName(),
                            adjustedAt: firebase.firestore.FieldValue.serverTimestamp(),
                            reason: reason,
                            observations: observations
                        }
                    };

                    const aliasFields = ['quantity', 'quantidade', 'executed', 'executedQty', 'executedQuantity', 'finalQuantity'];
                    aliasFields.forEach((field) => {
                        if (Object.prototype.hasOwnProperty.call(prodData, field)) {
                            updatePayload[field] = newQty;
                        }
                    });

                    transaction.update(doc.ref, updatePayload);
                    console.log(`[TRACE][handleReworkSubmit] adjusted production doc ${doc.id}: ${currentQty} -> ${newQty} (deducted ${deducted})`);
                }

                if (totalDeducted > 0) {
                    try {
                        const planRef = db.collection('planning').doc(planId);
                        const planSnapshot = await transaction.get(planRef);
                        if (planSnapshot.exists) {
                            const planData = planSnapshot.data() || {};
                            const planUpdate = {};
                            const planShiftData = planData[shiftKey];

                            if (planShiftData && typeof planShiftData === 'object') {
                                const planShiftCurrent = Number(planShiftData.produzido ?? planShiftData.quantity ?? planShiftData.quantidade ?? 0) || 0;
                                const planShiftNew = Math.max(0, planShiftCurrent - totalDeducted);
                                planUpdate[`${shiftKey}.produzido`] = planShiftNew;
                                if (Object.prototype.hasOwnProperty.call(planShiftData, 'quantity')) {
                                    planUpdate[`${shiftKey}.quantity`] = planShiftNew;
                                }
                                if (Object.prototype.hasOwnProperty.call(planShiftData, 'quantidade')) {
                                    planUpdate[`${shiftKey}.quantidade`] = planShiftNew;
                                }
                            }

                            ['total_produzido', 'totalProduced', 'executed_total', 'produzido_total'].forEach((field) => {
                                if (planData[field] !== undefined) {
                                    const currentTotal = Number(planData[field]) || 0;
                                    planUpdate[field] = Math.max(0, currentTotal - totalDeducted);
                                }
                            });

                            if (Object.keys(planUpdate).length > 0) {
                                planUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                                transaction.update(planRef, planUpdate);
                                console.log(`[TRACE][handleReworkSubmit] plan ${planId} updated (deducted ${totalDeducted})`);
                            }
                        }
                    } catch (planError) {
                        console.warn('[TRACE][handleReworkSubmit] failed to update plan totals during rework', planError);
                    }

                    const resolveOrderId = () => {
                        const candidates = [
                            selectedMachineData.order_id,
                            selectedMachineData.production_order_id,
                            selectedMachineData.production_order,
                            selectedMachineData.orderId
                        ];
                        for (const candidate of candidates) {
                            if (!candidate) continue;
                            const trimmed = String(candidate).trim();
                            if (trimmed) return trimmed;
                        }
                        return null;
                    };

                    const linkedOrderId = resolveOrderId();
                    if (linkedOrderId) {
                        try {
                            const orderRef = db.collection('production_orders').doc(linkedOrderId);
                            const orderSnapshot = await transaction.get(orderRef);
                            if (orderSnapshot.exists) {
                                const orderData = orderSnapshot.data() || {};
                                const orderUpdate = {};
                                const currentOrderTotal = Number(orderData.total_produzido ?? orderData.totalProduced ?? 0) || 0;
                                const newOrderTotal = Math.max(0, currentOrderTotal - totalDeducted);

                                if ('total_produzido' in orderData || !('totalProduced' in orderData)) {
                                    orderUpdate.total_produzido = newOrderTotal;
                                }
                                if ('totalProduced' in orderData) {
                                    orderUpdate.totalProduced = newOrderTotal;
                                }

                                if (orderData.last_progress && typeof orderData.last_progress === 'object') {
                                    const lastProgressExecuted = Number(orderData.last_progress.executed ?? orderData.last_progress.total ?? 0) || 0;
                                    const newLastExecuted = Math.max(0, lastProgressExecuted - totalDeducted);
                                    orderUpdate['last_progress.executed'] = newLastExecuted;
                                    orderUpdate['last_progress.updatedAt'] = firebase.firestore.FieldValue.serverTimestamp();
                                }

                                if (Object.keys(orderUpdate).length > 0) {
                                    orderUpdate.updatedAt = firebase.firestore.FieldValue.serverTimestamp();
                                    transaction.update(orderRef, orderUpdate);
                                    console.log(`[TRACE][handleReworkSubmit] production order ${linkedOrderId} updated (deducted ${totalDeducted})`);
                                }
                            }
                        } catch (orderError) {
                            console.warn('[TRACE][handleReworkSubmit] failed to update production order totals during rework', orderError);
                        }
                    }
                }

                const reworkData = {
                    planId,
                    data: dataReferencia,
                    turno: currentShift,
                    shiftKey,
                    quantidade: quantity,
                    appliedQuantity: totalDeducted,
                    documentosAjustados: adjustedDocs,
                    peso_kg: weight > 0 ? weight : null,
                    motivo: reason,
                    observacoes: observations,
                    machine: selectedMachineData.machine || null,
                    mp: selectedMachineData.mp || '',
                    registradoPor: currentUser.username || null,
                    registradoPorNome: getCurrentUserName(),
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };

                transaction.set(reworkRef, reworkData);
                console.log(`[TRACE][handleReworkSubmit] rework document prepared (adjustedDocs=${adjustedDocs}, totalDeducted=${totalDeducted})`);

                return { totalDeducted, adjustedDocs };
            });

            closeModal('quick-rework-modal');
            await populateMachineSelector();
            await Promise.all([
                loadTodayStats(),
                refreshLaunchCharts(),
                loadRecentEntries(false),
                refreshAnalysisIfActive()
            ]);

            if (transactionResult?.totalDeducted > 0) {
                showNotification('Retrabalho registrado e quantidade ajustada com sucesso!', 'success');
            } else {
                showNotification('Retrabalho registrado. Nenhum lançamento de produção foi ajustado para este turno.', 'warning');
            }
            
            // Registrar log de retrabalho
            registrarLogSistema('LANÇAMENTO DE RETRABALHO', 'retrabalho', {
                machine: selectedMachineData?.machine,
                quantidade: quantity,
                peso_kg: weight,
                motivo: reason,
                observacoes: observations
            });

            console.log('[TRACE][handleReworkSubmit] success path completed', transactionResult);
        } catch (error) {
            console.error('Erro ao registrar retrabalho:', error);
            alert('Erro ao registrar retrabalho. Tente novamente.');
        }
    }

    // Função utilitária para retry com backoff exponencial (para erros 429)
    async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 1000) {
        let lastError;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await fn();
            } catch (error) {
                lastError = error;
                const is429 = error.message?.includes('429') || error.code === 'resource-exhausted';
                if (!is429 || attempt === maxRetries) {
                    throw error;
                }
                const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 500;
                console.log(`[RETRY] Tentativa ${attempt + 1} falhou com 429, aguardando ${Math.round(delay)}ms...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        throw lastError;
    }
    
    // Funções auxiliares
    function getCurrentShift(reference = new Date()) {
        const hour = reference.getHours();
        
        if (hour >= 7 && hour < 15) {
            return 1; // 1º Turno
        } else if (hour >= 15 && hour < 23) {
            return 2; // 2º Turno
        } else {
            return 3; // 3º Turno
        }
    }

    function getShiftStartDateTime(reference = new Date()) {
        const shift = getCurrentShift(reference);
        const productionDay = getProductionDateString(reference);
        const shiftStartMap = {
            1: '07:00',
            2: '15:00',
            3: '23:20'
        };
        const startTime = shiftStartMap[shift] || '07:00';
        const startDate = combineDateAndTime(productionDay, startTime);
        if (startDate instanceof Date && !Number.isNaN(startDate.getTime())) {
            return startDate;
        }
        return null;
    }
    
    function updateMachineStatus() {
        // Notificação Web Push se máquina parada > 10 minutos
        if (machineStatus === 'stopped' && currentDowntimeStart) {
            const now = new Date();
            const startDateTime = combineDateAndTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            if (startDateTime instanceof Date && !Number.isNaN(startDateTime.getTime())) {
                const elapsedMs = now - startDateTime;
                if (elapsedMs > 10 * 60 * 1000 && !downtimeNotificationSent) {
                    sendDowntimeNotification();
                    downtimeNotificationSent = true;
                }
                if (elapsedMs <= 10 * 60 * 1000) {
                    downtimeNotificationSent = false;
                }
            }
        } else {
            downtimeNotificationSent = false;
        }
// Envia notificação Web Push se permitido
function sendDowntimeNotification() {
    if ('serviceWorker' in navigator && 'Notification' in window && Notification.permission === 'granted') {
        navigator.serviceWorker.getRegistration().then(function(reg) {
            if (reg) {
                reg.showNotification('Atenção: Máquina parada', {
                    body: 'Uma máquina está parada há mais de 10 minutos.',
                    icon: 'https://i.postimg.cc/5jdHwhF9/hokkaido-logo-110.png',
                    badge: 'https://i.postimg.cc/5jdHwhF9/hokkaido-logo-110.png',
                    data: '/'
                });
            }
        });
    }
}
    console.log('[DEBUG] updateMachineStatus: machineStatus=', machineStatus, 'currentDowntimeStart=', currentDowntimeStart);
    console.log('[DEBUG] toggleDowntime: chamado, machineStatus=', machineStatus, 'currentDowntimeStart=', currentDowntimeStart);
    console.log('[DEBUG] handleDowntimeSubmit: início, machineStatus=', machineStatus, 'currentDowntimeStart=', currentDowntimeStart);
        const btnDowntime = document.getElementById('btn-downtime');
        const downtimeIcon = document.getElementById('downtime-icon');
        const downtimeText = document.getElementById('downtime-text');
        const downtimeSubtitle = document.getElementById('downtime-subtitle');
        
        if (machineStatus === 'stopped') {
            // Máquina parada - mostrar botão START (verde)
            btnDowntime.classList.remove('from-red-500', 'to-red-600', 'hover:from-red-600', 'hover:to-red-700');
            btnDowntime.classList.add('from-green-500', 'to-green-600', 'hover:from-green-600', 'hover:to-green-700');
            downtimeIcon.setAttribute('data-lucide', 'play-circle');
            downtimeText.textContent = 'START';
            
            // Mostrar tempo da parada atual se disponível
            if (currentDowntimeStart) {
                const now = new Date();
                const startDateTime = combineDateAndTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
                if (startDateTime instanceof Date && !Number.isNaN(startDateTime.getTime())) {
                    const elapsedHours = ((now - startDateTime) / (1000 * 60 * 60)).toFixed(1);
                    downtimeSubtitle.textContent = `PARADA ATIVA - ${elapsedHours}h`;
                } else {
                    downtimeSubtitle.textContent = 'PARADA ATIVA - Retomar produção';
                }
            } else {
                downtimeSubtitle.textContent = 'Retomar produção';
            }
            
            downtimeSubtitle.classList.remove('text-red-100');
            downtimeSubtitle.classList.add('text-green-100');
        } else {
            // Máquina rodando - mostrar botão STOP (vermelho)
            btnDowntime.classList.remove('from-green-500', 'to-green-600', 'hover:from-green-600', 'hover:to-green-700');
            btnDowntime.classList.add('from-red-500', 'to-red-600', 'hover:from-red-600', 'hover:to-red-700');
            downtimeIcon.setAttribute('data-lucide', 'pause-circle');
            downtimeText.textContent = 'STOP';
            downtimeSubtitle.textContent = 'Parar máquina';
            downtimeSubtitle.classList.remove('text-green-100');
            downtimeSubtitle.classList.add('text-red-100');
        }
        
        lucide.createIcons();
    }
    
    /**
     * Timer visual de parada - atualiza a cada segundo
     * Usa múltiplas fontes de timestamp para robustez
     */
    function startDowntimeTimer() {
        const downtimeTimer = document.getElementById('downtime-timer');
        if (!downtimeTimer) return;
        
        downtimeTimer.classList.remove('hidden');
        
        const updateTimer = () => {
            if (!currentDowntimeStart) {
                downtimeTimer.textContent = '00:00:00';
                return;
            }
            
            const now = new Date();
            
            // Tentar obter o timestamp de início de múltiplas fontes
            let start = null;
            
            // Prioridade 1: Timestamp direto (objeto Date)
            if (currentDowntimeStart.startTimestamp instanceof Date && !isNaN(currentDowntimeStart.startTimestamp.getTime())) {
                start = currentDowntimeStart.startTimestamp;
            }
            // Prioridade 2: Timestamp ISO local
            else if (currentDowntimeStart.startTimestampLocal) {
                start = new Date(currentDowntimeStart.startTimestampLocal);
            }
            // Prioridade 3: Combinar data + hora
            else if (currentDowntimeStart.date && currentDowntimeStart.startTime) {
                start = parseDateTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            }
            // Prioridade 4: Fallback para combineDateAndTime
            else {
                start = combineDateAndTime(currentDowntimeStart.date, currentDowntimeStart.startTime);
            }
            
            if (!(start instanceof Date) || isNaN(start.getTime())) {
                downtimeTimer.textContent = '--:--:--';
                downtimeTimer.title = 'Erro ao calcular duração';
                return;
            }
            
            let diffMs = now.getTime() - start.getTime();
            if (diffMs < 0) diffMs = 0;
            
            const diffSec = Math.floor(diffMs / 1000);
            const days = Math.floor(diffSec / 86400);
            const hours = Math.floor((diffSec % 86400) / 3600);
            const minutes = Math.floor((diffSec % 3600) / 60);
            const seconds = diffSec % 60;
            
            // Formatar exibição baseada na duração
            let timeDisplay;
            if (days >= 1) {
                timeDisplay = `${days}d ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            } else {
                timeDisplay = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }
            downtimeTimer.textContent = timeDisplay;
            
            // Limpar classes anteriores
            downtimeTimer.classList.remove(
                'bg-red-300', 'bg-red-500', 'bg-orange-300', 'bg-yellow-300', 'bg-purple-300',
                'text-red-800', 'text-orange-800', 'text-yellow-800', 'text-purple-800', 'text-white',
                'animate-pulse'
            );
            
            // Alertas visuais baseados na duração
            const totalHours = diffMs / (1000 * 60 * 60);
            
            if (days >= 1) {
                // 1+ dia - Roxo/Crítico com animação
                downtimeTimer.classList.add('bg-purple-300', 'text-purple-800', 'animate-pulse');
                downtimeTimer.title = `⚠️ PARADA CRÍTICA: ${days} dia(s) e ${hours}h - Verificar urgentemente!`;
            } else if (totalHours >= 8) {
                // 8+ horas - Vermelho escuro (turno completo)
                downtimeTimer.classList.add('bg-red-500', 'text-white');
                downtimeTimer.title = `⚠️ Parada muito longa: ${hours}h${minutes}m - Atenção!`;
            } else if (totalHours >= 4) {
                // 4+ horas - Laranja
                downtimeTimer.classList.add('bg-orange-300', 'text-orange-800');
                downtimeTimer.title = `Parada longa: ${hours}h${minutes}m`;
            } else if (totalHours >= 1) {
                // 1+ hora - Amarelo
                downtimeTimer.classList.add('bg-yellow-300', 'text-yellow-800');
                downtimeTimer.title = `Parada em andamento: ${hours}h${minutes}m`;
            } else {
                // < 1 hora - Vermelho padrão
                downtimeTimer.classList.add('bg-red-300', 'text-red-800');
                downtimeTimer.title = `Parada ativa: ${timeDisplay}`;
            }
        };
        
        // Executar imediatamente e depois a cada segundo
        updateTimer();
        
        // Limpar intervalo anterior se existir
        if (downtimeTimer.interval) {
            clearInterval(downtimeTimer.interval);
        }
        downtimeTimer.interval = setInterval(updateTimer, 1000);
    }
    
    function stopDowntimeTimer() {
        const downtimeTimer = document.getElementById('downtime-timer');
        if (downtimeTimer) {
            downtimeTimer.classList.add('hidden');
            if (downtimeTimer.interval) {
                clearInterval(downtimeTimer.interval);
            }
        }
    }

    function formatSecondsToClock(totalSeconds) {
        const safeSeconds = Math.max(0, Math.floor(totalSeconds || 0));
        const hours = Math.floor(safeSeconds / 3600);
        const minutes = Math.floor((safeSeconds % 3600) / 60);
        const seconds = safeSeconds % 60;
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    }

    function updateProductionTimeDisplay(seconds) {
        if (!productionTimeDisplay) return;
        productionTimeDisplay.textContent = formatSecondsToClock(seconds);
    }

    function clearProductionTimerInterval() {
        if (productionTimer) {
            clearInterval(productionTimer);
            productionTimer = null;
        }
    }

    function resetProductionTimer() {
        productionTimerBaseSeconds = 0;
        productionTimerResumeTimestamp = null;
        clearProductionTimerInterval();
        updateProductionTimeDisplay(0);
    }

    function freezeProductionTimer() {
        if (productionTimerResumeTimestamp) {
            const elapsed = Math.floor((Date.now() - productionTimerResumeTimestamp) / 1000);
            productionTimerBaseSeconds += Math.max(elapsed, 0);
            productionTimerResumeTimestamp = null;
        }
        clearProductionTimerInterval();
        updateProductionTimeDisplay(productionTimerBaseSeconds);
    }

    function resumeProductionTimer() {
        if (productionTimerResumeTimestamp) {
            return;
        }
        productionTimerResumeTimestamp = Date.now();
        clearProductionTimerInterval();
        updateProductionTimeDisplay(productionTimerBaseSeconds);
        productionTimer = setInterval(() => {
            const elapsed = Math.floor((Date.now() - productionTimerResumeTimestamp) / 1000);
            updateProductionTimeDisplay(productionTimerBaseSeconds + Math.max(elapsed, 0));
        }, 1000);
    }

    function synchronizeProductionTimer(elapsedSeconds, shouldRun) {
        productionTimerBaseSeconds = Math.max(0, Math.floor(elapsedSeconds || 0));
        productionTimerResumeTimestamp = shouldRun ? Date.now() : null;
        clearProductionTimerInterval();
        updateProductionTimeDisplay(productionTimerBaseSeconds);

        if (!shouldRun) {
            return;
        }

        productionTimer = setInterval(() => {
            if (!productionTimerResumeTimestamp) {
                clearProductionTimerInterval();
                return;
            }
            const elapsed = Math.floor((Date.now() - productionTimerResumeTimestamp) / 1000);
            updateProductionTimeDisplay(productionTimerBaseSeconds + Math.max(elapsed, 0));
        }, 1000);
    }

    // Calcula o tempo de produção efetivo do turno atual desconsiderando paradas registradas.
    function calculateProductionRuntimeSeconds({ shiftStart, now, downtimes = [], activeDowntime = null }) {
        if (!(shiftStart instanceof Date) || Number.isNaN(shiftStart.getTime())) {
            return 0;
        }

        const referenceNow = now instanceof Date ? now : new Date();
        if (referenceNow <= shiftStart) {
            return 0;
        }

        const shiftStartMs = shiftStart.getTime();
        const nowMs = referenceNow.getTime();
        let downtimeMillis = 0;

        downtimes.forEach(dt => {
            if (!dt) return;
            const start = combineDateAndTime(dt.date, dt.startTime);
            const end = dt.endTime ? combineDateAndTime(dt.date, dt.endTime) : null;
            if (!(start instanceof Date) || Number.isNaN(start.getTime())) {
                return;
            }

            let effectiveEnd = end;
            if (!(effectiveEnd instanceof Date) || Number.isNaN(effectiveEnd.getTime()) || effectiveEnd <= start) {
                const durationMinutes = Number(dt.duration) || 0;
                effectiveEnd = new Date(start.getTime() + Math.max(durationMinutes, 0) * 60000);
            }

            const windowStart = Math.max(start.getTime(), shiftStartMs);
            const windowEnd = Math.min(effectiveEnd.getTime(), nowMs);
            if (windowEnd > windowStart) {
                downtimeMillis += windowEnd - windowStart;
            }
        });

        if (activeDowntime && activeDowntime.startTime && activeDowntime.date) {
            const activeStart = combineDateAndTime(activeDowntime.date, activeDowntime.startTime);
            if (activeStart instanceof Date && !Number.isNaN(activeStart.getTime())) {
                const windowStart = Math.max(activeStart.getTime(), shiftStartMs);
                if (nowMs > windowStart) {
                    downtimeMillis += nowMs - windowStart;
                }
            }
        }

        const elapsedMillis = nowMs - shiftStartMs;
        const runtimeMillis = Math.max(0, elapsedMillis - downtimeMillis);
        return Math.floor(runtimeMillis / 1000);
    }
    
    function setRecentEntriesState({ loading = false, empty = false }) {
        if (recentEntriesLoading) {
            recentEntriesLoading.classList.toggle('hidden', !loading);
        }
        if (recentEntriesEmpty) {
            recentEntriesEmpty.classList.toggle('hidden', !empty);
        }
        if (recentEntriesList) {
            recentEntriesList.classList.toggle('hidden', empty);
        }
    }

    function updateRecentEntriesEmptyMessage(message) {
        if (recentEntriesEmpty) {
            recentEntriesEmpty.innerHTML = `<p class="text-sm text-gray-500">${message}</p>`;
        }
    }

    function formatEntryTimestamp(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) return '';
        return new Intl.DateTimeFormat('pt-BR', {
            day: '2-digit',
            month: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
        }).format(date);
    }

    function buildRecentEntryMarkup(entry) {
        const typeConfig = {
            production: { label: 'Produção', badge: 'bg-green-100 text-green-700 border border-green-200' },
            loss: { label: 'Perda', badge: 'bg-orange-100 text-orange-700 border border-orange-200' },
            downtime: { label: 'Parada', badge: 'bg-red-100 text-red-700 border border-red-200' },
            rework: { label: 'Retrabalho', badge: 'bg-purple-100 text-purple-700 border border-purple-200' }
        };

        const config = typeConfig[entry.type] || { label: 'Lançamento', badge: 'bg-gray-100 text-gray-600 border border-gray-200' };
        const turnoLabel = entry.data.turno ? `Turno ${entry.data.turno}` : null;
        const timeLabel = formatEntryTimestamp(entry.timestamp);
        const registradoPorNome = entry.data.registradoPorNome || 'Desconhecido';
        const details = [];
        const parseNumber = (value) => {
            const parsed = parseOptionalNumber(value);
            return parsed !== null ? parsed : 0;
        };

        if (entry.data.mp) {
            details.push(`MP: ${entry.data.mp}`);
        }

        if (entry.type === 'production') {
            const produzido = parseInt(entry.data.produzido ?? entry.data.quantity ?? 0, 10) || 0;
            
            details.push(`<span class="font-semibold text-gray-800">${produzido} peça(s)</span>`);
            const pesoBruto = parseNumber(entry.data.peso_bruto ?? entry.data.weight ?? 0);
            if (pesoBruto > 0) {
                details.push(`${pesoBruto.toFixed(3)} kg`);
            }
        } else if (entry.type === 'loss') {
            const refugoKg = parseNumber(entry.data.refugo_kg ?? entry.data.weight ?? 0);
            const quantidade = parseInt(entry.data.quantidade ?? 0, 10) || 0;
            
            if (quantidade > 0) {
                details.push(`<span class="font-semibold text-gray-800">${quantidade} peça(s)</span>`);
            }
            if (refugoKg > 0) {
                details.push(`<span class="font-semibold text-gray-800">${refugoKg.toFixed(3)} kg</span>`);
            }
            if (entry.data.perdas || entry.data.motivo) {
                details.push(`Motivo: ${entry.data.perdas || entry.data.motivo}`);
            }
        } else if (entry.type === 'downtime') {
            const start = entry.data.startTime ? `${entry.data.startTime}` : '';
            const end = entry.data.endTime ? ` - ${entry.data.endTime}` : '';
            details.push(`Período: ${start}${end}`);
            
            // Calcular duração da parada
            if (entry.data.startTime && entry.data.endTime) {
                const [startHour, startMin] = entry.data.startTime.split(':').map(Number);
                const [endHour, endMin] = entry.data.endTime.split(':').map(Number);
                
                let startTotalMin = startHour * 60 + startMin;
                let endTotalMin = endHour * 60 + endMin;
                
                // Se fim é menor que inicio, passou da meia noite
                if (endTotalMin < startTotalMin) {
                    endTotalMin += 24 * 60;
                }
                
                const durationMin = endTotalMin - startTotalMin;
                const durationHours = Math.floor(durationMin / 60);
                const durationMins = durationMin % 60;
                
                let durationStr = '';
                if (durationHours > 0) {
                    durationStr = `${durationHours}h`;
                }
                if (durationMins > 0) {
                    durationStr += durationStr ? ` ${durationMins}min` : `${durationMins}min`;
                }
                if (durationMin === 0) {
                    durationStr = '0min';
                }
                
                details.push(`<span class="font-semibold text-red-600">⏱️ Duração: ${durationStr}</span>`);
            }
            
            if (entry.data.reason) {
                details.push(`Motivo: ${entry.data.reason}`);
            }
        } else if (entry.type === 'rework') {
            const quantidade = parseInt(entry.data.quantidade ?? entry.data.quantity ?? 0, 10) || 0;
            details.push(`<span class="font-semibold text-gray-800">${quantidade} peça(s)</span>`);
            const pesoKg = parseNumber(entry.data.peso_kg ?? entry.data.weight ?? 0);
            if (pesoKg > 0) {
                details.push(`${pesoKg.toFixed(3)} kg`);
            }
            if (entry.data.motivo) {
                details.push(`Motivo: ${entry.data.motivo}`);
            }
        }

        const observations = entry.data.observacoes || entry.data.observations || entry.data.notes;
        const canEdit = entry.type === 'production' || entry.type === 'loss';
        const actions = [];

        if (canEdit) {
            actions.push(`
                <button class="flex items-center gap-1 px-3 py-1.5 text-sm text-blue-600 border border-blue-200 rounded-lg hover:bg-blue-50"
                        data-action="edit" data-entry-id="${entry.id}" data-entry-type="${entry.type}">
                    <i data-lucide="pencil" class="w-4 h-4"></i>
                    Editar
                </button>
            `);
        }

        actions.push(`
            <button class="flex items-center gap-1 px-3 py-1.5 text-sm text-red-600 border border-red-200 rounded-lg hover:bg-red-50"
                    data-action="delete" data-entry-id="${entry.id}" data-entry-type="${entry.type}">
                <i data-lucide="trash-2" class="w-4 h-4"></i>
                Excluir
            </button>
        `);

        const metaChips = [config.label];
        if (turnoLabel) metaChips.push(turnoLabel);
        if (timeLabel) metaChips.push(timeLabel);

        return `
            <div class="border border-gray-200 rounded-lg p-4 bg-white shadow-sm">
                <div class="flex flex-col gap-3 md:flex-row md:items-start md:justify-between">
                    <div class="space-y-2 flex-1">
                        <div class="flex flex-wrap items-center gap-2 text-xs text-gray-500">
                            <span class="px-2 py-1 rounded-full ${config.badge}">${config.label}</span>
                            ${turnoLabel ? `<span class="px-2 py-1 rounded-full bg-gray-100 text-gray-600 border border-gray-200">${turnoLabel}</span>` : ''}
                            ${timeLabel ? `<span>${timeLabel}</span>` : ''}
                            <span class="px-2 py-1 rounded-full bg-blue-50 text-blue-600 border border-blue-200">👤 ${registradoPorNome}</span>
                        </div>
                        <div class="text-sm text-gray-700 space-x-2">
                            ${details.join('<span class="text-gray-300">–</span>')}
                        </div>
                        ${observations ? `<div class="text-xs text-gray-500">Obs.: ${observations}</div>` : ''}
                    </div>
                    <div class="flex items-center gap-2 flex-shrink-0">
                        ${actions.join('')}
                    </div>
                </div>
            </div>
        `;
    }

    function renderRecentEntries(entries) {
        if (!recentEntriesList) return;
        recentEntriesList.innerHTML = entries.map(buildRecentEntryMarkup).join('');
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }

    async function loadRecentEntries(showLoading = true, filterDate = null) {
        if (!recentEntriesList) return;

        if (showLoading) {
            setRecentEntriesState({ loading: true, empty: false });
        }

        if (!selectedMachineData) {
            recentEntriesCache = new Map();
            if (recentEntriesList) recentEntriesList.innerHTML = '';
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
            return;
        }

        try {
            const date = filterDate || window.lancamentoFilterDate || getProductionDateString();
            const planId = selectedMachineData.id;

            const productionSnapshot = await db.collection('production_entries')
                .where('planId', '==', planId)
                .where('data', '==', date)
                .get();

            const entries = [];
            recentEntriesCache = new Map();

            productionSnapshot.forEach(doc => {
                const data = doc.data();
                const type = (data.refugo_kg && data.refugo_kg > 0) || data.perdas ? 'loss' : 'production';
                const resolvedTimestamp = resolveProductionDateTime(data) || data.updatedAt?.toDate?.() || data.timestamp?.toDate?.() || data.createdAt?.toDate?.() || (data.datetime ? new Date(data.datetime) : null);

                const entry = {
                    id: doc.id,
                    type,
                    collection: 'production_entries',
                    data,
                    timestamp: resolvedTimestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });

            // Fallback: buscar lançamentos da máquina (ex. BORRA) que não possuem planId associado
            const machineId = normalizeMachineId(selectedMachineData.machine || '');
            if (machineId) {
                const machineSnapshot = await db.collection('production_entries')
                    .where('machine', '==', machineId)
                    .where('data', '==', date)
                    .get();

                machineSnapshot.forEach(doc => {
                    if (recentEntriesCache.has(doc.id)) return;
                    const data = doc.data();
                    const type = (data.refugo_kg && data.refugo_kg > 0) || data.perdas ? 'loss' : 'production';
                    const resolvedTimestamp = resolveProductionDateTime(data) || data.updatedAt?.toDate?.() || data.timestamp?.toDate?.() || data.createdAt?.toDate?.() || (data.datetime ? new Date(data.datetime) : null);

                    const entry = {
                        id: doc.id,
                        type,
                        collection: 'production_entries',
                        data,
                        timestamp: resolvedTimestamp
                    };

                    entries.push(entry);
                    recentEntriesCache.set(doc.id, entry);
                });
            }

            const downtimeSnapshot = await db.collection('downtime_entries')
                .where('machine', '==', selectedMachineData.machine)
                .where('date', '==', date)
                .get();

            downtimeSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || resolveProductionDateTime(data) || (data.startTime ? new Date(`${data.date}T${data.startTime}`) : null);

                const entry = {
                    id: doc.id,
                    type: 'downtime',
                    collection: 'downtime_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });

            const reworkSnapshot = await db.collection('rework_entries')
                .where('planId', '==', planId)
                .where('data', '==', date)
                .get();

            reworkSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || (data.data ? new Date(`${data.data}T12:00:00`) : null);

                const entry = {
                    id: doc.id,
                    type: 'rework',
                    collection: 'rework_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });

            entries.sort((a, b) => {
                const timeA = a.timestamp instanceof Date ? a.timestamp.getTime() : 0;
                const timeB = b.timestamp instanceof Date ? b.timestamp.getTime() : 0;
                return timeB - timeA;
            });

            // Armazenar todas as entradas para filtro
            allRecentEntries = entries;

            if (!entries.length) {
                updateRecentEntriesEmptyMessage('Ainda não há lançamentos para esta máquina.');
                setRecentEntriesState({ loading: false, empty: true });
            } else {
                applyEntryFilter(currentEntryFilter);
                setRecentEntriesState({ loading: false, empty: false });
            }
        } catch (error) {
            console.error('Erro ao carregar lançamentos recentes: ', error);
            updateRecentEntriesEmptyMessage('Não foi possível carregar os lançamentos. Tente novamente.');
            setRecentEntriesState({ loading: false, empty: true });
        }
    }

    function refreshRecentEntries(showLoading = false) {
        loadRecentEntries(showLoading);
    }
    window.refreshRecentEntries = refreshRecentEntries;

    // Funções auxiliares para indicador de data de lançamentos
    // Funções auxiliares para indicador de filtros de lançamentos
    function updateEntriesFilterIndicator() {
        const indicator = document.getElementById('entries-filter-indicator');
        const display = document.getElementById('entries-filter-display');
        const today = getProductionDateString();
        const filterDate = window.lancamentoFilterDate;
        const filterMachine = window.lancamentoFilterMachine;
        
        if (indicator && display) {
            const parts = [];
            
            if (filterDate && filterDate !== today) {
                const [year, month, day] = filterDate.split('-');
                parts.push(`Data: ${day}/${month}/${year}`);
            }
            
            if (filterMachine) {
                parts.push(`Máquina: ${filterMachine}`);
            }
            
            if (parts.length > 0) {
                display.textContent = parts.join(' | ');
                indicator.classList.remove('hidden');
            } else {
                indicator.classList.add('hidden');
            }
        }
    }
    
    function hideEntriesFilterIndicator() {
        const indicator = document.getElementById('entries-filter-indicator');
        if (indicator) {
            indicator.classList.add('hidden');
        }
    }
    
    // Função para carregar lançamentos com filtros de data e máquina
    async function loadRecentEntriesWithFilters() {
        if (!recentEntriesList) return;
        
        setRecentEntriesState({ loading: true, empty: false });
        
        const filterDate = window.lancamentoFilterDate || getProductionDateString();
        const filterMachine = window.lancamentoFilterMachine;
        
        // Se tiver máquina específica selecionada, buscar por ela
        const machineToSearch = filterMachine || (selectedMachineData ? selectedMachineData.machine : null);
        
        if (!machineToSearch) {
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
            return;
        }
        
        try {
            const entries = [];
            recentEntriesCache = new Map();
            
            // Buscar lançamentos de produção pela máquina
            const productionSnapshot = await db.collection('production_entries')
                .where('machine', '==', machineToSearch)
                .where('data', '==', filterDate)
                .get();
            
            productionSnapshot.forEach(doc => {
                const data = doc.data();
                // Verificar se é borra
                const isBorra = data.tipo_lancamento === 'BORRA' || data.lote === 'BORRA' || (data.observacoes && data.observacoes.toUpperCase().includes('BORRA'));
                const type = isBorra ? 'borra' : ((data.refugo_kg && data.refugo_kg > 0) || data.perdas ? 'loss' : 'production');
                const resolvedTimestamp = resolveProductionDateTime(data) || data.updatedAt?.toDate?.() || data.timestamp?.toDate?.() || data.createdAt?.toDate?.() || (data.datetime ? new Date(data.datetime) : null);

                const entry = {
                    id: doc.id,
                    type,
                    collection: 'production_entries',
                    data,
                    timestamp: resolvedTimestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });
            
            // Buscar paradas
            const downtimeSnapshot = await db.collection('downtime_entries')
                .where('machine', '==', machineToSearch)
                .where('date', '==', filterDate)
                .get();

            downtimeSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || resolveProductionDateTime(data) || (data.startTime ? new Date(`${data.date}T${data.startTime}`) : null);

                const entry = {
                    id: doc.id,
                    type: 'downtime',
                    collection: 'downtime_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });
            
            // Buscar retrabalhos
            const reworkSnapshot = await db.collection('rework_entries')
                .where('machine', '==', machineToSearch)
                .where('data', '==', filterDate)
                .get();

            reworkSnapshot.forEach(doc => {
                const data = doc.data();
                const timestamp = data.createdAt?.toDate?.() || data.timestamp?.toDate?.() || (data.data ? new Date(`${data.data}T12:00:00`) : null);

                const entry = {
                    id: doc.id,
                    type: 'rework',
                    collection: 'rework_entries',
                    data,
                    timestamp
                };

                entries.push(entry);
                recentEntriesCache.set(doc.id, entry);
            });
            
            // Ordenar por timestamp
            entries.sort((a, b) => {
                const timeA = a.timestamp instanceof Date ? a.timestamp.getTime() : 0;
                const timeB = b.timestamp instanceof Date ? b.timestamp.getTime() : 0;
                return timeB - timeA;
            });

            allRecentEntries = entries;

            if (!entries.length) {
                updateRecentEntriesEmptyMessage(`Nenhum lançamento encontrado para ${machineToSearch} em ${filterDate.split('-').reverse().join('/')}.`);
                setRecentEntriesState({ loading: false, empty: true });
            } else {
                applyEntryFilter(currentEntryFilter);
                setRecentEntriesState({ loading: false, empty: false });
            }
        } catch (error) {
            console.error('Erro ao carregar lançamentos com filtros:', error);
            updateRecentEntriesEmptyMessage('Erro ao carregar lançamentos. Tente novamente.');
            setRecentEntriesState({ loading: false, empty: true });
        }
    }

    // Função para aplicar filtro de tipo de entrada
    function applyEntryFilter(filter) {
        currentEntryFilter = filter;
        
        let filteredEntries = allRecentEntries;
        
        if (filter !== 'all') {
            filteredEntries = allRecentEntries.filter(entry => entry.type === filter);
        }
        
        if (filteredEntries.length === 0) {
            const filterLabels = {
                all: 'lançamentos',
                production: 'lançamentos de produção',
                downtime: 'paradas',
                loss: 'perdas',
                rework: 'retrabalhos'
            };
            updateRecentEntriesEmptyMessage(`Não há ${filterLabels[filter]} para exibir.`);
            setRecentEntriesState({ loading: false, empty: true });
        } else {
            renderRecentEntries(filteredEntries);
            setRecentEntriesState({ loading: false, empty: false });
        }
        
        // Atualizar estado visual dos botões de filtro
        updateFilterButtons(filter);
    }
    
    // Função para atualizar estado visual dos botões de filtro
    function updateFilterButtons(activeFilter) {
        const filterButtons = document.querySelectorAll('.filter-entry-btn');
        filterButtons.forEach(btn => {
            const btnFilter = btn.dataset.filter;
            if (btnFilter === activeFilter) {
                btn.classList.add('active', 'bg-white', 'text-blue-600', 'shadow-sm');
                btn.classList.remove('text-gray-600', 'hover:text-gray-900', 'hover:bg-gray-50');
            } else {
                btn.classList.remove('active', 'bg-white', 'text-blue-600', 'shadow-sm');
                btn.classList.add('text-gray-600', 'hover:text-gray-900', 'hover:bg-gray-50');
            }
        });
    }

    function handleRecentEntryAction(event) {
        const actionButton = event.target.closest('[data-action]');
        if (!actionButton) return;

        const action = actionButton.dataset.action;
        const entryId = actionButton.dataset.entryId;
        const entryType = actionButton.dataset.entryType;

        if (!entryId || !entryType) return;

        if (action === 'edit') {
            // ⚠️ VERIFICAÇÃO DE PERMISSÃO: Apenas gestores podem editar lançamentos
            if (!isUserGestorOrAdmin()) {
                showPermissionDeniedNotification('editar lançamentos');
                return;
            }
            openEntryForEditing(entryType, entryId);
        } else if (action === 'delete') {
            // A verificação de permissão é feita dentro de showConfirmModal
            let collection = 'production_entries';
            if (entryType === 'downtime') {
                collection = 'downtime_entries';
            } else if (entryType === 'rework') {
                collection = 'rework_entries';
            }
            showConfirmModal(entryId, collection);
        }
    }

    function openEntryForEditing(entryType, entryId) {
        const entry = recentEntriesCache.get(entryId);
        if (!entry) {
            console.warn('Registro para edição não encontrado:', entryId);
            return;
        }

        currentEditContext = {
            type: entryType,
            id: entryId,
            collection: entry.collection,
            original: entry.data
        };

        if (entryType === 'production') {
            document.getElementById('quick-production-qty').value = entry.data.produzido || 0;
            document.getElementById('quick-production-weight').value = entry.data.peso_bruto || 0;
            document.getElementById('quick-production-obs').value = entry.data.observacoes || '';
            openModal('quick-production-modal');
        } else if (entryType === 'loss') {
            document.getElementById('quick-losses-qty').value = entry.data.refugo_qty || entry.data.quantity || 0;
            document.getElementById('quick-losses-weight').value = entry.data.refugo_kg || 0;
            document.getElementById('quick-losses-reason').value = entry.data.perdas || '';
            document.getElementById('quick-losses-obs').value = entry.data.observacoes || '';
            const quickLossesDeleteBtn = document.getElementById('quick-losses-delete-btn');
            if (quickLossesDeleteBtn) quickLossesDeleteBtn.classList.remove('hidden');
            openModal('quick-losses-modal');
        } else {
            alert('Edição deste tipo de lançamento ainda não está disponível.');
        }
    }

    function showNotification(message, type = 'info') {
        console.log('🔔 Mostrando notificação:', { message, type });
        // Criar notificação toast
        const notification = document.createElement('div');
        notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg ${
            type === 'success' ? 'bg-green-100 text-green-800 border-green-200' :
            type === 'warning' ? 'bg-yellow-100 text-yellow-800 border-yellow-200' :
            type === 'error' ? 'bg-red-100 text-red-800 border-red-200' :
            'bg-blue-100 text-blue-800 border-blue-200'
        } border`;
        
        notification.innerHTML = `
            <div class="flex items-center gap-2">
                <i data-lucide="${
                    type === 'success' ? 'check-circle' :
                    type === 'warning' ? 'alert-triangle' :
                    type === 'error' ? 'x-circle' : 'info'
                }" class="w-5 h-5"></i>
                <span>${message}</span>
            </div>
        `;
        
        document.body.appendChild(notification);
        lucide.createIcons();
        
        // Remover após 3 segundos
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }
    
    // Função para carregar o painel de lançamento
    async function loadLaunchPanel() {
        try {
            showLoadingState('launch-panel', true);
            await populateMachineSelector();
            updateCurrentShiftDisplay();
            showLoadingState('launch-panel', false, false);
        } catch (error) {
            console.error("Erro ao carregar painel de lançamento: ", error);
            showLoadingState('launch-panel', false, true);
        }
    }
    
    function setActiveMachineCard(machine) {
        if (!machineCardGrid) return;

        // Remove seleção anterior
        const previousSelected = machineCardGrid.querySelector('.machine-card.selected');
        if (previousSelected) {
            previousSelected.classList.remove('selected');
        }

        if (!machine) {
            activeMachineCard = null;
            return;
        }

        // Adiciona seleção no novo card
        const nextCard = machineCardGrid.querySelector(`[data-machine="${machine}"]`);
        if (nextCard) {
            nextCard.classList.add('selected');
            activeMachineCard = nextCard;
            
            // Scroll suave para o card selecionado se necessário
            nextCard.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'nearest',
                inline: 'nearest'
            });
        } else {
            activeMachineCard = null;
        }
    }

    function isPlanActive(plan) {
        if (!plan) return false;
        const status = String(plan.status || '').toLowerCase();
        const inactiveStatuses = ['concluida', 'concluido', 'finalizada', 'finalizado', 'cancelada', 'cancelado', 'encerrada', 'encerrado'];
        if (status && inactiveStatuses.includes(status)) {
            return false;
        }
        // Não esconder automaticamente quando atingir a meta.
        // O card só deve sair quando for explicitamente finalizado (status atualizado para concluída).
        return true;
    }

    /**
     * Renderiza a barra de status das máquinas (estilo Excel)
     * Mostra todas as máquinas como células coloridas de acordo com o status
     */
    function renderMachineStatusBar(activePlans = [], activeDowntimeSet = new Set(), machinesDowntime = {}) {
        const statusBar = document.getElementById('machine-status-cells');
        if (!statusBar) return;
        
        // Criar set de máquinas com planejamento ativo
        const machinesWithPlan = new Set();
        activePlans.forEach(plan => {
            if (plan && plan.machine) {
                machinesWithPlan.add(normalizeMachineId(plan.machine));
            }
        });
        
        // Ordenar todas as máquinas do banco
        const sortedMachines = [...machineDatabase].sort((a, b) => 
            normalizeMachineId(a.id).localeCompare(normalizeMachineId(b.id), 'pt-BR', { numeric: true })
        );
        
        // Renderizar células
        statusBar.innerHTML = sortedMachines.map(machine => {
            const mid = normalizeMachineId(machine.id);
            const hasActiveDowntime = activeDowntimeSet.has(mid);
            const hasExtendedDowntime = machinesDowntime && machinesDowntime[mid];
            const hasPlan = machinesWithPlan.has(mid);
            
            // Determinar status e cor
            let statusClass = '';
            let statusTitle = '';
            
            if (hasActiveDowntime || hasExtendedDowntime) {
                // Máquina parada (normal ou longa)
                statusClass = 'bg-red-500 text-white border-red-600';
                const downtimeInfo = hasExtendedDowntime ? machinesDowntime[mid] : null;
                statusTitle = downtimeInfo 
                    ? `${mid} - PARADA: ${downtimeInfo.reason || downtimeInfo.type || 'Parada longa'}`
                    : `${mid} - PARADA`;
            } else if (hasPlan) {
                // Máquina produzindo (tem OP ativa)
                statusClass = 'bg-emerald-500 text-white border-emerald-600';
                statusTitle = `${mid} - Produzindo`;
            } else {
                // Máquina sem OP
                statusClass = 'bg-slate-600 text-slate-300 border-slate-500';
                statusTitle = `${mid} - Sem OP`;
            }
            
            // Extrair número da máquina para exibição compacta
            const machineNumber = mid.replace(/[^\d]/g, '') || mid.slice(-2);
            
            return `
                <div class="machine-status-cell ${statusClass} w-8 h-8 flex items-center justify-center 
                            text-xs font-bold rounded border cursor-pointer transition-all duration-200
                            hover:scale-110 hover:shadow-lg hover:z-10"
                     data-machine="${mid}"
                     title="${statusTitle}">
                    ${machineNumber}
                </div>
            `;
        }).join('');
        
        // Adicionar evento de clique nas células
        statusBar.querySelectorAll('.machine-status-cell').forEach(cell => {
            cell.addEventListener('click', () => {
                const machineId = cell.dataset.machine;
                // Scroll para o card da máquina se existir
                const machineCard = document.querySelector(`.machine-card[data-machine="${machineId}"]`);
                if (machineCard) {
                    machineCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    machineCard.classList.add('ring-2', 'ring-blue-500', 'ring-offset-2');
                    setTimeout(() => {
                        machineCard.classList.remove('ring-2', 'ring-blue-500', 'ring-offset-2');
                    }, 2000);
                    // Simular clique no card
                    machineCard.click();
                    
                    // NOVO: Scroll automático para painel de lançamento após seleção
                    setTimeout(() => {
                        const productionPanel = document.getElementById('production-control-panel');
                        if (productionPanel && !productionPanel.classList.contains('hidden')) {
                            productionPanel.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 500);
                }
            });
        });
    }

    function renderMachineCards(plans = [], productionEntries = [], downtimeEntries = [], activeDowntimeMachines = new Set(), machinesDowntime = {}) {
        if (!machineCardGrid) {
            if (machineSelector) {
                machineSelector.machineData = {};
                machineSelector.innerHTML = '<option value="">Selecione uma máquina...</option>';
            }
            return;
        }

        if (machineCardEmptyState) {
            machineCardEmptyState.textContent = 'Nenhuma máquina com planejamento ativo.';
            machineCardEmptyState.classList.add('hidden');
            machineCardEmptyState.classList.remove('text-red-100');
        }
        
        // Converter para Set para busca rápida (pode ser array ou Set)
        const activeDowntimeSet = activeDowntimeMachines instanceof Set 
            ? activeDowntimeMachines 
            : new Set(Array.isArray(activeDowntimeMachines) ? activeDowntimeMachines : []);

        // NOVO: Cache de status de paradas para cronômetro
        downtimeStatusCache = machinesDowntime;

        const activePlans = Array.isArray(plans) ? plans.filter(isPlanActive) : [];
        
        // NOVO: Renderizar barra de status das máquinas (estilo Excel)
        renderMachineStatusBar(activePlans, activeDowntimeSet, machinesDowntime);

        // NOVO: Mostrar TODAS as máquinas (planejadas + paradas + inativas)
        // Em vez de apenas as planejadas
        const allMachineIds = new Set();
        
        // Adicionar máquinas com planejamento
        activePlans.forEach(plan => {
            if (plan && plan.machine) {
                allMachineIds.add(normalizeMachineId(plan.machine));
            }
        });
        
        // Adicionar máquinas com parada longa ativa
        Object.keys(machinesDowntime).forEach(machineId => {
            allMachineIds.add(machineId);
        });
        
        // Se nenhuma máquina, mostrar todas (painel vazio mas existem)
        if (allMachineIds.size === 0) {
            machineDatabase.forEach(m => {
                allMachineIds.add(normalizeMachineId(m.id));
            });
        }

        machineCardData = {};
        if (machineSelector) {
            machineSelector.machineData = {};
        }

        const planById = {};
        const machineOrder = Array.from(allMachineIds).sort((a, b) => a.localeCompare(b, 'pt-BR', { numeric: true }));

        // Mapear plans por máquina
        activePlans.forEach(plan => {
            if (!plan || !plan.machine) return;
            const mid = normalizeMachineId(plan.machine);
            const enrichedPlan = { id: plan.id, ...plan };
            machineCardData[mid] = enrichedPlan;
            planById[plan.id] = enrichedPlan;
        });

        if (machineSelector) {
            const selectorOptions = ['<option value="">Selecione uma máquina...</option>']
                .concat(machineOrder.map(machine => `<option value="${machine}">${machine}</option>`));
            machineSelector.innerHTML = selectorOptions.join('');
            machineOrder.forEach(machine => {
                machineSelector.machineData[machine] = machineCardData[machine];
            });
        }

        // IMPORTANTE: Inicializar aggregated para TODAS as máquinas (mesmo sem planejamento)
        const aggregated = {};
        machineOrder.forEach(machine => {
            aggregated[machine] = {
                plan: machineCardData[machine] || {},  // Plan pode ser vazio para máquinas sem planejamento
                totalProduced: 0,
                totalLossesKg: 0,
                entries: [],
                byShift: { T1: 0, T2: 0, T3: 0 }
            };
        });

        const planIdSet = new Set(activePlans.map(plan => plan.id));
        const machineSet = new Set(machineOrder);
        const filteredProductionEntries = Array.isArray(productionEntries)
            ? productionEntries.filter(entry => entry && planIdSet.has(entry.planId))
            : [];
        const filteredDowntimeEntries = Array.isArray(downtimeEntries)
            ? downtimeEntries.filter(entry => entry && machineSet.has(entry.machine))
            : [];
        const combinedEntries = [];
        const fallbackShiftKey = `T${getCurrentShift()}`;

        filteredProductionEntries.forEach(entry => {
            if (!entry || !planIdSet.has(entry.planId)) return;
            const plan = planById[entry.planId];
            if (!plan) return;
            const machine = plan.machine;
            const produced = coerceToNumber(entry.produzido ?? entry.quantity, 0);
            const turno = normalizeShiftValue(entry.turno);

            aggregated[machine].totalProduced += produced;
            aggregated[machine].totalLossesKg += coerceToNumber(entry.refugo_kg, 0);
            if (turno) {
                aggregated[machine].byShift[turno] = (aggregated[machine].byShift[turno] || 0) + produced;
            }

            const entryForOee = {
                machine,
                turno,
                produzido: produced,
                duracao_min: coerceToNumber(entry.duracao_min ?? entry.duration_min ?? entry.duration, 0),
                refugo_kg: coerceToNumber(entry.refugo_kg, 0),
                piece_weight: plan.piece_weight,
                real_cycle_t1: plan.real_cycle_t1,
                real_cycle_t2: plan.real_cycle_t2,
                real_cycle_t3: plan.real_cycle_t3,
                budgeted_cycle: plan.budgeted_cycle,
                active_cavities_t1: plan.active_cavities_t1,
                active_cavities_t2: plan.active_cavities_t2,
                active_cavities_t3: plan.active_cavities_t3,
                mold_cavities: plan.mold_cavities
            };

            aggregated[machine].entries.push(entryForOee);
            combinedEntries.push(entryForOee);
        });

        Object.keys(machineCardCharts).forEach(machine => {
            if (machineCardCharts[machine]) {
                machineCardCharts[machine].destroy();
            }
            delete machineCardCharts[machine];
        });

        if (machineOrder.length === 0) {
            machineCardGrid.innerHTML = '';
            if (machineCardEmptyState) {
                machineCardEmptyState.classList.remove('hidden');
            }
            setActiveMachineCard(null);
            return;
        }

    const oeeSummary = combinedEntries.length > 0 ? calculateRealTimeOEE(combinedEntries) : null;
    const oeeByMachine = oeeSummary?.oeeByMachine || {};
    const currentShiftKey = oeeSummary?.currentShift || fallbackShiftKey;

    const resolvePackagingMultiple = (plan) => {
        if (!plan || typeof plan !== 'object') return 0;

        const flatCandidates = [
            'bag_capacity', 'bagCapacity', 'package_quantity', 'packageQuantity',
            'package_qty', 'packaging_qty', 'packagingQuantity', 'packagingQty',
            'units_per_bag', 'unitsPerBag', 'unit_per_bag', 'unitPerBag',
            'units_per_package', 'unitsPerPackage', 'pieces_per_bag', 'piecesPerBag',
            'pecas_por_saco', 'quantidade_por_saco', 'quantidadePorSaco',
            'qtd_por_saco', 'qtdPorSaco', 'quantidade_saco', 'quantidadeSaco',
            'capacidade_saco', 'capacidadeSaco', 'capacidade_embalagem', 'capacidadeEmbalagem'
        ];

        for (const key of flatCandidates) {
            if (Object.prototype.hasOwnProperty.call(plan, key)) {
                const value = parseOptionalNumber(plan[key]);
                if (Number.isFinite(value) && value > 0) {
                    return Math.round(value);
                }
            }
        }

        const nestedCandidates = [
            plan.packaging,
            plan.packaging_info,
            plan.packagingInfo,
            plan.embalagem,
            plan.embalagem_info,
            plan.embalagemInfo
        ];

        for (const nested of nestedCandidates) {
            if (!nested || typeof nested !== 'object') continue;
            for (const key of flatCandidates) {
                if (Object.prototype.hasOwnProperty.call(nested, key)) {
                    const value = parseOptionalNumber(nested[key]);
                    if (Number.isFinite(value) && value > 0) {
                        return Math.round(value);
                    }
                }
            }
            if (Object.prototype.hasOwnProperty.call(nested, 'quantity') || Object.prototype.hasOwnProperty.call(nested, 'quantidade')) {
                const fallbackValue = parseOptionalNumber(nested.quantity ?? nested.quantidade);
                if (Number.isFinite(fallbackValue) && fallbackValue > 0) {
                    return Math.round(fallbackValue);
                }
            }
        }

        return 0;
    };

    const formatQty = (value) => {
        const parsed = coerceToNumber(value, 0);
        return Math.round(parsed).toLocaleString('pt-BR');
    };
    const machineProgressInfo = {};

    machineCardGrid.innerHTML = machineOrder.map(machine => {
        const data = aggregated[machine];
        const plan = data.plan || {};
        const plannedQtyPrimary = parseOptionalNumber(plan.order_lot_size);
        const plannedQtyFallback = parseOptionalNumber(plan.lot_size);
        const plannedQty = Math.round(plannedQtyPrimary ?? plannedQtyFallback ?? 0);
        // OTIMIZAÇÃO: Usar APENAS data.totalProduced (soma dos entries) como fonte única
        // Isso elimina oscilação causada por conflito entre plan.total_produzido e soma dos entries
        const totalAccumulatedProduced = Math.round(data.totalProduced ?? 0);
        const lossesKg = Math.round(coerceToNumber(data.totalLossesKg, 0));
        const pieceWeight = coerceToNumber(plan.piece_weight, 0);
        const scrapPcs = pieceWeight > 0 ? Math.round((lossesKg * 1000) / pieceWeight) : 0;
        const goodProductionRaw = Math.max(0, totalAccumulatedProduced - scrapPcs);
        const goodProduction = Math.round(goodProductionRaw);
        const progressPercentRaw = plannedQty > 0 ? (goodProduction / plannedQty) * 100 : 0;
        const packagingMultiple = resolvePackagingMultiple(plan);
        const executedDisplayQty = packagingMultiple > 0 ? Math.floor(goodProduction / packagingMultiple) * packagingMultiple : goodProduction;
        const displayRemainingQty = Math.max(0, plannedQty - executedDisplayQty);

        const normalizedProgress = Math.max(0, Math.min(progressPercentRaw, 100));
        const progressPalette = resolveProgressPalette(progressPercentRaw);
        const progressTextClass = progressPalette.textClass || 'text-slate-600';
        const progressText = `${Math.max(0, progressPercentRaw).toFixed(progressPercentRaw >= 100 ? 0 : 1)}%`;
        const remainingQty = Math.max(0, plannedQty - goodProduction);
        const lotCompleted = plannedQty > 0 && goodProduction >= plannedQty;

        machineProgressInfo[machine] = {
            normalizedProgress,
            progressPercent: progressPercentRaw,
            palette: progressPalette
        };

        const oeeShiftData = oeeByMachine[machine]?.[currentShiftKey];
        const oeePercent = Math.max(0, Math.min((oeeShiftData?.oee || 0) * 100, 100));
        const oeePercentText = oeePercent ? oeePercent.toFixed(1) : '0.0';
        const oeeColorClass = oeePercent >= 85 ? 'text-emerald-600' : oeePercent >= 70 ? 'text-amber-500' : 'text-red-500';
        const nowRef = new Date();
        const shiftStart = getShiftStartDateTime(nowRef);
        let runtimeHours = 0, downtimeHours = 0;
        if (shiftStart instanceof Date && !Number.isNaN(shiftStart.getTime())) {
            const elapsedSec = Math.max(0, Math.floor((nowRef.getTime() - shiftStart.getTime()) / 1000));
            if (elapsedSec > 0) {
                const dts = filteredDowntimeEntries.filter(dt => dt && dt.machine === machine);
                const runtimeSec = calculateProductionRuntimeSeconds({ shiftStart, now: nowRef, downtimes: dts });
                runtimeHours = Math.max(0, runtimeSec / 3600);
                downtimeHours = Math.max(0, (elapsedSec / 3600) - runtimeHours);
            }
        }
        let qualityPct = 100;
        if (totalAccumulatedProduced > 0) {
            qualityPct = Math.max(0, Math.min(100, (goodProduction / totalAccumulatedProduced) * 100));
        } else if (lossesKg > 0) {
            qualityPct = 0;
        }
        const qualityColorClass = qualityPct >= 98 ? 'text-emerald-600' : (qualityPct >= 95 ? 'text-amber-600' : 'text-red-600');
        
        // Resolver nome do produto - priorizar nome sobre código
        const resolveProductName = (p) => {
            if (!p) return 'Produto não definido';
            
            // 1. Tentar buscar no database de produtos pelo código
            const productCode = p.product_cod || p.product_code || p.part_code;
            if (productCode && window.databaseModule?.productByCode) {
                const dbProduct = window.databaseModule.productByCode.get(Number(productCode)) || 
                                  window.databaseModule.productByCode.get(String(productCode));
                if (dbProduct?.name) {
                    return dbProduct.name.trim();
                }
            }
            
            // 2. Tentar campos de nome explícitos
            const nameFields = [
                p.product_name,
                p.productName,
                p.produto_nome,
                p.produtoNome,
                p.part_name,
                p.partName,
                p.product_snapshot?.name,
                p.product_snapshot?.product_name
            ];
            for (const name of nameFields) {
                if (name && typeof name === 'string' && name.trim()) {
                    return name.trim();
                }
            }
            
            // 3. Se product não parece ser um código (tem espaço ou mais de 15 chars), usar
            if (p.product && typeof p.product === 'string') {
                const prod = p.product.trim();
                if (prod.includes(' ') || prod.length > 15) {
                    return prod;
                }
            }
            
            // 4. Fallback para product mesmo que pareça código
            return p.product || 'Produto não definido';
        };
        const displayProductName = resolveProductName(plan);
        
        const productLine = displayProductName !== 'Produto não definido' ? `<p class=\"mt-1 text-sm text-slate-600\">${displayProductName}</p>` : '<p class=\"mt-1 text-sm text-slate-400\">Produto não definido</p>';
        const mpLine = plan.mp ? `<p class=\"text-xs text-slate-400 mt-1\">MP: ${plan.mp}</p>` : '';
        const shiftProduced = data.byShift[currentShiftKey] ?? data.byShift[fallbackShiftKey] ?? 0;

        // Lógica de cor do card: vermelho se houver parada ativa (normal OU longa)
        let cardColorClass = '';
        const hasActiveDowntime = activeDowntimeSet.has(machine);
        const hasExtendedDowntime = downtimeStatusCache && downtimeStatusCache[machine];
        if (hasActiveDowntime || hasExtendedDowntime) {
            cardColorClass = 'machine-stopped'; // vermelho para parada ativa (normal ou longa)
        }

        return `
            <div class="machine-card group relative bg-white rounded-lg border border-slate-200 hover:border-blue-300 shadow-sm hover:shadow-md transition-all duration-200 cursor-pointer p-3 ${lotCompleted && String(plan.status||'').toLowerCase()!=='concluida' ? 'completed-blink' : ''} ${cardColorClass}" data-machine="${machine}" data-plan-id="${plan.id}" data-order-id="${plan.order_id||''}" data-part-code="${plan.product_cod||''}"
                <!-- Header compacto -->
                <div class="flex items-center justify-between mb-2">
                    <div class="flex items-center gap-2">
                        <div class="machine-identifier w-8 h-8 bg-gradient-to-br from-blue-500 to-blue-600 rounded-full flex items-center justify-center text-white text-xs font-bold">
                            ${machine.slice(-2)}
                        </div>
                        <div>
                            <h3 class="text-sm font-bold text-slate-900">${machine}</h3>
                            <p class="text-xs text-slate-500 truncate max-w-[120px]" title="${displayProductName}">${displayProductName}</p>
                        </div>
                    </div>
                    <div class="text-right">
                        <div class="text-xs font-semibold text-blue-600">${plan.order_number || plan.order_number_original || '-'}</div>
                        <div class="text-[10px] text-slate-400 uppercase">OP</div>
                    </div>
                </div>
                
                <!-- OEE centralizado -->
                <div class="flex items-center justify-center mb-2">
                    <div class="text-center">
                        <span class="text-lg font-bold ${oeeColorClass}">${oeePercentText}%</span>
                        <span class="text-[10px] text-slate-400 uppercase ml-1">OEE</span>
                    </div>
                </div>

                <!-- Indicadores principais em linha -->
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <div class="text-center">
                        <div class="text-sm font-semibold text-slate-900">${formatQty(executedDisplayQty)}</div>
                        <div class="text-[10px] text-slate-500 uppercase">Exec. OP</div>
                    </div>
                    <div class="text-center">
                        <div class="text-sm font-semibold text-slate-900">${formatQty(displayRemainingQty)}</div>
                        <div class="text-[10px] text-slate-500 uppercase">Faltante</div>
                    </div>
                </div>

                <!-- Barra de progresso compacta -->
                <div class="mb-2">
                    <div class="flex items-center justify-between mb-1">
                        <span class="text-xs text-slate-500">OP Total (${formatQty(plannedQty)})</span>
                        <span class="text-xs font-semibold ${progressTextClass}">${progressText}</span>
                    </div>
                    <div class="w-full bg-slate-100 rounded-full h-2">
                        <div class="h-2 rounded-full transition-all duration-300 ${progressPalette.bgClass || 'bg-blue-500'}" style="width: ${normalizedProgress}%"></div>
                    </div>
                </div>

                <!-- Status compacto -->
                <div class="flex items-center justify-between text-xs mb-2">
                    <div class="flex gap-1">
                        <span class="px-2 py-0.5 rounded-full bg-green-100 text-green-700 text-[10px]" title="Tempo rodando">${runtimeHours.toFixed(1)}h</span>
                        ${downtimeHours > 0 ? `<span class="px-2 py-0.5 rounded-full bg-red-100 text-red-700 text-[10px]" title="Tempo parado">${downtimeHours.toFixed(1)}h</span>` : ''}
                    </div>
                    <div class="text-slate-500">
                        <span class="font-medium">${formatShiftLabel(currentShiftKey)}</span>
                    </div>
                </div>

                <!-- Indicador de Parada Longa (NOVO) -->
                ${(() => {
                    const hasMachineDowntime = machinesDowntime && machinesDowntime[machine];
                    if (hasMachineDowntime) {
                        const typeLabel = getDowntimeTypeLabel(hasMachineDowntime.type);
                        const typeColor = getDowntimeTypeColor(hasMachineDowntime.type);
                        const startDate = new Date(hasMachineDowntime.startDate).toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                        const endDate = hasMachineDowntime.endDate ? new Date(hasMachineDowntime.endDate).toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' }) : '∞';
                        const duration = getDowntimeDuration(hasMachineDowntime.startDate);
                        const recordId = hasMachineDowntime.recordId || '';  // ID do documento Firestore
                        return `
                            <div class="mb-2 p-2 rounded-lg bg-amber-50 border border-amber-200">
                                <div class="flex items-center justify-between mb-1">
                                    <div class="flex items-center gap-2">
                                        <i data-lucide="alert-triangle" class="w-4 h-4 text-amber-600"></i>
                                        <span class="text-xs font-bold text-amber-700">PARADA ATIVA</span>
                                    </div>
                                    <span class="inline-block px-2 py-0.5 text-xs font-mono font-bold text-amber-700 bg-amber-100 rounded">⏱️ ${duration}</span>
                                </div>
                                <div class="flex items-center gap-2 mb-2">
                                    <span class="inline-block px-2 py-0.5 text-xs font-semibold rounded ${typeColor}">${typeLabel}</span>
                                    <span class="text-xs text-amber-700">Desde ${startDate}</span>
                                </div>
                                <p class="text-xs text-amber-600 mb-2">${hasMachineDowntime.reason}</p>
                                <button type="button" 
                                        onclick="finalizarParada('${recordId}', '${machine}')"
                                        class="w-full py-1 px-2 bg-red-600 hover:bg-red-700 text-white text-xs font-semibold rounded transition-colors">
                                    🛑 FINALIZAR PARADA
                                </button>
                            </div>
                        `;
                    }
                    return '';
                })()}

                <!-- Mini card de parada ativa -->
                ${(() => {
                    // Verifica se há parada ativa (downtime sem fim) para esta máquina
                    const paradaAtiva = filteredDowntimeEntries.some(dt => dt && dt.machine === machine && (!dt.endTime && !dt.endDate));
                    return paradaAtiva ? `
                        <div class="mb-2 p-2 rounded-lg bg-red-50 border border-red-200 flex items-center gap-2">
                            <i data-lucide="alert-circle" class="w-4 h-4 text-red-600 animate-pulse"></i>
                            <span class="text-xs font-bold text-red-700">PARADA ATIVA - MÁQUINA PARADA</span>
                        </div>
                    ` : '';
                })()}                ${lotCompleted ? `
                    <div class="card-actions flex gap-2 mt-3">
                        ${String(plan.status||'').toLowerCase()!=='concluida' && plan.order_id ? `
                            <button type="button" class="btn btn-finalize card-finalize-btn" data-plan-id="${plan.id}" data-order-id="${plan.order_id}" title="Finalizar OP">
                                 <i data-lucide="check-circle"></i>
                                 <span>Finalizar OP</span>
                            </button>
                        ` : ''}
                        ${String(plan.status||'').toLowerCase()==='concluida' ? `
                            <button type="button" class="btn btn-activate card-activate-next-btn" data-plan-id="${plan.id}" data-machine="${machine}" data-part-code="${plan.product_cod||''}" title="Ativar próxima OP">
                                 <i data-lucide="play-circle"></i>
                                 <span>Ativar próxima OP</span>
                            </button>
                        ` : ''}
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');

        machineOrder.forEach(machine => {
            renderMachineCardProgress(machine, machineProgressInfo[machine]);
        });

        // NOVO: Iniciar cronômetros para máquinas paradas
        machineOrder.forEach(machine => {
            if (machinesDowntime && machinesDowntime[machine]) {
                const cardElement = machineCardGrid.querySelector(`[data-machine="${machine}"]`);
                if (cardElement) {
                    startDowntimeTimer(machine, cardElement);
                }
            }
        });

        if (selectedMachineData && selectedMachineData.machine && machineCardData[selectedMachineData.machine]) {
            setActiveMachineCard(selectedMachineData.machine);
        } else {
            selectedMachineData = null;
            setActiveMachineCard(null);
            if (productionControlPanel) {
                productionControlPanel.classList.add('hidden');
            }
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
        }

        // Recriar ícones (por causa dos botões novos)
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }

    function renderMachineCardProgress(machine, progressInfo) {
        if (!machine || !progressInfo) return;

        const canvasId = `progress-donut-${machine}`;
        const canvas = document.getElementById(canvasId);
        if (!canvas) {
            return;
        }

        if (machineCardCharts[machine]) {
            try {
                machineCardCharts[machine].destroy();
            } catch (error) {
                console.warn('[TRACE][renderMachineCardProgress] falha ao destruir gráfico anterior', { machine, error });
            }
        }

        const executed = Math.max(0, Math.min(progressInfo.normalizedProgress ?? 0, 100));
        const remainder = Math.max(0, 100 - executed);
        const primaryColor = progressInfo.palette?.start || '#2563EB';
        const secondaryColor = hexWithAlpha(primaryColor, 0.18);

        machineCardCharts[machine] = new Chart(canvas, {
            type: 'doughnut',
            data: {
                datasets: [{
                    data: [executed, remainder],
                    backgroundColor: [primaryColor, secondaryColor],
                    borderWidth: 0,
                    hoverOffset: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '70%',
                rotation: -90,
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false }
                },
                animation: {
                    animateRotate: executed > 0,
                    duration: 600
                }
            }
        });
    }

    // Função para popular o seletor de máquinas (e cards)
    async function populateMachineSelector(filterDate = null) {
        try {
            const today = filterDate || window.lancamentoFilterDate || getProductionDateString();
            const planSnapshot = await db.collection('planning').where('date', '==', today).get();
            let plans = planSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            // Enriquecer planos com dados da OP (lot size, execução acumulada)
            const orderCacheByPartCode = new Map();
            const orderCacheById = new Map();
            const productionTotalsByOrderId = new Map();

            for (const plan of plans) {
                const partCode = String(plan.product_cod || plan.product_code || plan.part_code || '').trim();
                let resolvedOrder = null;

                // Priorizar vínculo direto com a OP se existir no planejamento
                const linkedOrderId = plan.production_order_id || plan.production_order || plan.order_id || null;
                if (linkedOrderId) {
                    try {
                        if (!orderCacheById.has(linkedOrderId)) {
                            const doc = await db.collection('production_orders').doc(linkedOrderId).get();
                            if (doc.exists) {
                                orderCacheById.set(linkedOrderId, { id: doc.id, ...doc.data() });
                            } else {
                                orderCacheById.set(linkedOrderId, null);
                            }
                        }
                        resolvedOrder = orderCacheById.get(linkedOrderId);
                    } catch (e) {
                        console.warn('Falha ao carregar OP vinculada ao plano', plan.id, linkedOrderId, e);
                    }
                }

                if (!resolvedOrder && partCode) {
                    if (!orderCacheByPartCode.has(partCode)) {
                        try {
                            const ordersSnapshot = await db.collection('production_orders')
                                .where('part_code', '==', partCode)
                                .get();

                            const orders = ordersSnapshot.docs
                                .map(doc => ({ id: doc.id, ...doc.data() }))
                                .sort((a, b) => {
                                    // Ordenar da mais antiga para a mais recente para priorizar a OP antiga
                                    const aTs = a.createdAt?.toMillis ? a.createdAt.toMillis() : (a.createdAt?._seconds ? a.createdAt._seconds * 1000 : 0);
                                    const bTs = b.createdAt?.toMillis ? b.createdAt.toMillis() : (b.createdAt?._seconds ? b.createdAt._seconds * 1000 : 0);
                                    if (aTs && bTs && aTs !== bTs) return aTs - bTs; // mais antiga primeiro
                                    // Fallback por número da OP (numérico ascendente)
                                    const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
                                    return toNum(a.order_number) - toNum(b.order_number);
                                });

                            orderCacheByPartCode.set(partCode, orders);
                        } catch (orderError) {
                            console.warn('Não foi possível recuperar OPs para o código', partCode, orderError);
                            orderCacheByPartCode.set(partCode, []);
                        }
                    }

                    const cachedOrders = orderCacheByPartCode.get(partCode) || [];
                    if (cachedOrders.length > 0) {
                        // Preferir OP ativa/andamento na mesma máquina do plano
                        const sameMachine = cachedOrders.filter(o => (o.machine_id || o.machine) === plan.machine);
                        const isOpen = (o) => !['concluida','cancelada','finalizada','encerrada'].includes(String(o.status||'').toLowerCase());
                        resolvedOrder = sameMachine.find(o => ['ativa','em_andamento'].includes(String(o.status||'').toLowerCase()))
                            || sameMachine.find(isOpen)
                            || cachedOrders.find(isOpen)
                            || cachedOrders[0];
                    }
                }

                if (resolvedOrder) {
                    const resolvedLotSize = Number(resolvedOrder.lot_size) || 0;
                    plan.order_lot_size = resolvedLotSize;
                    plan.order_id = resolvedOrder.id;
                    plan.order_number = resolvedOrder.order_number || resolvedOrder.order_number_original || resolvedOrder.id;

                    // Buscar produção acumulada da OP se ainda não calculada
                    if (!productionTotalsByOrderId.has(resolvedOrder.id)) {
                        try {
                            const prodSnapshot = await db.collection('production_entries')
                                .where('orderId', '==', resolvedOrder.id)
                                .get();

                            const totalProduced = prodSnapshot.docs.reduce((sum, doc) => {
                                const entry = doc.data();
                                return sum + (Number(entry.produzido || entry.quantity || 0) || 0);
                            }, 0);

                            productionTotalsByOrderId.set(resolvedOrder.id, totalProduced);
                        } catch (prodError) {
                            console.warn('Não foi possível recuperar lançamentos da OP', resolvedOrder.id, prodError);
                            productionTotalsByOrderId.set(resolvedOrder.id, 0);
                        }
                    }

                    const accumulated = productionTotalsByOrderId.get(resolvedOrder.id) || 0;
                    const resolvedOrderTotal = coerceToNumber(resolvedOrder.total_produzido ?? resolvedOrder.totalProduced, 0);
                    const planAccumulated = coerceToNumber(plan.total_produzido, 0);
                    
                    // CORREÇÃO: Usar o MAIOR valor entre o armazenado na OP e o acumulado dos lançamentos
                    // Isso garante que após edição manual, novos lançamentos continuem incrementando
                    plan.total_produzido = Math.max(resolvedOrderTotal, accumulated, planAccumulated);

                    console.log('[MachineCard][OP]', {
                        machine: plan.machine,
                        partCode,
                        orderId: resolvedOrder.id,
                        lotSize: plan.order_lot_size,
                        accumulated: plan.total_produzido,
                        fromOrder: resolvedOrderTotal,
                        fromEntries: accumulated
                    });
                } else {
                    // Caso não exista OP vinculada, manter total produzido local e sinalizar lot size zerado
                    plan.order_lot_size = Number(plan.lot_size) || 0;
                    if (!Number.isFinite(plan.total_produzido)) {
                        plan.total_produzido = 0;
                    }
                    console.warn('[MachineCard][OP] Nenhuma OP encontrada para o plano', plan.id, 'partCode:', partCode);
                }
            }

            const activePlans = plans.filter(isPlanActive);

            let productionEntries = [];
            let downtimeEntries = [];
            if (activePlans.length > 0) {
                const productionSnapshot = await db.collection('production_entries').where('data', '==', today).get();
                const planIdSet = new Set(activePlans.map(plan => plan.id));
                productionEntries = productionSnapshot.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(entry => planIdSet.has(entry.planId));

                // Paradas do dia (inclui dia anterior para cobrir T3 após 00:00)
                const base = new Date(`${today}T12:00:00`);
                const prev = new Date(base); prev.setDate(prev.getDate() - 1);
                const prevStr = new Date(prev.getTime() - prev.getTimezoneOffset()*60000).toISOString().split('T')[0];
                const dtSnapshot = await db.collection('downtime_entries')
                    .where('date', 'in', [prevStr, today])
                    .get();
                const machineSet = new Set(activePlans.map(p => p.machine));
                downtimeEntries = dtSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(dt => machineSet.has(dt.machine));
            }

            // Buscar paradas ativas para colorir cards de vermelho
            let activeDowntimeSet = new Set();
            try {
                const activeSnapshot = await db.collection('active_downtimes').get();
                activeDowntimeSet = new Set(activeSnapshot.docs.map(doc => doc.id));
            } catch (e) {
                console.warn('Erro ao buscar paradas ativas:', e);
            }

            // NOVO: Carregar paradas longas para mostrar no painel de máquinas
            const machinesDowntime = await getAllMachinesDowntimeStatus();
            renderMachineCards(activePlans, productionEntries, downtimeEntries, activeDowntimeSet, machinesDowntime);
            
            // Disparar evento para sinalizar que dados foram atualizados
            document.dispatchEvent(new CustomEvent('machineDataUpdated', { detail: { machineCardData, activePlans } }));
        } catch (error) {
            console.error('Erro ao carregar máquinas: ', error);
            if (machineCardGrid) {
                machineCardGrid.innerHTML = '';
            }
            if (machineCardEmptyState) {
                machineCardEmptyState.textContent = 'Erro ao carregar máquinas. Tente novamente.';
                machineCardEmptyState.classList.remove('hidden');
                machineCardEmptyState.classList.add('text-red-100');
            }
            if (machineSelector) {
                machineSelector.innerHTML = '<option value="">Erro ao carregar máquinas</option>';
                machineSelector.machineData = {};
            }
        }
    }
    
    // Função para atualizar display do turno atual
    function updateCurrentShiftDisplay() {
        if (!currentShiftDisplay) return;
        
        const currentShift = getCurrentShift();
        currentShiftDisplay.textContent = `T${currentShift}`;
    }
    
    // Função para quando uma máquina é selecionada
    async function onMachineSelected(machine) {
        const previousMachine = selectedMachineData ? selectedMachineData.machine : null;
        const machineData = machineCardData[machine] || machineSelector?.machineData?.[machine];

        if (!machine || !machineData) {
            productionControlPanel.classList.add('hidden');
            selectedMachineData = null;
            setActiveMachineCard(null);
            resetProductionTimer();
            if (recentEntriesList) {
                recentEntriesList.innerHTML = '';
            }
            updateRecentEntriesEmptyMessage('Selecione uma máquina para visualizar os lançamentos.');
            setRecentEntriesState({ loading: false, empty: true });
            if (productMp) productMp.textContent = 'Matéria-prima não definida';
            return;
        }
        
        selectedMachineData = machineData;
        if (machineSelector) {
            machineSelector.value = machine;
        }
        setActiveMachineCard(machine);
        updateQuickProductionPieceWeightUI({ forceUpdateInput: true });
        
        // Carregar estado persistente da tara
        loadTareStateForAllForms(selectedMachineData.machine);
        
        // Atualizar informações de tara nos formulários
        updateTareDisplay('quick', document.getElementById('quick-production-use-tare')?.checked || false);
        updateTareDisplay('manual', document.getElementById('manual-production-use-tare')?.checked || false);
        updateTareDisplay('losses', document.getElementById('quick-losses-use-tare')?.checked || false);

        if (previousMachine !== selectedMachineData.machine) {
            resetProductionTimer();
        }
        
        // Atualizar informações da máquina
        if (machineIcon) machineIcon.textContent = machine;
        if (machineName) machineName.textContent = `Máquina ${machine}`;
        if (productName) productName.textContent = selectedMachineData.product || 'Produto não definido';
        if (productMp) {
            productMp.textContent = selectedMachineData.mp ? `MP: ${selectedMachineData.mp}` : 'Matéria-prima não definida';
        }

        // Sincronizar com OP ativa (se existir) antes de atualizar o card principal
        await syncSelectedMachineWithActiveOrder();
        // Centralizar atualização do card principal (inclui shiftTarget)
        updateMachineInfo();
        
        // Mostrar painel
        productionControlPanel.classList.remove('hidden');
        
        // NOVO: Scroll automático para o painel de lançamento de produção
        setTimeout(() => {
            const scrollTarget = document.getElementById('production-control-panel');
            if (scrollTarget) {
                // Adicionar destaque visual
                scrollTarget.classList.add('production-panel-highlight');
                
                scrollTarget.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // Remover classe de destaque após animação
                setTimeout(() => {
                    scrollTarget.classList.remove('production-panel-highlight');
                }, 2000);
            }
        }, 100);
        
        // NOVO: Verificar e alertar sobre paradas longas
        const downtime = await getActiveMachineDowntime(machine);
        if (downtime) {
            const typeLabel = getDowntimeTypeLabel(downtime.type);
            const startDate = new Date(downtime.startDate).toLocaleDateString('pt-BR');
            const endDate = new Date(downtime.endDate).toLocaleDateString('pt-BR');
            
            // Criar alerta visual
            const alertDiv = document.createElement('div');
            alertDiv.className = 'fixed top-4 right-4 bg-amber-100 border-l-4 border-amber-500 text-amber-800 p-4 rounded shadow-lg max-w-md z-50 animate-pulse';
            alertDiv.innerHTML = `
                <div class="flex items-start gap-3">
                    <i data-lucide="alert-triangle" class="w-6 h-6 flex-shrink-0"></i>
                    <div>
                        <h3 class="font-bold mb-1">⚠️ Máquina em Parada Longa</h3>
                        <p class="text-sm mb-2"><strong>${machine}</strong> está registrada em parada:</p>
                        <p class="text-sm font-semibold text-amber-700 mb-1">${typeLabel}</p>
                        <p class="text-xs mb-2"><strong>Período:</strong> ${startDate} a ${endDate}</p>
                        <p class="text-xs"><strong>Motivo:</strong> ${downtime.reason}</p>
                    </div>
                </div>
            `;
            document.body.appendChild(alertDiv);
            if (typeof lucide !== 'undefined') lucide.createIcons();
            
            // Remover alerta após 8 segundos
            setTimeout(() => {
                alertDiv.style.animation = 'fadeOut 0.5s ease-out';
                setTimeout(() => alertDiv.remove(), 500);
            }, 8000);
        }
        
        // Carregar dados
        await refreshLaunchCharts();
        await loadTodayStats();
        await loadRecentEntries(false);
        
        // Reset machine status (mas verificar se há parada ativa primeiro)
        machineStatus = 'running';
        updateMachineStatus();
        
        // Verificar se há parada ativa para esta máquina
        await checkActiveDowntimes();
    }
    
    // Função para carregar gráfico de produção por hora
    async function loadHourlyProductionChart() {
        if (!selectedMachineData || !hourlyProductionChart) return;

        currentActiveOrder = null;
        currentOrderProgress = { executed: 0, planned: 0, expected: 0 };

        try {
            const today = getProductionDateString();
            // 1) Recuperar todos os lançamentos de produção da MÁQUINA no dia atual
            //    (filtraremos em memória pelos planos do MESMO PRODUTO)
            const productionSnapshot = await db.collection('production_entries')
                .where('data', '==', today)
                .where('machine', '==', selectedMachineData.machine)
                .get();

            const hourlyData = {};
            for (let i = 7; i < 31; i++) {
                const hour = i >= 24 ? i - 24 : i;
                const hourStr = `${String(hour).padStart(2, '0')}:00`;
                hourlyData[hourStr] = { planned: 0, actual: 0 };
            }

            const partCode = selectedMachineData.product_cod || selectedMachineData.product_code;
            let matchedOrder = null;
            let lotSize = Number(selectedMachineData.planned_quantity) || 0;

            // 2) Identificar todos os planos de HOJE para esta máquina e MESMO PRODUTO
            //    para consolidar entre trocas de OP do mesmo produto
            let relevantPlans = [];
            try {
                const planSnap = await db.collection('planning')
                    .where('date', '==', today)
                    .where('machine', '==', selectedMachineData.machine)
                    .get();
                const partMatcher = String(partCode || '').trim().toLowerCase();
                relevantPlans = planSnap.docs
                    .map(doc => ({ id: doc.id, ...doc.data() }))
                    .filter(plan => {
                        const code = String(plan.product_cod || plan.product_code || plan.part_code || '').trim().toLowerCase();
                        return partMatcher && code && code === partMatcher;
                    });
            } catch (e) {
                console.warn('[HOUR-CHART] Falha ao recuperar planos do dia para consolidação', e);
                relevantPlans = [];
            }

            // Preferir a OP vinculada ao planejamento, se existir
            if (selectedMachineData.order_id) {
                try {
                    const doc = await db.collection('production_orders').doc(selectedMachineData.order_id).get();
                    if (doc.exists) {
                        matchedOrder = { id: doc.id, ...doc.data() };
                        const orderLotSize = Number(matchedOrder.lot_size);
                        if (Number.isFinite(orderLotSize) && orderLotSize > 0) {
                            lotSize = orderLotSize;
                        }
                    }
                } catch (e) {
                    console.warn('Falha ao recuperar OP vinculada ao plano:', e);
                }
            }

            // Fallback por código da peça, mantendo prioridade da mesma máquina
            if (!matchedOrder && partCode) {
                try {
                    const lotsSnapshot = await db.collection('production_orders')
                        .where('part_code', '==', String(partCode))
                        .get();

                    if (!lotsSnapshot.empty) {
                        const orderDocs = lotsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                        const toNum = (v) => { const n = parseInt(String(v||'').replace(/\D/g,''), 10); return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY; };
                        const isOpen = (o) => !['concluida','cancelada','finalizada','encerrada'].includes(String(o.status||'').toLowerCase());
                        const sameMachine = orderDocs.filter(o => (o.machine_id || o.machine) === selectedMachineData.machine);
                        matchedOrder = sameMachine.find(o => ['ativa','em_andamento'].includes(String(o.status||'').toLowerCase()))
                            || sameMachine.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orderDocs.filter(isOpen).sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0]
                            || orderDocs.sort((a,b) => toNum(a.order_number) - toNum(b.order_number))[0];

                        if (matchedOrder) {
                            const orderLotSize = Number(matchedOrder.lot_size);
                            if (Number.isFinite(orderLotSize) && orderLotSize > 0) {
                                lotSize = orderLotSize;
                            }
                        }
                    }
                } catch (lotError) {
                    console.warn('Não foi possível recuperar informações da ordem vinculada:', lotError);
                }
            }

            // 3) Calcular META DIÁRIA consolidada por MÁQUINA + PRODUTO (somatório dos planos do dia)
            let dailyTarget = 0;
            if (Array.isArray(relevantPlans) && relevantPlans.length > 0) {
                dailyTarget = relevantPlans.reduce((sum, p) => {
                    const pq = Number(p.planned_quantity || p.daily_target || 0) || 0;
                    return sum + pq;
                }, 0);
            }
            // Fallback: manter meta do plano selecionado se não houver agrupamento
            if (!Number.isFinite(dailyTarget) || dailyTarget <= 0) {
                dailyTarget = Number(selectedMachineData.planned_quantity) || Number(selectedMachineData.daily_target) || 0;
            }
            const hourlyTarget = HOURS_IN_PRODUCTION_DAY > 0 ? (dailyTarget / HOURS_IN_PRODUCTION_DAY) : 0;

            Object.keys(hourlyData).forEach(hour => {
                hourlyData[hour].planned = hourlyTarget;
            });

            // 4) Somar EXECUTADO por hora somente para lançamentos pertencentes aos planos do mesmo produto
            const relevantPlanIdSet = new Set((relevantPlans || []).map(p => p.id));
            // Se não encontramos planos relevantes (edge), considerar ao menos o plano atual como elegível
            if (relevantPlanIdSet.size === 0 && selectedMachineData.id) {
                relevantPlanIdSet.add(selectedMachineData.id);
            }

            productionSnapshot.forEach(doc => {
                const data = doc.data();
                // Filtrar por plano relevante (mesmo produto)
                if (data.planId && !relevantPlanIdSet.has(data.planId)) {
                    return;
                }
                const prodDate = resolveProductionDateTime(data);
                if (!prodDate) {
                    return;
                }
                const hour = `${String(prodDate.getHours()).padStart(2, '0')}:00`;
                if (!hourlyData[hour]) {
                    hourlyData[hour] = { planned: hourlyTarget, actual: 0 };
                }
                hourlyData[hour].actual += data.produzido || 0;
            });

            const totalExecuted = Object.values(hourlyData).reduce((sum, entry) => sum + (entry.actual || 0), 0);
            const hoursElapsed = getHoursElapsedInProductionDay(new Date());
            const expectedByNow = Math.min(dailyTarget, hoursElapsed * hourlyTarget);

            if (matchedOrder) {
                currentActiveOrder = { ...matchedOrder };
            }
            currentOrderProgress = {
                executed: totalExecuted,
                planned: dailyTarget,
                expected: expectedByNow
            };

            updateTimelineProgress(totalExecuted, dailyTarget, expectedByNow);

            if (hourlyChartInstance) {
                hourlyChartInstance.destroy();
                hourlyChartInstance = null;
            }

            const hours = Object.keys(hourlyData);
            const plannedData = hours.map(hour => Number(hourlyData[hour].planned || 0));
            const actualData = hours.map(hour => Number(hourlyData[hour].actual || 0));

            hourlyChartInstance = createHourlyProductionChart({
                canvas: hourlyProductionChart,
                labels: hours,
                executedPerHour: actualData,
                plannedPerHour: plannedData,
                highlightCurrentHour: true
            });

        } catch (error) {
            console.error('Erro ao carregar dados do gráfico: ', error);
        }
    }
    
    // Função para carregar estatísticas do dia (janela de produção 07:00 -> 07:00)
    async function loadTodayStats(filterDate = null) {
        if (!selectedMachineData) return;
        
        try {
            const today = filterDate || window.lancamentoFilterDate || getProductionDateString();
            // Janela do dia de produção atual: [hoje 07:00, amanhã 07:00)
            const windowStart = combineDateAndTime(today, '07:00');
            const nextDay = new Date(windowStart);
            nextDay.setDate(nextDay.getDate() + 1);
            const tomorrow = nextDay.toISOString().split('T')[0];
            const windowEnd = combineDateAndTime(tomorrow, '07:00');
            
            // Buscar dados de produção
            const prodSnapshot = await db.collection('production_entries')
                .where('machine', '==', selectedMachineData.machine)
                .where('data', '==', today)
                .get();
            
            const productions = prodSnapshot.docs.map(doc => doc.data());
            
                        // Buscar paradas de hoje e de amanhã (duas consultas simples)
                        const [dtSnapToday, dtSnapTomorrow] = await Promise.all([
                                db.collection('downtime_entries')
                                    .where('machine', '==', selectedMachineData.machine)
                                    .where('date', '==', today)
                                    .get(),
                                db.collection('downtime_entries')
                                    .where('machine', '==', selectedMachineData.machine)
                                    .where('date', '==', tomorrow)
                                    .get()
                        ]);
                        const downtimes = [...dtSnapToday.docs, ...dtSnapTomorrow.docs].map(doc => doc.data());
            
            // Calcular totais e produção por turno
            let totalProduced = 0;
            let totalLosses = 0;
            let producedT1 = 0;
            let producedT2 = 0;
            let producedT3 = 0;
            
            productions.forEach(prod => {
                const quantidade = Number(prod.produzido || prod.quantity || 0) || 0;
                const turno = Number(prod.turno || prod.shift || 0);
                
                totalProduced += quantidade;
                totalLosses += Number(prod.refugo_kg || 0) || 0;
                
                // Separar por turno
                if (turno === 1) {
                    producedT1 += quantidade;
                } else if (turno === 2) {
                    producedT2 += quantidade;
                } else if (turno === 3) {
                    producedT3 += quantidade;
                }
            });
            
            // Somar apenas a interseção com a janela de produção (evita inflar com 00:00-07:00 que pertence ao dia anterior)
            let totalDowntime = 0;
            downtimes.forEach(dt => {
                const start = combineDateAndTime(dt.date, dt.startTime);
                const end = combineDateAndTime(dt.date, dt.endTime);
                if (!(start instanceof Date) || Number.isNaN(start.getTime())) return;
                if (!(end instanceof Date) || Number.isNaN(end.getTime())) return;
                // Overlap com [windowStart, windowEnd)
                const overlapStart = start > windowStart ? start : windowStart;
                const overlapEnd = end < windowEnd ? end : windowEnd;
                if (overlapEnd > overlapStart) {
                    totalDowntime += Math.round((overlapEnd - overlapStart) / 60000);
                }
            });
            
            // Calcular eficiência baseado na meta diária (com fallback para planned_quantity)
            const dailyTarget = Number(selectedMachineData.daily_target || selectedMachineData.planned_quantity || 0);
            const efficiency = dailyTarget > 0 ? (totalProduced / dailyTarget * 100) : 0;
            
            // Atualizar display - produção por turno
            const producedT1El = document.getElementById('produced-t1');
            const producedT2El = document.getElementById('produced-t2');
            const producedT3El = document.getElementById('produced-t3');
            if (producedT1El) producedT1El.textContent = producedT1.toLocaleString('pt-BR');
            if (producedT2El) producedT2El.textContent = producedT2.toLocaleString('pt-BR');
            if (producedT3El) producedT3El.textContent = producedT3.toLocaleString('pt-BR');
            
            // Atualizar displays - totais
            if (producedToday) producedToday.textContent = totalProduced.toLocaleString('pt-BR');
            if (efficiencyToday) efficiencyToday.textContent = `${efficiency.toFixed(1)}%`;
            if (lossesToday) lossesToday.textContent = totalLosses.toFixed(2);
            if (downtimeToday) downtimeToday.textContent = totalDowntime;

            const shiftReference = new Date();
            const shiftStart = getShiftStartDateTime(shiftReference);
            const activeDowntime = (machineStatus === 'stopped' && currentDowntimeStart && currentDowntimeStart.machine === selectedMachineData.machine)
                ? currentDowntimeStart
                : null;

            if (shiftStart) {
                const runtimeSeconds = calculateProductionRuntimeSeconds({
                    shiftStart,
                    now: shiftReference,
                    downtimes,
                    activeDowntime
                });
                synchronizeProductionTimer(runtimeSeconds, machineStatus === 'running');
            } else {
                resetProductionTimer();
            }
            
        } catch (error) {
            console.error("Erro ao carregar estatísticas: ", error);
        }
    }



    // --- ABA DE ANÁLISE: RESUMO ---
    async function loadResumoData(showLoading = true) {
        const date = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
        if (!date) return;

        if (showLoading) showLoadingState('resumo', true);

        try {
            // NOVO: Buscar todos os planejamentos e filtrar os ATIVOS no cliente
            const planSnapshot = await db.collection('planning').get();
            const allPlans = planSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            const plans = allPlans.filter(isPlanActive);

            if (plans.length === 0) {
                showLoadingState('resumo', false, true);
                return;
            }
            
            const productionSnapshot = await db.collection('production_entries').where('data', '==', date).get();
            const productions = productionSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            const downtimeSnapshot = await db.collection('downtime_entries').where('date', '==', date).get();
            const downtimes = downtimeSnapshot.docs.map(doc => doc.data());

            currentReportData = processResumoData(plans, productions, downtimes);
            
            const currentView = reportQuantBtn && reportQuantBtn.classList.contains('active') ? 'quant' : 'effic';
            switchReportView(currentView);

            showLoadingState('resumo', false, false);

        } catch (error) {
            console.error("Erro ao carregar dados de resumo: ", error);
            showLoadingState('resumo', false, true);
        }
    }
    
    function processResumoData(plans, productions, downtimes) {
        return plans.map(plan => {
            const data = { ...plan, T1: {}, T2: {}, T3: {} };
            const turnos = ['T1', 'T2', 'T3'];

            turnos.forEach(turno => {
                const entries = productions.filter(p => p.planId === plan.id && p.turno === turno);
                const produzido = entries.reduce((sum, item) => sum + item.produzido, 0);
                
                const machineDowntimes = downtimes.filter(d => d.machine === plan.machine);
                const totalParadas = machineDowntimes.reduce((sum, item) => {
                    const start = new Date(`${item.date}T${item.startTime}`);
                    const end = new Date(`${item.date}T${item.endTime}`);
                    return sum + (end > start ? Math.round((end - start) / 60000) : 0);
                }, 0);

                const refugo_kg = entries.reduce((sum, item) => sum + item.refugo_kg, 0);
                const refugo_pcs = plan.piece_weight > 0 ? Math.round((refugo_kg * 1000) / plan.piece_weight) : 0;
                
                const ciclo_real = plan[`real_cycle_${turno.toLowerCase()}`] || plan.budgeted_cycle;
                const cav_ativas = plan[`active_cavities_${turno.toLowerCase()}`] || plan.mold_cavities;
                
                const oee = calculateShiftOEE(produzido, totalParadas / 3, refugo_pcs, ciclo_real, cav_ativas);

                data[turno] = { produzido, paradas: totalParadas, refugo_kg, refugo_pcs, ...oee };
                
                // Salvar histórico de OEE para este turno
                const dateStr = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
                saveOeeHistory(plan.machine, turno, dateStr, oee);
            });
            
            data.total_produzido = (data.T1.produzido || 0) + (data.T2.produzido || 0) + (data.T3.produzido || 0);
            return data;
        });
    }
    
    function calculateShiftOEE(produzido, tempoParadaMin, refugoPcs, cicloReal, cavAtivas) {
        const tempoTurnoMin = 480;
        
        const tempoProgramado = tempoTurnoMin;
        const tempoProduzindo = Math.max(0, tempoProgramado - Math.max(0, tempoParadaMin));
        const disponibilidade = tempoProgramado > 0 ? (tempoProduzindo / tempoProgramado) : 0;

        const producaoTeorica = cicloReal > 0 && cavAtivas > 0 ? (tempoProduzindo * 60 / cicloReal) * cavAtivas : 0;
        const performance = producaoTeorica > 0 ? Math.min(1, produzido / producaoTeorica) : (produzido > 0 ? 1 : 0);
        
        const totalProduzido = Math.max(0, produzido) + Math.max(0, refugoPcs);
        const qualidade = totalProduzido > 0 ? (Math.max(0, produzido) / totalProduzido) : (produzido > 0 ? 1 : 0);
        
        const oee = disponibilidade * performance * qualidade;

        const result = {
            disponibilidade: isNaN(disponibilidade) || !isFinite(disponibilidade) ? 0 : Math.max(0, Math.min(1, disponibilidade)),
            performance: isNaN(performance) || !isFinite(performance) ? 0 : Math.max(0, Math.min(1, performance)),
            qualidade: isNaN(qualidade) || !isFinite(qualidade) ? 0 : Math.max(0, Math.min(1, qualidade)),
            oee: isNaN(oee) || !isFinite(oee) ? 0 : Math.max(0, Math.min(1, oee))
        };

        console.log('[TRACE][calculateShiftOEE]', {
            inputs: { produzido, tempoParadaMin, refugoPcs, cicloReal, cavAtivas },
            calculations: { tempoProgramado, tempoProduzindo, producaoTeorica, totalProduzido },
            result
        });

        return result;
    }

    // --- FUNÇÕES PARA OEE EM TEMPO REAL ---
    
    // Função para calcular OEE em tempo real baseado nos dados atuais
    function calculateRealTimeOEE(data) {
        const now = new Date();
        const currentHour = now.getHours();
        const currentMinute = now.getMinutes();
        
        // Determinar turno atual
        let currentShift;
        if (currentHour >= 7 && currentHour < 15) {
            currentShift = 'T1';
        } else if (currentHour >= 15 && currentHour < 23) {
            currentShift = 'T2';
        } else {
            currentShift = 'T3';
        }
        
        // Calcular tempo decorrido no turno atual
        let tempoDecorridoMin;
        if (currentShift === 'T1') {
            tempoDecorridoMin = (currentHour - 7) * 60 + currentMinute;
        } else if (currentShift === 'T2') {
            tempoDecorridoMin = (currentHour - 15) * 60 + currentMinute;
        } else { // T3
            if (currentHour >= 23) {
                tempoDecorridoMin = (currentHour - 23) * 60 + currentMinute;
            } else {
                tempoDecorridoMin = (currentHour + 1) * 60 + currentMinute; // Para horas 0-6
            }
        }
        
        // Limitar o tempo decorrido ao máximo do turno
        tempoDecorridoMin = Math.min(tempoDecorridoMin, 480);
        
        const oeeByShift = {};
        const oeeByMachine = {};
        
        // Agrupar dados por máquina e turno
        const groupedData = {};
        data.forEach(item => {
            const key = `${item.machine}_${item.turno}`;
            if (!groupedData[key]) {
                groupedData[key] = {
                    machine: item.machine,
                    turno: item.turno,
                    produzido: 0,
                    paradas: 0,
                    refugo_pcs: 0,
                    ciclo_real: item.real_cycle_t1 || item.real_cycle_t2 || item.real_cycle_t3 || item.budgeted_cycle,
                    cav_ativas: item.active_cavities_t1 || item.active_cavities_t2 || item.active_cavities_t3 || item.mold_cavities
                };
            }
            
            groupedData[key].produzido += item.produzido || 0;
            groupedData[key].paradas += item.duracao_min || 0;
            
            if (item.piece_weight > 0) {
                groupedData[key].refugo_pcs += Math.round(((item.refugo_kg || 0) * 1000) / item.piece_weight);
            }
        });
        
        // Calcular OEE para cada grupo
        Object.values(groupedData).forEach(group => {
            const tempoParadaMin = group.paradas;
            const oeeCalc = calculateShiftOEE(
                group.produzido,
                tempoParadaMin,
                group.refugo_pcs,
                group.ciclo_real,
                group.cav_ativas
            );
            
            // Ajustar cálculo para tempo real se for o turno atual
            if (group.turno === currentShift) {
                const tempoProgramadoReal = tempoDecorridoMin;
                const tempoProduzindoReal = Math.max(0, tempoProgramadoReal - tempoParadaMin);
                const disponibilidadeReal = tempoProgramadoReal > 0 ? (tempoProduzindoReal / tempoProgramadoReal) : 0;
                
                const producaoTeoricaReal = group.ciclo_real > 0 && group.cav_ativas > 0 ? 
                    (tempoProduzindoReal * 60 / group.ciclo_real) * group.cav_ativas : 0;
                const performanceReal = producaoTeoricaReal > 0 ? (group.produzido / producaoTeoricaReal) : 0;
                
                const totalProduzidoReal = group.produzido + group.refugo_pcs;
                const qualidadeReal = totalProduzidoReal > 0 ? (group.produzido / totalProduzidoReal) : 0;
                
                const oeeReal = disponibilidadeReal * performanceReal * qualidadeReal;
                
                oeeCalc.disponibilidade = isNaN(disponibilidadeReal) || !isFinite(disponibilidadeReal) ? 0 : disponibilidadeReal;
                oeeCalc.performance = isNaN(performanceReal) || !isFinite(performanceReal) ? 0 : performanceReal;
                oeeCalc.qualidade = isNaN(qualidadeReal) || !isFinite(qualidadeReal) ? 0 : qualidadeReal;
                oeeCalc.oee = isNaN(oeeReal) || !isFinite(oeeReal) ? 0 : oeeReal;
                oeeCalc.isRealTime = true;
                oeeCalc.tempoDecorrido = tempoDecorridoMin;
            }
            
            // Armazenar por turno
            if (!oeeByShift[group.turno]) {
                oeeByShift[group.turno] = [];
            }
            oeeByShift[group.turno].push({
                machine: group.machine,
                ...oeeCalc
            });
            
            // Armazenar por máquina
            if (!oeeByMachine[group.machine]) {
                oeeByMachine[group.machine] = {};
            }
            oeeByMachine[group.machine][group.turno] = oeeCalc;
        });
        
        return {
            currentShift,
            tempoDecorridoMin,
            oeeByShift,
            oeeByMachine
        };
    }
    
    // Função para salvar histórico de OEE
    async function saveOeeHistory(machine, turno, data, oeeData) {
        try {
            const historyEntry = {
                machine,
                turno,
                data,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                disponibilidade: oeeData.disponibilidade,
                performance: oeeData.performance,
                qualidade: oeeData.qualidade,
                oee: oeeData.oee,
                isRealTime: oeeData.isRealTime || false,
                tempoDecorrido: oeeData.tempoDecorrido || 480
            };
            
            // Usar ID único baseado em máquina, turno e data para evitar duplicatas
            const docId = `${machine}_${turno}_${data}`;
            await db.collection('oee_history').doc(docId).set(historyEntry, { merge: true });
            
        } catch (error) {
            console.error("Erro ao salvar histórico de OEE: ", error);
        }
    }
    
    // Função para carregar histórico de OEE
    async function loadOeeHistory(startDate, endDate, machine = null, turno = null) {
        try {
            let query = db.collection('oee_history')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate)
                .orderBy('data')
                .orderBy('timestamp');
            
            if (machine) {
                query = query.where('machine', '==', machine);
            }
            
            if (turno) {
                query = query.where('turno', '==', turno);
            }
            
            const snapshot = await query.get();
            return snapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data(),
                timestamp: doc.data().timestamp?.toDate()
            }));
            
        } catch (error) {
            console.error("Erro ao carregar histórico de OEE: ", error);
            return [];
        }
    }
    
    // Função para agrupar OEE por períodos (hora, dia, semana)
    function groupOeeByPeriod(oeeHistory, period = 'day') {
        const grouped = {};
        
        oeeHistory.forEach(entry => {
            let key;
            const date = entry.timestamp || new Date(entry.data);
            
            switch (period) {
                case 'hour':
                    key = `${entry.data}_${String(date.getHours()).padStart(2, '0')}:00`;
                    break;
                case 'day':
                    key = entry.data;
                    break;
                case 'week':
                    const startOfWeek = new Date(date);
                    startOfWeek.setDate(date.getDate() - date.getDay());
                    key = startOfWeek.toISOString().split('T')[0];
                    break;
                default:
                    key = entry.data;
            }
            
            if (!grouped[key]) {
                grouped[key] = {
                    period: key,
                    machines: {},
                    shifts: {},
                    overall: {
                        disponibilidade: [],
                        performance: [],
                        qualidade: [],
                        oee: []
                    }
                };
            }
            
            // Agrupar por máquina
            if (!grouped[key].machines[entry.machine]) {
                grouped[key].machines[entry.machine] = {
                    disponibilidade: [],
                    performance: [],
                    qualidade: [],
                    oee: []
                };
            }
            
            // Agrupar por turno
            if (!grouped[key].shifts[entry.turno]) {
                grouped[key].shifts[entry.turno] = {
                    disponibilidade: [],
                    performance: [],
                    qualidade: [],
                    oee: []
                };
            }
            
            // Adicionar valores
            const metrics = ['disponibilidade', 'performance', 'qualidade', 'oee'];
            metrics.forEach(metric => {
                grouped[key].machines[entry.machine][metric].push(entry[metric]);
                grouped[key].shifts[entry.turno][metric].push(entry[metric]);
                grouped[key].overall[metric].push(entry[metric]);
            });
        });
        
        // Calcular médias
        Object.values(grouped).forEach(group => {
            const calculateAverage = (arr) => arr.length > 0 ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
            
            // Médias por máquina
            Object.values(group.machines).forEach(machine => {
                machine.avgDisponibilidade = calculateAverage(machine.disponibilidade);
                machine.avgPerformance = calculateAverage(machine.performance);
                machine.avgQualidade = calculateAverage(machine.qualidade);
                machine.avgOee = calculateAverage(machine.oee);
            });
            
            // Médias por turno
            Object.values(group.shifts).forEach(shift => {
                shift.avgDisponibilidade = calculateAverage(shift.disponibilidade);
                shift.avgPerformance = calculateAverage(shift.performance);
                shift.avgQualidade = calculateAverage(shift.qualidade);
                shift.avgOee = calculateAverage(shift.oee);
            });
            
            // Médias gerais
            group.overall.avgDisponibilidade = calculateAverage(group.overall.disponibilidade);
            group.overall.avgPerformance = calculateAverage(group.overall.performance);
            group.overall.avgQualidade = calculateAverage(group.overall.qualidade);
            group.overall.avgOee = calculateAverage(group.overall.oee);
        });
        
        return grouped;
    }

    function switchReportView(view) {
        if (reportQuantBtn && reportEfficBtn) {
            reportQuantBtn.classList.toggle('active', view === 'quant');
            reportEfficBtn.classList.toggle('active', view === 'effic');
        }
        if (view === 'quant') {
            renderRelatorioQuantitativo(currentReportData);
        } else {
            renderRelatorioEficiencia(currentReportData);
        }
    }
    
    function handleResumoTableClick(e) {
        const deleteButton = e.target.closest('.delete-resumo-btn');
        if (deleteButton) {
            const docId = deleteButton.dataset.id;
            showConfirmModal(docId, 'planning');
        }
    }
    
    function renderRelatorioQuantitativo(data) {
        if (!resumoContentContainer) return;
        
        const date = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
        const tableHTML = `
            <h3 class="text-lg font-bold mb-4 no-print">Relatório Quantitativo - ${date}</h3>
            <div class="print-header hidden">
                <h1 class="text-xl font-bold">Hokkaido Synchro - Relatório de Produção</h1>
                <p>Data: ${new Date(date.replace(/-/g, '/')).toLocaleDateString('pt-BR')}</p>
            </div>
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Máquina</th>
                        <th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Produto</th>
                        <th colspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase">Turno 1</th>
                        <th colspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 2</th>
                        <th colspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 3</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">Qtd. Planejada</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">Total Dia</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">Prod. Faltante</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle no-print">Ação</th>
                    </tr>
                    <tr>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase">Prod.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Refugo (kg)</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Prod.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Refugo (kg)</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Prod.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Refugo (kg)</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                    ${data.map(item => {
                        const plannedTotal = coerceToNumber(item.planned_quantity, 0);
                        const producedTotal = coerceToNumber(item.total_produzido, 0);
                        const faltante = plannedTotal - producedTotal;
                        return `
                        <tr>
                            <td class="px-2 py-2 whitespace-nowrap">${item.machine}</td><td class="px-2 py-2 whitespace-nowrap">${item.product}</td>
                            <td class="px-2 py-2 text-center">${(item.T1.produzido || 0).toLocaleString('pt-BR')}</td><td class="px-2 py-2 text-center">${(item.T1.refugo_kg || 0).toFixed(2)}</td>
                            <td class="px-2 py-2 text-center border-l">${(item.T2.produzido || 0).toLocaleString('pt-BR')}</td><td class="px-2 py-2 text-center">${(item.T2.refugo_kg || 0).toFixed(2)}</td>
                            <td class="px-2 py-2 text-center border-l">${(item.T3.produzido || 0).toLocaleString('pt-BR')}</td><td class="px-2 py-2 text-center">${(item.T3.refugo_kg || 0).toFixed(2)}</td>
                            <td class="px-2 py-2 text-center border-l">${plannedTotal.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-2 text-center font-bold border-l">${producedTotal.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-2 text-center font-bold border-l ${faltante > 0 ? 'text-status-error' : 'text-status-success'}">${faltante.toLocaleString('pt-BR')}</td>
                            <td class="px-2 py-2 text-center border-l no-print">
                                <button data-id="${item.id}" class="delete-resumo-btn text-status-error hover:text-red-700 p-1"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </td>
                        </tr>
                    `}).join('')}
                </tbody>
            </table>`;
        resumoContentContainer.innerHTML = tableHTML;
        lucide.createIcons();
    }

    function renderRelatorioEficiencia(data) {
        if (!resumoContentContainer) return;
        
        const formatPercent = (val, isRealTime = false) => {
            const colorClass = val < 0.7 ? 'text-status-error' : val < 0.85 ? 'text-status-warning' : 'text-status-success';
            const realtimeIndicator = isRealTime ? ' ⚡' : '';
            return `<span class="${colorClass}" title="${isRealTime ? 'OEE em Tempo Real' : 'OEE Calculado'}">${(val * 100).toFixed(1)}%${realtimeIndicator}</span>`;
        };
        
        const date = resumoDateSelector ? resumoDateSelector.value : getProductionDateString();
        const today = getProductionDateString();
        const isToday = date === today;
        
        // Se for hoje, calcular OEE em tempo real para cada item
        let realTimeData = {};
        if (isToday) {
            data.forEach(async (item) => {
                const combinedData = [{
                    machine: item.machine,
                    turno: 'T1',
                    produzido: item.T1.produzido || 0,
                    duracao_min: item.T1.paradas || 0,
                    refugo_kg: item.T1.refugo_kg || 0,
                    piece_weight: item.piece_weight,
                    real_cycle_t1: item.real_cycle_t1,
                    active_cavities_t1: item.active_cavities_t1,
                    budgeted_cycle: item.budgeted_cycle,
                    mold_cavities: item.mold_cavities
                }];
                
                const realTimeOee = calculateRealTimeOEE(combinedData);
                if (realTimeOee && realTimeOee.oeeByMachine[item.machine]) {
                    realTimeData[item.machine] = realTimeOee.oeeByMachine[item.machine];
                }
            });
        }
        
        const tableHTML = `
             <h3 class="text-lg font-bold mb-4 no-print">
                Relatório de Eficiência - ${date}
                ${isToday ? '<span class="text-sm text-green-600 ml-2">⚡ Dados em Tempo Real Disponíveis</span>' : ''}
             </h3>
             <div class="print-header hidden">
                <h1 class="text-xl font-bold">Hokkaido Synchro - Relatório de Eficiência</h1>
                <p>Data: ${new Date(date.replace(/-/g, '/')).toLocaleDateString('pt-BR')}</p>
                ${isToday ? '<p class="text-sm">⚡ Inclui dados em tempo real</p>' : ''}
            </div>
            <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                <h4 class="font-semibold text-blue-800 mb-2">Legenda:</h4>
                <div class="flex flex-wrap gap-4 text-sm">
                    <span class="text-status-success">★ ≥85% - Excelente</span>
                    <span class="text-status-warning">★ 70-84% - Aceitável</span>
                    <span class="text-status-error">★ <70% - Crítico</span>
                    ${isToday ? '<span class="text-green-600">⚡ Tempo Real</span>' : ''}
                </div>
            </div>
            <table class="min-w-full divide-y divide-gray-200">
                <thead class="bg-gray-50">
                    <tr>
                        <th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Máquina</th><th rowspan="2" class="px-2 py-2 text-left text-xs font-medium uppercase align-middle">Produto</th>
                        <th colspan="4" class="px-2 py-2 text-center text-xs font-medium uppercase">Turno 1</th>
                        <th colspan="4" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 2</th>
                        <th colspan="4" class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Turno 3</th>
                        <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle">OEE Médio</th>
                         <th rowspan="2" class="px-2 py-2 text-center text-xs font-medium uppercase border-l align-middle no-print">Ação</th>
                    </tr>
                    <tr>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase">Disp.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Perf.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Qual.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase font-bold">OEE</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Disp.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Perf.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Qual.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase font-bold">OEE</th>
                        <th class="px-2 py-2 text-center text-xs font-medium uppercase border-l">Disp.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Perf.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase">Qual.</th><th class="px-2 py-2 text-center text-xs font-medium uppercase font-bold">OEE</th>
                    </tr>
                </thead>
                <tbody class="divide-y divide-gray-200">
                    ${data.map(item => {
                        // Calcular OEE médio
                        const oeeValues = [item.T1.oee, item.T2.oee, item.T3.oee].filter(v => v > 0);
                        const avgOee = oeeValues.length > 0 ? oeeValues.reduce((a, b) => a + b, 0) / oeeValues.length : 0;
                        
                        // Verificar se há dados em tempo real para esta máquina
                        const machineRealTime = realTimeData[item.machine];
                        const hasRealTime = isToday && machineRealTime;
                        
                        return `
                        <tr class="${hasRealTime ? 'bg-green-50' : ''}">
                            <td class="px-2 py-2 whitespace-nowrap font-medium">${item.machine}</td>
                            <td class="px-2 py-2 whitespace-nowrap text-sm">${item.product}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T1.disponibilidade, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T1.performance, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T1.qualidade, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center font-bold">${formatPercent(item.T1.oee, hasRealTime && machineRealTime.T1)}</td>
                            <td class="px-2 py-2 text-center border-l">${formatPercent(item.T2.disponibilidade, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T2.performance, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T2.qualidade, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center font-bold">${formatPercent(item.T2.oee, hasRealTime && machineRealTime.T2)}</td>
                            <td class="px-2 py-2 text-center border-l">${formatPercent(item.T3.disponibilidade, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T3.performance, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center">${formatPercent(item.T3.qualidade, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center font-bold">${formatPercent(item.T3.oee, hasRealTime && machineRealTime.T3)}</td>
                            <td class="px-2 py-2 text-center border-l font-bold text-lg">${formatPercent(avgOee, hasRealTime)}</td>
                            <td class="px-2 py-2 text-center border-l no-print">
                                <button data-id="${item.id}" class="delete-resumo-btn text-status-error hover:text-red-700 p-1"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                            </td>
                        </tr>
                    `;}).join('')}
                </tbody>
            </table>
            ${isToday ? `
            <div class="mt-4 p-3 bg-green-50 border border-green-200 rounded-lg">
                <p class="text-sm text-green-700">
                    <strong>Nota:</strong> Os valores marcados com ⚡ representam cálculos de OEE em tempo real, 
                    atualizados conforme o progresso do turno atual.
                </p>
            </div>
            ` : ''}`;
        resumoContentContainer.innerHTML = tableHTML;
        lucide.createIcons();
    }

    function handlePrintReport() {
        window.print();
    }

    // --- ABA DE ANÁLISE: DASHBOARD ---
    
    async function loadDashboardData() {
        const startDate = startDateSelector ? startDateSelector.value : getProductionDateString();
        const endDate = endDateSelector ? endDateSelector.value : getProductionDateString();

        if (!startDate || !endDate) {
            alert('Por favor, selecione as datas de início e fim.');
            return;
        }
        
        showLoadingState('dashboard', true);
        const dashboardContent = document.getElementById('dashboard-content');
        if (dashboardContent) dashboardContent.style.display = 'none';

        try {
            const prodSnapshot = await db.collection('production_entries').where('data', '>=', startDate).where('data', '<=', endDate).get();
            const productions = prodSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            if (productions.length === 0) {
                fullDashboardData = { perdas: [] };
                populateMachineFilter([]);
                processAndRenderDashboard(fullDashboardData);
                if (dashboardContent) dashboardContent.style.display = 'block';
                showLoadingState('dashboard', false, false);
                return;
            }

            const planIds = [...new Set(productions.map(p => p.planId))];
            const plans = {};
            
            for (let i = 0; i < planIds.length; i += 10) {
                const batchIds = planIds.slice(i, i + 10);
                if (batchIds.length > 0) {
                    const planBatchSnapshot = await db.collection('planning').where(firebase.firestore.FieldPath.documentId(), 'in', batchIds).get();
                    planBatchSnapshot.docs.forEach(doc => {
                        plans[doc.id] = doc.data();
                    });
                }
            }
            
            const combinedData = productions.filter(prod => plans[prod.planId]).map(prod => ({ ...prod, ...plans[prod.planId] }));

            fullDashboardData = { perdas: combinedData };
            
            populateMachineFilter(combinedData);
            if (graphMachineFilter && graphMachineFilter.options.length > 1 && !graphMachineFilter.value) {
                 graphMachineFilter.value = graphMachineFilter.options[1].value;
            }
            processAndRenderDashboard(fullDashboardData);
            
            if (dashboardContent) dashboardContent.style.display = 'block';
            showLoadingState('dashboard', false, false);
        } catch (error) {
            console.error("Erro ao carregar dados do dashboard: ", error);
            showLoadingState('dashboard', false, true);
            const dashboardError = document.getElementById('dashboard-error');
            if (dashboardError) dashboardError.style.display = 'block';
        }
    }

    function processAndRenderDashboard({ perdas }) {
        const mainFilterMachine = machineFilter ? machineFilter.value : 'total';
        const graphFilterMachine = graphMachineFilter ? graphMachineFilter.value : null;

        const filteredDataForKpis = mainFilterMachine === 'total' ? perdas : perdas.filter(p => p.machine === mainFilterMachine);
        const filteredDataForGraphs = graphFilterMachine ? perdas.filter(p => p.machine === graphFilterMachine && p.data >= startDateSelector.value && p.data <= endDateSelector.value) : [];
        
        // Calcular OEE em tempo real
        const realTimeOee = calculateRealTimeOEE(filteredDataForKpis);
        
        // Usar OEE em tempo real se disponível, senão usar cálculo tradicional
        let kpis;
        if (realTimeOee && Object.keys(realTimeOee.oeeByMachine).length > 0) {
            // Calcular médias dos OEEs em tempo real
            const allOeeValues = Object.values(realTimeOee.oeeByMachine)
                .flatMap(machine => Object.values(machine));
            
            if (allOeeValues.length > 0) {
                kpis = {
                    disponibilidade: allOeeValues.reduce((sum, oee) => sum + oee.disponibilidade, 0) / allOeeValues.length,
                    performance: allOeeValues.reduce((sum, oee) => sum + oee.performance, 0) / allOeeValues.length,
                    qualidade: allOeeValues.reduce((sum, oee) => sum + oee.qualidade, 0) / allOeeValues.length,
                    oee: allOeeValues.reduce((sum, oee) => sum + oee.oee, 0) / allOeeValues.length,
                    isRealTime: true,
                    currentShift: realTimeOee.currentShift,
                    tempoDecorrido: realTimeOee.tempoDecorridoMin
                };
            } else {
                kpis = calculateDashboardOEE(filteredDataForKpis);
            }
        } else {
            kpis = calculateDashboardOEE(filteredDataForKpis);
        }
        
        updateKpiCards(kpis);
        
        if (graphFilterMachine) {
            renderProductionTimelineChart(filteredDataForGraphs, graphFilterMachine);
            renderOeeByShiftChart(filteredDataForGraphs, graphFilterMachine);
            renderOeeTrendChart(graphFilterMachine); // Novo gráfico de tendência
        } else {
             if (productionTimelineChartInstance) productionTimelineChartInstance.destroy();
             if (oeeByShiftChartInstance) oeeByShiftChartInstance.destroy();
             if (oeeTrendChartInstance) oeeTrendChartInstance.destroy();
             const messageDiv = document.getElementById('timeline-chart-message');
             if (messageDiv) messageDiv.style.display = 'flex';
        }

        renderParetoChart(filteredDataForKpis);
    }
    
    function calculateDashboardOEE(data) {
        if (data.length === 0) return { disponibilidade: 0, performance: 0, qualidade: 0, oee: 0 };

        let totalTempoProgramado = 0;
        let totalTempoParada = 0;
        let totalProducaoBoa = 0;
        let totalProducaoTeorica = 0;
        let totalRefugoPcs = 0;

        const machineDays = new Set(data.map(d => `${d.machine}-${d.data}`));
        totalTempoProgramado = machineDays.size * 3 * 480;

        data.forEach(item => {
            const cicloReal = item[`real_cycle_${item.turno.toLowerCase()}`] || item.budgeted_cycle;
            const cavAtivas = item[`active_cavities_${item.turno.toLowerCase()}`] || item.mold_cavities;
            const pesoPeca = item.piece_weight;
            
            totalTempoParada += item.duracao_min || 0;
            totalProducaoBoa += item.produzido || 0;

            if (pesoPeca > 0) {
               totalRefugoPcs += Math.round(((item.refugo_kg || 0) * 1000) / pesoPeca);
            }
            
            if (cicloReal > 0 && cavAtivas > 0) {
                const tempoProduzindo = 480 - (item.duracao_min || 0);
                totalProducaoTeorica += (tempoProduzindo * 60 / cicloReal) * cavAtivas;
            }
        });
        
        const tempoProduzindoTotal = totalTempoProgramado - totalTempoParada;

        const disponibilidade = totalTempoProgramado > 0 ? (tempoProduzindoTotal / totalTempoProgramado) : 0;
        const performance = totalProducaoTeorica > 0 ? (totalProducaoBoa / totalProducaoTeorica) : 0;
        const qualidade = (totalProducaoBoa + totalRefugoPcs) > 0 ? (totalProducaoBoa / (totalProducaoBoa + totalRefugoPcs)) : 0;
        const oee = disponibilidade * performance * qualidade;

        return {
            disponibilidade: isNaN(disponibilidade) ? 0 : disponibilidade,
            performance: isNaN(performance) ? 0 : performance,
            qualidade: isNaN(qualidade) ? 0 : qualidade,
            oee: isNaN(oee) ? 0 : oee
        };
    }

    function updateKpiCards(kpis) {
        const disponibilidadeEl = document.getElementById('kpi-disponibilidade');
        const performanceEl = document.getElementById('kpi-performance');
        const qualidadeEl = document.getElementById('kpi-qualidade');
        const oeeEl = document.getElementById('kpi-oee');
        
        if (disponibilidadeEl) {
            const dispValue = (kpis.disponibilidade * 100).toFixed(1) + '%';
            disponibilidadeEl.textContent = dispValue;
            if (kpis.isRealTime) {
                disponibilidadeEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
            }
        }
        
        if (performanceEl) {
            const perfValue = (kpis.performance * 100).toFixed(1) + '%';
            performanceEl.textContent = perfValue;
            if (kpis.isRealTime) {
                performanceEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
            }
        }
        
        if (qualidadeEl) {
            const qualValue = (kpis.qualidade * 100).toFixed(1) + '%';
            qualidadeEl.textContent = qualValue;
            if (kpis.isRealTime) {
                qualidadeEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
            }
        }
        
        if (oeeEl) {
            const oeeValue = (kpis.oee * 100).toFixed(1) + '%';
            oeeEl.textContent = oeeValue;
            if (kpis.isRealTime) {
                oeeEl.title = `Tempo Real - Turno ${kpis.currentShift} (${kpis.tempoDecorrido}min)`;
                oeeEl.style.color = '#059669'; // Verde para indicar tempo real
            } else {
                oeeEl.style.color = '';
            }
        }
    }

    function renderProductionTimelineChart(data, selectedMachine) {
        const ctx = document.getElementById('productionTimelineChart');
        if (!ctx) return;
        
        const messageDiv = document.getElementById('timeline-chart-message');
        
        if (productionTimelineChartInstance) productionTimelineChartInstance.destroy();
        
        if (!selectedMachine || selectedMachine === 'total') {
            ctx.style.display = 'none';
            if (messageDiv) messageDiv.style.display = 'flex';
            return;
        }
        ctx.style.display = 'block';
        if (messageDiv) messageDiv.style.display = 'none';
        
        const hourlyData = {};
        for (let i = 7; i < 24; i++) { hourlyData[`${String(i).padStart(2,'0')}:00`] = 0; }
        for (let i = 0; i < 7; i++) { hourlyData[`${String(i).padStart(2,'0')}:00`] = 0; }

        data.forEach(item => {
            const ts = item.timestamp?.toDate();
            if (!ts) return;
            const hour = `${String(ts.getHours()).padStart(2,'0')}:00`;
            if (hourlyData[hour] !== undefined) {
               hourlyData[hour] += item.produzido || 0;
            }
        });

        const sortedHours = Object.keys(hourlyData).sort((a,b) => {
            const hourA = parseInt(a.split(':')[0]);
            const hourB = parseInt(b.split(':')[0]);
            if (hourA >= 7 && hourB < 7) return -1;
            if (hourA < 7 && hourB >= 7) return 1;
            return hourA - hourB;
        });
        
        let cumulativeTotal = 0;
        const cumulativeProductionData = sortedHours.map(hour => {
            cumulativeTotal += hourlyData[hour];
            return cumulativeTotal;
        });

        const planItem = data.length > 0 ? data.find(d => d.planned_quantity > 0) : null;
        const metaDiaria = planItem ? planItem.planned_quantity : 0;
        const metaPorHora = metaDiaria / 24;
        
        let cumulativeTarget = 0;
        const cumulativeTargetData = sortedHours.map(() => {
            cumulativeTarget += metaPorHora;
            return cumulativeTarget;
        });
        
        let displayLabels = sortedHours;
        let displayProdData = cumulativeProductionData;
        let displayTargetData = cumulativeTargetData;
        
        const todayString = getProductionDateString();
        const viewingToday = (endDateSelector.value === todayString && startDateSelector.value === todayString);

        if (viewingToday) {
            const currentHour = new Date().getHours();
            let currentHourIndex = sortedHours.findIndex(h => parseInt(h.split(':')[0]) === currentHour);
            
            if (currentHourIndex === -1 && currentHour < 7) {
                currentHourIndex = 17 + currentHour;
            } else if (currentHourIndex === -1) {
                currentHourIndex = 23;
            }

            const sliceIndex = Math.min(currentHourIndex + 2, sortedHours.length);

            displayLabels = sortedHours.slice(0, sliceIndex);
            displayProdData = cumulativeProductionData.slice(0, sliceIndex);
            displayTargetData = cumulativeTargetData.slice(0, sliceIndex);
        }

        productionTimelineChartInstance = new Chart(ctx, {
            type: 'line',
            data: {
                labels: displayLabels,
                datasets: [
                    { 
                        label: 'Produção Acumulada', 
                        data: displayProdData, 
                        borderColor: '#0077C2',
                        backgroundColor: 'rgba(0, 119, 194, 0.1)',
                        fill: true,
                        tension: 0.3
                    },
                    {
                        label: 'Meta Acumulada',
                        data: displayTargetData,
                        borderColor: '#DC2626',
                        borderDash: [5, 5],
                        fill: false,
                        pointRadius: 0
                    }
                ]
            },
            options: {
                responsive: true,

                scales: { y: { beginAtZero: true, title: { display: true, text: 'Quantidade de Peças' } } },
                plugins: { 
                    legend: { position: 'top' },
                    tooltip: { mode: 'index', intersect: false }
                },
                hover: { mode: 'index', intersect: false }
            }
        });
    }

    function renderOeeByShiftChart(data, selectedMachine) {
        const ctx = document.getElementById('oeeByShiftChart');
        if (!ctx) return;
        
        if (oeeByShiftChartInstance) oeeByShiftChartInstance.destroy();
        
        if (!selectedMachine || selectedMachine === 'total') {
            return;
        }
        
        const oeeData = { T1: [], T2: [], T3: [] };
        data.forEach(item => {
            const refugoPcs = item.piece_weight > 0 ? ((item.refugo_kg || 0) * 1000) / item.piece_weight : 0;
            const oee = calculateShiftOEE(item.produzido || 0, item.duracao_min || 0, refugoPcs, item[`real_cycle_${item.turno.toLowerCase()}`] || item.budgeted_cycle, item[`active_cavities_${item.turno.toLowerCase()}`] || item.mold_cavities);
            if (oeeData[item.turno]) {
                oeeData[item.turno].push(oee.oee);
            }
        });

        const avgOee = (arr) => arr.length > 0 ? (arr.reduce((a, b) => a + b, 0) / arr.length) * 100 : 0;

        oeeByShiftChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Turno 1', 'Turno 2', 'Turno 3'],
                datasets: [{
                    label: 'Eficiência (OEE)',
                    data: [avgOee(oeeData.T1), avgOee(oeeData.T2), avgOee(oeeData.T3)],
                    backgroundColor: ['#4F46E5', '#10B981', '#0077C2']
                }]
            },
            options: {
                responsive: true,

                scales: { y: { beginAtZero: true, max: 100, ticks: { callback: value => value + '%' } } },
                plugins: { legend: { display: false } }
            }
        });
    }
    
    async function renderOeeTrendChart(selectedMachine) {
        const ctx = document.getElementById('oeeTrendChart');
        if (!ctx) return;
        
        if (oeeTrendChartInstance) oeeTrendChartInstance.destroy();
        
        if (!selectedMachine || selectedMachine === 'total') {
            return;
        }
        
        try {
            // Carregar histórico de OEE dos últimos 7 dias
            const endDate = endDateSelector.value;
            const startDateObj = new Date(endDate);
            startDateObj.setDate(startDateObj.getDate() - 6);
            const startDate = startDateObj.toISOString().split('T')[0];
            
            const oeeHistory = await loadOeeHistory(startDate, endDate, selectedMachine);
            
            if (oeeHistory.length === 0) {
                return;
            }
            
            // Agrupar por dia e turno
            const groupedByDay = groupOeeByPeriod(oeeHistory, 'day');
            
            // Preparar dados para o gráfico
            const dates = Object.keys(groupedByDay).sort();
            const datasets = [
                {
                    label: 'Turno 1',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.shifts.T1 ? (dayData.shifts.T1.avgOee * 100) : null;
                    }),
                    borderColor: '#4F46E5',
                    backgroundColor: 'rgba(79, 70, 229, 0.1)',
                    tension: 0.3,
                    fill: false
                },
                {
                    label: 'Turno 2',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.shifts.T2 ? (dayData.shifts.T2.avgOee * 100) : null;
                    }),
                    borderColor: '#10B981',
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    tension: 0.3,
                    fill: false
                },
                {
                    label: 'Turno 3',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.shifts.T3 ? (dayData.shifts.T3.avgOee * 100) : null;
                    }),
                    borderColor: '#0077C2',
                    backgroundColor: 'rgba(0, 119, 194, 0.1)',
                    tension: 0.3,
                    fill: false
                },
                {
                    label: 'OEE Médio Diário',
                    data: dates.map(date => {
                        const dayData = groupedByDay[date];
                        return dayData.overall.avgOee * 100;
                    }),
                    borderColor: '#DC2626',
                    backgroundColor: 'rgba(220, 38, 38, 0.1)',
                    borderWidth: 3,
                    borderDash: [5, 5],
                    tension: 0.3,
                    fill: false
                }
            ];
            
            // Formatear datas para exibição
            const formattedDates = dates.map(date => {
                const dateObj = new Date(date);
                return dateObj.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
            });
            
            oeeTrendChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: formattedDates,
                    datasets: datasets
                },
                options: {
                    responsive: true,
    
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'OEE (%)'
                            },
                            ticks: {
                                callback: value => value + '%'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Data'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        },
                        title: {
                            display: true,
                            text: `Tendência de OEE - ${selectedMachine} (Últimos 7 dias)`
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + (context.parsed.y || 0).toFixed(1) + '%';
                                }
                            }
                        }
                    },
                    hover: {
                        mode: 'index',
                        intersect: false
                    },
                    elements: {
                        point: {
                            radius: 4,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
        } catch (error) {
            console.error("Erro ao carregar gráfico de tendência de OEE: ", error);
        }
    }

    function renderParetoChart(data) {
        const ctx = document.getElementById('paretoChart');
        if (!ctx) return;
        
        if (paretoChartInstance) paretoChartInstance.destroy();

        const reasonCounts = data.reduce((acc, item) => {
            if(item.motivo_refugo && (item.refugo_kg || 0) > 0) {
                acc[item.motivo_refugo] = (acc[item.motivo_refugo] || 0) + (item.refugo_kg || 0);
            }
            return acc;
        }, {});

        const sortedReasons = Object.entries(reasonCounts).sort(([, a], [, b]) => b - a);
        const labels = sortedReasons.map(([reason]) => reason);
        const values = sortedReasons.map(([, count]) => count);
        const total = values.reduce((sum, val) => sum + val, 0);

        let cumulative = 0;
        const cumulativePercentage = values.map(val => {
            cumulative += val;
            return total > 0 ? (cumulative / total) * 100 : 0;
        });
        
        paretoChartInstance = new Chart(ctx, {
            type: 'bar',
            data: {
                labels,
                datasets: [
                    {
                        label: 'Refugo (kg)',
                        data: values,
                        backgroundColor: 'rgba(220, 38, 38, 0.7)',
                        yAxisID: 'y'
                    },
                    {
                        label: 'Acumulado %',
                        data: cumulativePercentage,
                        type: 'line',
                        borderColor: '#4F46E5',
                        backgroundColor: 'rgba(79, 70, 229, 0.2)',
                        fill: false,
                        tension: 0.1,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    y: { type: 'linear', display: true, position: 'left', beginAtZero: true, title: { display: true, text: 'Kg' }},
                    y1: { type: 'linear', display: true, position: 'right', min: 0, max: 105, grid: { drawOnChartArea: false }, ticks: { callback: value => value + '%' } }
                }
            }
        });
    }
    
    function populateMachineFilter(data) {
        const machines = [...new Set(data.map(item => item.machine))].sort();
        const mainOptions = '<option value="total">Visão Geral (Total)</option>' + machines.map(m => `<option value="${m}">${m}</option>`).join('');
        const graphOptions = '<option value="">Selecione...</option>' + machines.map(m => `<option value="${m}">${m}</option>`).join('');
        if (machineFilter) machineFilter.innerHTML = mainOptions;
        if (graphMachineFilter) graphMachineFilter.innerHTML = graphOptions;
    }

    init();
    // Função para popular opções dos formulários rápidos
    function populateQuickFormOptions() {
        // Popular motivos de perda
        const lossReasonSelect = document.getElementById('quick-losses-reason');
        if (lossReasonSelect) {
            lossReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            // Grupo PROCESSO
            const processoGroup = document.createElement('optgroup');
            processoGroup.label = 'PROCESSO';
            ["BOLHA", "CHUPAGEM", "CONTAMINAÇÃO", "DEGRADAÇÃO", "EMPENAMENTO", "FALHA", 
             "FIAPO", "FORA DE COR", "INÍCIO/REÍNICIO", "JUNÇÃO", "MANCHAS", 
             "MEDIDA FORA DO ESPECIFICADO", "MOÍDO", "PEÇAS PERDIDAS", "QUEIMA", "REBARBA"].forEach(reason => {
                const option = document.createElement('option');
                option.value = reason;
                option.textContent = reason;
                processoGroup.appendChild(option);
            });
            lossReasonSelect.appendChild(processoGroup);
            
            // Grupo FERRAMENTARIA
            const ferramentariaGroup = document.createElement('optgroup');
            ferramentariaGroup.label = 'FERRAMENTARIA';
            ["DEFORMAÇÃO", "GALHO PRESO", "MARCA D'ÁGUA", "MARCA EXTRATOR", "RISCOS", "SUJIDADE"].forEach(reason => {
                const option = document.createElement('option');
                option.value = reason;
                option.textContent = reason;
                ferramentariaGroup.appendChild(option);
            });
            lossReasonSelect.appendChild(ferramentariaGroup);
            
            // Grupo QUALIDADE
            const qualidadeGroup = document.createElement('optgroup');
            qualidadeGroup.label = 'QUALIDADE';
            const option = document.createElement('option');
            option.value = "INSPEÇÃO DE LINHA";
            option.textContent = "INSPEÇÃO DE LINHA";
            qualidadeGroup.appendChild(option);
            lossReasonSelect.appendChild(qualidadeGroup);
        }
        
        // Popular motivos de parada
        const downtimeReasonSelect = document.getElementById('quick-downtime-reason');
        if (downtimeReasonSelect) {
            downtimeReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            // Usar motivos do database.js ou fallback
            const downtimeReasons = getGroupedDowntimeReasons();
            
            Object.entries(downtimeReasons).forEach(([groupName, reasons]) => {
                const group = document.createElement('optgroup');
                group.label = groupName;
                reasons.forEach(reason => {
                    const option = document.createElement('option');
                    option.value = reason;
                    option.textContent = reason;
                    group.appendChild(option);
                });
                downtimeReasonSelect.appendChild(group);
            });
        }

        // Também popular o select de paradas manuais
        const manualDowntimeReasonSelect = document.getElementById('manual-downtime-reason');
        if (manualDowntimeReasonSelect) {
            manualDowntimeReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            // Usar motivos do database.js ou fallback
            const downtimeReasons = getGroupedDowntimeReasons();
            
            Object.entries(downtimeReasons).forEach(([groupName, reasons]) => {
                const group = document.createElement('optgroup');
                group.label = groupName;
                reasons.forEach(reason => {
                    const option = document.createElement('option');
                    option.value = reason;
                    option.textContent = reason;
                    group.appendChild(option);
                });
                manualDowntimeReasonSelect.appendChild(group);
            });
        }
    }

    // ================================
    // NOVO: Função para buscar paradas ativas por máquina
    // ================================
    async function getActiveMachineDowntime(machineId) {
        try {
            if (!window.db) return null;
            
            const normalizedId = normalizeMachineId(machineId);
            const now = new Date();
            const todayStr = now.toISOString().split('T')[0];  // YYYY-MM-DD
            
            // PRIORIDADE 1: Buscar paradas com status='active' (paradas em andamento)
            const activeSnap = await window.db
                .collection('extended_downtime_logs')
                .where('machine_id', '==', normalizedId)
                .where('status', '==', 'active')
                .get();
            
            // Se encontrou parada ativa, retorna imediatamente
            for (const doc of activeSnap.docs) {
                const data = doc.data();
                console.log('[MACHINE-DOWNTIME] Parada ATIVA encontrada:', { id: doc.id, machine: normalizedId, status: data.status });
                return {
                    recordId: doc.id,
                    type: data.type || 'maintenance',
                    reason: data.reason || 'Parada longa ativa',
                    startDate: data.start_date,
                    endDate: data.end_date,
                    status: 'active',
                    durationMinutes: data.duration_minutes
                };
            }
            
            // PRIORIDADE 2: Buscar paradas programadas (com end_date futuro)
            const extendedSnap = await window.db
                .collection('extended_downtime_logs')
                .where('machine_id', '==', normalizedId)
                .get();
            
            for (const doc of extendedSnap.docs) {
                const data = doc.data();
                
                // Ignorar paradas já finalizadas
                if (data.status === 'inactive' || data.status === 'finalized') {
                    continue;
                }
                
                // Verificar se a parada está dentro do período válido
                const startDate = data.start_date ? new Date(data.start_date + 'T00:00:00') : null;
                const endDate = data.end_date ? new Date(data.end_date + 'T23:59:59') : null;
                
                // Parada válida: já começou E (não tem fim OU fim é futuro)
                const hasStarted = startDate && startDate <= now;
                const isOngoing = !endDate || endDate >= now;
                
                if (hasStarted && isOngoing) {
                    return {
                        recordId: doc.id,
                        type: data.type || 'maintenance',
                        reason: data.reason || 'Parada longa ativa',
                        startDate: data.start_date,
                        endDate: data.end_date,
                        status: data.status || 'active',
                        durationMinutes: data.duration_minutes
                    };
                }
            }
            
            return null;
        } catch (error) {
            console.warn('[MACHINE-DOWNTIME] Erro ao buscar paradas:', error);
            return null;
        }
    }

    // NOVO: Função para buscar status de todas as máquinas
    async function getAllMachinesDowntimeStatus() {
        const statusMap = {};
        
        try {
            const promises = machineDatabase.map(async (machine) => {
                const mid = normalizeMachineId(machine.id);
                const downtime = await getActiveMachineDowntime(mid);
                if (downtime) {
                    statusMap[mid] = downtime;
                }
            });
            
            await Promise.all(promises);
        } catch (error) {
            console.error('[MACHINE-STATUS] Erro ao carregar status:', error);
        }
        
        return statusMap;
    }

    // ================================
    // NOVO: Variáveis globais do downtime
    // ================================
    // Armazenar timers de paradas
    const downtimeTimers = new Map();
    
    // Cache de status de paradas (inicializado em renderMachineCards)
    let downtimeStatusCache = {};

    // ============================================================
    // FINALIZAR PARADA - Encerra parada ativa
    // ============================================================
    async function finalizarParada(recordId, machineId) {
        console.log('[FINALIZAR-PARADA] Solicitação de finalização:', { recordId, machineId });
        
        if (!recordId || !machineId) {
            console.error('[FINALIZAR-PARADA] IDs inválidos');
            return;
        }

        try {
            // 1. Buscar o registro de parada ANTES de confirmar
            const recordSnapshot = await db.collection('extended_downtime_logs').doc(recordId).get();
            if (!recordSnapshot.exists) {
                showNotification('Registro de parada não encontrado', 'error');
                return;
            }

            const downtimeData = recordSnapshot.data();
            const now = new Date();
            
            // Calcular duração prévia para mostrar no alerta
            const startDatetime = downtimeData.start_datetime?.toDate?.() || new Date(downtimeData.start_date + 'T' + (downtimeData.start_time || '00:00'));
            const durationMinutes = Math.floor((now - startDatetime) / (1000 * 60));
            const hours = Math.floor(durationMinutes / 60);
            const mins = durationMinutes % 60;
            const durationText = hours > 0 ? `${hours}h ${mins}min` : `${mins}min`;
            
            // Tipo/Motivo da parada
            const reasonText = downtimeData.reason || downtimeData.type || 'Não informado';
            const startText = `${downtimeData.start_date || ''} às ${downtimeData.start_time || ''}`;
            
            // 2. ALERTA DE CONFIRMAÇÃO
            const confirmMessage = `⚠️ FINALIZAR PARADA LONGA?\n\n` +
                `🏭 Máquina: ${machineId}\n` +
                `📋 Motivo: ${reasonText}\n` +
                `🕐 Início: ${startText}\n` +
                `⏱️ Duração: ${durationText}\n\n` +
                `Deseja realmente finalizar esta parada?`;
            
            if (!confirm(confirmMessage)) {
                console.log('[FINALIZAR-PARADA] Usuário cancelou a finalização');
                showNotification('Finalização cancelada', 'info');
                return;
            }
            
            // 3. Usuário confirmou - prosseguir com finalização
            console.log('[FINALIZAR-PARADA] Usuário confirmou - encerrando parada');
            
            const endDate = now.toISOString().split('T')[0];  // YYYY-MM-DD
            const endTime = now.toTimeString().split(' ')[0].substring(0, 5);  // HH:MM

            // 4. Atualizar registro: marcar como inativo/finalizado
            await db.collection('extended_downtime_logs').doc(recordId).update({
                end_date: endDate,
                end_time: endTime,
                end_datetime: firebase.firestore.Timestamp.fromDate(now),
                duration_minutes: durationMinutes,
                status: 'inactive',  // Muda de 'active' para 'inactive'
                updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedBy: getActiveUser()?.name || 'Sistema'
            });

            console.log('[FINALIZAR-PARADA] Registrado como finalizado:', { 
                recordId, 
                machineId, 
                durationMinutes: `${hours}h ${mins}m`
            });

            // 5. Limpar cache e timers
            const mid = normalizeMachineId(machineId);
            
            // Limpar status cache
            if (window.downtimeStatusCache && window.downtimeStatusCache[mid]) {
                delete window.downtimeStatusCache[mid];
            }

            // Limpar timer de cronômetro
            if (window.downtimeTimers && window.downtimeTimers.has(mid)) {
                clearInterval(window.downtimeTimers.get(mid));
                window.downtimeTimers.delete(mid);
            }

            // 6. Mostrar notificação de sucesso
            showNotification(
                `✅ Parada finalizada para ${mid} após ${durationText}`,
                'success'
            );

            // 7. Re-renderizar painel de máquinas (recarrega todos os dados)
            if (typeof populateMachineSelector === 'function') {
                console.log('[FINALIZAR-PARADA] Recarregando painel de máquinas...');
                await populateMachineSelector();
            }

            // 8. Recarregar lista de paradas (se tab está aberta)
            if (typeof loadExtendedDowntimeList === 'function') {
                await loadExtendedDowntimeList();
            }

        } catch (error) {
            console.error('[FINALIZAR-PARADA] Erro:', error);
            showNotification(`Erro ao finalizar parada: ${error.message}`, 'error');
        }
    }

    // NOVO: Função auxiliar para obter cor do badge baseado no tipo
    function getDowntimeTypeColor(type) {
        const colors = {
            'maintenance': 'bg-blue-100 text-blue-800',
            'preventive': 'bg-blue-100 text-blue-800',
            'maintenance_planned': 'bg-blue-100 text-blue-800',
            'no_order': 'bg-red-100 text-red-800',
            'commercial': 'bg-amber-100 text-amber-800',
            'weekend': 'bg-gray-100 text-gray-800',
            'holiday': 'bg-purple-100 text-purple-800',
            'setup': 'bg-green-100 text-green-800',
            'other': 'bg-gray-100 text-gray-800'
        };
        return colors[type] || 'bg-gray-100 text-gray-800';
    }

    // NOVO: Função auxiliar para obter rótulo do tipo
    function getDowntimeTypeLabel(type) {
        const labels = {
            'maintenance': 'Manutenção Preventiva',
            'preventive': 'Manutenção Preventiva',
            'maintenance_planned': 'Manutenção Programada',
            'maintenance_emergency': 'Manutenção Emergencial',
            'no_order': 'Sem Pedido',
            'commercial': 'Parada Comercial',
            'weekend': 'Fim de Semana',
            'holiday': 'Feriado',
            'setup': 'Setup/Troca',
            'other': 'Outro'
        };
        return labels[type] || type;
    }

    // ================================
    // NOVO: Funções para cronômetro de parada
    // ================================
    
    // Calcular duração da parada em tempo real
    function getDowntimeDuration(startDate) {
        try {
            const start = new Date(startDate);
            const now = new Date();
            const diffMs = now.getTime() - start.getTime();
            
            if (diffMs < 0) return '0h 0m';
            
            const totalSeconds = Math.floor(diffMs / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds}s`;
            } else {
                return `${seconds}s`;
            }
        } catch (e) {
            return '0h 0m';
        }
    }
    
    // Iniciar cronômetro para uma máquina parada
    function startDowntimeTimer(machineId, cardElement) {
        try {
            // Verificar se cardElement é válido
            if (!cardElement || typeof cardElement.querySelector !== 'function') {
                console.warn('[DOWNTIME-TIMER] cardElement inválido para máquina:', machineId);
                return;
            }
            
            // Limpar timer anterior se existir
            if (downtimeTimers.has(machineId)) {
                clearInterval(downtimeTimers.get(machineId));
            }
            
            // Atualizar a cada segundo
            const interval = setInterval(() => {
                const timerElement = cardElement?.querySelector(`[data-timer-machine="${machineId}"]`);
                if (timerElement && window.db) {
                    // Buscar parada atual
                    const statusMap = downtimeStatusCache || {};
                    const downtime = statusMap[machineId];
                    
                    if (downtime) {
                        const duration = getDowntimeDuration(downtime.startDate);
                        timerElement.textContent = duration;
                    }
                } else if (!timerElement) {
                    // Elemento removido, limpar interval
                    clearInterval(interval);
                    downtimeTimers.delete(machineId);
                }
            }, 1000);
            
            downtimeTimers.set(machineId, interval);
        } catch (e) {
            console.warn('[DOWNTIME-TIMER] Erro ao iniciar timer:', e);
        }
    }

// Função de debug para modais
window.debugModals = function() {
    console.log('📍 DEBUG MODALS - Checking all modals...');
    
    const allModals = document.querySelectorAll('[id$="-modal"]');
    allModals.forEach(modal => {
        const rect = modal.getBoundingClientRect();
        const computed = window.getComputedStyle(modal);
        
        console.log(`📋 Modal: ${modal.id}`);
        console.log(`  - Hidden class: ${modal.classList.contains('hidden')}`);
        console.log(`  - Display: ${computed.display}`);
        console.log(`  - Opacity: ${computed.opacity}`);
        console.log(`  - Z-index: ${computed.zIndex}`);
        console.log(`  - Visibility: ${computed.visibility}`);
        console.log(`  - Position: ${rect.top}, ${rect.left} (${rect.width}x${rect.height})`);
        console.log(`  - In viewport: ${rect.top >= 0 && rect.left >= 0 && rect.bottom <= window.innerHeight && rect.right <= window.innerWidth}`);
        console.log('---');
    });
    
    return 'Debug complete. Check console for details.';
};

// Função para forçar abertura de qualquer modal
window.forceOpenModal = function(modalId) {
    console.log(`🔧 FORCE OPEN MODAL: ${modalId}`);
    
    const modal = document.getElementById(modalId);
    if (!modal) {
        console.error(`❌ Modal ${modalId} not found`);
        return false;
    }

    modalManager.portalize(modal);
    modal.setAttribute('data-modal-open', 'true');
    modal.setAttribute('aria-hidden', 'false');
    modal.classList.remove('hidden');
    modalManager.applyStyles(modal);

    const modalContent = modal.querySelector('.bg-white, .modal-content, [class*="bg-white"]');
    if (modalContent) {
        modalManager.applyContentStyles(modalContent);
    }

    requestAnimationFrame(() => modalManager.verify(modal));
    console.log(`✅ Modal ${modalId} forced open via modalManager`);
    return true;
};

    // Função para popular o modal de BORRA com máquinas e motivos do database.js
    function populateBorraModal() {
        // Popular máquinas no modal de BORRA
        const borraMachineSelect = document.getElementById('manual-borra-machine');
        if (borraMachineSelect) {
            borraMachineSelect.innerHTML = '<option value="">Selecione...</option>';
            machineDatabase.forEach(machine => {
                const option = document.createElement('option');
                const mid = normalizeMachineId(machine.id);
                option.value = mid;
                option.textContent = `${mid} - ${machine.model}`;
                borraMachineSelect.appendChild(option);
            });
            console.log('✅ Máquinas do modal de BORRA populadas');
        }

        // Popular motivos no modal de BORRA usando database.js
        const borraReasonSelect = document.getElementById('manual-borra-reason');
        if (borraReasonSelect) {
            borraReasonSelect.innerHTML = '<option value="">Selecione o motivo...</option>';
            
            const groupedReasons = getGroupedLossReasons();
            Object.entries(groupedReasons).forEach(([groupName, reasons]) => {
                const group = document.createElement('optgroup');
                group.label = groupName;
                reasons.forEach(reason => {
                    const option = document.createElement('option');
                    option.value = reason;
                    option.textContent = reason;
                    group.appendChild(option);
                });
                borraReasonSelect.appendChild(group);
            });
            console.log('✅ Motivos do modal de BORRA populados via database.js');
        }
    }

    // ======================================
    // QUALIDADE: Carregamento e renderização hora-a-hora
    // ======================================

    function loadQualityHourlyRecords() {
        console.log(`📍 loadQualityHourlyRecords() chamada`);
        console.log(`  currentQualityContext:`, currentQualityContext);
        
        if (!currentQualityContext) {
            console.log(`  ❌ currentQualityContext está vazio!`);
            return;
        }

        const { plan, hourly_entries } = currentQualityContext;
        console.log(`  plan:`, plan);
        console.log(`  hourly_entries (${hourly_entries?.length || 0} items):`, hourly_entries);
        
        if (!plan || !hourly_entries || hourly_entries.length === 0) {
            console.log(`  ⚠️ Sem dados - renderizando mensagem vazia`);
            if (qualityHourlyContainer) {
                qualityHourlyContainer.innerHTML = '<div id="quality-hourly-empty" class="py-6 text-center text-sm text-gray-500">Nenhum apontamento de produção registrado para este plano e data.</div>';
            }
            return;
        }

        // Agrupar por hora e calcular sacos
        const hourlyGroups = {};
        hourly_entries.forEach(entry => {
            const hora = entry.hora || '00:00';
            if (!hourlyGroups[hora]) {
                hourlyGroups[hora] = [];
            }
            hourlyGroups[hora].push(entry);
        });

        console.log(`  ✅ Agrupado por hora:`, hourlyGroups);
        renderQualityHourlyTable(hourlyGroups, plan);
    }

    function renderQualityHourlyTable(hourlyGroups, plan) {
        if (!qualityHourlyContainer) return;

        const cavitiesStandard = Number(plan?.mold_cavities) || 1;
        const horas = Object.keys(hourlyGroups).sort();

        let html = '<div class="overflow-x-auto">';
        html += '<table class="min-w-full divide-y divide-gray-200 border rounded-lg">';
        html += '<thead class="bg-gray-50"><tr>';
        html += '<th class="px-4 py-2 text-left text-xs font-semibold uppercase tracking-wide text-gray-600">Hora</th>';
        html += '<th class="px-4 py-2 text-right text-xs font-semibold uppercase tracking-wide text-gray-600">Quantidade (pcs)</th>';
        html += '<th class="px-4 py-2 text-right text-xs font-semibold uppercase tracking-wide text-gray-600">Sacos</th>';
        html += '<th class="px-4 py-2 text-right text-xs font-semibold uppercase tracking-wide text-gray-600">Cavidades</th>';
        html += '<th class="px-4 py-2 text-center text-xs font-semibold uppercase tracking-wide text-gray-600">Inspeção</th>';
        html += '<th class="px-4 py-2 text-left text-xs font-semibold uppercase tracking-wide text-gray-600">Observações</th>';
        html += '<th class="px-4 py-2 text-center text-xs font-semibold uppercase tracking-wide text-gray-600">Ação</th>';
        html += '</tr></thead>';
        html += '<tbody class="divide-y divide-gray-200">';

        horas.forEach((hora, index) => {
            const entries = hourlyGroups[hora];
            const totalQty = entries.reduce((sum, e) => sum + (Number(e.quantidade) || 0), 0);
            const totalEmbalagens = entries.reduce((sum, e) => sum + (Number(e.embalagem_fechada) || 0), 0);
            const sacos = totalEmbalagens > 0 ? totalEmbalagens : Math.ceil(totalQty / cavitiesStandard);
            const formId = `quality-hourly-form-${index}`;

            html += `<tr class="hover:bg-emerald-50">`;
            html += `<td class="px-4 py-3 text-sm font-medium text-gray-800">${hora}</td>`;
            html += `<td class="px-4 py-3 text-right text-sm text-gray-600">${totalQty}</td>`;
            html += `<td class="px-4 py-3 text-right text-sm font-semibold text-emerald-700">${sacos}</td>`;
            html += `<td class="px-4 py-3 text-right text-sm text-gray-600">${cavitiesStandard}</td>`;
            
            // Coluna: OK / Não OK (radio buttons)
            html += `<td class="px-4 py-3 text-center">`;
            html += `<div class="flex items-center justify-center gap-3">`;
            html += `<label class="inline-flex items-center gap-1 text-xs text-green-600 cursor-pointer">`;
            html += `<input type="radio" name="quality-ok-${index}" value="ok" class="quality-inspection-radio" data-hora="${hora}" data-index="${index}">`;
            html += `OK`;
            html += `</label>`;
            html += `<label class="inline-flex items-center gap-1 text-xs text-red-600 cursor-pointer">`;
            html += `<input type="radio" name="quality-ok-${index}" value="nao-ok" class="quality-inspection-radio" data-hora="${hora}" data-index="${index}">`;
            html += `Não OK`;
            html += `</label>`;
            html += `</div>`;
            html += `</td>`;
            
            // Coluna: Observações
            html += `<td class="px-4 py-3">`;
            html += `<textarea id="quality-obs-${index}" class="quality-obs-textarea w-full px-2 py-1 text-xs rounded border border-gray-300 focus:border-emerald-500 focus:ring-emerald-500" placeholder="Observações..." rows="2"></textarea>`;
            html += `</td>`;
            
            // Coluna: Botão Salvar
            html += `<td class="px-4 py-3 text-center">`;
            html += `<button type="button" class="quality-save-hourly-btn inline-flex items-center justify-center gap-1 rounded-lg bg-emerald-600 px-3 py-1 text-xs font-semibold text-white shadow-sm transition hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-500" data-hora="${hora}" data-index="${index}" data-qty="${totalQty}" data-sacos="${sacos}" data-cavities="${cavitiesStandard}">`;
            html += `<i data-lucide="save" class="w-3 h-3"></i>`;
            html += `Salvar`;
            html += `</button>`;
            html += `</td>`;
            html += `</tr>`;
        });

        html += '</tbody></table></div>';
        qualityHourlyContainer.innerHTML = html;

        // Adicionar event listeners
        document.querySelectorAll('.quality-save-hourly-btn').forEach(btn => {
            btn.addEventListener('click', handleQualityHourlyRowSubmit);
        });

        lucide.createIcons();
    }

    function handleQualityHourlyRowSubmit(event) {
        event.preventDefault();
        const btn = event.currentTarget;
        const index = btn.getAttribute('data-index');
        const hora = btn.getAttribute('data-hora');
        const qty = Number(btn.getAttribute('data-qty')) || 0;
        const sacos = Number(btn.getAttribute('data-sacos')) || 0;
        const cavities = Number(btn.getAttribute('data-cavities')) || 1;

        // Capturar status de inspeção (OK / Não OK)
        const inspectionRadio = document.querySelector(`input[name="quality-ok-${index}"]:checked`);
        if (!inspectionRadio) {
            showNotification('Por favor, marque OK ou Não OK para esta hora', 'warning');
            return;
        }
        const inspectionStatus = inspectionRadio.value;

        // Capturar observações
        const obsTextarea = document.getElementById(`quality-obs-${index}`);
        const observations = obsTextarea ? obsTextarea.value.trim() : '';

        // Montar payload
        const payload = {
            planId: currentQualityContext.plan.id,
            date: currentQualityContext.plan.date,
            hora: hora,
            turno: currentQualityContext.plan.turno || '1',
            quantity: qty,
            bags: sacos,
            cavitiesStandard: cavities,
            inspectionStatus: inspectionStatus, // 'ok' ou 'nao-ok'
            observations: observations,
            registeredBy: getCurrentUserName(),
            createdAt: new Date().toISOString()
        };

        // Salvar no Firestore
        if (!db) {
            showNotification('Banco de dados não inicializado', 'error');
            return;
        }

        // Bloquear botão durante salvamento
        btn.disabled = true;
        btn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin mr-1"></i>Salvando...';

        db.collection('qualityHourly').add(payload).then(docRef => {
            console.log('Controle de qualidade salvo com sucesso:', docRef.id);
            showNotification('Controle de qualidade registrado com sucesso!', 'success');
            
            // Recarregar dados de qualidade
            loadQualityHourlyControls();
            
        }).catch(error => {
            console.error('Erro ao salvar controle de qualidade:', error);
            showNotification('Erro ao salvar controle de qualidade: ' + error.message, 'error');
        }).finally(() => {
            // Reativar botão
            btn.disabled = false;
            btn.innerHTML = '<i data-lucide="save" class="w-4 h-4 mr-1"></i>Salvar';
            lucide.createIcons();
        });
    }

    // ============================================================
    // EXPOR FUNÇÕES GLOBALMENTE para HTML onclick handlers
    // ============================================================
    // Essas funções estão definidas dentro do DOMContentLoaded, mas precisam
    // ser acessadas pelo HTML onclick. Exposição via window permite acesso global.
    window.finalizarParada = finalizarParada;
    window.getActiveUser = getActiveUser;
    window.showNotification = showNotification;
    window.getActiveMachineDowntime = getActiveMachineDowntime;
    window.getAllMachinesDowntimeStatus = getAllMachinesDowntimeStatus;
    window.normalizeMachineId = normalizeMachineId;
    window.renderMachineCards = renderMachineCards;
    window.loadExtendedDowntimeList = loadExtendedDowntimeList;
    window.populateMachineSelector = populateMachineSelector;
    
    // Expor variáveis de cache para acesso em finalizarParada
    window.downtimeStatusCache = downtimeStatusCache;
    window.downtimeTimers = downtimeTimers;
    
    console.log('[GLOBAL-EXPOSURES] Funções de parada expostas no window global');
});

// Funções globais para navegação de subtabs Analytics IA
window.showPredictiveSubtab = function(subtabName) {
    // Esconder todas as subtabs
    const subtabs = document.querySelectorAll('.predictive-subtab-content');
    subtabs.forEach(tab => tab.classList.add('hidden'));
    
    // Remover classe ativa de todos os botões (novo estilo moderno)
    const buttons = document.querySelectorAll('.predictive-subtab-btn');
    buttons.forEach(btn => {
        btn.classList.remove('bg-gradient-to-r', 'from-purple-600', 'to-indigo-600', 'bg-purple-600', 'text-white', 'shadow-sm');
        btn.classList.add('bg-gray-50', 'text-gray-600');
    });
    
    // Mostrar subtab selecionada
    const targetTab = document.getElementById(`predictive-${subtabName}-content`);
    if (targetTab) {
        targetTab.classList.remove('hidden');
    }
    
    // Ativar botão clicado com novo estilo
    const clickedButton = event?.target?.closest('.predictive-subtab-btn');
    if (clickedButton) {
        clickedButton.classList.remove('bg-gray-50', 'text-gray-600', 'bg-gray-200', 'text-gray-700');
        clickedButton.classList.add('bg-purple-600', 'text-white', 'shadow-sm');
    }

    // Inicializar módulos específicos da subtab
    if (subtabName === 'dashboard' && window.analyticsIA) {
        console.log('[Analytics IA] Dashboard selecionado, inicializando...');
        setTimeout(async () => {
            try {
                if (!window.analyticsIA.isInitialized) {
                    await window.analyticsIA.initialize();
                } else {
                    window.analyticsIA.updateDashboard();
                }
            } catch (err) {
                console.error('[Analytics IA] Erro ao inicializar dashboard:', err);
            }
        }, 150);
    }

    if (subtabName === 'ranking' && window.analyticsIA) {
        console.log('[Analytics IA] Ranking selecionado, atualizando...');
        setTimeout(async () => {
            try {
                await window.analyticsIA.updateRanking();
            } catch (err) {
                console.error('[Analytics IA] Erro ao atualizar ranking:', err);
            }
        }, 150);
    }

    if (subtabName === 'spc' && window.spcController) {
        console.log('[SPC] Subtab SPC selecionada, inicializando...');
        // Pequeno delay para garantir que o container está visível
        setTimeout(async () => {
            try {
                if (!window.spcController.spcData.lastUpdate) {
                    console.log('[SPC] Primeira inicialização do SPC...');
                    await window.spcController.initialize();
                } else {
                    console.log('[SPC] SPC já inicializado, atualizando interface...');
                    window.spcController.updateSPCInterface();
                }
            } catch (err) {
                console.error('[SPC] Erro ao inicializar:', err);
            }
        }, 150);
    }

    const refreshBtn = document.getElementById('traceability-refresh-btn');
    if (refreshBtn) {
        if (subtabName === 'traceability') {
            refreshBtn.classList.remove('hidden');
        } else {
            refreshBtn.classList.add('hidden');
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = refreshBtn.dataset.defaultLabel || refreshBtn.innerHTML;
            refreshBtn.classList.remove('opacity-60', 'cursor-not-allowed');
        }
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }
    }
    
    console.log(`[PREDICTIVE-NAV] Navegando para subtab: ${subtabName}`);
};

// ===== NOVO: Importador de Ordens do ERP Sankhya =====

// Estado global do importador
window.importOrdersState = {
    file: null,
    parsedOrders: [],
    selectedRows: new Set()
};

// Abrir modal de importação
function openImportOrdersModal() {
    const modal = document.getElementById('import-orders-modal');
    if (modal) {
        modal.classList.remove('hidden');
        resetImportModal();
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Fechar modal de importação
function closeImportOrdersModal() {
    const modal = document.getElementById('import-orders-modal');
    if (modal) {
        modal.classList.add('hidden');
        resetImportModal();
    }
}

// Resetar estado do modal
function resetImportModal() {
    window.importOrdersState = { file: null, parsedOrders: [], selectedRows: new Set() };
    
    document.getElementById('import-file-input').value = '';
    document.getElementById('import-upload-area').classList.remove('hidden');
    document.getElementById('import-file-info').classList.add('hidden');
    document.getElementById('import-config').classList.add('hidden');
    document.getElementById('import-preview').classList.add('hidden');
    document.getElementById('import-status').classList.add('hidden');
    document.getElementById('import-execute-btn').disabled = true;
}

// Limpar arquivo selecionado
function clearImportFile() {
    resetImportModal();
}

// Handler para seleção de arquivo
function handleImportFileSelect(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    window.importOrdersState.file = file;
    
    // Mostrar info do arquivo
    document.getElementById('import-upload-area').classList.add('hidden');
    document.getElementById('import-file-info').classList.remove('hidden');
    document.getElementById('import-file-name').textContent = file.name;
    document.getElementById('import-file-size').textContent = formatFileSize(file.size);
    
    // Processar arquivo
    parseImportExcel(file);
}

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' bytes';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// Parsear arquivo Excel do ERP Sankhya
async function parseImportExcel(file) {
    try {
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        
        // Converter para array de arrays para ter acesso às linhas brutas
        const rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
        
        console.log('[Import] Dados brutos:', rawData.slice(0, 5));
        
        // Encontrar a linha de cabeçalho (contém "Nro. OP", "Centro de Trabalho", etc)
        let headerRowIndex = -1;
        let headers = [];
        
        for (let i = 0; i < Math.min(10, rawData.length); i++) {
            const row = rawData[i];
            if (row && row.some(cell => String(cell).includes('Nro. OP') || String(cell).includes('Centro de Trabalho'))) {
                headerRowIndex = i;
                headers = row.map(h => String(h || '').trim());
                break;
            }
        }
        
        if (headerRowIndex === -1) {
            alert('Formato de arquivo não reconhecido. Certifique-se de que é um relatório de Ordens de Produção do ERP.');
            resetImportModal();
            return;
        }
        
        console.log('[Import] Cabeçalhos encontrados na linha', headerRowIndex + 1, ':', headers);
        
        // Mapear índices das colunas
        const colIndex = {
            centroTrabalho: headers.findIndex(h => h.includes('Centro de Trabalho')),
            nroOP: headers.findIndex(h => h === 'Nro. OP' || h.includes('Nro. OP')),
            tamLote: headers.findIndex(h => h.includes('Tam. Lote')),
            saldoProduzir: headers.findIndex(h => h.includes('Saldo a Produzir')),
            produtoAcabado: headers.findIndex(h => h.includes('Produto Acabado')),
            status: headers.findIndex(h => h === 'Status'),
            descrProduto: headers.findIndex(h => h.includes('Descr. Produto')),
            nroLote: headers.findIndex(h => h === 'Nro. Lote' || h.includes('Nro. Lote')),
            cliente: headers.findIndex(h => h.includes('Nome Parceiro')),
            observacoes: headers.findIndex(h => h.includes('Observações'))
        };
        
        console.log('[Import] Índices de colunas:', colIndex);
        
        // Extrair dados das linhas após o cabeçalho
        const orders = [];
        for (let i = headerRowIndex + 1; i < rawData.length; i++) {
            const row = rawData[i];
            if (!row || row.length === 0) continue;
            
            // Pegar valores das colunas
            const centroTrabalho = colIndex.centroTrabalho >= 0 ? String(row[colIndex.centroTrabalho] || '') : '';
            const nroOP = colIndex.nroOP >= 0 ? String(row[colIndex.nroOP] || '') : '';
            const tamLote = colIndex.tamLote >= 0 ? row[colIndex.tamLote] : '';
            const saldoProduzir = colIndex.saldoProduzir >= 0 ? row[colIndex.saldoProduzir] : '';
            const produtoAcabado = colIndex.produtoAcabado >= 0 ? String(row[colIndex.produtoAcabado] || '') : '';
            const status = colIndex.status >= 0 ? String(row[colIndex.status] || '') : '';
            const descrProduto = colIndex.descrProduto >= 0 ? String(row[colIndex.descrProduto] || '') : '';
            const nroLote = colIndex.nroLote >= 0 ? String(row[colIndex.nroLote] || '') : '';
            const cliente = colIndex.cliente >= 0 ? String(row[colIndex.cliente] || '') : '';
            
            // Validar se é uma linha de dados (tem número de OP válido)
            if (!nroOP || nroOP === '' || isNaN(Number(nroOP))) continue;
            
            // Extrair código da máquina do Centro de Trabalho (ex: "3 - H02 - SANDRETTO" -> "H02")
            let machineId = '';
            if (centroTrabalho) {
                const match = centroTrabalho.match(/\d+\s*-\s*([A-Z0-9]+)/i);
                if (match) {
                    machineId = match[1].toUpperCase();
                } else {
                    machineId = centroTrabalho.split('-')[0]?.trim() || centroTrabalho;
                }
            }
            
            // Converter status do ERP para status do sistema
            let systemStatus = 'planejada';
            const statusLower = status.toLowerCase();
            if (statusLower.includes('andamento')) systemStatus = 'em_andamento';
            else if (statusLower.includes('criado')) systemStatus = 'planejada';
            else if (statusLower.includes('conclu') || statusLower.includes('finaliz')) systemStatus = 'concluida';
            else if (statusLower.includes('cancel')) systemStatus = 'cancelada';
            
            orders.push({
                index: orders.length,
                order_number: nroOP.trim(),
                part_code: produtoAcabado.trim(),
                part_name: descrProduto.trim(),
                machine_id: machineId,
                machine_full: centroTrabalho,
                customer: cliente.trim(),
                lot_size: parseImportNumber(tamLote) || 0,
                remaining: parseImportNumber(saldoProduzir) || 0,
                batch_number: nroLote.trim(),
                status_erp: status,
                status: systemStatus,
                selected: true
            });
        }
        
        console.log('[Import] Ordens extraídas:', orders.length, orders);
        
        if (orders.length === 0) {
            alert('Nenhuma ordem de produção válida encontrada no arquivo.');
            resetImportModal();
            return;
        }
        
        // Atualizar estado
        window.importOrdersState.parsedOrders = orders;
        window.importOrdersState.selectedRows = new Set(orders.map((_, i) => i));
        
        // Mostrar configurações e preview
        document.getElementById('import-config').classList.remove('hidden');
        document.getElementById('import-preview').classList.remove('hidden');
        document.getElementById('import-records-count').textContent = `${orders.length} registros encontrados`;
        document.getElementById('import-execute-btn').disabled = false;
        
        // Popular select de máquinas
        populateImportMachineSelect(orders);
        
        // Renderizar preview
        renderImportPreview(orders);
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
    } catch (error) {
        console.error('[Import] Erro ao processar arquivo:', error);
        alert('Erro ao processar arquivo Excel: ' + error.message);
        resetImportModal();
    }
}

// Popular select de máquinas
function populateImportMachineSelect(orders) {
    const select = document.getElementById('import-default-machine');
    if (!select) return;
    
    const machines = [...new Set(orders.map(o => o.machine_id).filter(m => m))];
    select.innerHTML = '<option value="">Usar do arquivo</option>';
    machines.forEach(m => {
        select.innerHTML += `<option value="${m}">${m}</option>`;
    });
}

// Renderizar preview da tabela
function renderImportPreview(orders) {
    const tbody = document.getElementById('import-preview-body');
    if (!tbody) return;
    
    tbody.innerHTML = orders.map((order, idx) => `
        <tr class="hover:bg-gray-50 ${order.selected ? '' : 'opacity-50'}">
            <td class="px-3 py-2">
                <input type="checkbox" 
                       class="import-row-checkbox w-4 h-4 text-indigo-600 rounded" 
                       data-index="${idx}" 
                       ${order.selected ? 'checked' : ''}
                       onchange="toggleImportRow(${idx}, this.checked)">
            </td>
            <td class="px-3 py-2 font-medium text-gray-800">${order.order_number}</td>
            <td class="px-3 py-2">${order.part_code}</td>
            <td class="px-3 py-2 text-gray-600 text-xs max-w-xs truncate" title="${order.part_name}">${order.part_name || '-'}</td>
            <td class="px-3 py-2">
                <span class="px-2 py-0.5 bg-blue-100 text-blue-700 rounded text-xs font-medium">${order.machine_id || '-'}</span>
            </td>
            <td class="px-3 py-2 text-center font-medium">${order.lot_size.toLocaleString('pt-BR')}</td>
            <td class="px-3 py-2">
                <span class="px-2 py-0.5 rounded text-xs font-medium ${getStatusBadgeClass(order.status)}">${order.status_erp || order.status}</span>
            </td>
            <td class="px-3 py-2 text-gray-600 text-xs max-w-xs truncate" title="${order.customer}">${order.customer || '-'}</td>
        </tr>
    `).join('');
}

function getStatusBadgeClass(status) {
    switch(status) {
        case 'em_andamento': return 'bg-amber-100 text-amber-700';
        case 'concluida': return 'bg-green-100 text-green-700';
        case 'cancelada': return 'bg-red-100 text-red-700';
        default: return 'bg-gray-100 text-gray-700';
    }
}

// Toggle seleção de linha
function toggleImportRow(index, checked) {
    const orders = window.importOrdersState.parsedOrders;
    if (orders[index]) {
        orders[index].selected = checked;
        if (checked) {
            window.importOrdersState.selectedRows.add(index);
        } else {
            window.importOrdersState.selectedRows.delete(index);
        }
    }
    updateImportSelectAll();
}

// Toggle todas as linhas
function toggleAllImportRows(checked) {
    const orders = window.importOrdersState.parsedOrders;
    orders.forEach((order, idx) => {
        order.selected = checked;
        if (checked) {
            window.importOrdersState.selectedRows.add(idx);
        } else {
            window.importOrdersState.selectedRows.delete(idx);
        }
    });
    renderImportPreview(orders);
}

function updateImportSelectAll() {
    const checkbox = document.getElementById('import-select-all');
    const orders = window.importOrdersState.parsedOrders;
    const allSelected = orders.every(o => o.selected);
    const someSelected = orders.some(o => o.selected);
    
    if (checkbox) {
        checkbox.checked = allSelected;
        checkbox.indeterminate = someSelected && !allSelected;
    }
}

// Executar importação
async function executeImportOrders() {
    const orders = window.importOrdersState.parsedOrders.filter(o => o.selected);
    
    if (orders.length === 0) {
        alert('Selecione pelo menos uma ordem para importar.');
        return;
    }
    
    const skipExisting = document.getElementById('import-skip-existing')?.checked ?? true;
    const defaultStatus = document.getElementById('import-default-status')?.value || 'from_file';
    const defaultMachine = document.getElementById('import-default-machine')?.value || '';
    
    // Mostrar status
    document.getElementById('import-config').classList.add('hidden');
    document.getElementById('import-preview').classList.add('hidden');
    document.getElementById('import-status').classList.remove('hidden');
    document.getElementById('import-result').classList.add('hidden');
    document.getElementById('import-progress-container').classList.remove('hidden');
    document.getElementById('import-execute-btn').disabled = true;
    
    let imported = 0;
    let skipped = 0;
    let errors = 0;
    
    try {
        // Verificar ordens existentes
        const existingOrders = new Set();
        if (skipExisting) {
            const snapshot = await db.collection('production_orders').get();
            snapshot.forEach(doc => {
                const data = doc.data();
                if (data.order_number) {
                    existingOrders.add(String(data.order_number));
                }
            });
        }
        
        const batch = db.batch();
        const ordersToImport = [];
        
        for (const order of orders) {
            // Verificar se já existe
            if (skipExisting && existingOrders.has(order.order_number)) {
                skipped++;
                continue;
            }
            
            // Preparar dados da ordem
            const orderData = {
                order_number: order.order_number,
                part_code: order.part_code,
                product: order.part_name || order.part_code || '',
                product_cod: order.part_code,
                machine_id: defaultMachine || order.machine_id || '',
                machine_name: order.machine_full || '',
                customer: order.customer || '',
                lot_size: order.lot_size,
                total_produced: 0,
                remaining: order.remaining || order.lot_size,
                batch_number: order.batch_number || '',
                status: defaultStatus === 'from_file' ? (order.status || 'planejada') : defaultStatus,
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                imported_at: firebase.firestore.FieldValue.serverTimestamp(),
                import_source: 'excel_erp'
            };
            
            console.log('[Import] Ordem preparada:', orderData);
            ordersToImport.push(orderData);
        }
        
        // Importar em lotes de 500 (limite do Firestore batch)
        const batchSize = 450;
        for (let i = 0; i < ordersToImport.length; i += batchSize) {
            const batchOrders = ordersToImport.slice(i, i + batchSize);
            const currentBatch = db.batch();
            
            for (const orderData of batchOrders) {
                const docRef = db.collection('production_orders').doc();
                currentBatch.set(docRef, orderData);
            }
            
            await currentBatch.commit();
            imported += batchOrders.length;
            
            // Atualizar progresso
            const progress = Math.round(((i + batchOrders.length) / ordersToImport.length) * 100);
            document.getElementById('import-progress-bar').style.width = `${progress}%`;
            document.getElementById('import-progress-text').textContent = `Importando... ${imported} de ${ordersToImport.length}`;
        }
        
        // Mostrar resultado
        document.getElementById('import-progress-container').classList.add('hidden');
        document.getElementById('import-result').classList.remove('hidden');
        
        if (imported > 0) {
            document.getElementById('import-result-icon').innerHTML = '<div class="p-4 bg-green-100 rounded-full inline-block"><i data-lucide="check-circle" class="w-12 h-12 text-green-600"></i></div>';
            document.getElementById('import-result-text').className = 'text-lg font-semibold text-green-700';
            document.getElementById('import-result-text').textContent = `${imported} ordem(s) importada(s) com sucesso!`;
        } else {
            document.getElementById('import-result-icon').innerHTML = '<div class="p-4 bg-amber-100 rounded-full inline-block"><i data-lucide="alert-circle" class="w-12 h-12 text-amber-600"></i></div>';
            document.getElementById('import-result-text').className = 'text-lg font-semibold text-amber-700';
            document.getElementById('import-result-text').textContent = 'Nenhuma ordem foi importada.';
        }
        
        let details = [];
        if (skipped > 0) details.push(`${skipped} ignorada(s) (já existem)`);
        if (errors > 0) details.push(`${errors} erro(s)`);
        document.getElementById('import-result-details').textContent = details.length > 0 ? details.join(' – ') : '';
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
        
        // Invalidar cache e atualizar lista de ordens
        productionOrdersCache = null;
        
        // Atualizar lista de ordens após 1.5 segundos
        setTimeout(async () => {
            if (typeof loadOrdersAnalysis === 'function') {
                await loadOrdersAnalysis();
                showNotification('Lista de ordens atualizada!', 'info');
            }
        }, 1500);
        
    } catch (error) {
        console.error('[Import] Erro durante importação:', error);
        
        document.getElementById('import-progress-container').classList.add('hidden');
        document.getElementById('import-result').classList.remove('hidden');
        document.getElementById('import-result-icon').innerHTML = '<div class="p-4 bg-red-100 rounded-full inline-block"><i data-lucide="x-circle" class="w-12 h-12 text-red-600"></i></div>';
        document.getElementById('import-result-text').className = 'text-lg font-semibold text-red-700';
        document.getElementById('import-result-text').textContent = 'Erro durante a importação';
        document.getElementById('import-result-details').textContent = error.message;
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Expor funções globalmente
window.openImportOrdersModal = openImportOrdersModal;
window.closeImportOrdersModal = closeImportOrdersModal;
window.handleImportFileSelect = handleImportFileSelect;
window.clearImportFile = clearImportFile;
window.toggleImportRow = toggleImportRow;
window.toggleAllImportRows = toggleAllImportRows;
window.executeImportOrders = executeImportOrders;

// ====== CADASTRO DE NOVOS PRODUTOS ======

// Abrir modal de novo produto
function openNewProductModal() {
    const modal = document.getElementById('new-product-modal');
    if (modal) {
        modal.classList.remove('hidden');
        resetNewProductModal();
        populateNewProductMPSelect();
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
}

// Fechar modal de novo produto
function closeNewProductModal() {
    const modal = document.getElementById('new-product-modal');
    if (modal) {
        modal.classList.add('hidden');
        resetNewProductModal();
    }
}

// Resetar modal de novo produto
function resetNewProductModal() {
    const form = document.getElementById('new-product-form');
    if (form) form.reset();
    
    const feedback = document.getElementById('new-product-feedback');
    if (feedback) {
        feedback.classList.add('hidden');
        feedback.textContent = '';
    }
    
    const calcResult = document.getElementById('new-product-calc-result');
    if (calcResult) calcResult.textContent = '';
}

// Popular select de matéria-prima
function populateNewProductMPSelect() {
    const select = document.getElementById('new-product-mp');
    if (!select) return;
    
    select.innerHTML = '<option value="">Selecione (opcional)...</option>';
    
    // Usar o banco de matérias-primas se disponível
    if (typeof materiaPrimaDatabase !== 'undefined' && Array.isArray(materiaPrimaDatabase)) {
        materiaPrimaDatabase.forEach(mp => {
            const opt = document.createElement('option');
            opt.value = mp.codigo;
            opt.textContent = `${mp.codigo} - ${mp.descricao}`;
            select.appendChild(opt);
        });
    }
}

// Calcular meta de peças por hora
function calcularMetaPPH() {
    const cavities = parseFloat(document.getElementById('new-product-cavities')?.value) || 0;
    const cycle = parseFloat(document.getElementById('new-product-cycle')?.value) || 0;
    
    if (cavities <= 0 || cycle <= 0) {
        document.getElementById('new-product-calc-result').textContent = '⚠️ Preencha cavidades e ciclo';
        return;
    }
    
    const pph = Math.round((3600 / cycle) * cavities);
    document.getElementById('new-product-calc-result').textContent = `= ${pph.toLocaleString('pt-BR')} peças/hora`;
    document.getElementById('new-product-pph').value = pph;
}

// Mostrar feedback no modal
function showNewProductFeedback(message, type = 'info') {
    const feedback = document.getElementById('new-product-feedback');
    if (!feedback) return;
    
    feedback.classList.remove('hidden', 'bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-amber-100', 'text-amber-800');
    
    if (type === 'success') {
        feedback.classList.add('bg-green-100', 'text-green-800');
    } else if (type === 'error') {
        feedback.classList.add('bg-red-100', 'text-red-800');
    } else {
        feedback.classList.add('bg-amber-100', 'text-amber-800');
    }
    
    feedback.textContent = message;
}

// Salvar novo produto
async function saveNewProduct() {
    const cod = parseInt(document.getElementById('new-product-cod')?.value, 10);
    const client = document.getElementById('new-product-client')?.value?.trim();
    const name = document.getElementById('new-product-name')?.value?.trim();
    const cavities = parseInt(document.getElementById('new-product-cavities')?.value, 10);
    const cycle = parseFloat(document.getElementById('new-product-cycle')?.value);
    const weight = parseFloat(document.getElementById('new-product-weight')?.value);
    const pph = parseInt(document.getElementById('new-product-pph')?.value, 10);
    const mp = document.getElementById('new-product-mp')?.value || '';
    
    // Validações
    if (!cod || cod <= 0) {
        showNewProductFeedback('⚠️ Informe um código válido para o produto.', 'error');
        document.getElementById('new-product-cod')?.focus();
        return;
    }
    
    if (!client) {
        showNewProductFeedback('⚠️ Selecione o cliente.', 'error');
        document.getElementById('new-product-client')?.focus();
        return;
    }
    
    if (!name) {
        showNewProductFeedback('⚠️ Informe o nome do produto.', 'error');
        document.getElementById('new-product-name')?.focus();
        return;
    }
    
    if (!cavities || cavities <= 0) {
        showNewProductFeedback('⚠️ Informe um número válido de cavidades.', 'error');
        document.getElementById('new-product-cavities')?.focus();
        return;
    }
    
    if (!cycle || cycle <= 0) {
        showNewProductFeedback('⚠️ Informe um tempo de ciclo válido.', 'error');
        document.getElementById('new-product-cycle')?.focus();
        return;
    }
    
    if (!weight || weight <= 0) {
        showNewProductFeedback('⚠️ Informe um peso válido.', 'error');
        document.getElementById('new-product-weight')?.focus();
        return;
    }
    
    if (!pph || pph <= 0) {
        showNewProductFeedback('⚠️ Informe a meta de peças/hora. Use o botão Calcular.', 'error');
        document.getElementById('new-product-pph')?.focus();
        return;
    }
    
    try {
        showNewProductFeedback('ó Verificando código do produto...', 'info');
        
        // Verificar se o código já existe no Firestore
        const existingSnapshot = await db.collection('products')
            .where('cod', '==', cod)
            .get();
        
        if (!existingSnapshot.empty) {
            showNewProductFeedback(`❌ Já existe um produto com o código ${cod}.`, 'error');
            return;
        }
        
        showNewProductFeedback('ó Salvando produto...', 'info');
        
        // Criar objeto do produto
        const newProduct = {
            cod: cod,
            client: client,
            name: name,
            cavities: cavities,
            cycle: cycle,
            weight: weight,
            pieces_per_hour_goal: pph,
            mp: mp,
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            createdBy: window.authSystem?.getCurrentUser?.()?.name || 'Sistema',
            source: 'manual_cadastro'
        };
        
        // Salvar no Firestore
        const docRef = await db.collection('products').add(newProduct);
        
        console.log('[PRODUTO] Novo produto cadastrado:', { id: docRef.id, ...newProduct });
        
        // Também adicionar ao productDatabase local se existir
        if (typeof productDatabase !== 'undefined' && Array.isArray(productDatabase)) {
            productDatabase.push({
                cod: cod,
                client: client,
                name: name,
                cavities: cavities,
                cycle: cycle,
                weight: weight,
                pieces_per_hour_goal: pph,
                mp: mp
            });
        }
        
        showNewProductFeedback(`✅ Produto ${cod} - ${name} cadastrado com sucesso!`, 'success');
        
        // Notificação de sucesso
        if (typeof showNotification === 'function') {
            showNotification(`Produto ${cod} cadastrado com sucesso!`, 'success');
        }
        
        // Fechar modal após 2 segundos
        setTimeout(() => {
            closeNewProductModal();
        }, 2000);
        
    } catch (error) {
        console.error('[PRODUTO] Erro ao salvar:', error);
        showNewProductFeedback(`❌ Erro ao salvar: ${error.message}`, 'error');
    }
}

// Expor funções globalmente
window.openNewProductModal = openNewProductModal;
window.closeNewProductModal = closeNewProductModal;
window.calcularMetaPPH = calcularMetaPPH;
window.saveNewProduct = saveNewProduct;

// ====== FUNÇÕES DE DIAGNÓSTICO E CORREÇÃO ======

// Listar TODAS as ordens no Firebase (para diagnóstico)
window.listarTodasOrdens = async function() {
    console.log('📍 Buscando TODAS as ordens no Firebase...');
    try {
        const snapshot = await db.collection('production_orders').get();
        console.log(`📋 Total de ordens no banco: ${snapshot.size}`);
        
        const orders = [];
        snapshot.forEach(doc => {
            const data = doc.data();
            orders.push({
                id: doc.id,
                order_number: data.order_number,
                product: data.product || data.part_name || data.part_code,
                machine_id: data.machine_id,
                status: data.status,
                lot_size: data.lot_size,
                import_source: data.import_source || 'manual',
                createdAt: data.createdAt
            });
        });
        
        console.table(orders);
        return orders;
    } catch (error) {
        console.error('❌ Erro ao buscar ordens:', error);
        return [];
    }
};

// Excluir ordens importadas (para limpar e reimportar)
window.excluirOrdensImportadas = async function() {
    if (!confirm('Deseja excluir TODAS as ordens importadas do Excel? Esta ação não pode ser desfeita!')) {
        return;
    }
    
    console.log('🗑️ Excluindo ordens importadas...');
    try {
        const snapshot = await db.collection('production_orders')
            .where('import_source', '==', 'excel_erp')
            .get();
        
        if (snapshot.empty) {
            console.log('ℹ️ Nenhuma ordem importada encontrada.');
            alert('Nenhuma ordem importada encontrada.');
            return;
        }
        
        console.log(`🗑️ Encontradas ${snapshot.size} ordens importadas para excluir...`);
        
        const batch = db.batch();
        snapshot.forEach(doc => {
            batch.delete(doc.ref);
        });
        
        await batch.commit();
        console.log(`✅ ${snapshot.size} ordens importadas excluídas com sucesso!`);
        alert(`${snapshot.size} ordens importadas foram excluídas. Atualize a página e importe novamente.`);
        
        // Limpar cache
        productionOrdersCache = null;
        
    } catch (error) {
        console.error('❌ Erro ao excluir ordens:', error);
        alert('Erro ao excluir ordens: ' + error.message);
    }
};

// Forçar atualização das ordens
window.forcarAtualizacaoOrdens = async function() {
    console.log('🔄 Forçando atualização da lista de ordens...');
    productionOrdersCache = null;
    
    if (typeof loadOrdersAnalysis === 'function') {
        await loadOrdersAnalysis();
        console.log('✅ Lista de ordens atualizada!');
    } else {
        console.error('❌ Função loadOrdersAnalysis não encontrada');
    }
};

// Excluir ordens específicas por índices da lista
window.excluirOrdensPorIndices = async function(indices) {
    if (!indices || !Array.isArray(indices) || indices.length === 0) {
        console.error('❌ Forneça um array de índices. Ex: excluirOrdensPorIndices([4, 26, 39, 50])');
        return;
    }
    
    console.log(`📍 Buscando ordens nos índices: ${indices.join(', ')}...`);
    
    try {
        const snapshot = await db.collection('production_orders').get();
        const allOrders = [];
        snapshot.forEach(doc => {
            allOrders.push({ id: doc.id, ref: doc.ref, data: doc.data() });
        });
        
        const ordersToDelete = indices.map(idx => allOrders[idx]).filter(o => o);
        
        if (ordersToDelete.length === 0) {
            console.error('❌ Nenhuma ordem encontrada nos índices especificados.');
            return;
        }
        
        console.log('📋 Ordens que serão excluídas:');
        ordersToDelete.forEach((o, i) => {
            console.log(`  ${indices[i]}: OP ${o.data.order_number} - ${o.data.product || o.data.part_code} (${o.data.machine_id})`);
        });
        
        if (!confirm(`Deseja excluir estas ${ordersToDelete.length} ordens? Esta ação não pode ser desfeita!`)) {
            console.log('❌ Operação cancelada pelo usuário.');
            return;
        }
        
        const batch = db.batch();
        ordersToDelete.forEach(o => batch.delete(o.ref));
        
        await batch.commit();
        console.log(`✅ ${ordersToDelete.length} ordens excluídas com sucesso!`);
        alert(`${ordersToDelete.length} ordens excluídas com sucesso! Agora você pode reimportar.`);
        
        // Limpar cache
        productionOrdersCache = null;
        
    } catch (error) {
        console.error('❌ Erro ao excluir ordens:', error);
        alert('Erro ao excluir ordens: ' + error.message);
    }
};

// Configurar drag and drop para o modal de importação
document.addEventListener('DOMContentLoaded', function() {
    setTimeout(() => {
        const uploadArea = document.getElementById('import-upload-area');
        if (uploadArea) {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.add('border-indigo-500', 'bg-indigo-50');
                }, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.remove('border-indigo-500', 'bg-indigo-50');
                }, false);
            });
            
            uploadArea.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.match(/\.(xlsx|xls)$/i)) {
                        document.getElementById('import-file-input').files = files;
                        handleImportFileSelect({ target: { files: [file] } });
                    } else {
                        alert('Por favor, selecione um arquivo Excel (.xlsx ou .xls)');
                    }
                }
            }, false);
        }
    }, 1000);
});

// ===== Importador de Ordens em Lote (Excel) =====

function parseImportNumber(value) {
    if (value === null || value === undefined || value === '') return null;

    if (typeof value === 'number') {
        return Number.isFinite(value) ? value : null;
    }

    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (!trimmed) return null;

        const normalized = trimmed
            .replace(/\s+/g, '')
            .replace(/\./g, '')
            .replace(',', '.');

        const parsed = Number(normalized);
        return Number.isFinite(parsed) ? parsed : null;
    }

    const fallback = Number(value);
    return Number.isFinite(fallback) ? fallback : null;
}

// Converter data do Excel para formato ISO
function excelDateToISO(excelDate) {
    if (!excelDate) return new Date().toISOString().split('T')[0];
    
    // Se for número (data do Excel)
    if (typeof excelDate === 'number') {
        const date = new Date((excelDate - 25569) * 86400 * 1000);
        return date.toISOString().split('T')[0];
    }
    
    // Se for string
    if (typeof excelDate === 'string') {
        const parsed = new Date(excelDate);
        if (!isNaN(parsed)) {
            return parsed.toISOString().split('T')[0];
        }
    }
    
    return new Date().toISOString().split('T')[0];
}

// Mapear nomes de colunas flexíveis
function mapColumnValue(row, possibleNames) {
    for (const name of possibleNames) {
        if (row[name] !== undefined && row[name] !== null && row[name] !== '') {
            return String(row[name]).trim();
        }
    }
    return '';
}

async function handleProductionOrdersImport(file) {
    if (!file) {
        alert('Selecione um arquivo.');
        return;
    }

    const statusElement = document.getElementById('import-orders-status');
    if (statusElement) {
        statusElement.textContent = 'Lendo arquivo Excel...';
        statusElement.className = 'text-sm font-semibold text-blue-600';
    }

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            
            // Pegar primeira planilha
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            
            // Converter para JSON
            const jsonData = XLSX.utils.sheet_to_json(worksheet);
            
            if (jsonData.length === 0) {
                alert('Arquivo vazio ou sem dados.');
                if (statusElement) statusElement.textContent = '';
                return;
            }

            // Processar linhas de dados
            const orders = [];
            for (let i = 0; i < jsonData.length; i++) {
                const row = jsonData[i];
                
                // Mapeamento flexível de colunas (aceita diferentes nomes)
                const numeroOP = mapColumnValue(row, ['numero_op', 'Numero_OP', 'Número OP', 'OP', 'op', 'ordem', 'Ordem', 'numero', 'Numero']);
                const codProduto = mapColumnValue(row, ['cod_produto', 'Cod_Produto', 'Código Produto', 'codigo_produto', 'produto', 'Produto', 'cod', 'Cod']);
                const codMP = mapColumnValue(row, ['cod_mp', 'Cod_MP', 'MP', 'mp', 'materia_prima', 'Matéria Prima', 'Materia Prima']);
                const maquina = mapColumnValue(row, ['maquina', 'Maquina', 'Máquina', 'machine', 'Machine']);
                const cliente = mapColumnValue(row, ['cliente', 'Cliente', 'customer', 'Customer']);
                const tamLote = mapColumnValue(row, ['tam_lote', 'Tam_Lote', 'Lote', 'lote', 'quantidade', 'Quantidade', 'qtd', 'Qtd', 'lot_size']);
                const numeroLote = mapColumnValue(row, ['numero_lote', 'Numero_Lote', 'batch', 'Batch', 'lote_numero']);
                const dataOrdem = row['data'] || row['Data'] || row['date'] || row['Date'] || '';
                
                // Validar campos obrigatórios
                if (!numeroOP || !codProduto || !maquina || !tamLote) {
                    console.warn(`Linha ${i + 2} incompleta (faltam campos obrigatórios), pulando...`);
                    continue;
                }

                orders.push({
                    order_number: numeroOP.toUpperCase().trim(),
                    part_code: codProduto.trim(),
                    raw_material: codMP.trim(),
                    machine_id: maquina.trim(),
                    customer: cliente.trim(),
                    lot_size: parseImportNumber(tamLote),
                    batch_number: numeroLote.trim(),
                    date: excelDateToISO(dataOrdem),
                    status: 'planejada'
                });
            }

            if (orders.length === 0) {
                alert('Nenhuma ordem válida encontrada no arquivo. Verifique se as colunas estão corretas.');
                if (statusElement) statusElement.textContent = '';
                return;
            }

            if (statusElement) {
                statusElement.textContent = `${orders.length} ordem(s) encontrada(s). Verificando...`;
            }

            // Mostrar prévia em modal
            showImportPreview(orders);
        } catch (error) {
            console.error('Erro ao processar arquivo Excel:', error);
            alert('Erro ao processar arquivo. Verifique se é um arquivo Excel válido (.xlsx)');
            if (statusElement) statusElement.textContent = '';
        }
    };
    reader.readAsArrayBuffer(file);
}

function showImportPreview(orders) {
    const previewContent = `
        <div class="space-y-4">
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3">
                <p class="text-sm text-blue-700"><strong>Total de ordens:</strong> ${orders.length}</p>
            </div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 border border-gray-300 text-xs">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="px-3 py-2 text-left font-semibold">OP Nú</th>
                            <th class="px-3 py-2 text-left font-semibold">Produto</th>
                            <th class="px-3 py-2 text-left font-semibold">MP</th>
                            <th class="px-3 py-2 text-left font-semibold">Máquina</th>
                            <th class="px-3 py-2 text-left font-semibold">Cliente</th>
                            <th class="px-3 py-2 text-right font-semibold">Lote</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${orders.slice(0, 10).map(o => `
                            <tr class="border-t hover:bg-gray-50">
                                <td class="px-3 py-2">${o.order_number}</td>
                                <td class="px-3 py-2">${o.part_code}</td>
                                <td class="px-3 py-2">${o.raw_material}</td>
                                <td class="px-3 py-2">${o.machine_id}</td>
                                <td class="px-3 py-2">${o.customer}</td>
                                <td class="px-3 py-2 text-right">${o.lot_size}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
                ${orders.length > 10 ? `<p class="text-xs text-gray-500 mt-2">... e mais ${orders.length - 10} ordens</p>` : ''}
            </div>
        </div>
    `;

    // Criar modal simples
    const modal = document.createElement('div');
    modal.id = 'import-preview-modal';
    modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';
    modal.innerHTML = `
        <div class="bg-white rounded-lg shadow-lg max-w-2xl w-full max-h-96 overflow-y-auto p-6">
            <h3 class="text-lg font-bold text-gray-900 mb-4">Prévia da Importação</h3>
            ${previewContent}
            <div class="mt-6 flex gap-3">
                <button id="confirm-import-btn" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg">
                    Confirmar Importação
                </button>
                <button id="cancel-import-btn" class="flex-1 bg-gray-400 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg">
                    Cancelar
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    document.getElementById('confirm-import-btn').addEventListener('click', () => {
        confirmImportOrders(orders);
        modal.remove();
    });

    document.getElementById('cancel-import-btn').addEventListener('click', () => {
        modal.remove();
    });
}

async function confirmImportOrders(orders) {
    const statusElement = document.getElementById('import-orders-status');
    if (!statusElement) return;

    statusElement.textContent = 'Importando ordens...';
    statusElement.className = 'text-sm font-semibold text-blue-600';

    let successCount = 0;
    let errorCount = 0;

    for (const order of orders) {
        try {
            // Buscar produto para extrair dados
            const product = window.databaseModule.productByCode.get(Number(order.part_code)) || window.databaseModule.productByCode.get(order.part_code);

            const docData = {
                order_number: order.order_number,
                order_number_original: order.order_number,
                part_code: order.part_code,
                product_cod: order.part_code,
                product: product?.name || '',
                customer: order.customer || (product?.client || ''),
                client: order.customer || (product?.client || ''),
                raw_material: order.raw_material,
                lot_size: parseImportNumber(order.lot_size),
                batch_number: order.batch_number,
                machine_id: order.machine_id || null,
                status: 'planejada',
                createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
            };

            if (product) {
                docData.product_snapshot = {
                    cod: product.cod || order.part_code,
                    client: product.client || '',
                    name: product.name || '',
                    cavities: parseImportNumber(product.cavities),
                    cycle: parseImportNumber(product.cycle),
                    weight: parseImportNumber(product.weight),
                    mp: product.mp || order.raw_material
                };
            }

            // Verificar duplicação de número de OP
            const existing = await db.collection('production_orders')
                .where('order_number', '==', order.order_number)
                .limit(1)
                .get();

            if (!existing.empty) {
                console.warn(`OP ${order.order_number} já existe, pulando...`);
                errorCount++;
                continue;
            }

            const docRef = await db.collection('production_orders').add(docData);
            successCount++;
            
            // Registrar log de importação
            registrarLogSistema('IMPORTAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                orderId: docRef.id,
                orderNumber: order.order_number,
                product: docData.product,
                lotSize: docData.lot_size
            });
        } catch (error) {
            console.error(`Erro ao importar OP ${order.order_number}:`, error);
            errorCount++;
        }
    }

    statusElement.textContent = `Importação concluída: ${successCount} ordens importadas, ${errorCount} erros.`;
    statusElement.className = errorCount === 0 ? 'text-sm font-semibold text-green-600' : 'text-sm font-semibold text-orange-600';

    // Atualizar lista de ordens
    setTimeout(() => {
        loadProductionOrders();
        document.getElementById('import-orders-file').value = '';
        statusElement.textContent = '';
    }, 2000);
}

// Download template Excel
function downloadExcelTemplate() {
    const headers = ['numero_op', 'cod_produto', 'cod_mp', 'maquina', 'cliente', 'tam_lote', 'numero_lote', 'data'];
    const exampleRows = [
        ['OP-001', 'PROD001', 'MP001', 'H-01', 'Cliente A', 5000, 'LOTE-001', '2025-11-27'],
        ['OP-002', 'PROD002', 'MP002', 'H-05', 'Cliente B', 3000, 'LOTE-002', '2025-11-27'],
        ['OP-003', 'PROD001', 'MP001', 'H-11', 'Cliente A', 7500, 'LOTE-003', '2025-11-27']
    ];
    
    // Criar workbook e worksheet
    const ws = XLSX.utils.aoa_to_sheet([headers, ...exampleRows]);
    
    // Formatar largura das colunas
    ws['!cols'] = [
        { wch: 12 }, // numero_op
        { wch: 12 }, // cod_produto
        { wch: 10 }, // cod_mp
        { wch: 10 }, // maquina
        { wch: 15 }, // cliente
        { wch: 10 }, // tam_lote
        { wch: 12 }, // numero_lote
        { wch: 12 }  // data
    ];
    
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Ordens');
    
    // Salvar arquivo
    XLSX.writeFile(wb, 'template_ordens.xlsx');
}

// Event listeners para importação
document.addEventListener('DOMContentLoaded', () => {
    const importBtn = document.getElementById('btn-import-orders');
    const importFile = document.getElementById('import-orders-file');
    const downloadTemplateBtn = document.getElementById('download-excel-template');

    if (importBtn && importFile) {
        importBtn.addEventListener('click', () => {
            const file = importFile.files[0];
            if (file) {
                handleProductionOrdersImport(file);
            } else {
                alert('Selecione um arquivo Excel (.xlsx).');
            }
        });
    }

    if (downloadTemplateBtn) {
        downloadTemplateBtn.addEventListener('click', downloadExcelTemplate);
    }
});

// ====================================
// DEBUG/TESTE - Disponível via console
// ====================================
// As funções de debug estão expostas dentro do DOMContentLoaded principal
// Use window._syncDebug para acessar funções de diagnóstico

document.addEventListener('DOMContentLoaded', () => {
    const refreshBtn = document.getElementById('traceability-refresh-btn');
    if (!refreshBtn) return;

    refreshBtn.dataset.defaultLabel = refreshBtn.innerHTML;

    refreshBtn.addEventListener('click', async () => {
        if (!window.traceabilitySystem) {
            console.warn('[TRACEABILITY] Sistema não inicializado');
            return;
        }

        refreshBtn.disabled = true;
        refreshBtn.classList.add('opacity-60', 'cursor-not-allowed');
        refreshBtn.innerHTML = '<span class="flex items-center gap-2"><i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i>Atualizando...</span>';
        if (typeof lucide !== 'undefined') {
            lucide.createIcons();
        }

        try {
            await window.traceabilitySystem.initialize();
        } catch (error) {
            console.error('[TRACEABILITY] Erro ao atualizar via botão:', error);
        } finally {
            refreshBtn.disabled = false;
            refreshBtn.classList.remove('opacity-60', 'cursor-not-allowed');
            refreshBtn.innerHTML = refreshBtn.dataset.defaultLabel;
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
    });
});


// =====================================
// 📊 MÓDULO DE RELATÓRIOS
// =====================================
const ReportsModule = (function() {
    'use strict';

    // Estado do módulo
    let currentPage = 1;
    let itemsPerPage = 20;
    let currentData = [];
    let currentReportType = 'producao';
    let charts = {
        shift: null,
        reason: null,
        timeline: null
    };

    // Helper para acessar o Firestore
    function getDB() {
        const db = window.db || (typeof db !== 'undefined' ? db : null);
        if (!db) {
            console.warn('[REPORTS] Banco de dados não iniciado. Tentando novamente em 500ms...');
            // Se não estiver pronto, aguardar e tentar novamente
            return null;
        }
        return db;
    }

    // Helper para mostrar toast
    function showReportToast(message, type = 'info') {
        // Tentar usar a função global showNotification
        if (typeof showNotification === 'function') {
            showNotification(message, type);
        } else if (typeof window.showNotification === 'function') {
            window.showNotification(message, type);
        } else {
            // Fallback simples usando console
            console.log(`[REPORTS ${type.toUpperCase()}] ${message}`);
            alert(message); // Se tudo falhar, usar alert
        }
    }

    // Inicialização do módulo
    function initialize() {
        console.log('[REPORTS] Inicializando módulo de relatórios...');
        
        // Verificar se os elementos existem
        const generateBtn = document.getElementById('report-generate-btn');
        const periodSelect = document.getElementById('report-period');
        const machineSelect = document.getElementById('report-machine');
        
        console.log('[REPORTS] Elementos encontrados:', {
            generateBtn: !!generateBtn,
            periodSelect: !!periodSelect,
            machineSelect: !!machineSelect
        });
        
        setupEventListeners();
        populateReportMachines();
        
        // Atualizar datas após um pequeno delay para garantir que o DOM está pronto
        setTimeout(() => {
            updateDatesFromPeriod();
        }, 100);
        
        console.log('[REPORTS] Módulo inicializado com sucesso');
    }

    // Popular máquinas no filtro de relatórios
    function populateReportMachines() {
        const machineSelect = document.getElementById('report-machine');
        if (!machineSelect) {
            console.warn('[REPORTS] Select de máquinas não encontrado');
            return;
        }
        
        // Limpar opções existentes, mantendo "Todas"
        machineSelect.innerHTML = '<option value="all">Todas Máquinas</option>';
        
        // Usar machineDatabase do databaseModule
        const machines = window.databaseModule?.machineDatabase || 
                        (typeof machineDatabase !== 'undefined' ? machineDatabase : null);
        
        if (machines && Array.isArray(machines)) {
            console.log('[REPORTS] Carregando', machines.length, 'máquinas no filtro');
            machines.forEach(machine => {
                const opt = document.createElement('option');
                opt.value = machine.id;
                opt.textContent = machine.id;
                machineSelect.appendChild(opt);
            });
        } else {
            console.warn('[REPORTS] machineDatabase não disponível');
        }
    }

    // Configurar listeners
    function setupEventListeners() {
        const generateBtn = document.getElementById('report-generate-btn');
        const exportExcelBtn = document.getElementById('report-export-excel');
        const exportPdfBtn = document.getElementById('report-export-pdf');
        const prevPageBtn = document.getElementById('report-prev-page');
        const nextPageBtn = document.getElementById('report-next-page');
        const reportTypeSelect = document.getElementById('report-type');
        const periodSelect = document.getElementById('report-period');

        if (generateBtn) {
            generateBtn.addEventListener('click', (e) => {
                e.preventDefault();
                console.log('[REPORTS] Botão Gerar Relatório clicado');
                generateReport();
            });
            console.log('[REPORTS] Listener adicionado ao botão Gerar Relatório');
        } else {
            console.warn('[REPORTS] Botão report-generate-btn não encontrado');
        }
        
        if (exportExcelBtn) {
            exportExcelBtn.addEventListener('click', exportToExcel);
        }
        if (exportPdfBtn) {
            exportPdfBtn.addEventListener('click', exportToPDF);
        }
        if (prevPageBtn) {
            prevPageBtn.addEventListener('click', () => changePage(-1));
        }
        if (nextPageBtn) {
            nextPageBtn.addEventListener('click', () => changePage(1));
        }
        if (reportTypeSelect) {
            reportTypeSelect.addEventListener('change', (e) => {
                currentReportType = e.target.value;
            });
        }
        if (periodSelect) {
            periodSelect.addEventListener('change', handlePeriodChange);
        }
        
        // Sincronizar radio buttons com select hidden
        setupReportTypeCards();
    }

    // Configurar cards de tipo de relatório
    function setupReportTypeCards() {
        const radioButtons = document.querySelectorAll('input[name="report-type-radio"]');
        const hiddenSelect = document.getElementById('report-type');
        
        radioButtons.forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked && hiddenSelect) {
                    hiddenSelect.value = e.target.value;
                    currentReportType = e.target.value;
                    
                    // Esconder mensagem inicial quando mudar tipo
                    const initialMsg = document.getElementById('report-initial');
                    if (initialMsg) {
                        // Manter visível até gerar relatório
                    }
                }
            });
        });
    }

    // Manipular mudança de período
    function handlePeriodChange() {
        const periodSelect = document.getElementById('report-period');
        const customDatesDiv = document.getElementById('report-custom-dates');
        
        if (periodSelect?.value === 'custom') {
            customDatesDiv?.classList.remove('hidden');
        } else {
            customDatesDiv?.classList.add('hidden');
            updateDatesFromPeriod();
        }
    }

    // Calcular datas baseado no período selecionado
    function updateDatesFromPeriod() {
        const periodSelect = document.getElementById('report-period');
        const startInput = document.getElementById('report-date-start');
        const endInput = document.getElementById('report-date-end');
        
        console.log('[REPORTS] updateDatesFromPeriod - elementos:', {
            periodSelect: !!periodSelect,
            startInput: !!startInput,
            endInput: !!endInput,
            period: periodSelect?.value
        });
        
        if (!periodSelect || !startInput || !endInput) {
            console.warn('[REPORTS] Elementos de data não encontrados');
            return;
        }
        
        const period = periodSelect.value;
        const today = new Date();
        let startDate = new Date();
        let endDate = new Date();
        
        switch (period) {
            case 'today':
                startDate = new Date(today);
                endDate = new Date(today);
                break;
            case 'yesterday':
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - 1);
                endDate = new Date(startDate);
                break;
            case '7days':
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - 7);
                endDate = new Date(today);
                break;
            case '30days':
                startDate = new Date(today);
                startDate.setDate(startDate.getDate() - 30);
                endDate = new Date(today);
                break;
            case 'month':
                startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                endDate = new Date(today);
                break;
            case 'lastmonth':
                startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                endDate = new Date(today.getFullYear(), today.getMonth(), 0);
                break;
            case 'custom':
                // Manter valores atuais
                return;
        }
        
        startInput.value = formatDateInput(startDate);
        endInput.value = formatDateInput(endDate);
    }

    function formatDateInput(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
    }

    // Gerar relatório
    async function generateReport() {
        console.log('[REPORTS] ========== INICIANDO GERAÇÃO DE RELATÓRIO ==========');
        
        // Mostrar loading imediatamente
        showLoading(true);
        
        // Esconder mensagem inicial
        const initialMsg = document.getElementById('report-initial');
        if (initialMsg) {
            initialMsg.classList.add('hidden');
            console.log('[REPORTS] Mensagem inicial escondida');
        }
        
        // Atualizar datas antes de gerar
        const periodSelect = document.getElementById('report-period');
        if (periodSelect && periodSelect.value !== 'custom') {
            updateDatesFromPeriod();
            console.log('[REPORTS] Datas atualizadas para período:', periodSelect.value);
        }
        
        // Pequeno delay para garantir que as datas foram atualizadas
        await new Promise(resolve => setTimeout(resolve, 50));
        
        // Verificar Firestore - usar window.db diretamente
        let firestore = window.db;
        if (!firestore) {
            console.log('[REPORTS] window.db não disponível, tentando retries...');
            let retries = 0;
            while (!firestore && retries < 3) {
                await new Promise(resolve => setTimeout(resolve, 300));
                firestore = window.db;
                retries++;
            }
        }
        
        console.log('[REPORTS] Firestore verificado:', { disponivel: !!firestore });
        
        if (!firestore) {
            showReportToast('Erro: Banco de dados não disponível. Tente novamente em alguns segundos.', 'error');
            console.error('[REPORTS] Firestore não disponível após retries:', { windowDb: !!window.db, globalDb: typeof db });
            showLoading(false);
            return;
        }

        // Obter tipo de relatório do radio button ou select
        const selectedRadio = document.querySelector('input[name="report-type-radio"]:checked');
        const reportType = selectedRadio?.value || document.getElementById('report-type')?.value || 'producao';
        
        // Obter datas - calcular diretamente se não estiverem definidas
        let startDate = document.getElementById('report-date-start')?.value;
        let endDate = document.getElementById('report-date-end')?.value;
        
        // Se as datas estiverem vazias, calcular baseado no período selecionado
        if (!startDate || !endDate) {
            const period = document.getElementById('report-period')?.value || '7days';
            const today = new Date();
            let calcStartDate = new Date();
            let calcEndDate = new Date();
            
            switch (period) {
                case 'today':
                    calcStartDate = new Date(today);
                    calcEndDate = new Date(today);
                    break;
                case 'yesterday':
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 1);
                    calcEndDate = new Date(calcStartDate);
                    break;
                case '7days':
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 7);
                    calcEndDate = new Date(today);
                    break;
                case '30days':
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 30);
                    calcEndDate = new Date(today);
                    break;
                case 'month':
                    calcStartDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    calcEndDate = new Date(today);
                    break;
                case 'lastmonth':
                    calcStartDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    calcEndDate = new Date(today.getFullYear(), today.getMonth(), 0);
                    break;
                default:
                    calcStartDate = new Date(today);
                    calcStartDate.setDate(calcStartDate.getDate() - 7);
                    calcEndDate = new Date(today);
            }
            
            // Formatar datas como YYYY-MM-DD
            const formatDate = (d) => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            startDate = formatDate(calcStartDate);
            endDate = formatDate(calcEndDate);
            console.log('[REPORTS] Datas calculadas automaticamente:', { period, startDate, endDate });
        }
        
        const machine = document.getElementById('report-machine')?.value || 'all';
        const shift = document.getElementById('report-shift')?.value || 'all';

        console.log('[REPORTS] Filtros finais:', { reportType, startDate, endDate, machine, shift });

        if (!startDate || !endDate) {
            showReportToast('Por favor, selecione as datas do período.', 'error');
            console.warn('[REPORTS] Datas ainda inválidas:', { startDate, endDate });
            showLoading(false);
            return;
        }

        hideResults();
        console.log('[REPORTS] Iniciando busca de dados...');

        try {
            let data = [];

            switch (reportType) {
                case 'producao':
                    data = await fetchProductionData(startDate, endDate, machine, shift);
                    break;
                case 'paradas':
                    data = await fetchDowntimeData(startDate, endDate, machine, shift);
                    break;
                case 'perdas':
                    data = await fetchLossesData(startDate, endDate, machine, shift);
                    break;
                case 'consolidado':
                    data = await fetchConsolidatedData(startDate, endDate, machine, shift);
                    break;
            }

            console.log('[REPORTS] Dados encontrados:', data.length);

            currentData = data;
            currentPage = 1;
            currentReportType = reportType;

            if (data.length === 0) {
                showEmptyState(true);
                showReportToast('Nenhum registro encontrado para o período selecionado.', 'warning');
            } else {
                updateKPIs(data, reportType);
                renderTable(data, reportType);
                updateCharts(data, reportType);
                showResults();
                showReportToast(`Relatório gerado: ${data.length} registros encontrados.`, 'success');
            }
        } catch (error) {
            console.error('[REPORTS] Erro ao gerar relatório:', error);
            showReportToast('Erro ao gerar relatório. Tente novamente.', 'error');
        } finally {
            showLoading(false);
        }
    }

    // Buscar dados de produção
    async function fetchProductionData(startDate, endDate, machine, shift) {
        const entries = [];
        const firestore = window.db;
        if (!firestore) {
            console.error('[REPORTS] Firestore não disponível em fetchProductionData');
            return entries;
        }
        
        try {
            console.log('[REPORTS] Buscando produção:', { startDate, endDate, machine, shift });
            
            // Buscar sem orderBy para evitar problemas de índice
            let query = firestore.collection('production_entries')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate);

            console.log('[REPORTS] Executando query de produção...');
            const snapshot = await query.get();
            
            console.log('[REPORTS] Produção - documentos encontrados:', snapshot.size);
            
            snapshot.forEach(doc => {
                const d = doc.data();
                
                // Filtro de máquina
                if (machine !== 'all' && d.machine !== machine) return;
                
                // Filtro de turno - campo é 'turno' não 'shift'
                if (shift !== 'all' && String(d.turno) !== shift) return;
                
                entries.push({
                    id: doc.id,
                    data: d.data || '',
                    turno: d.turno || '',
                    maquina: d.machine || '',
                    ordem: d.orderId || d.order_id || '',
                    produto: d.mp || d.productCode || '',
                    produzido: d.produzido || d.produced || d.quantity || 0,
                    operador: d.registradoPorNome || d.registradoPor || d.operator || '',
                    hora: d.timestamp?.toDate?.()?.toLocaleTimeString?.('pt-BR', {hour: '2-digit', minute: '2-digit'}) || ''
                });
            });
            console.log('[REPORTS] Produção - registros após filtros:', entries.length);
        } catch (error) {
            console.error('[REPORTS] Erro ao buscar produção:', error);
            showReportToast(`Erro ao buscar dados de produção: ${error.message}`, 'error');
        }
        
        return entries;
    }

    // Buscar dados de paradas
    async function fetchDowntimeData(startDate, endDate, machine, shift) {
        const entries = [];
        const firestore = window.db;
        if (!firestore) return entries;
        
        try {
            console.log('[REPORTS] Buscando paradas:', { startDate, endDate, machine, shift });
            
            // Buscar por campo 'data'
            let query = firestore.collection('downtime_entries')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate);

            console.log('[REPORTS] Executando query de paradas...');
            const snapshot = await query.get();
            
            console.log('[REPORTS] Paradas - documentos encontrados:', snapshot.size);
            
            snapshot.forEach(doc => {
                const d = doc.data();
                
                // Filtro de máquina
                if (machine !== 'all' && d.machine !== machine) return;
                
                // Filtro de turno
                const docTurno = d.turno || d.shift;
                if (shift !== 'all' && String(docTurno) !== shift) return;
                
                entries.push({
                    id: doc.id,
                    data: d.data || d.date || '',
                    turno: docTurno || '',
                    maquina: d.machine || '',
                    tipo: d.downtime_type || d.type || d.tipo || '',
                    motivo: d.reason || d.motivo || '',
                    duracao: d.duration || d.duracao || 0,
                    inicio: d.start_time || d.inicio || '',
                    fim: d.end_time || d.fim || '',
                    operador: d.registradoPorNome || d.operator || d.created_by || ''
                });
            });
            console.log('[REPORTS] Paradas - registros após filtros:', entries.length);
        } catch (error) {
            console.error('[REPORTS] Erro ao buscar paradas:', error);
            showReportToast(`Erro ao buscar dados de paradas: ${error.message}`, 'error');
        }
        
        return entries;
    }

    // Buscar dados de perdas/refugos
    async function fetchLossesData(startDate, endDate, machine, shift) {
        const entries = [];
        const firestore = window.db;
        if (!firestore) return entries;
        
        try {
            console.log('[REPORTS] Buscando perdas:', { startDate, endDate, machine, shift });
            
            // Buscar refugos de produção - usando campo 'data'
            let query = firestore.collection('production_entries')
                .where('data', '>=', startDate)
                .where('data', '<=', endDate);

            console.log('[REPORTS] Executando query de perdas...');
            const snapshot = await query.get();
            
            console.log('[REPORTS] Perdas (produção) - documentos:', snapshot.size);
            
            snapshot.forEach(doc => {
                const d = doc.data();
                
                // Filtro de data se fallback
                if (d.data && (d.data < startDate || d.data > endDate)) return;
                
                // Só incluir se tiver refugo
                const refugoKg = d.refugo_kg || d.scrap || d.rejected || d.refugo || 0;
                if (!refugoKg || refugoKg <= 0) return;
                
                // Filtro de máquina
                if (machine !== 'all' && d.machine !== machine) return;
                
                // Filtro de turno
                if (shift !== 'all' && String(d.turno) !== shift) return;
                
                entries.push({
                    id: doc.id,
                    data: d.data || '',
                    turno: d.turno || '',
                    maquina: d.machine || '',
                    ordem: d.orderId || '',
                    produto: d.mp || '',
                    tipo: 'Refugo Produção',
                    quantidade: refugoKg,
                    motivo: d.perdas || d.scrap_reason || '-',
                    operador: d.registradoPorNome || ''
                });
            });

            // Buscar retrabalhos
            try {
                console.log('[REPORTS] Buscando retrabalhos...');
                const reworkQuery = firestore.collection('rework_entries')
                    .where('data', '>=', startDate)
                    .where('data', '<=', endDate);

                const reworkSnapshot = await reworkQuery.get();
                
                console.log('[REPORTS] Retrabalhos - documentos:', reworkSnapshot.size);
                
                reworkSnapshot.forEach(doc => {
                    const d = doc.data();
                    
                    // Filtro de máquina
                    if (machine !== 'all' && d.machine !== machine) return;
                    
                    // Filtro de turno
                    const docTurno = d.turno || d.shift;
                    if (shift !== 'all' && String(docTurno) !== shift) return;
                    
                    entries.push({
                        id: doc.id,
                        data: d.data || d.date || '',
                        turno: docTurno || '',
                        maquina: d.machine || '',
                        ordem: d.orderId || d.orderNumber || '',
                        produto: d.mp || d.productCode || '',
                        tipo: 'Retrabalho',
                        quantidade: d.quantidade || d.quantity || 0,
                        motivo: d.motivo || d.reason || '-',
                        operador: d.registradoPorNome || d.operator || ''
                    });
                });
            } catch (reworkError) {
                console.warn('[REPORTS] Erro ao buscar retrabalhos:', reworkError.message);
            }
            
            console.log('[REPORTS] Perdas - total de registros:', entries.length);

        } catch (error) {
            console.error('[REPORTS] Erro ao buscar perdas:', error);
            showReportToast(`Erro ao buscar dados de perdas: ${error.message}`, 'error');
        }
        
        // Ordenar por data
        entries.sort((a, b) => b.data.localeCompare(a.data));
        
        return entries;
    }

    // Buscar dados consolidados
    async function fetchConsolidatedData(startDate, endDate, machine, shift) {
        const consolidated = {};
        
        try {
            // Buscar produção
            const productionData = await fetchProductionData(startDate, endDate, machine, shift);
            
            // Buscar paradas
            const downtimeData = await fetchDowntimeData(startDate, endDate, machine, shift);
            
            // Buscar perdas
            const lossesData = await fetchLossesData(startDate, endDate, machine, shift);
            
            // Agrupar por data
            productionData.forEach(item => {
                const key = item.data;
                if (!consolidated[key]) {
                    consolidated[key] = {
                        data: key,
                        producao: 0,
                        tempoParado: 0,
                        perdas: 0,
                        lancamentos: 0,
                        paradas: 0,
                        maquinas: new Set()
                    };
                }
                consolidated[key].producao += item.produzido;
                consolidated[key].lancamentos++;
                consolidated[key].maquinas.add(item.maquina);
            });
            
            downtimeData.forEach(item => {
                const key = item.data;
                if (!consolidated[key]) {
                    consolidated[key] = {
                        data: key,
                        producao: 0,
                        tempoParado: 0,
                        perdas: 0,
                        lancamentos: 0,
                        paradas: 0,
                        maquinas: new Set()
                    };
                }
                consolidated[key].tempoParado += item.duracao;
                consolidated[key].paradas++;
                consolidated[key].maquinas.add(item.maquina);
            });
            
            lossesData.forEach(item => {
                const key = item.data;
                if (!consolidated[key]) {
                    consolidated[key] = {
                        data: key,
                        producao: 0,
                        tempoParado: 0,
                        perdas: 0,
                        lancamentos: 0,
                        paradas: 0,
                        maquinas: new Set()
                    };
                }
                consolidated[key].perdas += item.quantidade;
            });
            
        } catch (error) {
            console.error('[REPORTS] Erro ao buscar consolidado:', error);
        }
        
        // Converter para array e calcular eficiência
        const result = Object.values(consolidated).map(item => ({
            data: item.data,
            producao: item.producao,
            tempoParado: item.tempoParado,
            perdas: item.perdas,
            lancamentos: item.lancamentos,
            paradas: item.paradas,
            maquinas: item.maquinas.size,
            eficiencia: item.producao > 0 ? Math.round((item.producao / (item.producao + item.perdas)) * 100) : 0
        }));
        
        // Ordenar por data
        result.sort((a, b) => b.data.localeCompare(a.data));
        
        return result;
    }

    // Atualizar KPIs
    function updateKPIs(data, reportType) {
        const kpisContainer = document.getElementById('report-kpis');
        if (!kpisContainer) return;

        let totalProduced = 0;
        let totalDowntime = 0;
        let totalLosses = 0;
        let avgEfficiency = 0;

        switch (reportType) {
            case 'producao':
                totalProduced = data.reduce((sum, item) => sum + (item.produzido || 0), 0);
                break;
            case 'paradas':
                totalDowntime = data.reduce((sum, item) => sum + (item.duracao || 0), 0);
                break;
            case 'perdas':
                totalLosses = data.reduce((sum, item) => sum + (item.quantidade || 0), 0);
                break;
            case 'consolidado':
                totalProduced = data.reduce((sum, item) => sum + (item.producao || 0), 0);
                totalDowntime = data.reduce((sum, item) => sum + (item.tempoParado || 0), 0);
                totalLosses = data.reduce((sum, item) => sum + (item.perdas || 0), 0);
                const efficiencies = data.filter(item => item.eficiencia > 0).map(item => item.eficiencia);
                avgEfficiency = efficiencies.length > 0 ? Math.round(efficiencies.reduce((a, b) => a + b, 0) / efficiencies.length) : 0;
                break;
        }

        // Atualizar elementos
        const kpiProduced = document.getElementById('report-kpi-produced');
        const kpiDowntime = document.getElementById('report-kpi-downtime');
        const kpiLosses = document.getElementById('report-kpi-losses');
        const kpiEfficiency = document.getElementById('report-kpi-efficiency');

        if (kpiProduced) kpiProduced.textContent = totalProduced.toLocaleString('pt-BR');
        if (kpiDowntime) kpiDowntime.textContent = formatDuration(totalDowntime);
        if (kpiLosses) kpiLosses.textContent = totalLosses.toLocaleString('pt-BR');
        if (kpiEfficiency) kpiEfficiency.textContent = `${avgEfficiency}%`;

        kpisContainer.classList.remove('hidden');
    }

    function formatDuration(minutes) {
        if (!minutes || minutes <= 0) return '0min';
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        if (hours > 0) {
            return `${hours}h ${mins}min`;
        }
        return `${mins}min`;
    }

    // Renderizar tabela
    function renderTable(data, reportType) {
        const thead = document.getElementById('report-table-head');
        const tbody = document.getElementById('report-table-body');
        const titleEl = document.getElementById('report-results-title');
        const countEl = document.getElementById('report-results-count');

        if (!thead || !tbody) return;

        // Definir colunas por tipo
        let columns = [];
        let title = '';

        switch (reportType) {
            case 'producao':
                title = 'Relatório de Produção';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'turno', label: 'Turno' },
                    { key: 'maquina', label: 'Máquina' },
                    { key: 'ordem', label: 'Ordem' },
                    { key: 'produto', label: 'Produto' },
                    { key: 'produzido', label: 'Produzido' },
                    { key: 'operador', label: 'Operador' },
                    { key: 'hora', label: 'Hora' }
                ];
                break;
            case 'paradas':
                title = 'Relatório de Paradas';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'turno', label: 'Turno' },
                    { key: 'maquina', label: 'Máquina' },
                    { key: 'tipo', label: 'Tipo' },
                    { key: 'motivo', label: 'Motivo' },
                    { key: 'duracao', label: 'Duração (min)' },
                    { key: 'inicio', label: 'Início' },
                    { key: 'fim', label: 'Fim' },
                    { key: 'operador', label: 'Operador' }
                ];
                break;
            case 'perdas':
                title = 'Relatório de Perdas/Refugos';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'turno', label: 'Turno' },
                    { key: 'maquina', label: 'Máquina' },
                    { key: 'ordem', label: 'Ordem' },
                    { key: 'produto', label: 'Produto' },
                    { key: 'tipo', label: 'Tipo' },
                    { key: 'quantidade', label: 'Quantidade' },
                    { key: 'motivo', label: 'Motivo' },
                    { key: 'operador', label: 'Operador' }
                ];
                break;
            case 'consolidado':
                title = 'Relatório Consolidado';
                columns = [
                    { key: 'data', label: 'Data' },
                    { key: 'maquinas', label: 'Máquinas' },
                    { key: 'lancamentos', label: 'Lançamentos' },
                    { key: 'producao', label: 'Produção Total' },
                    { key: 'paradas', label: 'Qtd Paradas' },
                    { key: 'tempoParado', label: 'Tempo Parado' },
                    { key: 'perdas', label: 'Perdas' },
                    { key: 'eficiencia', label: 'Eficiência' }
                ];
                break;
        }

        if (titleEl) titleEl.textContent = title;
        if (countEl) countEl.textContent = `${data.length} registros`;

        // Renderizar cabeçalho
        thead.innerHTML = `
            <tr>
                ${columns.map(col => `<th class="text-left px-4 py-3 text-sm font-semibold text-gray-700">${col.label}</th>`).join('')}
            </tr>
        `;

        // Paginação
        const startIdx = (currentPage - 1) * itemsPerPage;
        const endIdx = startIdx + itemsPerPage;
        const pageData = data.slice(startIdx, endIdx);

        // Renderizar dados
        tbody.innerHTML = pageData.map(item => `
            <tr class="hover:bg-gray-50 transition-colors">
                ${columns.map(col => {
                    let value = item[col.key];
                    
                    // Formatação especial
                    if (col.key === 'turno') {
                        value = `Turno ${value}`;
                    } else if (col.key === 'produzido' || col.key === 'producao' || col.key === 'quantidade' || col.key === 'perdas') {
                        value = (value || 0).toLocaleString('pt-BR');
                    } else if (col.key === 'tempoParado') {
                        value = formatDuration(value);
                    } else if (col.key === 'eficiencia') {
                        value = `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${value >= 80 ? 'bg-green-100 text-green-800' : value >= 60 ? 'bg-yellow-100 text-yellow-800' : 'bg-red-100 text-red-800'}">${value}%</span>`;
                    } else if (col.key === 'tipo' && item.tipo) {
                        const typeColors = {
                            'Refugo Produção': 'bg-red-100 text-red-800',
                            'Retrabalho': 'bg-orange-100 text-orange-800'
                        };
                        value = `<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${typeColors[item.tipo] || 'bg-gray-100 text-gray-800'}">${item.tipo}</span>`;
                    }
                    
                    return `<td class="px-4 py-3 text-sm text-gray-600">${value || '-'}</td>`;
                }).join('')}
            </tr>
        `).join('');

        // Atualizar paginação
        updatePagination(data.length);
    }

    // Atualizar paginação
    function updatePagination(totalItems) {
        const totalPages = Math.ceil(totalItems / itemsPerPage);
        const infoEl = document.getElementById('report-pagination-info');
        const pageInfoEl = document.getElementById('report-page-info');
        const prevBtn = document.getElementById('report-prev-page');
        const nextBtn = document.getElementById('report-next-page');

        const startIdx = (currentPage - 1) * itemsPerPage + 1;
        const endIdx = Math.min(currentPage * itemsPerPage, totalItems);

        if (infoEl) infoEl.textContent = `Mostrando ${startIdx}-${endIdx} de ${totalItems}`;
        if (pageInfoEl) pageInfoEl.textContent = `Página ${currentPage} de ${totalPages}`;

        if (prevBtn) prevBtn.disabled = currentPage <= 1;
        if (nextBtn) nextBtn.disabled = currentPage >= totalPages;
    }

    // Mudar página
    function changePage(direction) {
        const totalPages = Math.ceil(currentData.length / itemsPerPage);
        const newPage = currentPage + direction;

        if (newPage >= 1 && newPage <= totalPages) {
            currentPage = newPage;
            renderTable(currentData, currentReportType);
        }
    }

    // Atualizar gráficos
    function updateCharts(data, reportType) {
        const chartsContainer = document.getElementById('report-charts');
        if (!chartsContainer || typeof Chart === 'undefined') {
            console.log('[REPORTS] Chart.js não disponível');
            return;
        }

        // Destruir gráficos anteriores
        Object.values(charts).forEach(chart => {
            if (chart) chart.destroy();
        });

        if (data.length === 0) {
            chartsContainer.classList.add('hidden');
            return;
        }

        chartsContainer.classList.remove('hidden');

        // Gráfico de distribuição por turno
        const shiftData = {};
        data.forEach(item => {
            const shift = item.turno || 'N/A';
            const key = `Turno ${shift}`;
            shiftData[key] = (shiftData[key] || 0) + 1;
        });

        const shiftCtx = document.getElementById('report-chart-shift')?.getContext('2d');
        if (shiftCtx) {
            charts.shift = new Chart(shiftCtx, {
                type: 'bar',
                data: {
                    labels: Object.keys(shiftData),
                    datasets: [{
                        label: 'Registros por Turno',
                        data: Object.values(shiftData),
                        backgroundColor: ['#3b82f6', '#10b981', '#f59e0b'],
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }

        // Gráfico de distribuição por motivo (apenas para paradas)
        if (reportType === 'paradas' || reportType === 'perdas') {
            const reasonData = {};
            data.forEach(item => {
                const reason = item.motivo || item.tipo || 'Não especificado';
                reasonData[reason] = (reasonData[reason] || 0) + 1;
            });

            const reasonCtx = document.getElementById('report-chart-reason')?.getContext('2d');
            if (reasonCtx) {
                const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899'];
                charts.reason = new Chart(reasonCtx, {
                    type: 'doughnut',
                    data: {
                        labels: Object.keys(reasonData).slice(0, 7),
                        datasets: [{
                            data: Object.values(reasonData).slice(0, 7),
                            backgroundColor: colors
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'right' }
                        }
                    }
                });
            }
        }

        // Gráfico de evolução diária
        const timelineData = {};
        data.forEach(item => {
            const date = item.data;
            if (!timelineData[date]) {
                timelineData[date] = 0;
            }
            timelineData[date] += item.produzido || item.duracao || item.quantidade || item.producao || 1;
        });

        // Ordenar por data
        const sortedDates = Object.keys(timelineData).sort();
        const timelineValues = sortedDates.map(d => timelineData[d]);

        const timelineCtx = document.getElementById('report-chart-timeline')?.getContext('2d');
        if (timelineCtx && sortedDates.length > 0) {
            charts.timeline = new Chart(timelineCtx, {
                type: 'line',
                data: {
                    labels: sortedDates.map(d => {
                        const [year, month, day] = d.split('-');
                        return `${day}/${month}`;
                    }),
                    datasets: [{
                        label: 'Evolução Diária',
                        data: timelineValues,
                        borderColor: '#6366f1',
                        backgroundColor: 'rgba(99, 102, 241, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
        }
    }

    // Exportar para Excel
    function exportToExcel() {
        if (currentData.length === 0) {
            showReportToast('Nenhum dado para exportar. Gere um relatório primeiro.', 'warning');
            return;
        }

        try {
            // Converter dados para CSV
            const headers = Object.keys(currentData[0]).filter(k => k !== 'id');
            let csv = headers.join(';') + '\n';
            
            currentData.forEach(item => {
                const row = headers.map(h => {
                    let val = item[h];
                    if (typeof val === 'number') {
                        val = val.toString().replace('.', ',');
                    }
                    return val || '';
                });
                csv += row.join(';') + '\n';
            });

            // BOM para UTF-8
            const BOM = '\uFEFF';
            const blob = new Blob([BOM + csv], { type: 'text/csv;charset=utf-8;' });
            
            const link = document.createElement('a');
            const reportType = document.getElementById('report-type')?.value || 'relatorio';
            const date = new Date().toISOString().split('T')[0];
            link.download = `relatorio_${reportType}_${date}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();

            showReportToast('Relatório exportado com sucesso!', 'success');
        } catch (error) {
            console.error('[REPORTS] Erro ao exportar:', error);
            showReportToast('Erro ao exportar relatório.', 'error');
        }
    }

    // Exportar para PDF
    function exportToPDF() {
        if (currentData.length === 0) {
            showReportToast('Nenhum dado para exportar. Gere um relatório primeiro.', 'warning');
            return;
        }

        try {
            // Usar window.print() como fallback simples
            const reportType = document.getElementById('report-type')?.value || 'relatorio';
            const titles = {
                'producao': 'Relatório de Produção',
                'paradas': 'Relatório de Paradas',
                'perdas': 'Relatório de Perdas/Refugos',
                'consolidado': 'Relatório Consolidado'
            };

            const printWindow = window.open('', '_blank');
            const headers = Object.keys(currentData[0]).filter(k => k !== 'id');

            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${titles[reportType] || 'Relatório'}</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { color: #333; border-bottom: 2px solid #6366f1; padding-bottom: 10px; }
                        table { width: 100%; border-collapse: collapse; margin-top: 20px; font-size: 12px; }
                        th { background: #6366f1; color: white; padding: 10px; text-align: left; }
                        td { border: 1px solid #ddd; padding: 8px; }
                        tr:nth-child(even) { background: #f9f9f9; }
                        .date { color: #666; font-size: 12px; margin-bottom: 20px; }
                    </style>
                </head>
                <body>
                    <h1>${titles[reportType] || 'Relatório'}</h1>
                    <p class="date">Gerado em: ${new Date().toLocaleString('pt-BR')}</p>
                    <table>
                        <thead>
                            <tr>
                                ${headers.map(h => `<th>${h}</th>`).join('')}
                            </tr>
                        </thead>
                        <tbody>
                            ${currentData.slice(0, 100).map(item => `
                                <tr>
                                    ${headers.map(h => `<td>${item[h] || '-'}</td>`).join('')}
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                    ${currentData.length > 100 ? '<p><em>Exibindo primeiros 100 registros de ' + currentData.length + ' total.</em></p>' : ''}
                </body>
                </html>
            `);

            printWindow.document.close();
            printWindow.print();

            showReportToast('PDF aberto para impressão!', 'success');
        } catch (error) {
            console.error('[REPORTS] Erro ao gerar PDF:', error);
            showReportToast('Erro ao gerar PDF.', 'error');
        }
    }

    // Helpers de UI
    function showLoading(show) {
        const loading = document.getElementById('report-loading');
        if (loading) {
            loading.classList.toggle('hidden', !show);
        }
    }

    function showResults() {
        const results = document.getElementById('report-results');
        const empty = document.getElementById('report-empty');
        if (results) results.classList.remove('hidden');
        if (empty) empty.classList.add('hidden');
    }

    function hideResults() {
        const results = document.getElementById('report-results');
        const kpis = document.getElementById('report-kpis');
        const charts = document.getElementById('report-charts');
        const empty = document.getElementById('report-empty');
        if (results) results.classList.add('hidden');
        if (kpis) kpis.classList.add('hidden');
        if (charts) charts.classList.add('hidden');
        if (empty) empty.classList.add('hidden');
    }

    function showEmptyState(show) {
        const empty = document.getElementById('report-empty');
        if (empty) empty.classList.toggle('hidden', !show);
    }

    // Retornar API pública
    return {
        initialize,
        generateReport,
        exportToExcel,
        exportToPDF,
        populateReportMachines
    };
})();

// Expor globalmente
window.ReportsModule = ReportsModule;

// Inicializar módulo de relatórios quando DOM estiver pronto
document.addEventListener('DOMContentLoaded', () => {
    ReportsModule.initialize();
    
    // Popular máquinas também na inicialização global
    setTimeout(() => {
        const machineSelect = document.getElementById('report-machine');
        if (machineSelect && machineSelect.options.length <= 1) {
            const machines = window.databaseModule?.machineDatabase;
            if (machines && Array.isArray(machines)) {
                machines.forEach(machine => {
                    const opt = document.createElement('option');
                    opt.value = machine.id;
                    opt.textContent = machine.id;
                    machineSelect.appendChild(opt);
                });
                console.log('[REPORTS] Máquinas carregadas via fallback:', machines.length);
            }
        }
    }, 500);
});

// ============================================================
// MÓDULO: Aba Ordens (Nova Interface Centralizada)
// ============================================================
const OrdersPageModule = (function() {
    'use strict';
    
    let ordersCache = [];
    let currentView = 'cards';
    let isInitialized = false;
    
    // Elementos do DOM
    const elements = {};
    
    function cacheElements() {
        elements.grid = document.getElementById('orders-page-grid');
        elements.tableBody = document.getElementById('orders-page-table-body');
        elements.cardsContainer = document.getElementById('orders-page-cards-container');
        elements.tableContainer = document.getElementById('orders-page-table-container');
        elements.emptyState = document.getElementById('orders-page-empty');
        elements.resultsCount = document.getElementById('orders-page-results-count');
        elements.searchInput = document.getElementById('orders-page-search');
        elements.statusFilter = document.getElementById('orders-page-status-filter');
        elements.machineFilter = document.getElementById('orders-page-machine-filter');
        elements.sortSelect = document.getElementById('orders-page-sort');
        elements.clearFiltersBtn = document.getElementById('orders-page-clear-filters');
        elements.refreshBtn = document.getElementById('orders-page-refresh');
        elements.addBtn = document.getElementById('orders-page-add-btn');
        elements.addFirstBtn = document.getElementById('orders-page-add-first');
        elements.viewCardsBtn = document.getElementById('orders-page-view-cards');
        elements.viewTableBtn = document.getElementById('orders-page-view-table');
        elements.kpiTotal = document.getElementById('orders-page-kpi-total');
        elements.kpiPlanned = document.getElementById('orders-page-kpi-planned');
        elements.kpiActive = document.getElementById('orders-page-kpi-active');
        elements.kpiCompleted = document.getElementById('orders-page-kpi-completed');
        
        // Debug: verificar quais elementos foram encontrados
        console.log('[OrdersPage] Elementos encontrados:', {
            grid: !!elements.grid,
            tableBody: !!elements.tableBody,
            cardsContainer: !!elements.cardsContainer,
            resultsCount: !!elements.resultsCount,
            kpiTotal: !!elements.kpiTotal
        });
    }
    
    function setupEventListeners() {
        if (elements.searchInput) {
            elements.searchInput.addEventListener('input', debounce(renderOrders, 300));
            elements.searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') renderOrders();
            });
        }
        
        if (elements.statusFilter) {
            elements.statusFilter.addEventListener('change', renderOrders);
        }
        
        if (elements.machineFilter) {
            elements.machineFilter.addEventListener('change', renderOrders);
        }
        
        if (elements.sortSelect) {
            elements.sortSelect.addEventListener('change', renderOrders);
        }
        
        if (elements.clearFiltersBtn) {
            elements.clearFiltersBtn.addEventListener('click', clearFilters);
        }
        
        if (elements.refreshBtn) {
            elements.refreshBtn.addEventListener('click', refreshOrders);
        }
        
        if (elements.addBtn) {
            elements.addBtn.addEventListener('click', () => openOrderFormModal());
        }
        
        if (elements.addFirstBtn) {
            elements.addFirstBtn.addEventListener('click', () => openOrderFormModal());
        }
        
        if (elements.viewCardsBtn) {
            elements.viewCardsBtn.addEventListener('click', () => switchView('cards'));
        }
        
        if (elements.viewTableBtn) {
            elements.viewTableBtn.addEventListener('click', () => switchView('table'));
        }
        
        // Formulário do modal
        const formModal = document.getElementById('order-form-modal-form');
        if (formModal) {
            formModal.addEventListener('submit', handleFormSubmit);
        }
    }
    
    function switchView(view) {
        currentView = view;
        
        if (view === 'cards') {
            elements.cardsContainer?.classList.remove('hidden');
            elements.tableContainer?.classList.add('hidden');
            elements.viewCardsBtn?.classList.add('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewCardsBtn?.classList.remove('text-gray-500');
            elements.viewTableBtn?.classList.remove('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewTableBtn?.classList.add('text-gray-500');
        } else {
            elements.cardsContainer?.classList.add('hidden');
            elements.tableContainer?.classList.remove('hidden');
            elements.viewTableBtn?.classList.add('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewTableBtn?.classList.remove('text-gray-500');
            elements.viewCardsBtn?.classList.remove('bg-white', 'shadow-sm', 'text-emerald-600');
            elements.viewCardsBtn?.classList.add('text-gray-500');
        }
        
        renderOrders();
    }
    
    function clearFilters() {
        if (elements.searchInput) elements.searchInput.value = '';
        if (elements.statusFilter) elements.statusFilter.value = '';
        if (elements.machineFilter) elements.machineFilter.value = '';
        if (elements.sortSelect) elements.sortSelect.value = 'recent';
        renderOrders();
    }
    
    async function refreshOrders() {
        const icon = elements.refreshBtn?.querySelector('i');
        icon?.classList.add('animate-spin');
        ordersCache = [];
        await loadOrders();
        icon?.classList.remove('animate-spin');
        showNotification('Ordens atualizadas!', 'success');
    }
    
    async function loadOrders() {
        try {
            console.log('📋 [OrdersPage] Carregando ordens...');
            const snapshot = await db.collection('production_orders').get();
            ordersCache = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log('[OrdersPage] ' + ordersCache.length + ' ordens carregadas');
            
            populateMachineFilter();
            updateKPIs();
            renderOrders();
            
        } catch (error) {
            console.error('[OrdersPage] Erro ao carregar ordens:', error);
            showNotification('Erro ao carregar ordens', 'error');
        }
    }
    
    function populateMachineFilter() {
        if (!elements.machineFilter) return;
        
        const machines = [...new Set(ordersCache.map(o => o.machine_id).filter(m => m))].sort();
        
        elements.machineFilter.innerHTML = '<option value="">Todas Máquinas</option>';
        machines.forEach(m => {
            const machineInfo = window.databaseModule?.machineById?.get(m);
            const label = machineInfo ? m + ' - ' + machineInfo.model : m;
            elements.machineFilter.innerHTML += '<option value="' + m + '">' + label + '</option>';
        });
    }
    
    function updateKPIs() {
        const total = ordersCache.length;
        const planned = ordersCache.filter(o => (o.status || '').toLowerCase() === 'planejada').length;
        const active = ordersCache.filter(o => ['ativa', 'em_andamento'].includes((o.status || '').toLowerCase())).length;
        const completed = ordersCache.filter(o => ['concluida', 'finalizada'].includes((o.status || '').toLowerCase())).length;
        
        if (elements.kpiTotal) elements.kpiTotal.textContent = total.toLocaleString('pt-BR');
        if (elements.kpiPlanned) elements.kpiPlanned.textContent = planned.toLocaleString('pt-BR');
        if (elements.kpiActive) elements.kpiActive.textContent = active.toLocaleString('pt-BR');
        if (elements.kpiCompleted) elements.kpiCompleted.textContent = completed.toLocaleString('pt-BR');
    }
    
    function getFilteredOrders() {
        let filtered = [...ordersCache];
        
        // Filtro de busca
        const searchQuery = (elements.searchInput?.value || '').toLowerCase().trim();
        if (searchQuery) {
            filtered = filtered.filter(o => 
                (o.order_number || '').toLowerCase().includes(searchQuery) ||
                (o.product || '').toLowerCase().includes(searchQuery) ||
                (o.part_code || '').toLowerCase().includes(searchQuery) ||
                (o.customer || '').toLowerCase().includes(searchQuery)
            );
        }
        
        // Filtro de status
        const statusFilter = elements.statusFilter?.value || '';
        if (statusFilter) {
            filtered = filtered.filter(o => {
                const status = (o.status || '').toLowerCase();
                if (statusFilter === 'concluida') return ['concluida', 'finalizada'].includes(status);
                return status === statusFilter;
            });
        }
        
        // Filtro de máquina
        const machineFilter = elements.machineFilter?.value || '';
        if (machineFilter) {
            filtered = filtered.filter(o => o.machine_id === machineFilter);
        }
        
        // Ordenação
        const sortBy = elements.sortSelect?.value || 'recent';
        filtered.sort((a, b) => {
            switch (sortBy) {
                case 'recent':
                    return (b.createdAt?.toDate?.() || new Date(0)) - (a.createdAt?.toDate?.() || new Date(0));
                case 'oldest':
                    return (a.createdAt?.toDate?.() || new Date(0)) - (b.createdAt?.toDate?.() || new Date(0));
                case 'op-asc':
                    return (a.order_number || '').localeCompare(b.order_number || '');
                case 'op-desc':
                    return (b.order_number || '').localeCompare(a.order_number || '');
                case 'lot-desc':
                    return (Number(b.lot_size) || 0) - (Number(a.lot_size) || 0);
                case 'lot-asc':
                    return (Number(a.lot_size) || 0) - (Number(b.lot_size) || 0);
                default:
                    return 0;
            }
        });
        
        return filtered;
    }
    
    function renderOrders() {
        const filtered = getFilteredOrders();
        
        // Atualizar contador
        if (elements.resultsCount) {
            elements.resultsCount.textContent = filtered.length + ' ordem' + (filtered.length !== 1 ? 's' : '') + ' encontrada' + (filtered.length !== 1 ? 's' : '');
        }
        
        // Mostrar empty state se não houver ordens
        if (filtered.length === 0) {
            if (elements.grid) elements.grid.innerHTML = '';
            if (elements.tableBody) elements.tableBody.innerHTML = '';
            elements.emptyState?.classList.remove('hidden');
            elements.emptyState?.classList.add('flex');
            return;
        }
        
        elements.emptyState?.classList.add('hidden');
        elements.emptyState?.classList.remove('flex');
        
        if (currentView === 'cards') {
            renderCardsView(filtered);
        } else {
            renderTableView(filtered);
        }
        
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function renderCardsView(orders) {
        if (!elements.grid) return;
        
        const html = orders.map(order => {
            const status = (order.status || 'planejada').toLowerCase();
            const lotSize = Number(order.lot_size) || 0;
            const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
            const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
            
            const statusConfig = {
                'planejada': { bg: 'bg-slate-100', text: 'text-slate-700', border: 'border-slate-200', label: 'Planejada', icon: 'calendar' },
                'ativa': { bg: 'bg-blue-100', text: 'text-blue-700', border: 'border-blue-200', label: 'Ativa', icon: 'zap' },
                'em_andamento': { bg: 'bg-amber-100', text: 'text-amber-700', border: 'border-amber-200', label: 'Em Andamento', icon: 'play-circle' },
                'concluida': { bg: 'bg-emerald-100', text: 'text-emerald-700', border: 'border-emerald-200', label: 'Concluída', icon: 'check-circle-2' },
                'finalizada': { bg: 'bg-emerald-100', text: 'text-emerald-700', border: 'border-emerald-200', label: 'Finalizada', icon: 'check-circle-2' },
                'cancelada': { bg: 'bg-red-100', text: 'text-red-700', border: 'border-red-200', label: 'Cancelada', icon: 'x-circle' }
            };
            
            const sc = statusConfig[status] || statusConfig['planejada'];
            const progressColor = progress >= 100 ? 'bg-emerald-500' : progress >= 50 ? 'bg-blue-500' : 'bg-amber-500';
            const isActive = ['ativa', 'em_andamento'].includes(status);
            const canActivate = status === 'planejada';
            const canReactivate = ['concluida', 'finalizada'].includes(status);
            
            const machineInfo = window.databaseModule?.machineById?.get(order.machine_id);
            const machineLabel = machineInfo ? order.machine_id + ' - ' + machineInfo.model : (order.machine_id || 'N/A');
            
            return '<div class="bg-white rounded-xl border ' + (isActive ? 'border-blue-300 ring-2 ring-blue-100' : 'border-gray-200') + ' shadow-sm hover:shadow-md transition-all overflow-hidden">' +
                '<div class="p-4 border-b border-gray-100 ' + (isActive ? 'bg-blue-50' : 'bg-gray-50') + '">' +
                    '<div class="flex items-start justify-between gap-2">' +
                        '<div class="flex-1 min-w-0">' +
                            '<h4 class="font-bold text-gray-800 truncate">OP ' + escapeHtml(order.order_number || '') + '</h4>' +
                            '<p class="text-sm text-gray-600 truncate">' + escapeHtml(order.product || order.part_code || 'Produto não definido') + '</p>' +
                        '</div>' +
                        '<span class="flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ' + sc.bg + ' ' + sc.text + ' ' + sc.border + ' border">' +
                            '<i data-lucide="' + sc.icon + '" class="w-3 h-3"></i>' +
                            sc.label +
                        '</span>' +
                    '</div>' +
                '</div>' +
                '<div class="p-4 space-y-3">' +
                    '<div class="grid grid-cols-2 gap-2 text-sm">' +
                        '<div class="flex items-center gap-2 text-gray-600">' +
                            '<i data-lucide="user" class="w-4 h-4 text-gray-400"></i>' +
                            '<span class="truncate">' + escapeHtml(order.customer || 'N/A') + '</span>' +
                        '</div>' +
                        '<div class="flex items-center gap-2 text-gray-600">' +
                            '<i data-lucide="settings" class="w-4 h-4 text-gray-400"></i>' +
                            '<span class="truncate">' + escapeHtml(machineLabel) + '</span>' +
                        '</div>' +
                    '</div>' +
                    '<div class="bg-gray-50 rounded-lg p-3">' +
                        '<div class="flex items-center justify-between text-xs text-gray-500 mb-1">' +
                            '<span>Progresso</span>' +
                            '<span class="font-semibold">' + Math.round(progress) + '%</span>' +
                        '</div>' +
                        '<div class="w-full bg-gray-200 rounded-full h-2">' +
                            '<div class="' + progressColor + ' h-2 rounded-full transition-all" style="width: ' + progress + '%"></div>' +
                        '</div>' +
                        '<div class="flex justify-between text-xs text-gray-500 mt-1">' +
                            '<span>' + produced.toLocaleString('pt-BR') + ' prod.</span>' +
                            '<span>' + lotSize.toLocaleString('pt-BR') + ' plan.</span>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<div class="px-4 pb-4 flex gap-2">' +
                    (canActivate ? '<button onclick="OrdersPageModule.activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="play" class="w-4 h-4"></i>Ativar</button>' : '') +
                    (canReactivate ? '<button onclick="OrdersPageModule.reactivateOrder(\'' + order.id + '\')" class="flex-1 flex items-center justify-center gap-1.5 px-3 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg text-sm font-medium transition"><i data-lucide="rotate-ccw" class="w-4 h-4"></i>Reativar</button>' : '') +
                    '<button onclick="OrdersPageModule.editOrder(\'' + order.id + '\')" class="' + ((canActivate || canReactivate) ? 'flex-1' : 'w-full') + ' flex items-center justify-center gap-1.5 px-3 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg text-sm font-medium transition"><i data-lucide="edit-3" class="w-4 h-4"></i>Editar</button>' +
                '</div>' +
            '</div>';
        }).join('');
        
        elements.grid.innerHTML = html;
    }
    
    function renderTableView(orders) {
        if (!elements.tableBody) return;
        
        const html = orders.map(order => {
            const status = (order.status || 'planejada').toLowerCase();
            const lotSize = Number(order.lot_size) || 0;
            const produced = Number(order.total_produzido ?? order.totalProduced ?? order.total_produced) || 0;
            const progress = lotSize > 0 ? Math.min((produced / lotSize) * 100, 100) : 0;
            
            const statusConfig = {
                'planejada': { bg: 'bg-slate-100', text: 'text-slate-700', label: 'Planejada' },
                'ativa': { bg: 'bg-blue-100', text: 'text-blue-700', label: 'Ativa' },
                'em_andamento': { bg: 'bg-amber-100', text: 'text-amber-700', label: 'Em Andamento' },
                'concluida': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Concluída' },
                'finalizada': { bg: 'bg-emerald-100', text: 'text-emerald-700', label: 'Finalizada' },
                'cancelada': { bg: 'bg-red-100', text: 'text-red-700', label: 'Cancelada' }
            };
            
            const sc = statusConfig[status] || statusConfig['planejada'];
            const progressColor = progress >= 100 ? 'bg-emerald-500' : progress >= 50 ? 'bg-blue-500' : 'bg-amber-500';
            const canActivate = status === 'planejada';
            const canReactivate = ['concluida', 'finalizada'].includes(status);
            
            return '<tr class="hover:bg-gray-50">' +
                '<td class="px-4 py-3 font-medium text-gray-800">' + escapeHtml(order.order_number || '') + '</td>' +
                '<td class="px-4 py-3 text-gray-600">' + escapeHtml(order.product || order.part_code || 'N/A') + '</td>' +
                '<td class="px-4 py-3 text-gray-600">' + escapeHtml(order.customer || 'N/A') + '</td>' +
                '<td class="px-4 py-3 text-gray-600">' + escapeHtml(order.machine_id || 'N/A') + '</td>' +
                '<td class="px-4 py-3 text-center text-gray-700">' + lotSize.toLocaleString('pt-BR') + '</td>' +
                '<td class="px-4 py-3 text-center text-gray-700">' + produced.toLocaleString('pt-BR') + '</td>' +
                '<td class="px-4 py-3"><div class="flex items-center gap-2"><div class="flex-1 bg-gray-200 rounded-full h-2"><div class="' + progressColor + ' h-2 rounded-full" style="width: ' + progress + '%"></div></div><span class="text-xs font-medium text-gray-600">' + Math.round(progress) + '%</span></div></td>' +
                '<td class="px-4 py-3 text-center"><span class="px-2 py-1 rounded-full text-xs font-medium ' + sc.bg + ' ' + sc.text + '">' + sc.label + '</span></td>' +
                '<td class="px-4 py-3"><div class="flex items-center justify-center gap-1">' +
                    (canActivate ? '<button onclick="OrdersPageModule.activateOrder(\'' + order.id + '\', \'' + (order.machine_id || '') + '\')" class="p-1.5 text-emerald-600 hover:bg-emerald-50 rounded transition" title="Ativar"><i data-lucide="play" class="w-4 h-4"></i></button>' : '') +
                    (canReactivate ? '<button onclick="OrdersPageModule.reactivateOrder(\'' + order.id + '\')" class="p-1.5 text-blue-600 hover:bg-blue-50 rounded transition" title="Reativar"><i data-lucide="rotate-ccw" class="w-4 h-4"></i></button>' : '') +
                    '<button onclick="OrdersPageModule.editOrder(\'' + order.id + '\')" class="p-1.5 text-gray-600 hover:bg-gray-100 rounded transition" title="Editar"><i data-lucide="edit-3" class="w-4 h-4"></i></button>' +
                    '<button onclick="OrdersPageModule.deleteOrder(\'' + order.id + '\')" class="p-1.5 text-red-600 hover:bg-red-50 rounded transition" title="Excluir"><i data-lucide="trash-2" class="w-4 h-4"></i></button>' +
                '</div></td>' +
            '</tr>';
        }).join('');
        
        elements.tableBody.innerHTML = html;
    }
    
    // Ações das ordens
    async function activateOrder(orderId, machineId) {
        if (!machineId) {
            showNotification('Esta ordem não tem máquina definida. Edite a ordem primeiro.', 'warning');
            return;
        }
        
        if (!confirm('Deseja ativar esta ordem na máquina ' + machineId + '?')) return;
        
        try {
            await db.collection('production_orders').doc(orderId).update({
                status: 'ativa',
                activatedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            showNotification('Ordem ativada com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('ATIVAÇÃO DE ORDEM', 'ordem', {
                orderId: orderId,
                machine: machineId
            });
            
            await refreshOrders();
        } catch (error) {
            console.error('Erro ao ativar ordem:', error);
            showNotification('Erro ao ativar ordem', 'error');
        }
    }
    
    async function reactivateOrder(orderId) {
        if (!confirm('Deseja reativar esta ordem?')) return;
        
        try {
            await db.collection('production_orders').doc(orderId).update({ status: 'ativa' });
            showNotification('Ordem reativada com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('REATIVAÇÃO DE ORDEM', 'ordem', {
                orderId: orderId
            });
            
            await refreshOrders();
        } catch (error) {
            console.error('Erro ao reativar ordem:', error);
            showNotification('Erro ao reativar ordem', 'error');
        }
    }
    
    async function deleteOrder(orderId) {
        if (!confirm('Deseja excluir esta ordem? Esta ação não pode ser desfeita.')) return;
        
        try {
            const order = ordersCache.find(o => o.id === orderId);
            await db.collection('production_orders').doc(orderId).delete();
            showNotification('Ordem excluída com sucesso!', 'success');
            
            // Registrar log
            registrarLogSistema('EXCLUSÃO DE ORDEM', 'ordem', {
                orderId: orderId,
                orderNumber: order?.order_number || 'N/A'
            });
            
            await refreshOrders();
        } catch (error) {
            console.error('Erro ao excluir ordem:', error);
            showNotification('Erro ao excluir ordem', 'error');
        }
    }
    
    function editOrder(orderId) {
        const order = ordersCache.find(o => o.id === orderId);
        if (!order) {
            showNotification('Ordem não encontrada', 'error');
            return;
        }
        openOrderFormModal(order);
    }
    
    // Modal de formulário
    function openOrderFormModal(order) {
        const modal = document.getElementById('order-form-modal');
        if (!modal) return;
        
        const title = document.getElementById('order-form-title');
        const idInput = document.getElementById('order-form-id');
        const numberInput = document.getElementById('order-form-number');
        const partCodeInput = document.getElementById('order-form-part-code');
        const productInput = document.getElementById('order-form-product');
        const lotSizeInput = document.getElementById('order-form-lot-size');
        const batchInput = document.getElementById('order-form-batch');
        const packagingInput = document.getElementById('order-form-packaging');
        const customerInput = document.getElementById('order-form-customer');
        const machineSelect = document.getElementById('order-form-machine');
        const mpSelect = document.getElementById('order-form-mp');
        
        // Atualizar título
        if (title) {
            title.textContent = order ? 'Editar Ordem de Produção' : 'Nova Ordem de Produção';
        }
        
        // Popular select de máquinas
        if (machineSelect) {
            machineSelect.innerHTML = '<option value="">Selecione uma máquina</option>';
            if (typeof machineDatabase !== 'undefined' && machineDatabase.length > 0) {
                machineDatabase.forEach(function(machine) {
                    const mid = typeof normalizeMachineId === 'function' ? normalizeMachineId(machine.id) : machine.id;
                    machineSelect.innerHTML += '<option value="' + mid + '">' + mid + ' - ' + machine.model + '</option>';
                });
            }
        }
        
        // Popular select de matéria-prima
        if (mpSelect) {
            mpSelect.innerHTML = '<option value="">Selecione a MP...</option>';
            if (typeof materiaPrimaDatabase !== 'undefined' && materiaPrimaDatabase.length > 0) {
                materiaPrimaDatabase.forEach(function(mp) {
                    mpSelect.innerHTML += '<option value="' + mp.codigo + '">' + mp.codigo + ' - ' + mp.descricao + '</option>';
                });
            }
        }
        
        // Popular datalist de produtos
        var productList = document.getElementById('order-form-product-list');
        if (productList && typeof productDatabase !== 'undefined') {
            productList.innerHTML = '';
            productDatabase.forEach(function(prod) {
                productList.innerHTML += '<option value="' + prod.cod + '">' + prod.name + '</option>';
            });
        }
        
        // Preencher formulário
        if (idInput) idInput.value = order?.id || '';
        if (numberInput) numberInput.value = order?.order_number || '';
        if (partCodeInput) partCodeInput.value = order?.part_code || '';
        if (productInput) productInput.value = order?.product || '';
        if (lotSizeInput) lotSizeInput.value = order?.lot_size || '';
        if (batchInput) batchInput.value = order?.batch_number || '';
        if (packagingInput) packagingInput.value = order?.packaging_qty || '';
        if (customerInput) customerInput.value = order?.customer || '';
        if (machineSelect) machineSelect.value = order?.machine_id || '';
        if (mpSelect) mpSelect.value = order?.raw_material || '';
        
        modal.classList.remove('hidden');
        if (typeof lucide !== 'undefined') lucide.createIcons();
    }
    
    function closeOrderFormModal() {
        var modal = document.getElementById('order-form-modal');
        if (modal) modal.classList.add('hidden');
    }
    
    async function handleFormSubmit(e) {
        e.preventDefault();
        
        var id = document.getElementById('order-form-id')?.value;
        var orderData = {
            order_number: document.getElementById('order-form-number')?.value.trim() || '',
            part_code: document.getElementById('order-form-part-code')?.value.trim() || '',
            product: document.getElementById('order-form-product')?.value.trim() || '',
            lot_size: Number(document.getElementById('order-form-lot-size')?.value) || 0,
            batch_number: document.getElementById('order-form-batch')?.value.trim() || '',
            packaging_qty: Number(document.getElementById('order-form-packaging')?.value) || 0,
            customer: document.getElementById('order-form-customer')?.value.trim() || '',
            machine_id: document.getElementById('order-form-machine')?.value || '',
            raw_material: document.getElementById('order-form-mp')?.value || ''
        };
        
        if (!orderData.order_number) {
            showNotification('Informe o número da OP', 'warning');
            return;
        }
        
        if (!orderData.lot_size || orderData.lot_size <= 0) {
            showNotification('Informe o tamanho do lote', 'warning');
            return;
        }
        
        try {
            if (id) {
                await db.collection('production_orders').doc(id).update(orderData);
                showNotification('Ordem atualizada com sucesso!', 'success');
                
                // Registrar log de edição
                registrarLogSistema('EDIÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            } else {
                orderData.status = 'planejada';
                orderData.total_produced = 0;
                orderData.createdAt = firebase.firestore.FieldValue.serverTimestamp();
                const docRef = await db.collection('production_orders').add(orderData);
                showNotification('Ordem cadastrada com sucesso!', 'success');
                
                // Registrar log de criação
                registrarLogSistema('CRIAÇÃO DE ORDEM DE PRODUÇÃO', 'ordem', {
                    orderId: docRef.id,
                    orderNumber: orderData.order_number,
                    product: orderData.product,
                    lotSize: orderData.lot_size
                });
            }
            
            closeOrderFormModal();
            await refreshOrders();
            
        } catch (error) {
            console.error('Erro ao salvar ordem:', error);
            showNotification('Erro ao salvar ordem', 'error');
        }
    }
    
    // Inicialização
    function initialize() {
        if (isInitialized) return;
        
        console.log('[OrdersPage] Inicializando módulo...');
        cacheElements();
        setupEventListeners();
        loadOrders();
        isInitialized = true;
    }
    
    // API Pública
    return {
        initialize: initialize,
        refreshOrders: refreshOrders,
        loadOrders: loadOrders,
        activateOrder: activateOrder,
        reactivateOrder: reactivateOrder,
        deleteOrder: deleteOrder,
        editOrder: editOrder,
        openOrderFormModal: openOrderFormModal,
        closeOrderFormModal: closeOrderFormModal
    };
})();

// ============================================================
// FINALIZADOR DE PARADAS - Ativa downtime finalization
// ============================================================
// ============================================================
// Expor funções globalmente
window.OrdersPageModule = OrdersPageModule;
window.openOrderFormModal = function() { OrdersPageModule.openOrderFormModal(); };
window.closeOrderFormModal = function() { OrdersPageModule.closeOrderFormModal(); };

// Inicializar módulo de ordens quando página carregar
document.addEventListener('DOMContentLoaded', function() {
    // Pré-carregar ordens em background para ter dados prontos quando abrir a aba
    setTimeout(function() {
        if (window.OrdersPageModule && typeof window.OrdersPageModule.loadOrders === 'function') {
            console.log('[OrdersPage] Pré-carregando ordens em background...');
            // Só inicializa os elementos quando a aba for aberta
        }
    }, 2000);
});
